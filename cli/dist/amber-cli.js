#!/usr/bin/env node
(function(define, require){
define(function (requirejs) {
var module = void 0; // Bad UMDs workaround
requirejs.resolve = require.resolve;
require = requirejs;
/*!
 * @overview es6-promise - a tiny implementation of Promises/A+.
 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
 * @license   Licensed under MIT license
 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
 * @version   v4.2.8+1e68dce6
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define('amber/es6-promise',factory) :
	(global.ES6Promise = factory());
}(this, (function () { 'use strict';

function objectOrFunction(x) {
  var type = typeof x;
  return x !== null && (type === 'object' || type === 'function');
}

function isFunction(x) {
  return typeof x === 'function';
}



var _isArray = void 0;
if (Array.isArray) {
  _isArray = Array.isArray;
} else {
  _isArray = function (x) {
    return Object.prototype.toString.call(x) === '[object Array]';
  };
}

var isArray = _isArray;

var len = 0;
var vertxNext = void 0;
var customSchedulerFn = void 0;

var asap = function asap(callback, arg) {
  queue[len] = callback;
  queue[len + 1] = arg;
  len += 2;
  if (len === 2) {
    // If len is 2, that means that we need to schedule an async flush.
    // If additional callbacks are queued before the queue is flushed, they
    // will be processed by this flush that we are scheduling.
    if (customSchedulerFn) {
      customSchedulerFn(flush);
    } else {
      scheduleFlush();
    }
  }
};

function setScheduler(scheduleFn) {
  customSchedulerFn = scheduleFn;
}

function setAsap(asapFn) {
  asap = asapFn;
}

var browserWindow = typeof window !== 'undefined' ? window : undefined;
var browserGlobal = browserWindow || {};
var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && {}.toString.call(process) === '[object process]';

// test for web worker but not in IE10
var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';

// node
function useNextTick() {
  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
  // see https://github.com/cujojs/when/issues/410 for details
  return function () {
    return process.nextTick(flush);
  };
}

// vertx
function useVertxTimer() {
  if (typeof vertxNext !== 'undefined') {
    return function () {
      vertxNext(flush);
    };
  }

  return useSetTimeout();
}

function useMutationObserver() {
  var iterations = 0;
  var observer = new BrowserMutationObserver(flush);
  var node = document.createTextNode('');
  observer.observe(node, { characterData: true });

  return function () {
    node.data = iterations = ++iterations % 2;
  };
}

// web worker
function useMessageChannel() {
  var channel = new MessageChannel();
  channel.port1.onmessage = flush;
  return function () {
    return channel.port2.postMessage(0);
  };
}

function useSetTimeout() {
  // Store setTimeout reference so es6-promise will be unaffected by
  // other code modifying setTimeout (like sinon.useFakeTimers())
  var globalSetTimeout = setTimeout;
  return function () {
    return globalSetTimeout(flush, 1);
  };
}

var queue = new Array(1000);
function flush() {
  for (var i = 0; i < len; i += 2) {
    var callback = queue[i];
    var arg = queue[i + 1];

    callback(arg);

    queue[i] = undefined;
    queue[i + 1] = undefined;
  }

  len = 0;
}

function attemptVertx() {
  try {
    var vertx = Function('return this')().require('vertx');
    vertxNext = vertx.runOnLoop || vertx.runOnContext;
    return useVertxTimer();
  } catch (e) {
    return useSetTimeout();
  }
}

var scheduleFlush = void 0;
// Decide what async method to use to triggering processing of queued callbacks:
if (isNode) {
  scheduleFlush = useNextTick();
} else if (BrowserMutationObserver) {
  scheduleFlush = useMutationObserver();
} else if (isWorker) {
  scheduleFlush = useMessageChannel();
} else if (browserWindow === undefined && typeof require === 'function') {
  scheduleFlush = attemptVertx();
} else {
  scheduleFlush = useSetTimeout();
}

function then(onFulfillment, onRejection) {
  var parent = this;

  var child = new this.constructor(noop);

  if (child[PROMISE_ID] === undefined) {
    makePromise(child);
  }

  var _state = parent._state;


  if (_state) {
    var callback = arguments[_state - 1];
    asap(function () {
      return invokeCallback(_state, child, callback, parent._result);
    });
  } else {
    subscribe(parent, child, onFulfillment, onRejection);
  }

  return child;
}

/**
  `Promise.resolve` returns a promise that will become resolved with the
  passed `value`. It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    resolve(1);
  });

  promise.then(function(value){
    // value === 1
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.resolve(1);

  promise.then(function(value){
    // value === 1
  });
  ```

  @method resolve
  @static
  @param {Any} value value that the returned promise will be resolved with
  Useful for tooling.
  @return {Promise} a promise that will become fulfilled with the given
  `value`
*/
function resolve$1(object) {
  /*jshint validthis:true */
  var Constructor = this;

  if (object && typeof object === 'object' && object.constructor === Constructor) {
    return object;
  }

  var promise = new Constructor(noop);
  resolve(promise, object);
  return promise;
}

var PROMISE_ID = Math.random().toString(36).substring(2);

function noop() {}

var PENDING = void 0;
var FULFILLED = 1;
var REJECTED = 2;

function selfFulfillment() {
  return new TypeError("You cannot resolve a promise with itself");
}

function cannotReturnOwn() {
  return new TypeError('A promises callback cannot return that same promise.');
}

function tryThen(then$$1, value, fulfillmentHandler, rejectionHandler) {
  try {
    then$$1.call(value, fulfillmentHandler, rejectionHandler);
  } catch (e) {
    return e;
  }
}

function handleForeignThenable(promise, thenable, then$$1) {
  asap(function (promise) {
    var sealed = false;
    var error = tryThen(then$$1, thenable, function (value) {
      if (sealed) {
        return;
      }
      sealed = true;
      if (thenable !== value) {
        resolve(promise, value);
      } else {
        fulfill(promise, value);
      }
    }, function (reason) {
      if (sealed) {
        return;
      }
      sealed = true;

      reject(promise, reason);
    }, 'Settle: ' + (promise._label || ' unknown promise'));

    if (!sealed && error) {
      sealed = true;
      reject(promise, error);
    }
  }, promise);
}

function handleOwnThenable(promise, thenable) {
  if (thenable._state === FULFILLED) {
    fulfill(promise, thenable._result);
  } else if (thenable._state === REJECTED) {
    reject(promise, thenable._result);
  } else {
    subscribe(thenable, undefined, function (value) {
      return resolve(promise, value);
    }, function (reason) {
      return reject(promise, reason);
    });
  }
}

function handleMaybeThenable(promise, maybeThenable, then$$1) {
  if (maybeThenable.constructor === promise.constructor && then$$1 === then && maybeThenable.constructor.resolve === resolve$1) {
    handleOwnThenable(promise, maybeThenable);
  } else {
    if (then$$1 === undefined) {
      fulfill(promise, maybeThenable);
    } else if (isFunction(then$$1)) {
      handleForeignThenable(promise, maybeThenable, then$$1);
    } else {
      fulfill(promise, maybeThenable);
    }
  }
}

function resolve(promise, value) {
  if (promise === value) {
    reject(promise, selfFulfillment());
  } else if (objectOrFunction(value)) {
    var then$$1 = void 0;
    try {
      then$$1 = value.then;
    } catch (error) {
      reject(promise, error);
      return;
    }
    handleMaybeThenable(promise, value, then$$1);
  } else {
    fulfill(promise, value);
  }
}

function publishRejection(promise) {
  if (promise._onerror) {
    promise._onerror(promise._result);
  }

  publish(promise);
}

function fulfill(promise, value) {
  if (promise._state !== PENDING) {
    return;
  }

  promise._result = value;
  promise._state = FULFILLED;

  if (promise._subscribers.length !== 0) {
    asap(publish, promise);
  }
}

function reject(promise, reason) {
  if (promise._state !== PENDING) {
    return;
  }
  promise._state = REJECTED;
  promise._result = reason;

  asap(publishRejection, promise);
}

function subscribe(parent, child, onFulfillment, onRejection) {
  var _subscribers = parent._subscribers;
  var length = _subscribers.length;


  parent._onerror = null;

  _subscribers[length] = child;
  _subscribers[length + FULFILLED] = onFulfillment;
  _subscribers[length + REJECTED] = onRejection;

  if (length === 0 && parent._state) {
    asap(publish, parent);
  }
}

function publish(promise) {
  var subscribers = promise._subscribers;
  var settled = promise._state;

  if (subscribers.length === 0) {
    return;
  }

  var child = void 0,
      callback = void 0,
      detail = promise._result;

  for (var i = 0; i < subscribers.length; i += 3) {
    child = subscribers[i];
    callback = subscribers[i + settled];

    if (child) {
      invokeCallback(settled, child, callback, detail);
    } else {
      callback(detail);
    }
  }

  promise._subscribers.length = 0;
}

function invokeCallback(settled, promise, callback, detail) {
  var hasCallback = isFunction(callback),
      value = void 0,
      error = void 0,
      succeeded = true;

  if (hasCallback) {
    try {
      value = callback(detail);
    } catch (e) {
      succeeded = false;
      error = e;
    }

    if (promise === value) {
      reject(promise, cannotReturnOwn());
      return;
    }
  } else {
    value = detail;
  }

  if (promise._state !== PENDING) {
    // noop
  } else if (hasCallback && succeeded) {
    resolve(promise, value);
  } else if (succeeded === false) {
    reject(promise, error);
  } else if (settled === FULFILLED) {
    fulfill(promise, value);
  } else if (settled === REJECTED) {
    reject(promise, value);
  }
}

function initializePromise(promise, resolver) {
  try {
    resolver(function resolvePromise(value) {
      resolve(promise, value);
    }, function rejectPromise(reason) {
      reject(promise, reason);
    });
  } catch (e) {
    reject(promise, e);
  }
}

var id = 0;
function nextId() {
  return id++;
}

function makePromise(promise) {
  promise[PROMISE_ID] = id++;
  promise._state = undefined;
  promise._result = undefined;
  promise._subscribers = [];
}

function validationError() {
  return new Error('Array Methods must be provided an Array');
}

var Enumerator = function () {
  function Enumerator(Constructor, input) {
    this._instanceConstructor = Constructor;
    this.promise = new Constructor(noop);

    if (!this.promise[PROMISE_ID]) {
      makePromise(this.promise);
    }

    if (isArray(input)) {
      this.length = input.length;
      this._remaining = input.length;

      this._result = new Array(this.length);

      if (this.length === 0) {
        fulfill(this.promise, this._result);
      } else {
        this.length = this.length || 0;
        this._enumerate(input);
        if (this._remaining === 0) {
          fulfill(this.promise, this._result);
        }
      }
    } else {
      reject(this.promise, validationError());
    }
  }

  Enumerator.prototype._enumerate = function _enumerate(input) {
    for (var i = 0; this._state === PENDING && i < input.length; i++) {
      this._eachEntry(input[i], i);
    }
  };

  Enumerator.prototype._eachEntry = function _eachEntry(entry, i) {
    var c = this._instanceConstructor;
    var resolve$$1 = c.resolve;


    if (resolve$$1 === resolve$1) {
      var _then = void 0;
      var error = void 0;
      var didError = false;
      try {
        _then = entry.then;
      } catch (e) {
        didError = true;
        error = e;
      }

      if (_then === then && entry._state !== PENDING) {
        this._settledAt(entry._state, i, entry._result);
      } else if (typeof _then !== 'function') {
        this._remaining--;
        this._result[i] = entry;
      } else if (c === Promise$1) {
        var promise = new c(noop);
        if (didError) {
          reject(promise, error);
        } else {
          handleMaybeThenable(promise, entry, _then);
        }
        this._willSettleAt(promise, i);
      } else {
        this._willSettleAt(new c(function (resolve$$1) {
          return resolve$$1(entry);
        }), i);
      }
    } else {
      this._willSettleAt(resolve$$1(entry), i);
    }
  };

  Enumerator.prototype._settledAt = function _settledAt(state, i, value) {
    var promise = this.promise;


    if (promise._state === PENDING) {
      this._remaining--;

      if (state === REJECTED) {
        reject(promise, value);
      } else {
        this._result[i] = value;
      }
    }

    if (this._remaining === 0) {
      fulfill(promise, this._result);
    }
  };

  Enumerator.prototype._willSettleAt = function _willSettleAt(promise, i) {
    var enumerator = this;

    subscribe(promise, undefined, function (value) {
      return enumerator._settledAt(FULFILLED, i, value);
    }, function (reason) {
      return enumerator._settledAt(REJECTED, i, reason);
    });
  };

  return Enumerator;
}();

/**
  `Promise.all` accepts an array of promises, and returns a new promise which
  is fulfilled with an array of fulfillment values for the passed promises, or
  rejected with the reason of the first passed promise to be rejected. It casts all
  elements of the passed iterable to promises as it runs this algorithm.

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = resolve(2);
  let promise3 = resolve(3);
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // The array here would be [ 1, 2, 3 ];
  });
  ```

  If any of the `promises` given to `all` are rejected, the first promise
  that is rejected will be given as an argument to the returned promises's
  rejection handler. For example:

  Example:

  ```javascript
  let promise1 = resolve(1);
  let promise2 = reject(new Error("2"));
  let promise3 = reject(new Error("3"));
  let promises = [ promise1, promise2, promise3 ];

  Promise.all(promises).then(function(array){
    // Code here never runs because there are rejected promises!
  }, function(error) {
    // error.message === "2"
  });
  ```

  @method all
  @static
  @param {Array} entries array of promises
  @param {String} label optional string for labeling the promise.
  Useful for tooling.
  @return {Promise} promise that is fulfilled when all `promises` have been
  fulfilled, or rejected if any of them become rejected.
  @static
*/
function all(entries) {
  return new Enumerator(this, entries).promise;
}

/**
  `Promise.race` returns a new promise which is settled in the same way as the
  first passed promise to settle.

  Example:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 2');
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // result === 'promise 2' because it was resolved before promise1
    // was resolved.
  });
  ```

  `Promise.race` is deterministic in that only the state of the first
  settled promise matters. For example, even if other promises given to the
  `promises` array argument are resolved, but the first settled promise has
  become rejected before the other promises became fulfilled, the returned
  promise will become rejected:

  ```javascript
  let promise1 = new Promise(function(resolve, reject){
    setTimeout(function(){
      resolve('promise 1');
    }, 200);
  });

  let promise2 = new Promise(function(resolve, reject){
    setTimeout(function(){
      reject(new Error('promise 2'));
    }, 100);
  });

  Promise.race([promise1, promise2]).then(function(result){
    // Code here never runs
  }, function(reason){
    // reason.message === 'promise 2' because promise 2 became rejected before
    // promise 1 became fulfilled
  });
  ```

  An example real-world use case is implementing timeouts:

  ```javascript
  Promise.race([ajax('foo.json'), timeout(5000)])
  ```

  @method race
  @static
  @param {Array} promises array of promises to observe
  Useful for tooling.
  @return {Promise} a promise which settles in the same way as the first passed
  promise to settle.
*/
function race(entries) {
  /*jshint validthis:true */
  var Constructor = this;

  if (!isArray(entries)) {
    return new Constructor(function (_, reject) {
      return reject(new TypeError('You must pass an array to race.'));
    });
  } else {
    return new Constructor(function (resolve, reject) {
      var length = entries.length;
      for (var i = 0; i < length; i++) {
        Constructor.resolve(entries[i]).then(resolve, reject);
      }
    });
  }
}

/**
  `Promise.reject` returns a promise rejected with the passed `reason`.
  It is shorthand for the following:

  ```javascript
  let promise = new Promise(function(resolve, reject){
    reject(new Error('WHOOPS'));
  });

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  Instead of writing the above, your code now simply becomes the following:

  ```javascript
  let promise = Promise.reject(new Error('WHOOPS'));

  promise.then(function(value){
    // Code here doesn't run because the promise is rejected!
  }, function(reason){
    // reason.message === 'WHOOPS'
  });
  ```

  @method reject
  @static
  @param {Any} reason value that the returned promise will be rejected with.
  Useful for tooling.
  @return {Promise} a promise rejected with the given `reason`.
*/
function reject$1(reason) {
  /*jshint validthis:true */
  var Constructor = this;
  var promise = new Constructor(noop);
  reject(promise, reason);
  return promise;
}

function needsResolver() {
  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
}

function needsNew() {
  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
}

/**
  Promise objects represent the eventual result of an asynchronous operation. The
  primary way of interacting with a promise is through its `then` method, which
  registers callbacks to receive either a promise's eventual value or the reason
  why the promise cannot be fulfilled.

  Terminology
  -----------

  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
  - `thenable` is an object or function that defines a `then` method.
  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
  - `exception` is a value that is thrown using the throw statement.
  - `reason` is a value that indicates why a promise was rejected.
  - `settled` the final resting state of a promise, fulfilled or rejected.

  A promise can be in one of three states: pending, fulfilled, or rejected.

  Promises that are fulfilled have a fulfillment value and are in the fulfilled
  state.  Promises that are rejected have a rejection reason and are in the
  rejected state.  A fulfillment value is never a thenable.

  Promises can also be said to *resolve* a value.  If this value is also a
  promise, then the original promise's settled state will match the value's
  settled state.  So a promise that *resolves* a promise that rejects will
  itself reject, and a promise that *resolves* a promise that fulfills will
  itself fulfill.


  Basic Usage:
  ------------

  ```js
  let promise = new Promise(function(resolve, reject) {
    // on success
    resolve(value);

    // on failure
    reject(reason);
  });

  promise.then(function(value) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Advanced Usage:
  ---------------

  Promises shine when abstracting away asynchronous interactions such as
  `XMLHttpRequest`s.

  ```js
  function getJSON(url) {
    return new Promise(function(resolve, reject){
      let xhr = new XMLHttpRequest();

      xhr.open('GET', url);
      xhr.onreadystatechange = handler;
      xhr.responseType = 'json';
      xhr.setRequestHeader('Accept', 'application/json');
      xhr.send();

      function handler() {
        if (this.readyState === this.DONE) {
          if (this.status === 200) {
            resolve(this.response);
          } else {
            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
          }
        }
      };
    });
  }

  getJSON('/posts.json').then(function(json) {
    // on fulfillment
  }, function(reason) {
    // on rejection
  });
  ```

  Unlike callbacks, promises are great composable primitives.

  ```js
  Promise.all([
    getJSON('/posts'),
    getJSON('/comments')
  ]).then(function(values){
    values[0] // => postsJSON
    values[1] // => commentsJSON

    return values;
  });
  ```

  @class Promise
  @param {Function} resolver
  Useful for tooling.
  @constructor
*/

var Promise$1 = function () {
  function Promise(resolver) {
    this[PROMISE_ID] = nextId();
    this._result = this._state = undefined;
    this._subscribers = [];

    if (noop !== resolver) {
      typeof resolver !== 'function' && needsResolver();
      this instanceof Promise ? initializePromise(this, resolver) : needsNew();
    }
  }

  /**
  The primary way of interacting with a promise is through its `then` method,
  which registers callbacks to receive either a promise's eventual value or the
  reason why the promise cannot be fulfilled.
   ```js
  findUser().then(function(user){
    // user is available
  }, function(reason){
    // user is unavailable, and you are given the reason why
  });
  ```
   Chaining
  --------
   The return value of `then` is itself a promise.  This second, 'downstream'
  promise is resolved with the return value of the first promise's fulfillment
  or rejection handler, or rejected if the handler throws an exception.
   ```js
  findUser().then(function (user) {
    return user.name;
  }, function (reason) {
    return 'default name';
  }).then(function (userName) {
    // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
    // will be `'default name'`
  });
   findUser().then(function (user) {
    throw new Error('Found user, but still unhappy');
  }, function (reason) {
    throw new Error('`findUser` rejected and we're unhappy');
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
    // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
  });
  ```
  If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
   ```js
  findUser().then(function (user) {
    throw new PedagogicalException('Upstream error');
  }).then(function (value) {
    // never reached
  }).then(function (value) {
    // never reached
  }, function (reason) {
    // The `PedgagocialException` is propagated all the way down to here
  });
  ```
   Assimilation
  ------------
   Sometimes the value you want to propagate to a downstream promise can only be
  retrieved asynchronously. This can be achieved by returning a promise in the
  fulfillment or rejection handler. The downstream promise will then be pending
  until the returned promise is settled. This is called *assimilation*.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // The user's comments are now available
  });
  ```
   If the assimliated promise rejects, then the downstream promise will also reject.
   ```js
  findUser().then(function (user) {
    return findCommentsByAuthor(user);
  }).then(function (comments) {
    // If `findCommentsByAuthor` fulfills, we'll have the value here
  }, function (reason) {
    // If `findCommentsByAuthor` rejects, we'll have the reason here
  });
  ```
   Simple Example
  --------------
   Synchronous Example
   ```javascript
  let result;
   try {
    result = findResult();
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
  findResult(function(result, err){
    if (err) {
      // failure
    } else {
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findResult().then(function(result){
    // success
  }, function(reason){
    // failure
  });
  ```
   Advanced Example
  --------------
   Synchronous Example
   ```javascript
  let author, books;
   try {
    author = findAuthor();
    books  = findBooksByAuthor(author);
    // success
  } catch(reason) {
    // failure
  }
  ```
   Errback Example
   ```js
   function foundBooks(books) {
   }
   function failure(reason) {
   }
   findAuthor(function(author, err){
    if (err) {
      failure(err);
      // failure
    } else {
      try {
        findBoooksByAuthor(author, function(books, err) {
          if (err) {
            failure(err);
          } else {
            try {
              foundBooks(books);
            } catch(reason) {
              failure(reason);
            }
          }
        });
      } catch(error) {
        failure(err);
      }
      // success
    }
  });
  ```
   Promise Example;
   ```javascript
  findAuthor().
    then(findBooksByAuthor).
    then(function(books){
      // found books
  }).catch(function(reason){
    // something went wrong
  });
  ```
   @method then
  @param {Function} onFulfilled
  @param {Function} onRejected
  Useful for tooling.
  @return {Promise}
  */

  /**
  `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
  as the catch block of a try/catch statement.
  ```js
  function findAuthor(){
  throw new Error('couldn't find that author');
  }
  // synchronous
  try {
  findAuthor();
  } catch(reason) {
  // something went wrong
  }
  // async with promises
  findAuthor().catch(function(reason){
  // something went wrong
  });
  ```
  @method catch
  @param {Function} onRejection
  Useful for tooling.
  @return {Promise}
  */


  Promise.prototype.catch = function _catch(onRejection) {
    return this.then(null, onRejection);
  };

  /**
    `finally` will be invoked regardless of the promise's fate just as native
    try/catch/finally behaves
  
    Synchronous example:
  
    ```js
    findAuthor() {
      if (Math.random() > 0.5) {
        throw new Error();
      }
      return new Author();
    }
  
    try {
      return findAuthor(); // succeed or fail
    } catch(error) {
      return findOtherAuther();
    } finally {
      // always runs
      // doesn't affect the return value
    }
    ```
  
    Asynchronous example:
  
    ```js
    findAuthor().catch(function(reason){
      return findOtherAuther();
    }).finally(function(){
      // author was either found, or not
    });
    ```
  
    @method finally
    @param {Function} callback
    @return {Promise}
  */


  Promise.prototype.finally = function _finally(callback) {
    var promise = this;
    var constructor = promise.constructor;

    if (isFunction(callback)) {
      return promise.then(function (value) {
        return constructor.resolve(callback()).then(function () {
          return value;
        });
      }, function (reason) {
        return constructor.resolve(callback()).then(function () {
          throw reason;
        });
      });
    }

    return promise.then(callback, callback);
  };

  return Promise;
}();

Promise$1.prototype.then = then;
Promise$1.all = all;
Promise$1.race = race;
Promise$1.resolve = resolve$1;
Promise$1.reject = reject$1;
Promise$1._setScheduler = setScheduler;
Promise$1._setAsap = setAsap;
Promise$1._asap = asap;

/*global self*/
function polyfill() {
  var local = void 0;

  if (typeof global !== 'undefined') {
    local = global;
  } else if (typeof self !== 'undefined') {
    local = self;
  } else {
    try {
      local = Function('return this')();
    } catch (e) {
      throw new Error('polyfill failed because global object is unavailable in this environment');
    }
  }

  var P = local.Promise;

  if (P) {
    var promiseToString = null;
    try {
      promiseToString = Object.prototype.toString.call(P.resolve());
    } catch (e) {
      // silently ignored
    }

    if (promiseToString === '[object Promise]' && !P.cast) {
      return;
    }
  }

  local.Promise = Promise$1;
}

// Strange compat..
Promise$1.polyfill = polyfill;
Promise$1.Promise = Promise$1;

return Promise$1;

})));



//# sourceMappingURL=es6-promise.map
;
//jshint eqnull:true

define('amber/kernel-checks',[],function () {
    "use strict";

    function assert (fn) {
        try {
            if (fn()) return;
        } catch (ex) {
            throw new Error("Error:\n" + ex + "in assertion:\n" + fn);
        }
        throw new Error("Assertion failed:\n" + fn);
    }

    assert(function () {
        return !("hasOwnProperty" in Object.create(null));
    });
    assert(function () {
        return Object.getPrototypeOf(Object.create(null)) === null;
    });
    assert(function () {
        var p = {};
        return Object.getPrototypeOf(Object.create(p)) === p;
    });
    assert(function () {
        var p = {x: 4, y: 5}, q = {x: 6};
        var r = Object.setPrototypeOf(q, p);
        return r === q &&
            q.x === 6 &&
            q.y === 5;
    });
    // assert(function () {
    //     return new Function("return this")().Object === Object;
    // });
    // assert(function () {
    //     return Object.create(new Function("return this")()).Object === Object;
    // });
    assert(function () {
        return typeof global !== "undefined";
    });
    assert(function () {
        return global.Object === Object;
    });
    assert(function () {
        return Object.create(global).Object === Object;
    });
    assert(function () {
        return (function () {
                return this;
            }).apply(void 0) === void 0;
    });
    assert(function () {
        return (function () {
                return this;
            }).apply(null) === null;
    });
    assert(function () {
        return (function () {
                return this;
            }).apply(3) === 3;
    });
    assert(function () {
        return (function () {
                return this;
            }).apply("foo") === "foo";
    });
    assert(function () {
        return (function () {
                return this;
            }).apply(true) === true;
    });
    assert(function () {
        var o = Object.freeze({});
        try {
            o.foo = "bar";
        } catch (ex) {
        }
        return o.foo == null;
    });
    assert(function () {
        return typeof Promise === "function";
    });
    assert(function () {
        return typeof Promise.resolve === "function";
    });
    assert(function () {
        return typeof Promise.reject === "function";
    });
    assert(function () {
        return typeof new Promise(function () {
            }).then === "function";
    });
});

define('amber/brikz',[], function () {
    return function Brikz(api, apiKey, initKey, backupKey) {
        "use strict";

        //jshint eqnull:true

        var backup = {};
        apiKey = apiKey || 'exports';
        initKey = initKey || '__init__';
        backupKey = backupKey || 'backup';

        function mixin(src, target, what) {
            for (var keys = Object.keys(what || src), l = keys.length, i = 0; i < l; ++i) {
                if (src == null) {
                    target[keys[i]] = undefined;
                } else {
                    var value = src[keys[i]];
                    if (typeof value !== "undefined") {
                        target[keys[i]] = value;
                    }
                }
            }
            return target;
        }

        return function brikz() {
            Object.keys(backup).forEach(function (key) {
                mixin(null, api, (backup[key] || 0)[apiKey] || {});
            });
            var oapi = mixin(api, {}),
                order = [],
                chk = {};

            function ensure(key) {
                var b = brikz[key],
                    bak = backup[key];
                while (typeof b === "function") {
                    (b.deps || []).forEach(ensure);
                    b[backupKey] = bak;
                    mixin(null, api, api);
                    b = new b(brikz, api);
                }
                brikz[key] = b;
                if (b && !chk[key]) {
                    chk[key] = true;
                    order.push(b);
                }
                if (b && !b[apiKey]) {
                    b[apiKey] = mixin(api, {});
                }
            }

            Object.keys(brikz).forEach(ensure);
            mixin(oapi, mixin(null, api, api));
            order.forEach(function (brik) {
                mixin(brik[apiKey] || {}, api);
            });
            order.forEach(function (brik) {
                if (brik[initKey]) {
                    brik[initKey]();
                    if (brik[initKey].once) {
                        delete brik[initKey];
                    }
                }
            });
            backup = mixin(brikz, {});
        };
    };
});
//jshint eqnull:true

define('amber/junk-drawer',[],function () {
    "use strict";

    function inherits (child, parent) {
        child.prototype = Object.create(parent.prototype, {
            constructor: {
                value: child,
                enumerable: false, configurable: true, writable: true
            }
        });
        return child;
    }

    function installMethodOfJsObject (obj, name, fn) {
        Object.defineProperty(obj, name, {
            value: fn,
            enumerable: false, configurable: true, writable: true
        });
    }

    function noop () {
    }

    function declareJsMethod (obj, name) {
        if (obj[name] == null) installMethodOfJsObject(obj, name, noop);
    }

    var table = {
        ':': '_',
        '&': '_and',
        '|': '_or',
        '+': '_plus',
        '-': '_minus',
        '*': '_star',
        '/': '_slash',
        '\\': '_backslash',
        '~': '_tild',
        '%': '_percent',
        '>': '_gt',
        '<': '_lt',
        '=': '_eq',
        ',': '_comma',
        '@': '_at'
    };

    /* Convert a Smalltalk selector into a JS selector */
    function st2js (string) {
        return '_' + string
            .replace(/[:&|+\-*/\\~%><=,@]/g, function (ch) {
                return table[ch];
            });
    };

    function js2st (selector) {
        if (selector.match(/^__/)) {
            return binaryJsToSt(selector);
        } else {
            return keywordJsToSt(selector);
        }
    }

    function keywordJsToSt (selector) {
        return selector.replace(/^_/, '').replace(/_/g, ':');
    }

    function binaryJsToSt (selector) {
        return selector
            .replace(/^_/, '')
            .replace(/_and/g, '&')
            .replace(/_or/g, '|')
            .replace(/_plus/g, '+')
            .replace(/_minus/g, '-')
            .replace(/_star/g, '*')
            .replace(/_slash/g, '/')
            .replace(/_backslash/g, '\\')
            .replace(/_tild/g, '~')
            .replace(/_percent/g, '%')
            .replace(/_gt/g, '>')
            .replace(/_lt/g, '<')
            .replace(/_eq/g, '=')
            .replace(/_comma/g, ',')
            .replace(/_at/g, '@');
    }

    function addElement (array, el) {
        if (typeof el === 'undefined') {
            return;
        }
        if (array.indexOf(el) === -1) {
            array.push(el);
        }
    }

    function removeElement (array, el) {
        var i = array.indexOf(el);
        if (i !== -1) {
            array.splice(i, 1);
        }
    }

    function extend (target, source) {
        Object.keys(source).forEach(function (key) {
            target[key] = source[key];
        });
        return target;
    }

    function extendWithMethods (target, source) {
        Object.keys(source).forEach(function (key) {
            installMethodOfJsObject(target, key, source[key]);
        });
        return target;
    }

    function deleteKeysFrom (keys, obj) {
        keys.forEach(function (each) {
            delete obj[each];
        });
    }

    return {
        deleteKeysFrom: deleteKeysFrom,
        extendWithMethods: extendWithMethods,
        extend: extend,
        removeElement: removeElement,
        addElement: addElement,
        js2st: js2st,
        st2js: st2js,
        declareJsMethod: declareJsMethod,
        installMethodOfJsObject: installMethodOfJsObject,
        inherits: inherits
    }
});

//jshint eqnull:true

define('amber/kernel-fundamentals',['./junk-drawer'], function ($goodies) {
    "use strict";

    var inherits = $goodies.inherits;
    var declareJsMethod = $goodies.declareJsMethod;
    var addElement = $goodies.addElement;
    var removeElement = $goodies.removeElement;

    var hop = Object.prototype.hasOwnProperty;

    function SelectorsBrik (brikz, st) {
        var selectorSet = Object.create(null);
        var selectors = this.selectors = [];

        this.registerSelector = function (stSelector) {
            if (selectorSet[stSelector]) return false;
            selectors.push(stSelector);
            return selectorSet[stSelector] = true;
        };

        st.allSelectors = function () {
            return selectors;
        };
    }

    function PackagesBrik (brikz, st) {
        st.packageDescriptors = {};

        /* Add a package load descriptor to the system */
        st.addPackage = function (name, properties) {
            if (!name) return null;
            return st.packageDescriptors[name] = {properties: properties};
        };
    }

    function FundamentalsFactory (globals, emit) {
        var specialConstructors = Object.create(null);

        function declareEvent (name) {
            declareJsMethod(emit, name);
        }

        function RootBrik (brikz, st) {
            /* Smalltalk foundational objects */

            /* SmalltalkRoot is the hidden root of the normal Amber hierarchy.
             All objects including `ProtoObject` inherit from SmalltalkRoot.
             Detached roots (eg. wrapped JS classes like Number or Date)
             do not directly inherit from SmalltalkRoot, but employ a workaround.*/
            function SmalltalkRoot () {
            }

            function SmalltalkProtoObject () {
            }

            function SmalltalkObject () {
            }

            specialConstructors.ProtoObject = inherits(SmalltalkProtoObject, SmalltalkRoot);
            specialConstructors.Object = inherits(SmalltalkObject, SmalltalkProtoObject);

            this.Root = SmalltalkRoot;
            this.Object = SmalltalkObject;
        }

        BehavioralsBrik.deps = ["root"];

        function BehavioralsBrik (brikz, st) {
            /* Smalltalk classes and traits */

            var traitsOrClasses = [];

            this.buildTraitOrClass = function (builder) {
                var traitOrClass = globals.hasOwnProperty(builder.name) && globals[builder.name];
                if (traitOrClass) {
                    builder.updateExisting(traitOrClass);
                    return traitOrClass;
                } else {
                    return addTraitOrClass(builder.make());
                }
            };

            declareEvent("behavioralAdded");

            function addTraitOrClass (traitOrClass) {
                globals[traitOrClass.name] = traitOrClass;
                addElement(traitsOrClasses, traitOrClass);
                traitOrClass.added();
                emit.behavioralAdded(traitOrClass);
                return traitOrClass;
            }

            declareEvent("behavioralRemoved");

            function removeTraitOrClass (traitOrClass) {
                emit.behavioralRemoved(traitOrClass);
                traitOrClass.removed();
                removeElement(traitsOrClasses, traitOrClass);
                delete globals[traitOrClass.name];
                return traitOrClass;
            }

            this.removeTraitOrClass = removeTraitOrClass;

            st.traitsOrClasses = this.traitsOrClasses = traitsOrClasses;
        }

        MethodsBrik.deps = ["selectors", "root"];

        function MethodsBrik (brikz, st) {
            var registerSelector = brikz.selectors.registerSelector;
            var SmalltalkObject = brikz.root.Object;

            function SmalltalkMethod () {
            }

            specialConstructors.CompiledMethod = inherits(SmalltalkMethod, SmalltalkObject);

            /* Smalltalk method object. To add a method to a class,
             use api.addMethod() */

            st.method = function (spec, factory) {
                var that = new SmalltalkMethod();
                that.selector = spec.selector;
                that.args = spec.args || [];
                that.protocol = spec.protocol;
                that.source = spec.source;
                that.pragmas = spec.pragmas;
                that.messageSends = spec.messageSends || [];
                // TODO remove .referencedClasses, have .referencedGlobals
                that.referencedClasses = spec.referencedClasses || [];
                that.fn = spec.fn;
                if (factory) that.instantiateFn = factory;
                return that;
            };

            /* Add/remove a method to/from a class */

            st.addMethod = function (method, traitOrBehavior) {
                if (method.owner != null) {
                    throw new Error("addMethod: Method " + method.selector + " already bound to " + method.owner);
                }
                method.owner = traitOrBehavior;
                registerNewSelectors(method);
                traitOrBehavior.localMethods[method.selector] = method;
                updateMethod(method.selector, traitOrBehavior);
            };

            declareEvent("selectorsAdded");

            function registerNewSelectors (method) {
                var newSelectors = [];

                function selectorInUse (stSelector) {
                    if (registerSelector(stSelector)) {
                        newSelectors.push(stSelector);
                    }
                }

                selectorInUse(method.selector);
                method.messageSends.forEach(selectorInUse);
                emit.selectorsAdded(newSelectors);
            }

            st.removeMethod = function (method, traitOrBehavior) {
                if (traitOrBehavior.localMethods[method.selector] !== method) return;

                delete traitOrBehavior.localMethods[method.selector];
                updateMethod(method.selector, traitOrBehavior);
            };

            this.setupMethods = function (traitOrBehavior) {
                traitOrBehavior.localMethods = Object.create(null);
                var superclass = traitOrBehavior.superclass;
                traitOrBehavior.methods = Object.create(superclass ? superclass.methods : null);
            };

            function setLocalMethods (traitOrBehavior, newLocalMethods) {
                var oldLocalMethods = traitOrBehavior.localMethods;
                traitOrBehavior.localMethods = newLocalMethods;
                var selector;
                for (selector in newLocalMethods) {
                    updateMethod(selector, traitOrBehavior);
                }
                for (selector in oldLocalMethods) {
                    updateMethod(selector, traitOrBehavior);
                }
            }

            this.setLocalMethods = setLocalMethods;

            declareEvent("methodReplaced");

            function updateMethod (selector, traitOrBehavior) {
                var oldMethod,
                    newMethod = traitOrBehavior.localMethods[selector],
                    methods = traitOrBehavior.methods;
                if (hop.call(methods, selector)) {
                    oldMethod = methods[selector];
                    if (newMethod === oldMethod) return;
                } else {
                    if (newMethod == null) {
                        console.warn("Removal of nonexistent method " + traitOrBehavior + " >> " + selector);
                        return;
                    }
                    oldMethod = null;
                }
                if (newMethod != null) {
                    if (newMethod.methodClass && newMethod.methodClass !== traitOrBehavior) {
                        console.warn("Resetting methodClass of " + newMethod.methodClass.name + " >> " + selector + " to " + traitOrBehavior.name);
                    }
                    newMethod.methodClass = traitOrBehavior;
                    methods[selector] = newMethod;
                    traitOrBehavior.methodAdded(newMethod);
                } else {
                    delete methods[selector];
                    traitOrBehavior.methodRemoved(oldMethod);
                }
                emit.methodReplaced(newMethod, oldMethod, traitOrBehavior);
            }

            this.updateMethod = updateMethod;
        }

        NilBrik.deps = ["root"];

        function NilBrik (brikz, st) {
            var SmalltalkObject = brikz.root.Object;

            function SmalltalkNil () {
            }

            specialConstructors.UndefinedObject = inherits(SmalltalkNil, SmalltalkObject);

            this.nilAsReceiver = new SmalltalkNil();
            this.nilAsValue = this.nilAsReceiver; // TODO null

            // Adds an `a$nil` property to the `nil` object.  When sending
            // nil objects from one environment to another, doing
            // `anObject == nil` (in JavaScript) does not always answer
            // true as the referenced nil object might come from the other
            // environment.
            Object.defineProperty(this.nilAsReceiver, 'a$nil', {
                value: true,
                enumerable: false, configurable: false, writable: false
            });
        }

        /* Making smalltalk that has basic building blocks */
        function configure (brikz) {
            brikz.root = RootBrik;
            brikz.nil = NilBrik;
            brikz.selectors = SelectorsBrik;
            brikz.packages = PackagesBrik;
            brikz.behaviorals = BehavioralsBrik;
            brikz.methods = MethodsBrik;

            brikz();
        }

        return {configure: configure, specialConstructors: specialConstructors};
    }

    return FundamentalsFactory;
});

//jshint eqnull:true

define('amber/kernel-language',['./junk-drawer'], function ($goodies) {
    "use strict";

    var inherits = $goodies.inherits;
    var declareJsMethod = $goodies.declareJsMethod;
    var addElement = $goodies.addElement;
    var removeElement = $goodies.removeElement;
    var extend = $goodies.extend;
    var deleteKeysFrom = $goodies.deleteKeysFrom;

    MethodCompositionBrik.deps = ["methods"];

    function MethodCompositionBrik (brikz, st) {
        var setLocalMethods = brikz.methods.setLocalMethods;
        var updateMethod = brikz.methods.updateMethod;

        function aliased (selector, method) {
            var result = st.method(method, method.instantiateFn);
            if (method.selector !== selector) {
                result.selector = selector;
                result.source = '"Aliased as ' + selector + '"\n' + method.source;
            }
            result.owner = method.owner;
            return result;
        }

        function fillTraitTransformation (traitTransformation, obj) {
            // assert(Object.getOwnProperties(obj).length === 0)
            var traitMethods = traitTransformation.trait.methods;
            Object.keys(traitMethods).forEach(function (selector) {
                obj[selector] = aliased(selector, traitMethods[selector]);
            });
            var traitAliases = traitTransformation.aliases;
            if (traitAliases) {
                Object.keys(traitAliases).forEach(function (aliasSelector) {
                    var aliasedMethod = traitMethods[traitAliases[aliasSelector]];
                    if (aliasedMethod) obj[aliasSelector] = aliased(aliasSelector, aliasedMethod);
                    // else delete obj[aliasSelector]; // semantically correct; optimized away
                });
            }
            var traitExclusions = traitTransformation.exclusions;
            if (traitExclusions) {
                deleteKeysFrom(traitExclusions, obj);
            }
            return obj;
        }

        function buildCompositionChain (traitComposition) {
            return traitComposition.reduce(function (soFar, each) {
                return fillTraitTransformation(each, Object.create(soFar));
            }, null);
        }

        st.setTraitComposition = function (traitComposition, traitOrBehavior) {
            var oldLocalMethods = traitOrBehavior.localMethods,
                newLocalMethodsTemplate = Object.create(buildCompositionChain(traitComposition));
            setLocalMethods(traitOrBehavior, extend(newLocalMethodsTemplate, oldLocalMethods));
            (traitOrBehavior.traitComposition || []).forEach(function (each) {
                removeElement(each.trait.traitUsers, traitOrBehavior);
            });
            traitOrBehavior.traitComposition = traitComposition && traitComposition.length ? traitComposition : null;
            (traitOrBehavior.traitComposition || []).forEach(function (each) {
                addElement(each.trait.traitUsers, traitOrBehavior);
            });
        };

        function aliasesOfSelector (selector, traitAliases) {
            if (!traitAliases) return [selector];
            var result = Object.keys(traitAliases).filter(function (aliasSelector) {
                return traitAliases[aliasSelector] === selector
            });
            if (!traitAliases[selector]) result.push(selector);
            return result;
        }

        function applyTraitMethodAddition (selector, method, traitTransformation, obj) {
            var changes = aliasesOfSelector(selector, traitTransformation.aliases);
            changes.forEach(function (aliasSelector) {
                obj[aliasSelector] = aliased(aliasSelector, method);
            });
            var traitExclusions = traitTransformation.exclusions;
            if (traitExclusions) {
                deleteKeysFrom(traitExclusions, obj);
            }
            return changes;
        }

        function applyTraitMethodDeletion (selector, traitTransformation, obj) {
            var changes = aliasesOfSelector(selector, traitTransformation.aliases);
            deleteKeysFrom(changes, obj);
            return changes;
        }

        function traitMethodChanged (selector, method, trait, traitOrBehavior) {
            var traitComposition = traitOrBehavior.traitComposition,
                chain = traitOrBehavior.localMethods,
                changes = [];
            for (var i = traitComposition.length - 1; i >= 0; --i) {
                chain = Object.getPrototypeOf(chain);
                var traitTransformation = traitComposition[i];
                if (traitTransformation.trait !== trait) continue;
                changes.push.apply(changes, method ?
                    applyTraitMethodAddition(selector, method, traitTransformation, chain) :
                    applyTraitMethodDeletion(selector, traitTransformation, chain));
            }
            // assert(chain === null);
            changes.forEach(function (each) {
                updateMethod(each, traitOrBehavior);
            });
        }

        this.traitMethodChanged = traitMethodChanged;
    }

    function LanguageFactory (specialConstructors, emit) {
        function declareEvent (name) {
            declareJsMethod(emit, name);
        }

        TraitsBrik.deps = ["behaviorals", "methods", "composition", "root"];

        function TraitsBrik (brikz, st) {
            var SmalltalkObject = brikz.root.Object;
            var setupMethods = brikz.methods.setupMethods;
            var traitMethodChanged = brikz.composition.traitMethodChanged;
            var buildTraitOrClass = brikz.behaviorals.buildTraitOrClass;

            function SmalltalkTrait () {
            }

            specialConstructors.Trait = inherits(SmalltalkTrait, SmalltalkObject);

            SmalltalkTrait.prototype.trait = true;
            declareJsMethod(SmalltalkTrait.prototype, "toString");
            declareJsMethod(SmalltalkTrait.prototype, "added");
            declareJsMethod(SmalltalkTrait.prototype, "removed");
            declareJsMethod(SmalltalkTrait.prototype, "methodAdded");
            declareJsMethod(SmalltalkTrait.prototype, "methodRemoved");

            SmalltalkTrait.prototype.toString = function () {
                return 'Smalltalk Trait ' + this.name;
            };

            SmalltalkTrait.prototype.methodAdded = function (method) {
                propagateMethodChange(this, method.selector, method);
            };

            SmalltalkTrait.prototype.methodRemoved = function (method) {
                propagateMethodChange(this, method.selector, null);
            };

            function propagateMethodChange (trait, selector, method) {
                trait.traitUsers.forEach(function (each) {
                    traitMethodChanged(selector, method, trait, each);
                });
            }

            function traitBuilder (traitName, category) {
                return {
                    name: traitName,
                    make: function () {
                        var that = new SmalltalkTrait();
                        that.name = traitName;
                        that.category = category;
                        that.traitUsers = [];
                        setupMethods(that);
                        return that;
                    },
                    updateExisting: function (trait) {
                    }
                };
            }

            st.addTrait = function (className, category) {
                return buildTraitOrClass(traitBuilder(className, category));
            };
        }

        ClassModelBrik.deps = ["root", "nil"];

        function ClassModelBrik (brikz, st) {
            var SmalltalkRoot = brikz.root.Root;
            var SmalltalkObject = brikz.root.Object;
            var nilAsReceiver = brikz.nil.nilAsReceiver;

            function SmalltalkBehavior () {
            }

            function SmalltalkClass () {
            }

            function SmalltalkMetaclass () {
            }

            this.newMetaclass = function () {
                return new SmalltalkMetaclass();
            };

            specialConstructors.Behavior = inherits(SmalltalkBehavior, SmalltalkObject);
            specialConstructors.Class = inherits(SmalltalkClass, SmalltalkBehavior);
            specialConstructors.Metaclass = inherits(SmalltalkMetaclass, SmalltalkBehavior);

            SmalltalkMetaclass.prototype.meta = true;
            declareJsMethod(SmalltalkClass.prototype, "toString");
            declareJsMethod(SmalltalkMetaclass.prototype, "toString");
            declareJsMethod(SmalltalkClass.prototype, "added");
            declareJsMethod(SmalltalkClass.prototype, "removed");
            declareJsMethod(SmalltalkBehavior.prototype, "methodAdded");
            declareJsMethod(SmalltalkBehavior.prototype, "methodRemoved");

            SmalltalkClass.prototype.toString = function () {
                return 'Smalltalk ' + this.name;
            };

            SmalltalkMetaclass.prototype.toString = function () {
                return 'Smalltalk Metaclass ' + this.instanceClass.name;
            };

            declareEvent("classCreated");
            SmalltalkClass.prototype.added = function () {
                registerToSuperclass(this);
                emit.classCreated(this);
            };

            SmalltalkClass.prototype.removed = function () {
                unregisterFromSuperclass(this);
            };

            declareEvent("behaviorMethodAdded");
            SmalltalkBehavior.prototype.methodAdded = function (method) {
                emit.behaviorMethodAdded(method, this);
            };

            declareEvent("behaviorMethodRemoved");
            SmalltalkBehavior.prototype.methodRemoved = function (method) {
                emit.behaviorMethodRemoved(method, this);
            };

            // Fake root class of the system.
            // Effective superclass of all classes created with `nil subclass: ...`.
            var nilAsClass = this.nilAsClass = {
                fn: SmalltalkRoot,
                subclasses: [],
                a$cls: {fn: SmalltalkClass, methods: Object.create(null)}
            };

            this.bootstrapHierarchy = function (realClass) {
                nilAsClass.a$cls = realClass;
                nilAsClass.subclasses.forEach(function (each) {
                    each.a$cls.superclass = realClass;
                    Object.setPrototypeOf(each.a$cls.methods, realClass.methods);
                    registerToSuperclass(each.a$cls);
                });
            };

            function registerToSuperclass (klass) {
                addElement((klass.superclass || nilAsClass).subclasses, klass);
            }

            function unregisterFromSuperclass (klass) {
                removeElement((klass.superclass || nilAsClass).subclasses, klass);
            }

            function metaSubclasses (metaclass) {
                return metaclass.instanceClass.subclasses
                    .filter(function (each) {
                        return !each.meta;
                    })
                    .map(function (each) {
                        return each.a$cls;
                    });
            }

            st.metaSubclasses = metaSubclasses;

            st.traverseClassTree = function (klass, fn) {
                var queue = [klass], sentinel = {};
                for (var i = 0; i < queue.length; ++i) {
                    var item = queue[i];
                    if (fn(item, sentinel) === sentinel) continue;
                    var subclasses = item.meta ? metaSubclasses(item) : item.subclasses;
                    queue.push.apply(queue, subclasses);
                }
            };

            /**
             * This function is used all over the compiled amber code.
             * It takes any value (JavaScript or Smalltalk)
             * and returns a proper Amber Smalltalk receiver.
             *
             * null or undefined -> nilAsReceiver,
             * object having Smalltalk signature -> unchanged,
             * otherwise wrapped foreign (JS) object
             */
            this.asReceiver = function (o) {
                if (o == null) return nilAsReceiver;
                else if (o.a$cls != null) return o;
                else return st.wrapJavaScript(o);
            };

            // TODO remove, .iVarNames backward compatibility
            this.__init__ = function () {
                brikz.classConstruction.iVarNamesCompat(SmalltalkBehavior);
            };
        }

        ClassConstructionBrik.deps = ["classModel", "behaviorals", "methods"];

        function ClassConstructionBrik (brikz, st) {
            var nilAsClass = brikz.classModel.nilAsClass;
            var newMetaclass = brikz.classModel.newMetaclass;
            var buildTraitOrClass = brikz.behaviorals.buildTraitOrClass;
            var setupMethods = brikz.methods.setupMethods;
            var removeTraitOrClass = brikz.behaviorals.removeTraitOrClass;

            declareEvent("slotsChanged");

            function setSlots (klass, slots) {
                slots.forEach(function (name) {
                    if (!name.match(/^[a-zA-Z][a-zA-Z0-9]*$/))
                        throw new Error("Wrong identifier name: " + name);
                });

                klass.slots = slots;
                emit.slotsChanged(klass);
            }

            st.setSlots = setSlots;

            // TODO remove, .iVarNames backward compatibility
            this.iVarNamesCompat = function (SmalltalkBehavior) {
                Object.defineProperty(SmalltalkBehavior.prototype, "iVarNames", {
                    enumerable: true,
                    configurable: true,
                    get: function () {
                        return this.slots;
                    },
                    set: function (instanceVariableNames) {
                        setSlots(this, instanceVariableNames);
                    }
                });
            };

            /* Smalltalk class creation. A class is an instance of an automatically
             created metaclass object. Newly created classes (not their metaclass)
             should be added to the system, see smalltalk.addClass().
             Superclass linking is *not* handled here, see api.initialize()  */

            function classBuilder (className, superclass, category, fn) {
                var logicalSuperclass = superclass;
                if (superclass == null || superclass.a$nil) {
                    superclass = nilAsClass;
                    logicalSuperclass = null;
                }

                function klass () {
                    var that = metaclass().instanceClass;

                    that.superclass = logicalSuperclass;
                    that.fn = fn || inherits(function () {
                    }, superclass.fn);
                    that.slots = [];

                    that.name = className;
                    that.category = category;
                    that.subclasses = [];

                    setupMethods(that);
                    return that;
                }

                function metaclass () {
                    var that = newMetaclass();

                    that.superclass = superclass.a$cls;
                    that.fn = inherits(function () {
                    }, that.superclass.fn);
                    that.slots = [];

                    that.instanceClass = new that.fn();

                    wireKlass(that);
                    setupMethods(that);
                    return that;
                }

                return {
                    name: className,
                    make: klass,
                    updateExisting: function (klass) {
                        if (logicalSuperclass == null && klass.superclass != null || logicalSuperclass != null && klass.superclass !== logicalSuperclass || fn != null && fn !== klass.fn)
                            throw new Error("Incompatible change of class: " + klass.name);
                    }
                };
            }

            function wireKlass (klass) {
                Object.defineProperty(klass.fn.prototype, "a$cls", {
                    value: klass,
                    enumerable: false, configurable: true, writable: true
                });
            }

            this.wireKlass = wireKlass;

            /* Add a class to the system, creating a new one if needed.
             A Package is lazily created if one with given name does not exist. */

            st.addClass = function (className, superclass, category) {
                // TODO remove, backward compatibility (note: only deprecated as of this note)
                if (arguments[3]) {
                    var added = st.addClass(className, superclass, arguments[3]);
                    setSlots(added, category);
                    return added;
                }

                // While subclassing nil is allowed, it might be an error, so
                // warn about it.
                if (typeof superclass === 'undefined' || superclass && superclass.a$nil) {
                    console.warn('Compiling ' + className + ' as a subclass of `nil`. A dependency might be missing.');
                }
                return buildTraitOrClass(classBuilder(className, superclass, category, specialConstructors[className]));
            };

            st.removeClass = removeTraitOrClass;
        }

        /* Making smalltalk that can load */

        function configure (brikz) {
            brikz.traits = TraitsBrik;
            brikz.composition = MethodCompositionBrik;
            brikz.classModel = ClassModelBrik;
            brikz.classConstruction = ClassConstructionBrik;

            brikz();
        }

        return {configure: configure};
    }

    return LanguageFactory;
});

//jshint eqnull:true

define('amber/kernel-runtime',['./junk-drawer'], function ($goodies) {
    "use strict";

    var installMethodOfJsObject = $goodies.installMethodOfJsObject;
    var declareJsMethod = $goodies.declareJsMethod;
    var st2js = $goodies.st2js;
    var js2st = $goodies.js2st;
    var deleteKeysFrom = $goodies.deleteKeysFrom;
    var extendWithMethods = $goodies.extendWithMethods;

    var hop = Object.prototype.hasOwnProperty;

    function cleanMethodOfJsObjectEx (obj, name) {
        var attachments;
        var old = Object.getOwnPropertyDescriptor(obj, name);
        if (old != null && (old = old.value) != null) {
            attachments = old.a$atx;
            if (attachments != null) {
                deleteKeysFrom(Object.keys(attachments), obj);
            }
        }
    }

    function installMethodOfJsObjectEx (obj, name, fn) {
        cleanMethodOfJsObjectEx(obj, name);
        var attachments = fn.a$atx;
        if (attachments != null) {
            extendWithMethods(obj, attachments);
        }
        return installMethodOfJsObject(obj, name, fn);
    }

    function SelectorConversionBrik (brikz, st) {
        var st2jsMemo = Object.create(null);

        st.st2js = function (stSelector) {
            return st2jsMemo[stSelector] || st2js(stSelector);
        };

        this.st2js = function (stSelector) {
            return st2jsMemo[stSelector] || (st2jsMemo[stSelector] = st2js(stSelector));
        };

        /* Convert a string to a valid smalltalk selector.
         if you modify the following functions, also change st2js
         accordingly */
        st.js2st = js2st;

        st.st2prop = function (stSelector) {
            var colonPosition = stSelector.indexOf(':');
            return colonPosition === -1 ? stSelector : stSelector.slice(0, colonPosition);
        };
    }

    function RuntimeFactory (globals, emit) {
        RuntimeSelectorsBrik.deps = ["selectors", "selectorConversion", "classModel"];

        function RuntimeSelectorsBrik (brikz, st) {
            var selectors = brikz.selectors.selectors;
            var nilAsClass = brikz.classModel.nilAsClass;
            var st2js = brikz.selectorConversion.st2js;

            var jsSelectors = this.jsSelectors = [];

            /* Method not implemented handlers */

            function installNewSelectors (newSelectors, targetClasses) {
                newSelectors.forEach(function (selector) {
                    var jsSelector = st2js(selector);
                    jsSelectors.push(jsSelector);
                    var fn = createDnuHandler(selector);
                    installMethodOfJsObject(nilAsClass.fn.prototype, jsSelector, fn);
                    targetClasses.forEach(function (target) {
                        installMethodOfJsObject(target.fn.prototype, jsSelector, fn);
                    });
                });
            }

            this.installNewSelectors = installNewSelectors;

            /* Dnu handler method */

            function createDnuHandler (stSelector) {
                return function () {
                    return globals.Message._selector_arguments_notUnderstoodBy_(
                        stSelector, [].slice.call(arguments), this
                    );
                };
            }

            installNewSelectors(selectors, []);
        }

        RuntimeClassesBrik.deps = ["runtimeSelectors", "behaviorals", "classConstruction", "runtimeMethods"];

        function RuntimeClassesBrik (brikz, st) {
            var jsSelectors = brikz.runtimeSelectors.jsSelectors;
            var installNewSelectors = brikz.runtimeSelectors.installNewSelectors;
            var installAmberMethodIntoAmberClass = brikz.runtimeMethods.installAmberMethodIntoAmberClass;
            var traitsOrClasses = brikz.behaviorals.traitsOrClasses;
            var wireKlass = brikz.classConstruction.wireKlass;

            var detachedRootClasses = [];

            function detachClass (klass) {
                klass.detachedRoot = true;
                detachedRootClasses = traitsOrClasses.filter(function (klass) {
                    return klass.detachedRoot;
                });
                initClass(klass);
            }

            st.detachClass = detachClass;

            emit.selectorsAdded = function (newSelectors) {
                installNewSelectors(newSelectors, detachedRootClasses);
            };

            /* Initialize a class in its class hierarchy. Handle both classes and
             metaclasses. */

            function initClassAndMetaclass (klass) {
                initClass(klass);
                initClass(klass.a$cls);
            }

            traitsOrClasses.forEach(function (traitOrClass) {
                if (!traitOrClass.trait) initClassAndMetaclass(traitOrClass);
            });

            function installStHooks () {
                emit.behavioralAdded = function (traitOrClass) {
                    traitOrClass._enterOrganization();
                };

                emit.behavioralRemoved = function (traitOrClass) {
                    traitOrClass._leaveOrganization();
                };
            }

            this.installStHooks = installStHooks;

            emit.classCreated = initClassAndMetaclass;

            emit.slotsChanged = initClassSlots;

            function initClass (klass) {
                wireKlass(klass);
                initClassMethods(klass);
                initClassSlots(klass);
            }

            function initClassMethods (klass) {
                if (klass.detachedRoot) {
                    copySuperclass(klass);
                }
                installMethods(klass);
            }

            function initClassSlots (klass) {
                installIvarCompat(klass);
            }

            function copySuperclass (klass) {
                var myproto = klass.fn.prototype,
                    superproto = klass.superclass.fn.prototype;
                jsSelectors.forEach(function (jsSelector) {
                    installMethodOfJsObjectEx(myproto, jsSelector, superproto[jsSelector]);
                });
            }

            function installMethods (klass) {
                var methods = klass.methods;
                Object.keys(methods).forEach(function (selector) {
                    installAmberMethodIntoAmberClass(methods[selector], klass);
                });
            }

            // TODO remove, ["@foo"] backward compatibility
            function installIvarCompat (klass) {
                var ivars = klass.slots;
                ivars.forEach(function (ivar) {
                    Object.defineProperty(klass.fn.prototype, "@" + ivar, {
                        get: function () {
                            return this[ivar];
                        },
                        set: function (value) {
                            return this[ivar] = value;
                        },
                        enumerable: false,
                        configurable: true
                    });
                });
            }

            /* Create an alias for an existing class */

            st.alias = function (traitOrClass, alias) {
                globals[alias] = traitOrClass;
            };

            /* Manually set the constructor of an existing Smalltalk klass, making it a detached root class. */

            st.setClassConstructor = this.setClassConstructor = function (klass, constructor) {
                klass.fn = constructor;
                detachClass(klass);
                var prototype = constructor.prototype;
                klass.subclasses.forEach(function (subclass) {
                    Object.setPrototypeOf(subclass.fn.prototype, prototype);
                });
            };
        }

        FrameBindingBrik.deps = ["runtimeClasses"];

        function FrameBindingBrik (brikz, st) {
            var setClassConstructor = brikz.runtimeClasses.setClassConstructor;

            setClassConstructor(globals.Number, Number);
            setClassConstructor(globals.BlockClosure, Function);
            setClassConstructor(globals.Boolean, Boolean);
            setClassConstructor(globals.Date, Date);
            setClassConstructor(globals.String, String);
            setClassConstructor(globals.Array, Array);
            setClassConstructor(globals.RegularExpression, RegExp);
            setClassConstructor(globals.Error, Error);
            setClassConstructor(globals.Promise, Promise);

            this.__init__ = function () {
                st.alias(globals.Array, "OrderedCollection");
                st.alias(globals.Date, "Time");
            }
        }

        RuntimeMethodsBrik.deps = ["selectorConversion"];

        function RuntimeMethodsBrik (brikz, st) {
            var st2js = brikz.selectorConversion.st2js;

            function installAmberMethodIntoAmberClass (method, klass) {
                if (method.fn == null) {
                    if (method.instantiateFn) {
                        method.fn = method.instantiateFn(method.methodClass);
                    }
                }
                var jsSelector = method.jsSelector;
                if (!jsSelector) {
                    jsSelector = method.jsSelector = st2js(method.selector);
                }
                return installMethodOfJsObjectEx(klass.fn.prototype, jsSelector, method.fn);
            }

            this.installAmberMethodIntoAmberClass = installAmberMethodIntoAmberClass;

            emit.behaviorMethodAdded = function (method, klass) {
                installAmberMethodIntoAmberClass(method, klass);
                propagateMethodChange(klass, method, klass);
            };

            emit.behaviorMethodRemoved = function (method, klass) {
                cleanMethodOfJsObjectEx(klass.fn.prototype, method.jsSelector);
                delete klass.fn.prototype[method.jsSelector];
                propagateMethodChange(klass, method, null);
            };

            function installStHooks () {
                emit.methodReplaced = function (newMethod, oldMethod, traitOrBehavior) {
                    traitOrBehavior._methodOrganizationEnter_andLeave_(newMethod, oldMethod);
                };
            }

            this.installStHooks = installStHooks;

            function propagateMethodChange (klass, method, exclude) {
                var selector = method.selector;
                var jsSelector = method.jsSelector;
                st.traverseClassTree(klass, function (subclass, sentinel) {
                    if (subclass === exclude) return;
                    if (hop.call(subclass.methods, selector)) return sentinel;
                    if (subclass.detachedRoot) {
                        installMethodOfJsObjectEx(subclass.fn.prototype, jsSelector, subclass.superclass.fn.prototype[jsSelector]);
                    }
                });
            }
        }

        function PrimitivesBrik (brikz, st) {
            /* Converts a JavaScript object to valid Smalltalk Object */
            st.readJSObject = function (js) {
                if (js == null) return null;
                else if (Array.isArray(js)) return js.map(st.readJSObject);
                else if (js.constructor !== Object) return js;

                var pairs = [];
                for (var i in js) {
                    pairs.push(i, st.readJSObject(js[i]));
                }
                return globals.Dictionary._newFromPairs_(pairs);
            };

            /* Boolean assertion */
            st.assert = function (shouldBeBoolean) {
                if (typeof shouldBeBoolean === "boolean") return shouldBeBoolean;
                else if (shouldBeBoolean != null && typeof shouldBeBoolean === "object") {
                    shouldBeBoolean = shouldBeBoolean.valueOf();
                    if (typeof shouldBeBoolean === "boolean") return shouldBeBoolean;
                }
                globals.NonBooleanReceiver._signalOn_(shouldBeBoolean);
            };
        }

        RuntimeBrik.deps = ["selectorConversion", "runtimeClasses"];

        function RuntimeBrik (brikz, st) {
            var setClassConstructor = brikz.runtimeClasses.setClassConstructor;

            function SmalltalkMethodContext (home, setup) {
                // TODO lazy fill of .sendIdx
                this.sendIdx = {};
                // TODO very likely .senderContext, not .homeContext here
                this.homeContext = home;
                this.setup = setup;
            }

            // Fallbacks
            SmalltalkMethodContext.prototype.supercall = false;
            SmalltalkMethodContext.prototype.locals = Object.freeze({});
            SmalltalkMethodContext.prototype.receiver = null;
            SmalltalkMethodContext.prototype.selector = null;
            SmalltalkMethodContext.prototype.outerContext = null;
            SmalltalkMethodContext.prototype.index = 0;
            declareJsMethod(SmalltalkMethodContext.prototype, "fill");
            declareJsMethod(SmalltalkMethodContext.prototype, "fillBlock");

            SmalltalkMethodContext.prototype.fill = function (receiver, selector, locals) {
                this.receiver = receiver;
                this.selector = selector;
                if (locals != null) this.locals = locals;
                if (this.homeContext) {
                    this.homeContext.evaluatedSelector = selector;
                }
            };

            SmalltalkMethodContext.prototype.fillBlock = function (locals, ctx, index) {
                if (locals != null) this.locals = locals;
                this.outerContext = ctx;
                if (index) this.index = index;
            };

            setClassConstructor(globals.MethodContext, SmalltalkMethodContext);

            /* This is the current call context object.
             In Smalltalk code, it is accessible just by using 'thisContext' variable.
             In JS code, use api.getThisContext() (see below).
             */

            var thisContext = null;

            function resultWithNoErrorHandling (worker) {
                try {
                    return worker(thisContext);
                } finally {
                    thisContext = null;
                }
            }

            // TODO deprecated, remove
            st.seamless = function (worker) {
                return worker();
                // return st.withContext(worker, new SmalltalkMethodContext(thisContext, function (ctx) {
                //     ctx.fill(null, "seamlessDoIt", {}, globals.UndefinedObject);
                // }));
            };

            /*
             Standard way to run within context.
             Sets up error handler if entering first ST context in a stack.
             */
            st.withContext = function (worker, setup) {
                var oldContext = thisContext;
                thisContext = new SmalltalkMethodContext(thisContext, setup);
                var result = oldContext == null ? resultWithNoErrorHandling(worker) : worker(thisContext);
                thisContext = oldContext;
                return result;
            };

            /* Handle thisContext pseudo variable */

            st.getThisContext = function () {
                if (!thisContext) return null;
                thisContext.setup(thisContext);
                return thisContext;
            };
        }

        MessageSendBrik.deps = ["selectorConversion"];

        function MessageSendBrik (brikz, st) {

            /* Send message programmatically. Used to implement #perform: & Co. */
            st.send2 = function (self, selector, args, klass) {
                var method = klass ? klass.fn.prototype[st.st2js(selector)] : self.a$cls && self[st.st2js(selector)];
                return method != null ?
                    method.apply(self, args || []) :
                    globals.Message._selector_arguments_notUnderstoodBy_(
                        selector, [].slice.call(args), self.a$cls ? self : wrapJavaScript(self)
                    );
            };

            function wrapJavaScript (o) {
                return globals.JSObjectProxy._on_(o);
            }

            st.wrapJavaScript = wrapJavaScript;

            /* If the object property is a function, then call it, except if it starts with
             an uppercase character (we probably want to answer the function itself in this
             case and send it #new from Amber).
             */
            st.accessJavaScript = function (self, propertyName, args) {
                var propertyValue = self[propertyName];
                if (typeof propertyValue === "function" && !(args.length === 0 && /^[A-Z]/.test(propertyName)))
                    return propertyValue.apply(self, args);
                switch (args.length) {
                    case 0:
                        return propertyValue;
                    case 1:
                        self[propertyName] = args[0];
                        return self;
                    default:
                        throw new Error("Cannot interpret " + propertyName + " with " + args.length + " arguments; field is a " + typeof propertyValue + ", not a function")
                }
            };
        }

        StartImageBrik.deps = ["runtimeClasses", "runtimeMethods"];

        function StartImageBrik (brikz, st) {
            this.run = function () {
                brikz.runtimeClasses.installStHooks();
                brikz.runtimeMethods.installStHooks();
                return globals.AmberBootstrapInitialization._run();
            };
        }

        /* Making smalltalk that can run */

        function configure (brikz) {
            brikz.runtimeSelectors = RuntimeSelectorsBrik;
            brikz.runtimeClasses = RuntimeClassesBrik;
            brikz.frameBinding = FrameBindingBrik;
            brikz.runtimeMethods = RuntimeMethodsBrik;
            brikz.messageSend = MessageSendBrik;
            brikz.runtime = RuntimeBrik;
            brikz.primitives = PrimitivesBrik;
            brikz.selectorConversion = SelectorConversionBrik;
            brikz.startImage = StartImageBrik;

            brikz();
        }

        return {configure: configure};
    }

    return RuntimeFactory;
});

/* ====================================================================
 |
 |   Amber Smalltalk
 |   http://amber-lang.net
 |
 ======================================================================

 ======================================================================
 |
 | Copyright (c) 2010-2014
 | Nicolas Petton <petton.nicolas@gmail.com>
 |
 | Copyright (c) 2012-2019
 | The Amber team https://lolg.it/org/amber/members
 | Amber contributors (see /CONTRIBUTORS)
 |
 | Amber is released under the MIT license
 |
 | Permission is hereby granted, free of charge, to any person obtaining
 | a copy of this software and associated documentation files (the
 | 'Software'), to deal in the Software without restriction, including
 | without limitation the rights to use, copy, modify, merge, publish,
 | distribute, sublicense, and/or sell copies of the Software, and to
 | permit persons to whom the Software is furnished to do so, subject to
 | the following conditions:
 |
 | The above copyright notice and this permission notice shall be
 | included in all copies or substantial portions of the Software.
 |
 | THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 | EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 | MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 | IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 | CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 | TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 | SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 |
 ==================================================================== */

//jshint eqnull:true

define('amber/boot',[
    'require', './kernel-checks', './brikz', './kernel-fundamentals', './kernel-language'
], function (require, _, Brikz, FundamentalsFactory, LanguageFactory) {
    "use strict";

    var globals = Object.create(global);
    var emit = Object.create(null);

    var runtimeLoadedPromise = new Promise(function (resolve, reject) {
        require(['./kernel-runtime'], resolve, reject);
    });

    function SmalltalkInitBrik (brikz, st) {
        var initialized = false;

        globals.SmalltalkSettings = {};

        /* Smalltalk initialization. Called on page load */

        st.initialize = function () {
            return runtimeLoadedPromise.then(function (RuntimeFactory) {
                if (initialized) return;
                brikz.classModel.bootstrapHierarchy(globals.Class);
                RuntimeFactory(globals, emit).configure(brikz);
                return Promise.resolve(brikz.startImage.run())
                    .then(function () {
                        initialized = true;
                    });
            });
        };
    }

    var api = {};
    var brikz = Brikz(api);

    var fundamentals = FundamentalsFactory(globals, emit);
    fundamentals.configure(brikz);

    LanguageFactory(fundamentals.specialConstructors, emit).configure(brikz);

    brikz.stInit = SmalltalkInitBrik;

    brikz();

    // TODO deprecated, remove
    Object.defineProperty(globals, "CharacterArray", {
        enumerable: true,
        configurable: true,
        get: function () {
            return this.String;
        }
    });

    return {
        api: api,
        nilAsReceiver: brikz.nil.nilAsReceiver,
        nilAsValue: brikz.nil.nilAsValue,
        nilAsClass: brikz.classModel.nilAsClass,
        globals: globals,
        asReceiver: brikz.classModel.asReceiver
    };
});

define('amber/helpers',["./boot", "./junk-drawer", "require"], function (boot, $goodies, require) {
    var globals = boot.globals,
        exports = {},
        extend = $goodies.extend,
        api = boot.api;

    // API

    exports.popupHelios = function () {
        require(['helios/index'], function (helios) {
            helios.popup();
        }, function (err) {
            window.alert("Error loading helios.\nIf not present, you can install it with 'npm install @ambers/helios --save-dev'.\nThe error follows:\n" + err);
        });
    };
    Object.defineProperty(exports, "api", {
        value: api,
        enumerable: true, configurable: true, writable: false
    });
    Object.defineProperty(exports, "globals", {
        value: globals,
        enumerable: true, configurable: true, writable: false
    });
    Object.defineProperty(exports, "$nil", {
        value: boot.nilAsReceiver,
        enumerable: true, configurable: true, writable: false
    });
    Object.defineProperty(exports, "nil", {
        value: boot.nilAsValue,
        enumerable: true, configurable: true, writable: false
    });

    function settingsInLocalStorage () {
        var storage;
        try {
            storage = 'localStorage' in global && global.localStorage;
        } catch (ex) {
            console.warn("Access denied to localStorage, " +
                "settings not loaded nor, subsequently, saved.");
            return;
        }

        if (storage) {
            var fromStorage;
            try {
                fromStorage = JSON.parse(storage.getItem('amber.SmalltalkSettings'));
            } catch (ex) {
                // pass
            }
            extend(globals.SmalltalkSettings, fromStorage || {});
            if (typeof window !== "undefined") {
                window.addEventListener('beforeunload', function () {
                    storage.setItem('amber.SmalltalkSettings', JSON.stringify(globals.SmalltalkSettings));
                });
            }
        }
    }

    exports.initialize = function (options) {
        return new Promise(function (resolve) {
            globals.SmalltalkSettings['transport.defaultAmdNamespace'] = "amber/core";
            api.amdRequire = require; // TODO better
            settingsInLocalStorage();
            extend(globals.SmalltalkSettings, options || {});
            resolve(api.initialize());
        });
    };

    exports.loadPackages = function (modules) {
        return new Promise(function (resolve, reject) {
            require(modules, resolve, reject);
        }).then(function () {
            return globals.Smalltalk._postLoad();
        });
    };

    exports.beClean = function () {
        return globals.Smalltalk._beClean();
    };

    // Exports

    return exports;
});

define('amber/core/Kernel-Helpers',["amber/boot", "require"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Helpers");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addTrait("TIsInGroup", "Kernel-Helpers");
$globals.TIsInGroup.comment="I contain all `isXxx` checking methods that check\x0aif receiver is part of some group of objects (`isBehavior` etc.)\x0a\x0aI should NOT contain tests for\x0ahaving a certain property (`isImmutable` etc.).";
$core.addMethod(
$core.method({
selector: "isBehavior",
protocol: "testing",
args: [],
source: "isBehavior\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isBoolean",
protocol: "testing",
args: [],
source: "isBoolean\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isClass",
protocol: "testing",
args: [],
source: "isClass\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isCompiledMethod",
protocol: "testing",
args: [],
source: "isCompiledMethod\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isError",
protocol: "testing",
args: [],
source: "isError\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isMetaclass",
protocol: "testing",
args: [],
source: "isMetaclass\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isNumber",
protocol: "testing",
args: [],
source: "isNumber\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isPackage",
protocol: "testing",
args: [],
source: "isPackage\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isString",
protocol: "testing",
args: [],
source: "isString\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);

$core.addMethod(
$core.method({
selector: "isSymbol",
protocol: "testing",
args: [],
source: "isSymbol\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TIsInGroup);


$core.addTrait("TSubclassable", "Kernel-Helpers");
$core.addMethod(
$core.method({
selector: "subclass:",
protocol: "class creation",
args: ["aString"],
source: "subclass: aString \x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString slots: #() package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:slots:package:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_slots_package_(aString,[],nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:",{aString:aString})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:",
protocol: "class creation",
args: ["aString", "anotherString"],
source: "subclass: aString instanceVariableNames: anotherString\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString instanceVariableNames: anotherString package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_instanceVariableNames_package_(aString,anotherString,nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:",{aString:aString,anotherString:anotherString})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:category:",
protocol: "class creation",
args: ["aString", "aString2", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 category: aString3\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}, function ($methodClass){ return function (aString,aString2,aString3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_instanceVariableNames_package_(aString,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:category:",{aString:aString,aString2:aString2,aString3:aString3})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",
protocol: "class creation",
args: ["aString", "aString2", "classVars", "pools", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 classVariableNames: classVars poolDictionaries: pools category: aString3\x0a\x09\x22Kept for file-in compatibility. ignores class variables and pools.\x22\x0a\x09^ self subclass: aString instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:instanceVariableNames:package:"]
}, function ($methodClass){ return function (aString,aString2,classVars,pools,aString3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_instanceVariableNames_package_(aString,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:classVariableNames:poolDictionaries:category:",{aString:aString,aString2:aString2,classVars:classVars,pools:pools,aString3:aString3})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:instanceVariableNames:package:",
protocol: "class creation",
args: ["aString", "aString2", "aString3"],
source: "subclass: aString instanceVariableNames: aString2 package: aString3\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString slots: aString2 instanceVariablesStringAsSlotList package: aString3",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:slots:package:", "instanceVariablesStringAsSlotList"]
}, function ($methodClass){ return function (aString,aString2,aString3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_slots_package_(aString,$recv(aString2)._instanceVariablesStringAsSlotList(),aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:instanceVariableNames:package:",{aString:aString,aString2:aString2,aString3:aString3})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:slots:",
protocol: "class creation",
args: ["aString", "aCollection"],
source: "subclass: aString slots: aCollection\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString slots: aCollection package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:slots:package:"]
}, function ($methodClass){ return function (aString,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_slots_package_(aString,aCollection,nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:slots:",{aString:aString,aCollection:aCollection})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:slots:classVariables:package:",
protocol: "class creation",
args: ["aString", "aCollection", "anObject", "anotherString"],
source: "subclass: aString slots: aCollection classVariables: anObject package: anotherString\x0a\x09\x22Kept for file-in compatibility. ignores class variables.\x22\x0a\x09^ ClassBuilder new\x0a\x09\x09superclass: self subclass: aString slots: aCollection package: anotherString",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["superclass:subclass:slots:package:", "new"]
}, function ($methodClass){ return function (aString,aCollection,anObject,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._superclass_subclass_slots_package_(self,aString,aCollection,anotherString);
}, function($ctx1) {$ctx1.fill(self,"subclass:slots:classVariables:package:",{aString:aString,aCollection:aCollection,anObject:anObject,anotherString:anotherString})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:slots:classVariables:poolDictionaries:package:",
protocol: "class creation",
args: ["aString", "aCollection", "anObject", "anotherObject", "anotherString"],
source: "subclass: aString slots: aCollection classVariables: anObject poolDictionaries: anotherObject package: anotherString\x0a\x09\x22Kept for file-in compatibility. ignores class variables and pools.\x22\x0a\x09^ ClassBuilder new\x0a\x09\x09superclass: self subclass: aString slots: aCollection package: anotherString",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["superclass:subclass:slots:package:", "new"]
}, function ($methodClass){ return function (aString,aCollection,anObject,anotherObject,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._superclass_subclass_slots_package_(self,aString,aCollection,anotherString);
}, function($ctx1) {$ctx1.fill(self,"subclass:slots:classVariables:poolDictionaries:package:",{aString:aString,aCollection:aCollection,anObject:anObject,anotherObject:anotherObject,anotherString:anotherString})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:slots:package:",
protocol: "class creation",
args: ["aString", "aCollection", "anotherString"],
source: "subclass: aString slots: aCollection package: anotherString\x0a\x09^ ClassBuilder new\x0a\x09\x09superclass: self subclass: aString slots: aCollection package: anotherString",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["superclass:subclass:slots:package:", "new"]
}, function ($methodClass){ return function (aString,aCollection,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._superclass_subclass_slots_package_(self,aString,aCollection,anotherString);
}, function($ctx1) {$ctx1.fill(self,"subclass:slots:package:",{aString:aString,aCollection:aCollection,anotherString:anotherString})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription"],
source: "subclass: aString uses: aTraitCompositionDescription \x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString uses: aTraitCompositionDescription slots: #() package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:uses:slots:package:"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_uses_slots_package_(aString,aTraitCompositionDescription,[],nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:instanceVariableNames:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription", "anotherString"],
source: "subclass: aString uses: aTraitCompositionDescription instanceVariableNames: anotherString\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString uses: aTraitCompositionDescription instanceVariableNames: anotherString package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:uses:instanceVariableNames:package:"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_uses_instanceVariableNames_package_(aString,aTraitCompositionDescription,anotherString,nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:instanceVariableNames:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,anotherString:anotherString})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:instanceVariableNames:category:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription", "aString2", "aString3"],
source: "subclass: aString uses: aTraitCompositionDescription instanceVariableNames: aString2 category: aString3\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString uses: aTraitCompositionDescription instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:uses:instanceVariableNames:package:"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,aString2,aString3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_uses_instanceVariableNames_package_(aString,aTraitCompositionDescription,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:instanceVariableNames:category:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,aString2:aString2,aString3:aString3})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription", "aString2", "classVars", "pools", "aString3"],
source: "subclass: aString uses: aTraitCompositionDescription instanceVariableNames: aString2 classVariableNames: classVars poolDictionaries: pools category: aString3\x0a\x09\x22Kept for file-in compatibility. ignores class variables and pools.\x22\x0a\x09^ self subclass: aString uses: aTraitCompositionDescription instanceVariableNames: aString2 package: aString3",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:uses:instanceVariableNames:package:"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,aString2,classVars,pools,aString3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_uses_instanceVariableNames_package_(aString,aTraitCompositionDescription,aString2,aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:instanceVariableNames:classVariableNames:poolDictionaries:category:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,aString2:aString2,classVars:classVars,pools:pools,aString3:aString3})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:instanceVariableNames:package:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription", "aString2", "aString3"],
source: "subclass: aString uses: aTraitCompositionDescription instanceVariableNames: aString2 package: aString3\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString uses: aTraitCompositionDescription slots: aString2 instanceVariablesStringAsSlotList package: aString3",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:uses:slots:package:", "instanceVariablesStringAsSlotList"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,aString2,aString3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_uses_slots_package_(aString,aTraitCompositionDescription,$recv(aString2)._instanceVariablesStringAsSlotList(),aString3);
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:instanceVariableNames:package:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,aString2:aString2,aString3:aString3})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:slots:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription", "aCollection"],
source: "subclass: aString uses: aTraitCompositionDescription slots: aCollection\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self subclass: aString uses: aTraitCompositionDescription slots: aCollection package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:uses:slots:package:"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclass_uses_slots_package_(aString,aTraitCompositionDescription,aCollection,nil);
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:slots:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,aCollection:aCollection})});
}; }),
$globals.TSubclassable);

$core.addMethod(
$core.method({
selector: "subclass:uses:slots:package:",
protocol: "class creation",
args: ["aString", "aTraitCompositionDescription", "aCollection", "aString3"],
source: "subclass: aString uses: aTraitCompositionDescription slots: aCollection package: aString3\x0a\x09| cls |\x0a\x09cls := self subclass: aString slots: aCollection package: aString3.\x0a\x09cls setTraitComposition: aTraitCompositionDescription asTraitComposition.\x0a\x09^ cls",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:slots:package:", "setTraitComposition:", "asTraitComposition"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,aCollection,aString3){
var self=this,$self=this;
var cls;
return $core.withContext(function($ctx1) {
cls=$self._subclass_slots_package_(aString,aCollection,aString3);
$recv(cls)._setTraitComposition_($recv(aTraitCompositionDescription)._asTraitComposition());
return cls;
}, function($ctx1) {$ctx1.fill(self,"subclass:uses:slots:package:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,aCollection:aCollection,aString3:aString3,cls:cls})});
}; }),
$globals.TSubclassable);

});

define('amber/core/Kernel-Objects',["amber/boot", "require", "amber/core/Kernel-Helpers"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Objects");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ProtoObject", null, "Kernel-Objects");
$globals.ProtoObject.comment="I implement the basic behavior required for any object in Amber.\x0a\x0aIn most cases, subclassing `ProtoObject` is wrong and `Object` should be used instead. However subclassing `ProtoObject` can be useful in some special cases like proxy implementations.";
$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["anObject"],
source: "= anObject\x0a\x09^ self == anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["=="]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__eq_eq(anObject);
}, function($ctx1) {$ctx1.fill(self,"=",{anObject:anObject})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "==",
protocol: "comparing",
args: ["anObject"],
source: "== anObject\x0a<inlineJS: 'return self === anObject'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self === anObject"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self === anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{anObject:anObject})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09^ self printString",
referencedClasses: [],
pragmas: [],
messageSends: ["printString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._printString();
}, function($ctx1) {$ctx1.fill(self,"asString",{})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "class",
protocol: "accessing",
args: [],
source: "class\x0a\x09<inlineJS: 'return $self.a$cls'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self.a$cls"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.a$cls;
return self;
}, function($ctx1) {$ctx1.fill(self,"class",{})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "doesNotUnderstand:",
protocol: "error handling",
args: ["aMessage"],
source: "doesNotUnderstand: aMessage\x0a\x09MessageNotUnderstood new\x0a\x09\x09receiver: self;\x0a\x09\x09message: aMessage;\x0a\x09\x09signal",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["receiver:", "new", "message:", "signal"]
}, function ($methodClass){ return function (aMessage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageNotUnderstood)._new();
$recv($1)._receiver_(self);
$recv($1)._message_(aMessage);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"doesNotUnderstand:",{aMessage:aMessage})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "evaluate:on:",
protocol: "evaluating",
args: ["aString", "anEvaluator"],
source: "evaluate: aString on: anEvaluator\x0a\x09^ anEvaluator evaluate: aString receiver: self",
referencedClasses: [],
pragmas: [],
messageSends: ["evaluate:receiver:"]
}, function ($methodClass){ return function (aString,anEvaluator){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anEvaluator)._evaluate_receiver_(aString,self);
}, function($ctx1) {$ctx1.fill(self,"evaluate:on:",{aString:aString,anEvaluator:anEvaluator})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "identityHash",
protocol: "accessing",
args: [],
source: "identityHash\x0a\x09<inlineJS: '\x0a\x09\x09self._deprecatedAPI();\x0a\x09\x09var hash=self.identityHash;\x0a\x09\x09if (hash) return hash;\x0a\x09\x09hash=$core.nextId();\x0a\x09\x09Object.defineProperty(self, ''identityHash'', {value:hash});\x0a\x09\x09return hash;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09self._deprecatedAPI();\x0a\x09\x09var hash=self.identityHash;\x0a\x09\x09if (hash) return hash;\x0a\x09\x09hash=$core.nextId();\x0a\x09\x09Object.defineProperty(self, 'identityHash', {value:hash});\x0a\x09\x09return hash;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		self._deprecatedAPI();
		var hash=self.identityHash;
		if (hash) return hash;
		hash=$core.nextId();
		Object.defineProperty(self, 'identityHash', {value:hash});
		return hash;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"identityHash",{})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNil:",
protocol: "testing",
args: ["aBlock"],
source: "ifNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return self;

}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNil:ifNotNil:",
protocol: "testing",
args: ["aBlock", "anotherBlock"],
source: "ifNil: aBlock ifNotNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ anotherBlock value: self",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anotherBlock)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"ifNil:ifNotNil:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:",
protocol: "testing",
args: ["aBlock"],
source: "ifNotNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ aBlock value: self",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:",{aBlock:aBlock})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:ifNil:",
protocol: "testing",
args: ["aBlock", "anotherBlock"],
source: "ifNotNil: aBlock ifNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ aBlock value: self",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:ifNil:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "inspect",
protocol: "inspecting",
args: [],
source: "inspect\x0a\x09Inspector inspect: self",
referencedClasses: ["Inspector"],
pragmas: [],
messageSends: ["inspect:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Inspector)._inspect_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspect",{})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "inspecting",
args: ["anInspector"],
source: "inspectOn: anInspector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
return self;

}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "instVarNamed:",
protocol: "accessing",
args: ["aString"],
source: "instVarNamed: aString\x0a\x09<inlineJS: 'return $self[aString]'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self[aString]"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self[aString];
return self;
}, function($ctx1) {$ctx1.fill(self,"instVarNamed:",{aString:aString})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "instVarNamed:put:",
protocol: "accessing",
args: ["aString", "anObject"],
source: "instVarNamed: aString put: anObject\x0a\x09<inlineJS: '$self[aString] = anObject'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$self[aString] = anObject"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self[aString] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"instVarNamed:put:",{aString:aString,anObject:anObject})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "isKindOf:",
protocol: "testing",
args: ["aClass"],
source: "isKindOf: aClass\x0a\x09^ (self isMemberOf: aClass) or: [ self class inheritsFrom: aClass ]",
referencedClasses: [],
pragmas: [],
messageSends: ["or:", "isMemberOf:", "inheritsFrom:", "class"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isMemberOf_(aClass))){
return true;
} else {
return $recv($self._class())._inheritsFrom_(aClass);
}
}, function($ctx1) {$ctx1.fill(self,"isKindOf:",{aClass:aClass})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "isNil",
protocol: "testing",
args: [],
source: "isNil\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "notNil",
protocol: "testing",
args: [],
source: "notNil\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "perform:",
protocol: "message handling",
args: ["aString"],
source: "perform: aString\x0a\x09^ self perform: aString withArguments: #()",
referencedClasses: [],
pragmas: [],
messageSends: ["perform:withArguments:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._perform_withArguments_(aString,[]);
}, function($ctx1) {$ctx1.fill(self,"perform:",{aString:aString})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "perform:with:",
protocol: "message handling",
args: ["aString", "anObject"],
source: "perform: aString with: anObject\x0a\x09<inlineJS: 'return $core.send2(self, aString, [anObject])'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.send2(self, aString, [anObject])"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.send2(self, aString, [anObject]);
return self;
}, function($ctx1) {$ctx1.fill(self,"perform:with:",{aString:aString,anObject:anObject})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "perform:withArguments:",
protocol: "message handling",
args: ["aString", "aCollection"],
source: "perform: aString withArguments: aCollection\x0a\x09<inlineJS: 'return $core.send2(self, aString, aCollection)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.send2(self, aString, aCollection)"]]],
messageSends: []
}, function ($methodClass){ return function (aString,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.send2(self, aString, aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"perform:withArguments:",{aString:aString,aCollection:aCollection})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: (self class name first isVowel\x0a\x09\x09ifTrue: [ 'an ' ]\x0a\x09\x09ifFalse: [ 'a ' ]).\x0a\x09aStream nextPutAll: self class name",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "ifTrue:ifFalse:", "isVowel", "first", "name", "class"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($recv($recv([$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0])._name()
,$ctx1.sendIdx["name"]=1
][0])._first())._isVowel())){
$1="an ";
} else {
$1="a ";
}
[$recv(aStream)._nextPutAll_($1)
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$recv(aStream)._nextPutAll_($recv($self._class())._name());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "printString",
protocol: "printing",
args: [],
source: "printString\x0a\x09^ String streamContents: [ :str | \x0a\x09\x09self printOn: str ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "printOn:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $self._printOn_(str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"printString",{})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "yourself",
protocol: "accessing",
args: [],
source: "yourself\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "~=",
protocol: "comparing",
args: ["anObject"],
source: "~= anObject\x0a\x09^ (self = anObject) = false",
referencedClasses: [],
pragmas: [],
messageSends: ["="]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv($self.__eq(anObject)).__eq(false)
,$ctx1.sendIdx["="]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"~=",{anObject:anObject})});
}; }),
$globals.ProtoObject);

$core.addMethod(
$core.method({
selector: "~~",
protocol: "comparing",
args: ["anObject"],
source: "~~ anObject\x0a\x09^ (self == anObject) = false",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "=="]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.__eq_eq(anObject)).__eq(false);
}, function($ctx1) {$ctx1.fill(self,"~~",{anObject:anObject})});
}; }),
$globals.ProtoObject);


$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.ProtoObject.a$cls);


$core.addClass("Object", $globals.ProtoObject, "Kernel-Objects");
$globals.Object.comment="**I am the root of the Smalltalk class system**. With the exception of unual subclasses of `ProtoObject`, all other classes in the system are subclasses of me.\x0a\x0aI provide default behavior common to all normal objects (some of it inherited from `ProtoObject`), such as:\x0a\x0a- accessing\x0a- copying\x0a- comparison\x0a- error handling\x0a- message sending\x0a- reflection\x0a\x0aAlso utility messages that all objects should respond to are defined here.\x0a\x0aI have no instance variable.\x0a\x0a##Access\x0a\x0aInstance variables can be accessed with `#instVarAt:` and `#instVarAt:put:`. `#instanceVariableNames` answers a collection of all instance variable names.\x0aAccessing JavaScript properties of an object is done through `#basicAt:`, `#basicAt:put:` and `basicDelete:`.\x0a\x0a##Copying\x0a\x0aCopying an object is handled by `#copy` and `#deepCopy`. The first one performs a shallow copy of the receiver, while the second one performs a deep copy.\x0aThe hook method `#postCopy` can be overriden in subclasses to copy fields as necessary to complete the full copy. It will be sent by the copy of the receiver.\x0a\x0a##Comparison\x0a\x0aI understand equality `#=` and identity `#==` comparison.\x0a\x0a##Error handling\x0a\x0a- `#halt` is the typical message to use for inserting breakpoints during debugging.\x0a- `#error:` throws a generic error exception\x0a- `#doesNotUnderstand:` handles the fact that there was an attempt to send the given message to the receiver but the receiver does not understand this message.\x0a\x09Overriding this message can be useful to implement proxies for example.";
$core.addMethod(
$core.method({
selector: "->",
protocol: "converting",
args: ["anObject"],
source: "-> anObject\x0a\x09^ Association key: self value: anObject",
referencedClasses: ["Association"],
pragmas: [],
messageSends: ["key:value:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Association)._key_value_(self,anObject);
}, function($ctx1) {$ctx1.fill(self,"->",{anObject:anObject})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "andSelfToNumber:",
protocol: "converting",
args: ["aNumber"],
source: "andSelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"andSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "appendToString:",
protocol: "copying",
args: ["aString"],
source: "appendToString: aString\x0a\x09self error: 'Cannot add self to a string.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Cannot add self to a string.");
return self;
}, function($ctx1) {$ctx1.fill(self,"appendToString:",{aString:aString})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "asJSONString",
protocol: "converting",
args: [],
source: "asJSONString\x0a\x09^ JSON stringify: self asJavaScriptObject",
referencedClasses: ["JSON"],
pragmas: [],
messageSends: ["stringify:", "asJavaScriptObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.JSON)._stringify_($self._asJavaScriptObject());
}, function($ctx1) {$ctx1.fill(self,"asJSONString",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09| variables |\x0a\x09self deprecatedAPI: 'Implement domain-specific #asJavaScriptObject on your classes instead.'.\x0a\x09variables := HashedCollection new.\x0a\x09self class allInstanceVariableNames do: [ :each |\x0a\x09\x09variables at: each put: (self instVarNamed: each) asJavaScriptObject ].\x0a\x09^ variables",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["deprecatedAPI:", "new", "do:", "allInstanceVariableNames", "class", "at:put:", "asJavaScriptObject", "instVarNamed:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Implement domain-specific #asJavaScriptObject on your classes instead.");
variables=$recv($globals.HashedCollection)._new();
$recv($recv($self._class())._allInstanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(variables)._at_put_(each,$recv($self._instVarNamed_(each))._asJavaScriptObject());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return variables;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptObject",{variables:variables})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09self deprecatedAPI: 'Implement domain-specific #asJavaScriptSource on your classes instead.'.\x0a\x09^ self asString",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "asString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Implement domain-specific #asJavaScriptSource on your classes instead.");
return $self._asString();
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicAt:",
protocol: "accessing",
args: ["aString"],
source: "basicAt: aString\x0a\x09<inlineJS: 'return self[aString]'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self[aString]"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self[aString];
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAt:",{aString:aString})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicAt:put:",
protocol: "accessing",
args: ["aString", "anObject"],
source: "basicAt: aString put: anObject\x0a\x09<inlineJS: 'return self[aString] = anObject'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self[aString] = anObject"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self[aString] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAt:put:",{aString:aString,anObject:anObject})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicDelete:",
protocol: "accessing",
args: ["aString"],
source: "basicDelete: aString\x0a\x09<inlineJS: 'delete self[aString]; return aString'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["delete self[aString]; return aString"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
delete self[aString]; return aString;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicDelete:",{aString:aString})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicPerform:",
protocol: "message handling",
args: ["aString"],
source: "basicPerform: aString\x0a\x09^ self basicPerform: aString withArguments: #()",
referencedClasses: [],
pragmas: [],
messageSends: ["basicPerform:withArguments:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._basicPerform_withArguments_(aString,[]);
}, function($ctx1) {$ctx1.fill(self,"basicPerform:",{aString:aString})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "basicPerform:withArguments:",
protocol: "message handling",
args: ["aString", "aCollection"],
source: "basicPerform: aString withArguments: aCollection\x0a\x09<inlineJS: 'return self[aString].apply(self, aCollection);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self[aString].apply(self, aCollection);"]]],
messageSends: []
}, function ($methodClass){ return function (aString,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self[aString].apply(self, aCollection);;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicPerform:withArguments:",{aString:aString,aCollection:aCollection})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "browse",
protocol: "browsing",
args: [],
source: "browse\x0a\x09Finder findClass: self class",
referencedClasses: ["Finder"],
pragmas: [],
messageSends: ["findClass:", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._findClass_($self._class());
return self;
}, function($ctx1) {$ctx1.fill(self,"browse",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "copy",
protocol: "copying",
args: [],
source: "copy\x0a\x09^ self shallowCopy postCopy",
referencedClasses: [],
pragmas: [],
messageSends: ["postCopy", "shallowCopy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._shallowCopy())._postCopy();
}, function($ctx1) {$ctx1.fill(self,"copy",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09<inlineJS: '\x0a\x09\x09var copy = self.a$cls._new();\x0a\x09\x09Object.keys(self).forEach(function (i) {\x0a\x09\x09\x09copy[i] = $recv(self[i])._deepCopy();\x0a\x09\x09});\x0a\x09\x09return copy;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var copy = self.a$cls._new();\x0a\x09\x09Object.keys(self).forEach(function (i) {\x0a\x09\x09\x09copy[i] = $recv(self[i])._deepCopy();\x0a\x09\x09});\x0a\x09\x09return copy;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var copy = self.a$cls._new();
		Object.keys(self).forEach(function (i) {
			copy[i] = $recv(self[i])._deepCopy();
		});
		return copy;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "deprecatedAPI",
protocol: "error handling",
args: [],
source: "deprecatedAPI\x0a\x09\x22Just a simple way to deprecate methods.\x0a\x09#deprecatedAPI is in the 'error handling' protocol even if it doesn't throw an error,\x0a\x09but it could in the future.\x22\x0a\x09console warn: thisContext home asString, ' is deprecated! (in ', thisContext home home asString, ')'.",
referencedClasses: [],
pragmas: [],
messageSends: ["warn:", ",", "asString", "home"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(console)._warn_([$recv([$recv($recv([$recv([$core.getThisContext()._home()
,$ctx1.sendIdx["home"]=1
][0])._asString()
,$ctx1.sendIdx["asString"]=1
][0]).__comma(" is deprecated! (in ")).__comma($recv([$recv($core.getThisContext()._home())._home()
,$ctx1.sendIdx["home"]=2
][0])._asString())
,$ctx1.sendIdx[","]=2
][0]).__comma(")")
,$ctx1.sendIdx[","]=1
][0]);
return self;
}, function($ctx1) {$ctx1.fill(self,"deprecatedAPI",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "deprecatedAPI:",
protocol: "error handling",
args: ["aString"],
source: "deprecatedAPI: aString\x0a\x09\x22Just a simple way to deprecate methods.\x0a\x09#deprecatedAPI is in the 'error handling' protocol even if it doesn't throw an error,\x0a\x09but it could in the future.\x22\x0a\x09console warn: thisContext home asString, ' is deprecated! (in ', thisContext home home asString, ')'.\x0a\x09console warn: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["warn:", ",", "asString", "home"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(console)._warn_([$recv([$recv($recv([$recv([$core.getThisContext()._home()
,$ctx1.sendIdx["home"]=1
][0])._asString()
,$ctx1.sendIdx["asString"]=1
][0]).__comma(" is deprecated! (in ")).__comma($recv([$recv($core.getThisContext()._home())._home()
,$ctx1.sendIdx["home"]=2
][0])._asString())
,$ctx1.sendIdx[","]=2
][0]).__comma(")")
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["warn:"]=1
][0];
$recv(console)._warn_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"deprecatedAPI:",{aString:aString})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "divideBySelfToNumber:",
protocol: "accessing",
args: ["aNumber"],
source: "divideBySelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"divideBySelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "divisionRemainderBySelfToNumber:",
protocol: "accessing",
args: ["aNumber"],
source: "divisionRemainderBySelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"divisionRemainderBySelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "error:",
protocol: "error handling",
args: ["aString"],
source: "error: aString\x0a\x09Error signal: aString",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["signal:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Error)._signal_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"error:",{aString:aString})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "halt",
protocol: "error handling",
args: [],
source: "halt\x0a\x09Halt signal",
referencedClasses: ["Halt"],
pragmas: [],
messageSends: ["signal"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Halt)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"halt",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "in:",
protocol: "evaluating",
args: ["aValuable"],
source: "in: aValuable\x0a\x09^ aValuable value: self",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aValuable){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aValuable)._value_(self);
}, function($ctx1) {$ctx1.fill(self,"in:",{aValuable:aValuable})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isMemberOf:",
protocol: "testing",
args: ["aClass"],
source: "isMemberOf: aClass\x0a\x09^ self class = aClass",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "class"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class()).__eq(aClass);
}, function($ctx1) {$ctx1.fill(self,"isMemberOf:",{aClass:aClass})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isNumberEqualToSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberEqualToSelf: aNumber\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isNumberGreaterThanOrEqualToSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberGreaterThanOrEqualToSelf: aNumber\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isNumberGreaterThanSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberGreaterThanSelf: aNumber\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isNumberLessThanOrEqualToSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberLessThanOrEqualToSelf: aNumber\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isNumberLessThanSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberLessThanSelf: aNumber\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isParseFailure",
protocol: "testing",
args: [],
source: "isParseFailure\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isStringEqualToSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringEqualToSelf: aString\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isStringGreaterThanOrEqualToSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringGreaterThanOrEqualToSelf: aString\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isStringGreaterThanSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringGreaterThanSelf: aString\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isStringLessThanOrEqualToSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringLessThanOrEqualToSelf: aString\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "isStringLessThanSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringLessThanSelf: aString\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "minusSelfToNumber:",
protocol: "accessing",
args: ["aNumber"],
source: "minusSelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"minusSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "orSelfToNumber:",
protocol: "converting",
args: ["aNumber"],
source: "orSelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"orSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "plusSelfToNumber:",
protocol: "accessing",
args: ["aNumber"],
source: "plusSelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"plusSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "postCopy",
protocol: "copying",
args: [],
source: "postCopy",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: "streaming",
args: ["aStream"],
source: "putOn: aStream\x0a\x09aStream nextPut: self",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPut:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPut_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "respondsTo:",
protocol: "testing",
args: ["aSelector"],
source: "respondsTo: aSelector\x0a\x09^ self class canUnderstand: aSelector",
referencedClasses: [],
pragmas: [],
messageSends: ["canUnderstand:", "class"]
}, function ($methodClass){ return function (aSelector){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._canUnderstand_(aSelector);
}, function($ctx1) {$ctx1.fill(self,"respondsTo:",{aSelector:aSelector})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09<inlineJS: '\x0a\x09\x09var copy = self.a$cls._new();\x0a\x09\x09Object.keys(self).forEach(function(i) {\x0a\x09\x09\x09copy[i] = self[i];\x0a\x09\x09});\x0a\x09\x09return copy;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var copy = self.a$cls._new();\x0a\x09\x09Object.keys(self).forEach(function(i) {\x0a\x09\x09\x09copy[i] = self[i];\x0a\x09\x09});\x0a\x09\x09return copy;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var copy = self.a$cls._new();
		Object.keys(self).forEach(function(i) {
			copy[i] = self[i];
		});
		return copy;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "shouldNotImplement",
protocol: "error handling",
args: [],
source: "shouldNotImplement\x0a\x09self error: 'This method should not be implemented in ', self class name",
referencedClasses: [],
pragmas: [],
messageSends: ["error:", ",", "name", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("This method should not be implemented in ".__comma($recv($self._class())._name()));
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldNotImplement",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09self error: 'Object not indexable'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Object not indexable");
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "subclassResponsibility",
protocol: "error handling",
args: [],
source: "subclassResponsibility\x0a\x09self error: 'This method is a responsibility of a subclass'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("This method is a responsibility of a subclass");
return self;
}, function($ctx1) {$ctx1.fill(self,"subclassResponsibility",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "timesSelfToNumber:",
protocol: "accessing",
args: ["aNumber"],
source: "timesSelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"timesSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "value",
protocol: "evaluating",
args: [],
source: "value\x0a\x09<inlineJS: 'return self.valueOf()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.valueOf()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.valueOf();
return self;
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "xorSelfToNumber:",
protocol: "converting",
args: ["aNumber"],
source: "xorSelfToNumber: aNumber\x0a\x09self error: 'I am not a number.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("I am not a number.");
return self;
}, function($ctx1) {$ctx1.fill(self,"xorSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Object);


$core.addMethod(
$core.method({
selector: "accessorProtocolWith:",
protocol: "helios",
args: ["aGenerator"],
source: "accessorProtocolWith: aGenerator\x0a\x09aGenerator accessorProtocolForObject",
referencedClasses: [],
pragmas: [],
messageSends: ["accessorProtocolForObject"]
}, function ($methodClass){ return function (aGenerator){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._accessorProtocolForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"accessorProtocolWith:",{aGenerator:aGenerator})});
}; }),
$globals.Object.a$cls);

$core.addMethod(
$core.method({
selector: "accessorsSourceCodesWith:",
protocol: "helios",
args: ["aGenerator"],
source: "accessorsSourceCodesWith: aGenerator\x0a\x09aGenerator accessorsForObject",
referencedClasses: [],
pragmas: [],
messageSends: ["accessorsForObject"]
}, function ($methodClass){ return function (aGenerator){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._accessorsForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"accessorsSourceCodesWith:",{aGenerator:aGenerator})});
}; }),
$globals.Object.a$cls);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09\x22no op\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Object.a$cls);

$core.addMethod(
$core.method({
selector: "initializeProtocolWith:",
protocol: "helios",
args: ["aGenerator"],
source: "initializeProtocolWith: aGenerator\x0a\x09aGenerator initializeProtocolForObject",
referencedClasses: [],
pragmas: [],
messageSends: ["initializeProtocolForObject"]
}, function ($methodClass){ return function (aGenerator){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._initializeProtocolForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeProtocolWith:",{aGenerator:aGenerator})});
}; }),
$globals.Object.a$cls);

$core.addMethod(
$core.method({
selector: "initializeSourceCodesWith:",
protocol: "helios",
args: ["aGenerator"],
source: "initializeSourceCodesWith: aGenerator\x0a\x09aGenerator initializeForObject",
referencedClasses: [],
pragmas: [],
messageSends: ["initializeForObject"]
}, function ($methodClass){ return function (aGenerator){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aGenerator)._initializeForObject();
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeSourceCodesWith:",{aGenerator:aGenerator})});
}; }),
$globals.Object.a$cls);


$core.addClass("Boolean", $globals.Object, "Kernel-Objects");
$globals.Boolean.comment="I define the protocol for logic testing operations and conditional control structures for the logical values (see the `controlling` protocol).\x0a\x0aI have two instances, `true` and `false`.\x0a\x0aI am directly mapped to JavaScript Boolean. The `true` and `false` objects are the JavaScript boolean objects.\x0a\x0a## Usage Example:\x0a\x0a    aBoolean not ifTrue: [ ... ] ifFalse: [ ... ]";
$core.addMethod(
$core.method({
selector: "&",
protocol: "controlling",
args: ["aBoolean"],
source: "& aBoolean\x0a\x09<inlineJS: '\x0a\x09\x09if(self == true) {\x0a\x09\x09return aBoolean;\x0a\x09\x09} else {\x0a\x09\x09return false;\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if(self == true) {\x0a\x09\x09return aBoolean;\x0a\x09\x09} else {\x0a\x09\x09return false;\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if(self == true) {
		return aBoolean;
		} else {
		return false;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"&",{aBoolean:aBoolean})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "==",
protocol: "comparing",
args: ["aBoolean"],
source: "== aBoolean\x0a<inlineJS: '\x0a\x09if (typeof aBoolean === \x22boolean\x22) return (self == true) === aBoolean;\x0a\x09else if (aBoolean != null && typeof aBoolean === \x22object\x22) return (self == true) === aBoolean.valueOf();\x0a\x09else return false;\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09if (typeof aBoolean === \x22boolean\x22) return (self == true) === aBoolean;\x0a\x09else if (aBoolean != null && typeof aBoolean === \x22object\x22) return (self == true) === aBoolean.valueOf();\x0a\x09else return false;"]]],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	if (typeof aBoolean === "boolean") return (self == true) === aBoolean;
	else if (aBoolean != null && typeof aBoolean === "object") return (self == true) === aBoolean.valueOf();
	else return false;;
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{aBoolean:aBoolean})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "and:",
protocol: "controlling",
args: ["aBlock"],
source: "and: aBlock\x0a\x09^ self\x0a\x09\x09ifTrue: \x22aBlock\x22 [ aBlock value ]\x0a\x09\x09ifFalse: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert(self)){
return $recv(aBlock)._value();
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"and:",{aBlock:aBlock})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asBit",
protocol: "converting",
args: [],
source: "asBit\x0a\x09^ self ifTrue: [ 1 ] ifFalse: [ 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert(self)){
return (1);
} else {
return (0);
}
}, function($ctx1) {$ctx1.fill(self,"asBit",{})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ self asString",
referencedClasses: [],
pragmas: [],
messageSends: ["asString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._asString();
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09<inlineJS: 'return self.toString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asString",{})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifFalse:",
protocol: "controlling",
args: ["aBlock"],
source: "ifFalse: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifTrue: [] ifFalse: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ifTrue_ifFalse_((function(){

}),aBlock);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:",{aBlock:aBlock})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifFalse:ifTrue:",
protocol: "controlling",
args: ["aBlock", "anotherBlock"],
source: "ifFalse: aBlock ifTrue: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifTrue: anotherBlock ifFalse: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ifTrue_ifFalse_(anotherBlock,aBlock);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:ifTrue:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifTrue:",
protocol: "controlling",
args: ["aBlock"],
source: "ifTrue: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifTrue: aBlock ifFalse: []",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ifTrue_ifFalse_(aBlock,(function(){

}));
}, function($ctx1) {$ctx1.fill(self,"ifTrue:",{aBlock:aBlock})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "ifTrue:ifFalse:",
protocol: "controlling",
args: ["aBlock", "anotherBlock"],
source: "ifTrue: aBlock ifFalse: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09<inlineJS: '\x0a\x09\x09if(self == true) {\x0a\x09\x09return aBlock._value();\x0a\x09\x09} else {\x0a\x09\x09return anotherBlock._value();\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if(self == true) {\x0a\x09\x09return aBlock._value();\x0a\x09\x09} else {\x0a\x09\x09return anotherBlock._value();\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if(self == true) {
		return aBlock._value();
		} else {
		return anotherBlock._value();
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"ifTrue:ifFalse:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "isBoolean",
protocol: "testing",
args: [],
source: "isBoolean\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "not",
protocol: "controlling",
args: [],
source: "not\x0a\x09^ self = false",
referencedClasses: [],
pragmas: [],
messageSends: ["="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__eq(false);
}, function($ctx1) {$ctx1.fill(self,"not",{})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "or:",
protocol: "controlling",
args: ["aBlock"],
source: "or: aBlock\x0a\x09^ self\x0a\x09\x09ifTrue: [ true ]\x0a\x09\x09ifFalse: \x22aBlock\x22 [ aBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert(self)){
return true;
} else {
return $recv(aBlock)._value();
}
}, function($ctx1) {$ctx1.fill(self,"or:",{aBlock:aBlock})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self asString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "asString"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_($self._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Boolean);

$core.addMethod(
$core.method({
selector: "|",
protocol: "controlling",
args: ["aBoolean"],
source: "| aBoolean\x0a\x09<inlineJS: '\x0a\x09\x09if(self == true) {\x0a\x09\x09return true;\x0a\x09\x09} else {\x0a\x09\x09return aBoolean;\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if(self == true) {\x0a\x09\x09return true;\x0a\x09\x09} else {\x0a\x09\x09return aBoolean;\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if(self == true) {
		return true;
		} else {
		return aBoolean;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"|",{aBoolean:aBoolean})});
}; }),
$globals.Boolean);



$core.addClass("Date", $globals.Object, "Kernel-Objects");
$globals.Date.comment="I am used to work with both dates and times. Therefore `Date today` and `Date now` are both valid in\x0aAmber and answer the same date object.\x0a\x0aDate directly maps to the `Date()` JavaScript constructor, and Amber date objects are JavaScript date objects.\x0a\x0a## API\x0a\x0aThe class-side `instance creation` protocol contains some convenience methods for creating date/time objects such as `#fromSeconds:`.\x0a\x0aArithmetic and comparison is supported (see the `comparing` and `arithmetic` protocols).\x0a\x0aThe `converting` protocol provides convenience methods for various convertions (to numbers, strings, etc.).";
$core.addMethod(
$core.method({
selector: "+",
protocol: "arithmetic",
args: ["aNumber"],
source: "+ aNumber\x0a\x09<inlineJS: 'return new Date($self.getTime() + aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new Date($self.getTime() + aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new Date($self.getTime() + aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"+",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "-",
protocol: "arithmetic",
args: ["aDate"],
source: "- aDate\x0a\x09<inlineJS: 'return self - aDate'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self - aDate"]]],
messageSends: []
}, function ($methodClass){ return function (aDate){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self - aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"-",{aDate:aDate})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "<",
protocol: "comparing",
args: ["aDate"],
source: "< aDate\x0a\x09<inlineJS: 'return self < aDate'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self < aDate"]]],
messageSends: []
}, function ($methodClass){ return function (aDate){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self < aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"<",{aDate:aDate})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "<=",
protocol: "comparing",
args: ["aDate"],
source: "<= aDate\x0a\x09<inlineJS: 'return self <= aDate'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self <= aDate"]]],
messageSends: []
}, function ($methodClass){ return function (aDate){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self <= aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,"<=",{aDate:aDate})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["aDate"],
source: "= aDate\x0a\x09^ (aDate class == self class) and: [ self asMilliseconds == aDate asMilliseconds ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "==", "class", "asMilliseconds"]
}, function ($methodClass){ return function (aDate){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$recv(aDate)._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq_eq($self._class())
,$ctx1.sendIdx["=="]=1
][0])){
return $recv([$self._asMilliseconds()
,$ctx1.sendIdx["asMilliseconds"]=1
][0]).__eq_eq($recv(aDate)._asMilliseconds());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{aDate:aDate})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: ">",
protocol: "comparing",
args: ["aDate"],
source: "> aDate\x0a\x09<inlineJS: 'return self > aDate'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self > aDate"]]],
messageSends: []
}, function ($methodClass){ return function (aDate){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self > aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,">",{aDate:aDate})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: ">=",
protocol: "comparing",
args: ["aDate"],
source: ">= aDate\x0a\x09<inlineJS: 'return self >= aDate'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self >= aDate"]]],
messageSends: []
}, function ($methodClass){ return function (aDate){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self >= aDate;
return self;
}, function($ctx1) {$ctx1.fill(self,">=",{aDate:aDate})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asDateString",
protocol: "converting",
args: [],
source: "asDateString\x0a\x09<inlineJS: 'return self.toDateString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toDateString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toDateString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asDateString",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asLocaleString",
protocol: "converting",
args: [],
source: "asLocaleString\x0a\x09<inlineJS: 'return self.toLocaleString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toLocaleString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toLocaleString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asLocaleString",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asMilliseconds",
protocol: "converting",
args: [],
source: "asMilliseconds\x0a\x09^ self time",
referencedClasses: [],
pragmas: [],
messageSends: ["time"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._time();
}, function($ctx1) {$ctx1.fill(self,"asMilliseconds",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: "converting",
args: [],
source: "asNumber\x0a\x09^ self asMilliseconds",
referencedClasses: [],
pragmas: [],
messageSends: ["asMilliseconds"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._asMilliseconds();
}, function($ctx1) {$ctx1.fill(self,"asNumber",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09<inlineJS: 'return self.toString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asString",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "asTimeString",
protocol: "converting",
args: [],
source: "asTimeString\x0a\x09<inlineJS: 'return self.toTimeString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toTimeString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toTimeString();
return self;
}, function($ctx1) {$ctx1.fill(self,"asTimeString",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "day",
protocol: "accessing",
args: [],
source: "day\x0a\x09^ self dayOfWeek",
referencedClasses: [],
pragmas: [],
messageSends: ["dayOfWeek"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._dayOfWeek();
}, function($ctx1) {$ctx1.fill(self,"day",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "day:",
protocol: "accessing",
args: ["aNumber"],
source: "day: aNumber\x0a\x09self dayOfWeek: aNumber",
referencedClasses: [],
pragmas: [],
messageSends: ["dayOfWeek:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._dayOfWeek_(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"day:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfMonth",
protocol: "accessing",
args: [],
source: "dayOfMonth\x0a\x09<inlineJS: 'return self.getDate()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getDate()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getDate();
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfMonth",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfMonth:",
protocol: "accessing",
args: ["aNumber"],
source: "dayOfMonth: aNumber\x0a\x09<inlineJS: 'self.setDate(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setDate(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setDate(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfMonth:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfWeek",
protocol: "accessing",
args: [],
source: "dayOfWeek\x0a\x09<inlineJS: 'return self.getDay() + 1'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getDay() + 1"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getDay() + 1;
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfWeek",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "dayOfWeek:",
protocol: "accessing",
args: ["aNumber"],
source: "dayOfWeek: aNumber\x0a\x09<inlineJS: 'return self.setDay(aNumber - 1)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.setDay(aNumber - 1)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.setDay(aNumber - 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"dayOfWeek:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "hours",
protocol: "accessing",
args: [],
source: "hours\x0a\x09<inlineJS: 'return self.getHours()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getHours()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getHours();
return self;
}, function($ctx1) {$ctx1.fill(self,"hours",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "hours:",
protocol: "accessing",
args: ["aNumber"],
source: "hours: aNumber\x0a\x09<inlineJS: 'self.setHours(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setHours(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setHours(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"hours:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "milliseconds",
protocol: "accessing",
args: [],
source: "milliseconds\x0a\x09<inlineJS: 'return self.getMilliseconds()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getMilliseconds()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getMilliseconds();
return self;
}, function($ctx1) {$ctx1.fill(self,"milliseconds",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "milliseconds:",
protocol: "accessing",
args: ["aNumber"],
source: "milliseconds: aNumber\x0a\x09<inlineJS: 'self.setMilliseconds(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setMilliseconds(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setMilliseconds(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"milliseconds:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "minutes",
protocol: "accessing",
args: [],
source: "minutes\x0a\x09<inlineJS: 'return self.getMinutes()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getMinutes()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getMinutes();
return self;
}, function($ctx1) {$ctx1.fill(self,"minutes",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "minutes:",
protocol: "accessing",
args: ["aNumber"],
source: "minutes: aNumber\x0a\x09<inlineJS: 'self.setMinutes(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setMinutes(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setMinutes(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"minutes:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "month",
protocol: "accessing",
args: [],
source: "month\x0a\x09<inlineJS: 'return self.getMonth() + 1'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getMonth() + 1"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getMonth() + 1;
return self;
}, function($ctx1) {$ctx1.fill(self,"month",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "month:",
protocol: "accessing",
args: ["aNumber"],
source: "month: aNumber\x0a\x09<inlineJS: 'self.setMonth(aNumber - 1)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setMonth(aNumber - 1)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setMonth(aNumber - 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"month:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self asString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "asString"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_($self._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "seconds",
protocol: "accessing",
args: [],
source: "seconds\x0a\x09<inlineJS: 'return self.getSeconds()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getSeconds()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getSeconds();
return self;
}, function($ctx1) {$ctx1.fill(self,"seconds",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "seconds:",
protocol: "accessing",
args: ["aNumber"],
source: "seconds: aNumber\x0a\x09<inlineJS: 'self.setSeconds(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setSeconds(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setSeconds(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"seconds:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "time",
protocol: "accessing",
args: [],
source: "time\x0a\x09<inlineJS: 'return self.getTime()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getTime()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getTime();
return self;
}, function($ctx1) {$ctx1.fill(self,"time",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "time:",
protocol: "accessing",
args: ["aNumber"],
source: "time: aNumber\x0a\x09<inlineJS: 'self.setTime(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setTime(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setTime(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"time:",{aNumber:aNumber})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "year",
protocol: "accessing",
args: [],
source: "year\x0a\x09<inlineJS: 'return self.getFullYear()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.getFullYear()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.getFullYear();
return self;
}, function($ctx1) {$ctx1.fill(self,"year",{})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "year:",
protocol: "accessing",
args: ["aNumber"],
source: "year: aNumber\x0a\x09<inlineJS: 'self.setFullYear(aNumber)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.setFullYear(aNumber)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.setFullYear(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"year:",{aNumber:aNumber})});
}; }),
$globals.Date);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'magnitude'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "magnitude";

}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "fromMilliseconds:",
protocol: "instance creation",
args: ["aNumber"],
source: "fromMilliseconds: aNumber\x0a\x09^ self new: aNumber",
referencedClasses: [],
pragmas: [],
messageSends: ["new:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._new_(aNumber);
}, function($ctx1) {$ctx1.fill(self,"fromMilliseconds:",{aNumber:aNumber})});
}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "fromSeconds:",
protocol: "instance creation",
args: ["aNumber"],
source: "fromSeconds: aNumber\x0a\x09^ self fromMilliseconds: aNumber * 1000",
referencedClasses: [],
pragmas: [],
messageSends: ["fromMilliseconds:", "*"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._fromMilliseconds_($recv(aNumber).__star((1000)));
}, function($ctx1) {$ctx1.fill(self,"fromSeconds:",{aNumber:aNumber})});
}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "fromString:",
protocol: "instance creation",
args: ["aString"],
source: "fromString: aString\x0a\x09\x22Example: Date fromString('2011/04/15 00:00:00')\x22\x0a\x09^ self new: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["new:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._new_(aString);
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString})});
}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "millisecondsToRun:",
protocol: "instance creation",
args: ["aBlock"],
source: "millisecondsToRun: aBlock\x0a\x09| t |\x0a\x09t := Date now.\x0a\x09aBlock value.\x0a\x09^ Date now - t",
referencedClasses: ["Date"],
pragmas: [],
messageSends: ["now", "value", "-"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var t;
return $core.withContext(function($ctx1) {
t=[$recv($globals.Date)._now()
,$ctx1.sendIdx["now"]=1
][0];
$recv(aBlock)._value();
return $recv($recv($globals.Date)._now()).__minus(t);
}, function($ctx1) {$ctx1.fill(self,"millisecondsToRun:",{aBlock:aBlock,t:t})});
}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "new:",
protocol: "instance creation",
args: ["anObject"],
source: "new: anObject\x0a\x09<inlineJS: 'return new Date(anObject)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new Date(anObject)"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new Date(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"new:",{anObject:anObject})});
}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "now",
protocol: "instance creation",
args: [],
source: "now\x0a\x09^ self today",
referencedClasses: [],
pragmas: [],
messageSends: ["today"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._today();
}, function($ctx1) {$ctx1.fill(self,"now",{})});
}; }),
$globals.Date.a$cls);

$core.addMethod(
$core.method({
selector: "today",
protocol: "instance creation",
args: [],
source: "today\x0a\x09^ self new",
referencedClasses: [],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._new();
}, function($ctx1) {$ctx1.fill(self,"today",{})});
}; }),
$globals.Date.a$cls);


$core.addClass("Number", $globals.Object, "Kernel-Objects");
$globals.Number.comment="I am the Amber representation for all numbers.\x0aI am directly mapped to JavaScript Number.\x0a\x0a## API\x0a\x0aI provide all necessary methods for arithmetic operations, comparison, conversion and so on with numbers.\x0a\x0aMy instances can also be used to evaluate a block a fixed number of times:\x0a\x0a\x095 timesRepeat: [ Transcript show: 'This will be printed 5 times'; cr ].\x0a\x09\x0a\x091 to: 5 do: [ :aNumber| Transcript show: aNumber asString; cr ].\x0a\x09\x0a\x091 to: 10 by: 2 do: [ :aNumber| Transcript show: aNumber asString; cr ].";
$core.addMethod(
$core.method({
selector: "&",
protocol: "converting",
args: ["aNumber"],
source: "& aNumber\x0a\x09^ self bitAnd: aNumber",
referencedClasses: [],
pragmas: [],
messageSends: ["bitAnd:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._bitAnd_(aNumber);
}, function($ctx1) {$ctx1.fill(self,"&",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "*",
protocol: "arithmetic",
args: ["aNumber"],
source: "* aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self * aNumber :\x0a\x09\x09$recv(aNumber)._timesSelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self * aNumber :\x0a\x09\x09$recv(aNumber)._timesSelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self * aNumber :
		$recv(aNumber)._timesSelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"*",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "**",
protocol: "mathematical functions",
args: ["exponent"],
source: "** exponent\x0a\x09^ self raisedTo: exponent",
referencedClasses: [],
pragmas: [],
messageSends: ["raisedTo:"]
}, function ($methodClass){ return function (exponent){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._raisedTo_(exponent);
}, function($ctx1) {$ctx1.fill(self,"**",{exponent:exponent})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "+",
protocol: "arithmetic",
args: ["aNumber"],
source: "+ aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self + aNumber :\x0a\x09\x09$recv(aNumber)._plusSelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self + aNumber :\x0a\x09\x09$recv(aNumber)._plusSelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self + aNumber :
		$recv(aNumber)._plusSelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"+",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "-",
protocol: "arithmetic",
args: ["aNumber"],
source: "- aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self - aNumber :\x0a\x09\x09$recv(aNumber)._minusSelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self - aNumber :\x0a\x09\x09$recv(aNumber)._minusSelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self - aNumber :
		$recv(aNumber)._minusSelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"-",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "/",
protocol: "arithmetic",
args: ["aNumber"],
source: "/ aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self / aNumber :\x0a\x09\x09$recv(aNumber)._divideBySelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self / aNumber :\x0a\x09\x09$recv(aNumber)._divideBySelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self / aNumber :
		$recv(aNumber)._divideBySelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"/",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "//",
protocol: "arithmetic",
args: ["aNumber"],
source: "// aNumber\x0a\x09^ (self / aNumber) floor",
referencedClasses: [],
pragmas: [],
messageSends: ["floor", "/"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.__slash(aNumber))._floor();
}, function($ctx1) {$ctx1.fill(self,"//",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "<",
protocol: "comparing",
args: ["aNumber"],
source: "< aNumber\x0a<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) < aNumber :\x0a\x09$recv(aNumber)._isNumberLessThanSelf_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) < aNumber :\x0a\x09$recv(aNumber)._isNumberLessThanSelf_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
	Number(self) < aNumber :
	$recv(aNumber)._isNumberLessThanSelf_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"<",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "<=",
protocol: "comparing",
args: ["aNumber"],
source: "<= aNumber\x0a<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) <= aNumber :\x0a\x09$recv(aNumber)._isNumberLessThanOrEqualToSelf_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) <= aNumber :\x0a\x09$recv(aNumber)._isNumberLessThanOrEqualToSelf_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
	Number(self) <= aNumber :
	$recv(aNumber)._isNumberLessThanOrEqualToSelf_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"<=",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "==",
protocol: "comparing",
args: ["aNumber"],
source: "== aNumber\x0a<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) === aNumber :\x0a\x09$recv(aNumber)._isNumberEqualToSelf_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) === aNumber :\x0a\x09$recv(aNumber)._isNumberEqualToSelf_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
	Number(self) === aNumber :
	$recv(aNumber)._isNumberEqualToSelf_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: ">",
protocol: "comparing",
args: ["aNumber"],
source: "> aNumber\x0a<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) > aNumber :\x0a\x09$recv(aNumber)._isNumberGreaterThanSelf_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) > aNumber :\x0a\x09$recv(aNumber)._isNumberGreaterThanSelf_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
	Number(self) > aNumber :
	$recv(aNumber)._isNumberGreaterThanSelf_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,">",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: ">=",
protocol: "comparing",
args: ["aNumber"],
source: ">= aNumber\x0a<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) >= aNumber :\x0a\x09$recv(aNumber)._isNumberGreaterThanOrEqualToSelf_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09Number(self) >= aNumber :\x0a\x09$recv(aNumber)._isNumberGreaterThanOrEqualToSelf_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
	Number(self) >= aNumber :
	$recv(aNumber)._isNumberGreaterThanOrEqualToSelf_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,">=",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "@",
protocol: "converting",
args: ["aNumber"],
source: "@ aNumber\x0a\x09^ Point x: self y: aNumber",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["x:y:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_(self,aNumber);
}, function($ctx1) {$ctx1.fill(self,"@",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "\x5c\x5c",
protocol: "arithmetic",
args: ["aNumber"],
source: "\x5c\x5c aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self % aNumber :\x0a\x09\x09$recv(aNumber)._divisionRemainderBySelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self % aNumber :\x0a\x09\x09$recv(aNumber)._divisionRemainderBySelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self % aNumber :
		$recv(aNumber)._divisionRemainderBySelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"\x5c\x5c",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "abs",
protocol: "arithmetic",
args: [],
source: "abs\x0a\x09<inlineJS: 'return Math.abs(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.abs(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.abs(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"abs",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "andSelfToNumber:",
protocol: "converting",
args: ["aNumber"],
source: "andSelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber & self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber & self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber & self;
return self;
}, function($ctx1) {$ctx1.fill(self,"andSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcCos",
protocol: "mathematical functions",
args: [],
source: "arcCos\x0a\x09<inlineJS: 'return Math.acos(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.acos(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.acos(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcCos",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcSin",
protocol: "mathematical functions",
args: [],
source: "arcSin\x0a\x09<inlineJS: 'return Math.asin(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.asin(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.asin(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcSin",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcTan",
protocol: "mathematical functions",
args: [],
source: "arcTan\x0a\x09<inlineJS: 'return Math.atan(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.atan(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.atan(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcTan",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "arcTan:",
protocol: "mathematical functions",
args: ["aNumber"],
source: "arcTan: aNumber\x0a\x09<inlineJS: 'return Math.atan2(self, aNumber);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.atan2(self, aNumber);"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.atan2(self, aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"arcTan:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ '(', self printString, ')'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "printString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv("(".__comma($self._printString())).__comma(")")
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: "converting",
args: [],
source: "asNumber\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asPoint",
protocol: "converting",
args: [],
source: "asPoint\x0a\x09^ Point x: self y: self",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["x:y:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_(self,self);
}, function($ctx1) {$ctx1.fill(self,"asPoint",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09<inlineJS: 'return String(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return String(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return String(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asString",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "atRandom",
protocol: "converting",
args: [],
source: "atRandom\x0a\x09^ (Random new next * self) truncated + 1",
referencedClasses: ["Random"],
pragmas: [],
messageSends: ["+", "truncated", "*", "next", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($recv($recv($globals.Random)._new())._next()).__star(self))._truncated()).__plus((1));
}, function($ctx1) {$ctx1.fill(self,"atRandom",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "between:and:",
protocol: "testing",
args: ["min", "max"],
source: "between: min and: max\x0a ^ self >= min and: [ self <= max ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", ">=", "<="]
}, function ($methodClass){ return function (min,max){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self.__gt_eq(min))){
return $self.__lt_eq(max);
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"between:and:",{min:min,max:max})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "bitAnd:",
protocol: "converting",
args: ["aNumber"],
source: "bitAnd: aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self & aNumber :\x0a\x09\x09$recv(aNumber)._andSelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self & aNumber :\x0a\x09\x09$recv(aNumber)._andSelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self & aNumber :
		$recv(aNumber)._andSelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"bitAnd:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "bitNot",
protocol: "converting",
args: [],
source: "bitNot\x0a\x09<inlineJS: 'return ~self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return ~self"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return ~self;
return self;
}, function($ctx1) {$ctx1.fill(self,"bitNot",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "bitOr:",
protocol: "converting",
args: ["aNumber"],
source: "bitOr: aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self | aNumber :\x0a\x09\x09$recv(aNumber)._orSelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self | aNumber :\x0a\x09\x09$recv(aNumber)._orSelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self | aNumber :
		$recv(aNumber)._orSelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"bitOr:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "bitXor:",
protocol: "converting",
args: ["aNumber"],
source: "bitXor: aNumber\x0a\x09<inlineJS: 'return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self ^ aNumber :\x0a\x09\x09$recv(aNumber)._xorSelfToNumber_(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aNumber === \x22number\x22 ?\x0a\x09\x09self ^ aNumber :\x0a\x09\x09$recv(aNumber)._xorSelfToNumber_(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aNumber === "number" ?
		self ^ aNumber :
		$recv(aNumber)._xorSelfToNumber_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"bitXor:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "ceiling",
protocol: "converting",
args: [],
source: "ceiling\x0a\x09<inlineJS: 'return Math.ceil(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.ceil(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.ceil(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"ceiling",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "copy",
protocol: "copying",
args: [],
source: "copy\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "cos",
protocol: "mathematical functions",
args: [],
source: "cos\x0a\x09<inlineJS: 'return Math.cos(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.cos(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.cos(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"cos",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09^ self copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._copy();
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "degreesToRadians",
protocol: "converting",
args: [],
source: "degreesToRadians\x0a\x09^ self * Number radiansPerDegree",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["*", "radiansPerDegree"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__star($recv($globals.Number)._radiansPerDegree());
}, function($ctx1) {$ctx1.fill(self,"degreesToRadians",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "divideBySelfToNumber:",
protocol: "arithmetic",
args: ["aNumber"],
source: "divideBySelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber / self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber / self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber / self;
return self;
}, function($ctx1) {$ctx1.fill(self,"divideBySelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "divisionRemainderBySelfToNumber:",
protocol: "arithmetic",
args: ["aNumber"],
source: "divisionRemainderBySelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber % self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber % self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber % self;
return self;
}, function($ctx1) {$ctx1.fill(self,"divisionRemainderBySelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "even",
protocol: "testing",
args: [],
source: "even\x0a\x09^ 0 = (self \x5c\x5c 2)",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "\x5c\x5c"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return (0).__eq($self.__backslash_backslash((2)));
}, function($ctx1) {$ctx1.fill(self,"even",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "floor",
protocol: "converting",
args: [],
source: "floor\x0a\x09<inlineJS: 'return Math.floor(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.floor(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.floor(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"floor",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isFinite",
protocol: "testing",
args: [],
source: "isFinite\x0a\x09\x22Answer whether the receiver is finite\x22\x0a\x09<inlineJS: 'return Number.isFinite(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Number.isFinite(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Number.isFinite(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"isFinite",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNaN",
protocol: "testing",
args: [],
source: "isNaN\x0a\x09\x22Answer whether the receiver is IEEE-754 not-a-number\x22\x0a\x09<inlineJS: 'return Number.isNaN(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Number.isNaN(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Number.isNaN(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"isNaN",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumber",
protocol: "testing",
args: [],
source: "isNumber\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumberEqualToSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberEqualToSelf: aNumber\x0a\x09<inlineJS: 'return aNumber === Number(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber === Number(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber === Number(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"isNumberEqualToSelf:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumberGreaterThanOrEqualToSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberGreaterThanOrEqualToSelf: aNumber\x0a\x09<inlineJS: 'return aNumber >= self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber >= self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber >= self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isNumberGreaterThanOrEqualToSelf:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumberGreaterThanSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberGreaterThanSelf: aNumber\x0a\x09<inlineJS: 'return aNumber > self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber > self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber > self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isNumberGreaterThanSelf:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumberLessThanOrEqualToSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberLessThanOrEqualToSelf: aNumber\x0a\x09<inlineJS: 'return aNumber <= self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber <= self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber <= self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isNumberLessThanOrEqualToSelf:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isNumberLessThanSelf:",
protocol: "comparing",
args: ["aNumber"],
source: "isNumberLessThanSelf: aNumber\x0a\x09<inlineJS: 'return aNumber < self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber < self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber < self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isNumberLessThanSelf:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "isZero",
protocol: "testing",
args: [],
source: "isZero\x0a\x09^ self = 0",
referencedClasses: [],
pragmas: [],
messageSends: ["="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__eq((0));
}, function($ctx1) {$ctx1.fill(self,"isZero",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "ln",
protocol: "mathematical functions",
args: [],
source: "ln\x0a\x09<inlineJS: 'return Math.log(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.log(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.log(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"ln",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "ln1p",
protocol: "mathematical functions",
args: [],
source: "ln1p\x0a\x09<inlineJS: 'return Math.log1p(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.log1p(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.log1p(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"ln1p",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "log",
protocol: "mathematical functions",
args: [],
source: "log\x0a\x09<inlineJS: 'return Math.log(self) / Math.LN10;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.log(self) / Math.LN10;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.log(self) / Math.LN10;;
return self;
}, function($ctx1) {$ctx1.fill(self,"log",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "log:",
protocol: "mathematical functions",
args: ["aNumber"],
source: "log: aNumber\x0a\x09<inlineJS: 'return Math.log(self) / Math.log(aNumber);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.log(self) / Math.log(aNumber);"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.log(self) / Math.log(aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"log:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "max:",
protocol: "arithmetic",
args: ["aNumber"],
source: "max: aNumber\x0a\x09<inlineJS: 'return Math.max(self, aNumber);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.max(self, aNumber);"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.max(self, aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"max:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "min:",
protocol: "arithmetic",
args: ["aNumber"],
source: "min: aNumber\x0a\x09<inlineJS: 'return Math.min(self, aNumber);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.min(self, aNumber);"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.min(self, aNumber);;
return self;
}, function($ctx1) {$ctx1.fill(self,"min:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "min:max:",
protocol: "arithmetic",
args: ["aMin", "aMax"],
source: "min: aMin max: aMax\x0a\x09^ (self min: aMin) max: aMax",
referencedClasses: [],
pragmas: [],
messageSends: ["max:", "min:"]
}, function ($methodClass){ return function (aMin,aMax){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._min_(aMin))._max_(aMax);
}, function($ctx1) {$ctx1.fill(self,"min:max:",{aMin:aMin,aMax:aMax})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "minusSelfToNumber:",
protocol: "arithmetic",
args: ["aNumber"],
source: "minusSelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber - self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber - self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber - self;
return self;
}, function($ctx1) {$ctx1.fill(self,"minusSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "negated",
protocol: "arithmetic",
args: [],
source: "negated\x0a\x09^ 0 - self",
referencedClasses: [],
pragmas: [],
messageSends: ["-"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return (0).__minus(self);
}, function($ctx1) {$ctx1.fill(self,"negated",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "negative",
protocol: "testing",
args: [],
source: "negative\x0a\x09\x22Answer whether the receiver is mathematically negative.\x22\x0a\x0a\x09^ self < 0",
referencedClasses: [],
pragmas: [],
messageSends: ["<"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__lt((0));
}, function($ctx1) {$ctx1.fill(self,"negative",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "odd",
protocol: "testing",
args: [],
source: "odd\x0a\x09^ self even not",
referencedClasses: [],
pragmas: [],
messageSends: ["not", "even"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._even())._not();
}, function($ctx1) {$ctx1.fill(self,"odd",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "orSelfToNumber:",
protocol: "converting",
args: ["aNumber"],
source: "orSelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber | self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber | self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber | self;
return self;
}, function($ctx1) {$ctx1.fill(self,"orSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "plusSelfToNumber:",
protocol: "arithmetic",
args: ["aNumber"],
source: "plusSelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber + self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber + self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber + self;
return self;
}, function($ctx1) {$ctx1.fill(self,"plusSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "positive",
protocol: "testing",
args: [],
source: "positive\x0a\x09\x22Answer whether the receiver is positive or equal to 0. (ST-80 protocol).\x22\x0a\x0a\x09^ self >= 0",
referencedClasses: [],
pragmas: [],
messageSends: [">="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__gt_eq((0));
}, function($ctx1) {$ctx1.fill(self,"positive",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self asString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "asString"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_($self._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "printShowingDecimalPlaces:",
protocol: "printing",
args: ["placesDesired"],
source: "printShowingDecimalPlaces: placesDesired\x0a\x09<inlineJS: 'return self.toFixed(placesDesired)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toFixed(placesDesired)"]]],
messageSends: []
}, function ($methodClass){ return function (placesDesired){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toFixed(placesDesired);
return self;
}, function($ctx1) {$ctx1.fill(self,"printShowingDecimalPlaces:",{placesDesired:placesDesired})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "printStringBase:",
protocol: "converting",
args: ["aBase"],
source: "printStringBase: aBase\x0a\x09<inlineJS: 'return self.toString(aBase)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toString(aBase)"]]],
messageSends: []
}, function ($methodClass){ return function (aBase){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toString(aBase);
return self;
}, function($ctx1) {$ctx1.fill(self,"printStringBase:",{aBase:aBase})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "radiansToDegrees",
protocol: "converting",
args: [],
source: "radiansToDegrees\x0a\x09^ self / Number radiansPerDegree",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["/", "radiansPerDegree"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__slash($recv($globals.Number)._radiansPerDegree());
}, function($ctx1) {$ctx1.fill(self,"radiansToDegrees",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "raisedTo:",
protocol: "mathematical functions",
args: ["exponent"],
source: "raisedTo: exponent\x0a\x09<inlineJS: 'return Math.pow(self, exponent);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.pow(self, exponent);"]]],
messageSends: []
}, function ($methodClass){ return function (exponent){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.pow(self, exponent);;
return self;
}, function($ctx1) {$ctx1.fill(self,"raisedTo:",{exponent:exponent})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "rounded",
protocol: "converting",
args: [],
source: "rounded\x0a\x09<inlineJS: 'return Math.round(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.round(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.round(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"rounded",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "sign",
protocol: "mathematical functions",
args: [],
source: "sign\x0a\x09self isZero \x0a\x09\x09ifTrue: [ ^ 0 ].\x0a\x09self positive\x0a\x09\x09ifTrue: [ ^ 1 ]\x0a\x09\x09ifFalse: [ ^ -1 ].",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "isZero", "ifTrue:ifFalse:", "positive"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isZero())){
return (0);
}
if($core.assert($self._positive())){
return (1);
} else {
return (-1);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"sign",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "sin",
protocol: "mathematical functions",
args: [],
source: "sin\x0a\x09<inlineJS: 'return Math.sin(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.sin(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.sin(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"sin",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "sqrt",
protocol: "mathematical functions",
args: [],
source: "sqrt\x0a\x09<inlineJS: 'return Math.sqrt(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.sqrt(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.sqrt(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"sqrt",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "squared",
protocol: "mathematical functions",
args: [],
source: "squared\x0a\x09^ self * self",
referencedClasses: [],
pragmas: [],
messageSends: ["*"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__star(self);
}, function($ctx1) {$ctx1.fill(self,"squared",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "tan",
protocol: "mathematical functions",
args: [],
source: "tan\x0a\x09<inlineJS: 'return Math.tan(self);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.tan(self);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.tan(self);;
return self;
}, function($ctx1) {$ctx1.fill(self,"tan",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "timesRepeat:",
protocol: "enumerating",
args: ["aBlock"],
source: "timesRepeat: aBlock\x0a\x09| count |\x0a\x09count := 1.\x0a\x09[ count > self ] whileFalse: [\x0a\x09\x09aBlock value.\x0a\x09\x09count := count + 1 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", ">", "value", "+"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var count;
return $core.withContext(function($ctx1) {
count=(1);
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(count).__gt(self);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value();
count=$recv(count).__plus((1));
return count;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"timesRepeat:",{aBlock:aBlock,count:count})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "timesSelfToNumber:",
protocol: "arithmetic",
args: ["aNumber"],
source: "timesSelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber * self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber * self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber * self;
return self;
}, function($ctx1) {$ctx1.fill(self,"timesSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:",
protocol: "converting",
args: ["aNumber"],
source: "to: aNumber\x0a\x09| array first last count |\x0a\x09first := self truncated.\x0a\x09last := aNumber truncated + 1.\x0a\x09count := 1.\x0a\x09array := Array new.\x0a\x09(last - first) timesRepeat: [\x0a\x09\x09array at: count put: first.\x0a\x09\x09count := count + 1.\x0a\x09\x09first := first + 1 ].\x0a\x09^ array",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["truncated", "+", "new", "timesRepeat:", "-", "at:put:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
var array,first,last,count;
return $core.withContext(function($ctx1) {
first=[$self._truncated()
,$ctx1.sendIdx["truncated"]=1
][0];
last=[$recv($recv(aNumber)._truncated()).__plus((1))
,$ctx1.sendIdx["+"]=1
][0];
count=(1);
array=$recv($globals.Array)._new();
$recv($recv(last).__minus(first))._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
$recv(array)._at_put_(count,first);
count=[$recv(count).__plus((1))
,$ctx2.sendIdx["+"]=2
][0];
first=$recv(first).__plus((1));
return first;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return array;
}, function($ctx1) {$ctx1.fill(self,"to:",{aNumber:aNumber,array:array,first:first,last:last,count:count})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:by:",
protocol: "converting",
args: ["stop", "step"],
source: "to: stop by: step\x0a\x09| array value pos |\x0a\x09value := self.\x0a\x09array := Array new.\x0a\x09pos := 1.\x0a\x09step = 0 ifTrue: [ self error: 'step must be non-zero' ].\x0a\x09step < 0\x0a\x09\x09ifTrue: [ [ value >= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09array at: pos put: value.\x0a\x09\x09\x09\x09\x09pos := pos + 1.\x0a\x09\x09\x09\x09\x09value := value + step ]]\x0a\x09\x09ifFalse: [ [ value <= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09array at: pos put: value.\x0a\x09\x09\x09\x09pos := pos + 1.\x0a\x09\x09\x09\x09\x09value := value + step ]].\x0a\x09^ array",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["new", "ifTrue:", "=", "error:", "ifTrue:ifFalse:", "<", "whileTrue:", ">=", "at:put:", "+", "<="]
}, function ($methodClass){ return function (stop,step){
var self=this,$self=this;
var array,value,pos;
return $core.withContext(function($ctx1) {
value=self;
array=$recv($globals.Array)._new();
pos=(1);
if($core.assert($recv(step).__eq((0)))){
$self._error_("step must be non-zero");
}
if($core.assert($recv(step).__lt((0)))){
[$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__gt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
[$recv(array)._at_put_(pos,value)
,$ctx2.sendIdx["at:put:"]=1
][0];
pos=[$recv(pos).__plus((1))
,$ctx2.sendIdx["+"]=1
][0];
value=[$recv(value).__plus(step)
,$ctx2.sendIdx["+"]=2
][0];
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}))
,$ctx1.sendIdx["whileTrue:"]=1
][0];
} else {
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__lt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(array)._at_put_(pos,value);
pos=[$recv(pos).__plus((1))
,$ctx2.sendIdx["+"]=3
][0];
value=$recv(value).__plus(step);
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}));
}
return array;
}, function($ctx1) {$ctx1.fill(self,"to:by:",{stop:stop,step:step,array:array,value:value,pos:pos})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:by:do:",
protocol: "enumerating",
args: ["stop", "step", "aBlock"],
source: "to: stop by: step do: aBlock\x0a\x09| value |\x0a\x09value := self.\x0a\x09step = 0 ifTrue: [ self error: 'step must be non-zero' ].\x0a\x09step < 0\x0a\x09\x09ifTrue: [ [ value >= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09aBlock value: value.\x0a\x09\x09\x09\x09\x09value := value + step ]]\x0a\x09\x09ifFalse: [ [ value <= stop ] whileTrue: [\x0a\x09\x09\x09\x09\x09aBlock value: value.\x0a\x09\x09\x09\x09\x09value := value + step ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "=", "error:", "ifTrue:ifFalse:", "<", "whileTrue:", ">=", "value:", "+", "<="]
}, function ($methodClass){ return function (stop,step,aBlock){
var self=this,$self=this;
var value;
return $core.withContext(function($ctx1) {
value=self;
if($core.assert($recv(step).__eq((0)))){
$self._error_("step must be non-zero");
}
if($core.assert($recv(step).__lt((0)))){
[$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__gt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
[$recv(aBlock)._value_(value)
,$ctx2.sendIdx["value:"]=1
][0];
value=[$recv(value).__plus(step)
,$ctx2.sendIdx["+"]=1
][0];
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}))
,$ctx1.sendIdx["whileTrue:"]=1
][0];
} else {
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(value).__lt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value_(value);
value=$recv(value).__plus(step);
return value;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}));
}
return self;
}, function($ctx1) {$ctx1.fill(self,"to:by:do:",{stop:stop,step:step,aBlock:aBlock,value:value})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "to:do:",
protocol: "enumerating",
args: ["stop", "aBlock"],
source: "to: stop do: aBlock\x0a\x09\x22Evaluate aBlock for each number from self to aNumber.\x22\x0a\x09| nextValue |\x0a\x09nextValue := self.\x0a\x09[ nextValue <= stop ]\x0a\x09\x09whileTrue:\x0a\x09\x09\x09[ aBlock value: nextValue.\x0a\x09\x09\x09nextValue := nextValue + 1 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["whileTrue:", "<=", "value:", "+"]
}, function ($methodClass){ return function (stop,aBlock){
var self=this,$self=this;
var nextValue;
return $core.withContext(function($ctx1) {
nextValue=self;
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(nextValue).__lt_eq(stop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value_(nextValue);
nextValue=$recv(nextValue).__plus((1));
return nextValue;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"to:do:",{stop:stop,aBlock:aBlock,nextValue:nextValue})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "truncated",
protocol: "converting",
args: [],
source: "truncated\x0a\x09<inlineJS: '\x0a\x09\x09if(self >= 0) {\x0a\x09\x09\x09return Math.floor(self);\x0a\x09\x09} else {\x0a\x09\x09\x09return Math.floor(self * (-1)) * (-1);\x0a\x09\x09};\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if(self >= 0) {\x0a\x09\x09\x09return Math.floor(self);\x0a\x09\x09} else {\x0a\x09\x09\x09return Math.floor(self * (-1)) * (-1);\x0a\x09\x09};\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if(self >= 0) {
			return Math.floor(self);
		} else {
			return Math.floor(self * (-1)) * (-1);
		};
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"truncated",{})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "xorSelfToNumber:",
protocol: "converting",
args: ["aNumber"],
source: "xorSelfToNumber: aNumber\x0a\x09<inlineJS: 'return aNumber ^ self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aNumber ^ self"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aNumber ^ self;
return self;
}, function($ctx1) {$ctx1.fill(self,"xorSelfToNumber:",{aNumber:aNumber})});
}; }),
$globals.Number);

$core.addMethod(
$core.method({
selector: "|",
protocol: "converting",
args: ["aNumber"],
source: "| aNumber\x0a\x09^ self bitOr: aNumber",
referencedClasses: [],
pragmas: [],
messageSends: ["bitOr:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._bitOr_(aNumber);
}, function($ctx1) {$ctx1.fill(self,"|",{aNumber:aNumber})});
}; }),
$globals.Number);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'magnitude'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "magnitude";

}; }),
$globals.Number.a$cls);

$core.addMethod(
$core.method({
selector: "e",
protocol: "instance creation",
args: [],
source: "e\x0a\x09<inlineJS: 'return Math.E;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.E;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.E;;
return self;
}, function($ctx1) {$ctx1.fill(self,"e",{})});
}; }),
$globals.Number.a$cls);

$core.addMethod(
$core.method({
selector: "negativeInfinity",
protocol: "instance creation",
args: [],
source: "negativeInfinity\x0a\x09<inlineJS: 'return Number.NEGATIVE_INFINITY'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Number.NEGATIVE_INFINITY"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Number.NEGATIVE_INFINITY;
return self;
}, function($ctx1) {$ctx1.fill(self,"negativeInfinity",{})});
}; }),
$globals.Number.a$cls);

$core.addMethod(
$core.method({
selector: "pi",
protocol: "instance creation",
args: [],
source: "pi\x0a\x09<inlineJS: 'return Math.PI'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.PI"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.PI;
return self;
}, function($ctx1) {$ctx1.fill(self,"pi",{})});
}; }),
$globals.Number.a$cls);

$core.addMethod(
$core.method({
selector: "positiveInfinity",
protocol: "instance creation",
args: [],
source: "positiveInfinity\x0a\x09<inlineJS: 'return Number.POSITIVE_INFINITY'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Number.POSITIVE_INFINITY"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Number.POSITIVE_INFINITY;
return self;
}, function($ctx1) {$ctx1.fill(self,"positiveInfinity",{})});
}; }),
$globals.Number.a$cls);

$core.addMethod(
$core.method({
selector: "radiansPerDegree",
protocol: "instance creation",
args: [],
source: "radiansPerDegree\x0a\x09^ (self pi) / 180",
referencedClasses: [],
pragmas: [],
messageSends: ["/", "pi"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._pi()).__slash((180));
}, function($ctx1) {$ctx1.fill(self,"radiansPerDegree",{})});
}; }),
$globals.Number.a$cls);


$core.addClass("Point", $globals.Object, "Kernel-Objects");
$core.setSlots($globals.Point, ["x", "y"]);
$globals.Point.comment="I represent an x-y pair of numbers usually designating a geometric coordinate.\x0a\x0a## API\x0a\x0aInstances are traditionally created using the binary `#@` message to a number:\x0a\x0a\x09100@120\x0a\x0aPoints can then be arithmetically manipulated:\x0a\x0a\x09100@100 + (10@10)\x0a\x0a...or for example:\x0a\x0a\x09(100@100) * 2\x0a\x0a**NOTE:** Creating a point with a negative y-value will need a space after `@` in order to avoid a parsing error:\x0a\x0a\x09100@ -100 \x22but 100@-100 would not parse\x22";
$core.addMethod(
$core.method({
selector: "*",
protocol: "arithmetic",
args: ["aPoint"],
source: "* aPoint\x0a\x09^ Point x: self x * aPoint asPoint x y: self y * aPoint asPoint y",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["x:y:", "*", "x", "asPoint", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__star($recv([$recv(aPoint)._asPoint()
,$ctx1.sendIdx["asPoint"]=1
][0])._x())
,$ctx1.sendIdx["*"]=1
][0],$recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__star($recv($recv(aPoint)._asPoint())._y()));
}, function($ctx1) {$ctx1.fill(self,"*",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "+",
protocol: "arithmetic",
args: ["aPoint"],
source: "+ aPoint\x0a\x09^ Point x: self x + aPoint asPoint x y: self y + aPoint asPoint y",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["x:y:", "+", "x", "asPoint", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__plus($recv([$recv(aPoint)._asPoint()
,$ctx1.sendIdx["asPoint"]=1
][0])._x())
,$ctx1.sendIdx["+"]=1
][0],$recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__plus($recv($recv(aPoint)._asPoint())._y()));
}, function($ctx1) {$ctx1.fill(self,"+",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "-",
protocol: "arithmetic",
args: ["aPoint"],
source: "- aPoint\x0a\x09^ Point x: self x - aPoint asPoint x y: self y - aPoint asPoint y",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["x:y:", "-", "x", "asPoint", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__minus($recv([$recv(aPoint)._asPoint()
,$ctx1.sendIdx["asPoint"]=1
][0])._x())
,$ctx1.sendIdx["-"]=1
][0],$recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__minus($recv($recv(aPoint)._asPoint())._y()));
}, function($ctx1) {$ctx1.fill(self,"-",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "/",
protocol: "arithmetic",
args: ["aPoint"],
source: "/ aPoint\x0a\x09^ Point x: self x / aPoint asPoint x y: self y / aPoint asPoint y",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["x:y:", "/", "x", "asPoint", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Point)._x_y_([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__slash($recv([$recv(aPoint)._asPoint()
,$ctx1.sendIdx["asPoint"]=1
][0])._x())
,$ctx1.sendIdx["/"]=1
][0],$recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__slash($recv($recv(aPoint)._asPoint())._y()));
}, function($ctx1) {$ctx1.fill(self,"/",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "<",
protocol: "comparing",
args: ["aPoint"],
source: "< aPoint\x0a\x09^ self x < aPoint x and: [\x0a\x09\x09self y < aPoint y ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "<", "x", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__lt($recv(aPoint)._x())
,$ctx1.sendIdx["<"]=1
][0])){
return $recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__lt($recv(aPoint)._y());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"<",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "<=",
protocol: "comparing",
args: ["aPoint"],
source: "<= aPoint\x0a\x09^ self x <= aPoint x and: [\x0a\x09\x09self y <= aPoint y ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "<=", "x", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__lt_eq($recv(aPoint)._x())
,$ctx1.sendIdx["<="]=1
][0])){
return $recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__lt_eq($recv(aPoint)._y());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"<=",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["aPoint"],
source: "= aPoint\x0a\x09^ aPoint class = self class and: [\x0a\x09\x09(aPoint x = self x) & (aPoint y = self y) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "=", "class", "&", "x", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$recv(aPoint)._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq($self._class())
,$ctx1.sendIdx["="]=1
][0])){
return $recv([$recv([$recv(aPoint)._x()
,$ctx1.sendIdx["x"]=1
][0]).__eq($self._x())
,$ctx1.sendIdx["="]=2
][0]).__and($recv([$recv(aPoint)._y()
,$ctx1.sendIdx["y"]=1
][0]).__eq($self._y()));
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: ">",
protocol: "comparing",
args: ["aPoint"],
source: "> aPoint\x0a\x09^ self x > aPoint x and: [\x0a\x09\x09self y > aPoint y ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", ">", "x", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__gt($recv(aPoint)._x())
,$ctx1.sendIdx[">"]=1
][0])){
return $recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__gt($recv(aPoint)._y());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,">",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: ">=",
protocol: "comparing",
args: ["aPoint"],
source: ">= aPoint\x0a\x09^ self x >= aPoint x and: [\x0a\x09\x09self y >= aPoint y ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", ">=", "x", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._x()
,$ctx1.sendIdx["x"]=1
][0]).__gt_eq($recv(aPoint)._x())
,$ctx1.sendIdx[">="]=1
][0])){
return $recv([$self._y()
,$ctx1.sendIdx["y"]=1
][0]).__gt_eq($recv(aPoint)._y());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,">=",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "angle",
protocol: "geometry",
args: [],
source: "angle\x0a\x09^ self y arcTan: self x",
referencedClasses: [],
pragmas: [],
messageSends: ["arcTan:", "y", "x"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._y())._arcTan_($self._x());
}, function($ctx1) {$ctx1.fill(self,"angle",{})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "asPoint",
protocol: "converting",
args: [],
source: "asPoint\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "corner:",
protocol: "rectangle creation",
args: ["aPoint"],
source: "corner: aPoint\x0a\x09^ Rectangle origin: self corner: aPoint",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["origin:corner:"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Rectangle)._origin_corner_(self,aPoint);
}, function($ctx1) {$ctx1.fill(self,"corner:",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "dist:",
protocol: "transforming",
args: ["aPoint"],
source: "dist: aPoint \x0a\x09\x22Answer the distance between aPoint and the receiver.\x22\x0a\x09| dx dy |\x0a\x09dx := aPoint x - x.\x0a\x09dy := aPoint y - y.\x0a\x09^ (dx * dx + (dy * dy)) sqrt",
referencedClasses: [],
pragmas: [],
messageSends: ["-", "x", "y", "sqrt", "+", "*"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
var dx,dy;
return $core.withContext(function($ctx1) {
dx=[$recv($recv(aPoint)._x()).__minus($self.x)
,$ctx1.sendIdx["-"]=1
][0];
dy=$recv($recv(aPoint)._y()).__minus($self.y);
return $recv($recv([$recv(dx).__star(dx)
,$ctx1.sendIdx["*"]=1
][0]).__plus($recv(dy).__star(dy)))._sqrt();
}, function($ctx1) {$ctx1.fill(self,"dist:",{aPoint:aPoint,dx:dx,dy:dy})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "dotProduct:",
protocol: "point functions",
args: ["aPoint"],
source: "dotProduct: aPoint\x0a\x09^ (x * aPoint x) + (y * aPoint y)",
referencedClasses: [],
pragmas: [],
messageSends: ["+", "*", "x", "y"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$recv($self.x).__star($recv(aPoint)._x())
,$ctx1.sendIdx["*"]=1
][0]).__plus($recv($self.y).__star($recv(aPoint)._y()));
}, function($ctx1) {$ctx1.fill(self,"dotProduct:",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "extent:",
protocol: "rectangle creation",
args: ["aPoint"],
source: "extent: aPoint\x0a\x09^ Rectangle origin: self extent: aPoint",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["origin:extent:"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Rectangle)._origin_extent_(self,aPoint);
}, function($ctx1) {$ctx1.fill(self,"extent:",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "normal",
protocol: "point functions",
args: [],
source: "normal\x0a\x09\x22Answer a Point representing the unit vector rotated 90 deg clockwise. For the zero point return -1@0.\x22\x0a\x0a\x09| n d |\x0a\x09n := y negated @ x.\x0a\x09(d := (n x * n x + (n y * n y))) = 0\x0a\x09\x09 ifTrue: [ ^ -1 @0 ].\x0a\x09^ n / d sqrt",
referencedClasses: [],
pragmas: [],
messageSends: ["@", "negated", "ifTrue:", "=", "+", "*", "x", "y", "/", "sqrt"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var n,d;
return $core.withContext(function($ctx1) {
n=[$recv($recv($self.y)._negated()).__at($self.x)
,$ctx1.sendIdx["@"]=1
][0];
d=$recv([$recv([$recv(n)._x()
,$ctx1.sendIdx["x"]=1
][0]).__star($recv(n)._x())
,$ctx1.sendIdx["*"]=1
][0]).__plus($recv([$recv(n)._y()
,$ctx1.sendIdx["y"]=1
][0]).__star($recv(n)._y()));
if($core.assert($recv(d).__eq((0)))){
return (-1).__at((0));
}
return $recv(n).__slash($recv(d)._sqrt());
}, function($ctx1) {$ctx1.fill(self,"normal",{n:n,d:d})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "normalized",
protocol: "point functions",
args: [],
source: "normalized\x0a\x09| r |\x0a\x09r := self r.\x0a\x09\x0a\x09r = 0\x0a\x09\x09ifTrue: [ ^ Point x: 0 y: 0 ]\x0a\x09\x09ifFalse: [ ^ Point x: x / r y: y / r ]",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["r", "ifTrue:ifFalse:", "=", "x:y:", "/"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var r;
return $core.withContext(function($ctx1) {
r=$self._r();
if($core.assert($recv(r).__eq((0)))){
return [$recv($globals.Point)._x_y_((0),(0))
,$ctx1.sendIdx["x:y:"]=1
][0];
} else {
return $recv($globals.Point)._x_y_([$recv($self.x).__slash(r)
,$ctx1.sendIdx["/"]=1
][0],$recv($self.y).__slash(r));
}
return self;
}, function($ctx1) {$ctx1.fill(self,"normalized",{r:r})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09\x22Print receiver in classic x@y notation.\x22\x0a\x0a\x09x printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: '@'.\x0a\x09(y notNil and: [ y negative ]) ifTrue: [\x0a\x09\x09\x09\x22Avoid ambiguous @- construct\x22\x0a\x09\x09\x09aStream space ].\x0a\x09\x0a\x09y printOn: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "ifTrue:", "and:", "notNil", "negative", "space"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
[$recv($self.x)._printOn_(aStream)
,$ctx1.sendIdx["printOn:"]=1
][0];
$recv(aStream)._nextPutAll_("@");
if($core.assert($recv($self.y)._notNil())){
$1=$recv($self.y)._negative();
} else {
$1=false;
}
if($core.assert($1)){
$recv(aStream)._space();
}
$recv($self.y)._printOn_(aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "r",
protocol: "polar coordinates",
args: [],
source: "r\x0a\x09^ ((x * x) + (y * y)) sqrt",
referencedClasses: [],
pragmas: [],
messageSends: ["sqrt", "+", "*"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv([$recv($self.x).__star($self.x)
,$ctx1.sendIdx["*"]=1
][0]).__plus($recv($self.y).__star($self.y)))._sqrt();
}, function($ctx1) {$ctx1.fill(self,"r",{})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "rectangle:",
protocol: "rectangle creation",
args: ["aPoint"],
source: "rectangle: aPoint\x0a\x09^ Rectangle point: self point: aPoint",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["point:point:"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Rectangle)._point_point_(self,aPoint);
}, function($ctx1) {$ctx1.fill(self,"rectangle:",{aPoint:aPoint})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "translateBy:",
protocol: "transforming",
args: ["delta"],
source: "translateBy: delta\x0a\x09\x22Answer a Point translated by delta (an instance of Point).\x22\x0a\x09^ (delta x + x) @ (delta y + y)",
referencedClasses: [],
pragmas: [],
messageSends: ["@", "+", "x", "y"]
}, function ($methodClass){ return function (delta){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$recv($recv(delta)._x()).__plus($self.x)
,$ctx1.sendIdx["+"]=1
][0]).__at($recv($recv(delta)._y()).__plus($self.y));
}, function($ctx1) {$ctx1.fill(self,"translateBy:",{delta:delta})});
}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "x",
protocol: "accessing",
args: [],
source: "x\x0a\x09^ x",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.x;

}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "x:",
protocol: "accessing",
args: ["aNumber"],
source: "x: aNumber\x0a\x09x := aNumber",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
$self.x=aNumber;
return self;

}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "y",
protocol: "accessing",
args: [],
source: "y\x0a\x09^ y",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.y;

}; }),
$globals.Point);

$core.addMethod(
$core.method({
selector: "y:",
protocol: "accessing",
args: ["aNumber"],
source: "y: aNumber\x0a\x09y := aNumber",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
$self.y=aNumber;
return self;

}; }),
$globals.Point);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'magnitude'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "magnitude";

}; }),
$globals.Point.a$cls);

$core.addMethod(
$core.method({
selector: "x:y:",
protocol: "instance creation",
args: ["aNumber", "anotherNumber"],
source: "x: aNumber y: anotherNumber\x0a\x09^ self new\x0a\x09\x09x: aNumber;\x0a\x09\x09y: anotherNumber;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["x:", "new", "y:", "yourself"]
}, function ($methodClass){ return function (aNumber,anotherNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._x_(aNumber);
$recv($1)._y_(anotherNumber);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"x:y:",{aNumber:aNumber,anotherNumber:anotherNumber})});
}; }),
$globals.Point.a$cls);


$core.addClass("Random", $globals.Object, "Kernel-Objects");
$globals.Random.comment="I an used to generate a random number and I am implemented as a trivial wrapper around javascript `Math.random()`.\x0a\x0a## API\x0a\x0aThe typical use case it to use the `#next` method like the following:\x0a\x0a\x09Random new next\x0a\x0aThis will return a float x where x < 1 and x > 0. If you want a random integer from 1 to 10 you can use `#atRandom`\x0a\x0a\x0910 atRandom\x0a\x0aA random number in a specific interval can be obtained with the following:\x0a\x0a\x09(3 to: 7) atRandom\x0a\x0aBe aware that `#to:` does not create an Interval as in other Smalltalk implementations but in fact an `Array` of numbers, so it's better to use:\x0a\x0a\x095 atRandom + 2\x0a\x0aSince `#atRandom` is implemented in `SequencableCollection` you can easy pick an element at random:\x0a\x0a\x09#('a' 'b' 'c') atRandom\x0a\x0aAs well as letter from a `String`:\x0a\x0a\x09'abc' atRandom\x0a\x0aSince Amber does not have Characters this will return a `String` of length 1 like for example `'b'`.";
$core.addMethod(
$core.method({
selector: "next",
protocol: "accessing",
args: [],
source: "next\x0a\x09<inlineJS: 'return Math.random()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Math.random()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Math.random();
return self;
}, function($ctx1) {$ctx1.fill(self,"next",{})});
}; }),
$globals.Random);

$core.addMethod(
$core.method({
selector: "next:",
protocol: "accessing",
args: ["anInteger"],
source: "next: anInteger\x0a\x09^ (1 to: anInteger) collect: [ :each | self next ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "to:", "next"]
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv((1)._to_(anInteger))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $self._next();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"next:",{anInteger:anInteger})});
}; }),
$globals.Random);



$core.addClass("Rectangle", $globals.Object, "Kernel-Objects");
$core.setSlots($globals.Rectangle, ["origin", "corner"]);
$globals.Rectangle.comment="I represent a Rectangle defined by my two corners.\x0a\x0aThe simplest way to create an instance is using Point methods:\x0a\x0a    1@1 corner: 2@2\x0a\x0aWIll create a rectangle with 1@1 as the top left and 2@2 at the bottom right.\x0a\x0a    1@1 extent: 1@1\x0a\x0aWill create the same rectangle, defining an origin and a size instead of an origin and a corner.";
$core.addMethod(
$core.method({
selector: "=",
protocol: "testing",
args: ["aRectangle"],
source: "= aRectangle\x0a\x09^ origin = aRectangle origin and: [ corner = aRectangle corner ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "=", "origin", "corner"]
}, function ($methodClass){ return function (aRectangle){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv($self.origin).__eq($recv(aRectangle)._origin())
,$ctx1.sendIdx["="]=1
][0])){
return $recv($self.corner).__eq($recv(aRectangle)._corner());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{aRectangle:aRectangle})});
}; }),
$globals.Rectangle);

$core.addMethod(
$core.method({
selector: "containsPoint:",
protocol: "testing",
args: ["aPoint"],
source: "containsPoint: aPoint\x0a\x09^ origin <= aPoint and: [ corner >= aPoint ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "<=", ">="]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self.origin).__lt_eq(aPoint))){
return $recv($self.corner).__gt_eq(aPoint);
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"containsPoint:",{aPoint:aPoint})});
}; }),
$globals.Rectangle);

$core.addMethod(
$core.method({
selector: "containsRect:",
protocol: "testing",
args: ["aRect"],
source: "containsRect: aRect\x0a\x09^ aRect origin >= origin and: [ aRect corner <= corner ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", ">=", "origin", "<=", "corner"]
}, function ($methodClass){ return function (aRect){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv(aRect)._origin()).__gt_eq($self.origin))){
return $recv($recv(aRect)._corner()).__lt_eq($self.corner);
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"containsRect:",{aRect:aRect})});
}; }),
$globals.Rectangle);

$core.addMethod(
$core.method({
selector: "corner",
protocol: "accessing",
args: [],
source: "corner\x0a\x09^ corner",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.corner;

}; }),
$globals.Rectangle);

$core.addMethod(
$core.method({
selector: "origin",
protocol: "accessing",
args: [],
source: "origin\x0a\x09^ origin",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.origin;

}; }),
$globals.Rectangle);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "testing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09origin printOn: aStream.\x0a\x09aStream nextPutAll: ' corner: '.\x0a\x09corner printOn: aStream.",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv($self.origin)._printOn_(aStream)
,$ctx1.sendIdx["printOn:"]=1
][0];
$recv(aStream)._nextPutAll_(" corner: ");
$recv($self.corner)._printOn_(aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Rectangle);

$core.addMethod(
$core.method({
selector: "setPoint:point:",
protocol: "private",
args: ["pt1", "pt2"],
source: "setPoint: pt1 point: pt2\x0a\x0a\x09origin := (pt1 x min: pt2 x)@(pt1 y min: pt2 y).\x0a\x09corner := (pt1 x max: pt2 x)@(pt1 y max: pt2 y).",
referencedClasses: [],
pragmas: [],
messageSends: ["@", "min:", "x", "y", "max:"]
}, function ($methodClass){ return function (pt1,pt2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.origin=[$recv([$recv([$recv(pt1)._x()
,$ctx1.sendIdx["x"]=1
][0])._min_([$recv(pt2)._x()
,$ctx1.sendIdx["x"]=2
][0])
,$ctx1.sendIdx["min:"]=1
][0]).__at($recv([$recv(pt1)._y()
,$ctx1.sendIdx["y"]=1
][0])._min_([$recv(pt2)._y()
,$ctx1.sendIdx["y"]=2
][0]))
,$ctx1.sendIdx["@"]=1
][0];
$self.corner=$recv([$recv([$recv(pt1)._x()
,$ctx1.sendIdx["x"]=3
][0])._max_($recv(pt2)._x())
,$ctx1.sendIdx["max:"]=1
][0]).__at($recv([$recv(pt1)._y()
,$ctx1.sendIdx["y"]=3
][0])._max_($recv(pt2)._y()));
return self;
}, function($ctx1) {$ctx1.fill(self,"setPoint:point:",{pt1:pt1,pt2:pt2})});
}; }),
$globals.Rectangle);


$core.addMethod(
$core.method({
selector: "origin:corner:",
protocol: "instance creation",
args: ["anOrigin", "aCorner"],
source: "origin: anOrigin corner: aCorner\x0a\x09^ self basicNew setPoint: anOrigin point: aCorner.",
referencedClasses: [],
pragmas: [],
messageSends: ["setPoint:point:", "basicNew"]
}, function ($methodClass){ return function (anOrigin,aCorner){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._basicNew())._setPoint_point_(anOrigin,aCorner);
}, function($ctx1) {$ctx1.fill(self,"origin:corner:",{anOrigin:anOrigin,aCorner:aCorner})});
}; }),
$globals.Rectangle.a$cls);

$core.addMethod(
$core.method({
selector: "origin:extent:",
protocol: "instance creation",
args: ["anOrigin", "anExtent"],
source: "origin: anOrigin extent: anExtent\x0a\x09^ self basicNew setPoint: anOrigin point: anOrigin + anExtent.",
referencedClasses: [],
pragmas: [],
messageSends: ["setPoint:point:", "basicNew", "+"]
}, function ($methodClass){ return function (anOrigin,anExtent){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._basicNew())._setPoint_point_(anOrigin,$recv(anOrigin).__plus(anExtent));
}, function($ctx1) {$ctx1.fill(self,"origin:extent:",{anOrigin:anOrigin,anExtent:anExtent})});
}; }),
$globals.Rectangle.a$cls);

$core.addMethod(
$core.method({
selector: "point:point:",
protocol: "instance creation",
args: ["anOrigin", "aCorner"],
source: "point: anOrigin point: aCorner\x0a\x09^ self basicNew setPoint: anOrigin point: aCorner.",
referencedClasses: [],
pragmas: [],
messageSends: ["setPoint:point:", "basicNew"]
}, function ($methodClass){ return function (anOrigin,aCorner){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._basicNew())._setPoint_point_(anOrigin,aCorner);
}, function($ctx1) {$ctx1.fill(self,"point:point:",{anOrigin:anOrigin,aCorner:aCorner})});
}; }),
$globals.Rectangle.a$cls);


$core.addClass("UndefinedObject", $globals.Object, "Kernel-Objects");
$globals.UndefinedObject.comment="I describe the behavior of my sole instance, `nil`. `nil` represents a prior value for variables that have not been initialized, or for results which are meaningless.\x0a\x0a`nil` is the Smalltalk equivalent of the `undefined` JavaScript object.\x0a\x0a__note:__ When sending messages to the `undefined` JavaScript object, it will be replaced by `nil`.";
$core.addMethod(
$core.method({
selector: "==",
protocol: "testing",
args: ["anObject"],
source: "== anObject\x0a\x09^ anObject isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["isNil"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._isNil();
}, function($ctx1) {$ctx1.fill(self,"==",{anObject:anObject})});
}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ null",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return null;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ 'null'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "null";

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "identityHash",
protocol: "accessing",
args: [],
source: "identityHash\x0a\x09^ 'NIL'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "NIL";

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNil:",
protocol: "testing",
args: ["aBlock"],
source: "ifNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self ifNil: aBlock ifNotNil: []",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ifNil_ifNotNil_(aBlock,(function(){

}));
}, function($ctx1) {$ctx1.fill(self,"ifNil:",{aBlock:aBlock})});
}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNil:ifNotNil:",
protocol: "testing",
args: ["aBlock", "anotherBlock"],
source: "ifNil: aBlock ifNotNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ aBlock value",
referencedClasses: [],
pragmas: [],
messageSends: ["value"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._value();
}, function($ctx1) {$ctx1.fill(self,"ifNil:ifNotNil:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:",
protocol: "testing",
args: ["aBlock"],
source: "ifNotNil: aBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return self;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "ifNotNil:ifNil:",
protocol: "testing",
args: ["aBlock", "anotherBlock"],
source: "ifNotNil: aBlock ifNil: anotherBlock\x0a\x09\x22inlined in the Compiler\x22\x0a\x09^ anotherBlock value",
referencedClasses: [],
pragmas: [],
messageSends: ["value"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anotherBlock)._value();
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:ifNil:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "isNil",
protocol: "testing",
args: [],
source: "isNil\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "notNil",
protocol: "testing",
args: [],
source: "notNil\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: 'nil'",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.UndefinedObject);

$core.addMethod(
$core.method({
selector: "value",
protocol: "evaluating",
args: [],
source: "value\x0a\x09<inlineJS: 'return null'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return null"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return null;
return self;
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.UndefinedObject);


$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09\x09self error: 'You cannot create new instances of UndefinedObject. Use nil'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("You cannot create new instances of UndefinedObject. Use nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.UndefinedObject.a$cls);

$core.setTraitComposition([{trait: $globals.TIsInGroup}], $globals.Object);
$core.setTraitComposition([{trait: $globals.TSubclassable}], $globals.UndefinedObject);

});

define('amber/core/Kernel-Collections',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Collections");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("Association", $globals.Object, "Kernel-Collections");
$core.setSlots($globals.Association, ["key", "value"]);
$globals.Association.comment="I represent a pair of associated objects, a key and a value. My instances can serve as entries in a dictionary.\x0a\x0aInstances can be created with the class-side method `#key:value:`";
$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["anAssociation"],
source: "= anAssociation\x0a\x09^ self class = anAssociation class and: [\x0a\x09\x09self key = anAssociation key and: [\x0a\x09\x09self value = anAssociation value ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "=", "class", "key", "value"]
}, function ($methodClass){ return function (anAssociation){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq($recv(anAssociation)._class())
,$ctx1.sendIdx["="]=1
][0])){
if($core.assert([$recv([$self._key()
,$ctx1.sendIdx["key"]=1
][0]).__eq($recv(anAssociation)._key())
,$ctx1.sendIdx["="]=2
][0])){
return $recv([$self._value()
,$ctx1.sendIdx["value"]=1
][0]).__eq($recv(anAssociation)._value());
} else {
return false;
}
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{anAssociation:anAssociation})});
}; }),
$globals.Association);

$core.addMethod(
$core.method({
selector: "key",
protocol: "accessing",
args: [],
source: "key\x0a\x09^ key",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.key;

}; }),
$globals.Association);

$core.addMethod(
$core.method({
selector: "key:",
protocol: "accessing",
args: ["aKey"],
source: "key: aKey\x0a\x09key := aKey",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aKey){
var self=this,$self=this;
$self.key=aKey;
return self;

}; }),
$globals.Association);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09self key printOn: aStream.\x0a\x09aStream nextPutAll: ' -> '.\x0a\x09self value printOn: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "key", "nextPutAll:", "value"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv($self._key())._printOn_(aStream)
,$ctx1.sendIdx["printOn:"]=1
][0];
$recv(aStream)._nextPutAll_(" -> ");
$recv($self._value())._printOn_(aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Association);

$core.addMethod(
$core.method({
selector: "value",
protocol: "accessing",
args: [],
source: "value\x0a\x09^ value",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.value;

}; }),
$globals.Association);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "accessing",
args: ["aValue"],
source: "value: aValue\x0a\x09value := aValue",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aValue){
var self=this,$self=this;
$self.value=aValue;
return self;

}; }),
$globals.Association);


$core.addMethod(
$core.method({
selector: "key:value:",
protocol: "instance creation",
args: ["aKey", "aValue"],
source: "key: aKey value: aValue\x0a\x09\x09^ self new\x0a\x09\x09key: aKey;\x0a\x09\x09value: aValue;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["key:", "new", "value:", "yourself"]
}, function ($methodClass){ return function (aKey,aValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._key_(aKey);
$recv($1)._value_(aValue);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"key:value:",{aKey:aKey,aValue:aValue})});
}; }),
$globals.Association.a$cls);


$core.addClass("BucketStore", $globals.Object, "Kernel-Collections");
$core.setSlots($globals.BucketStore, ["buckets", "hashBlock"]);
$globals.BucketStore.comment="I am an helper class for hash-based stores.\x0a\x0aI hold buckets which are selected by a hash, specified using `#hashBlock:`.\x0aThe hash can be any object, and\x0ait is used as a JS property (that is, in ES5\x0aits toString() value counts).\x0a\x0a## API\x0aI maintain a list of buckets. Client code can use this API:\x0a - `#bucketOfElement:` (to ask a bucket for element, I can return JS null if n/a)\x0a - `#do:` (to enumerate all elements of all buckets)\x0a - `#removeAll` (to remove all buckets)\x0a\x0aClient code itself should add/remove elements\x0ain a bucket. The `nil` object should not be put into any bucket.\x0a\x0aTypes of buckets are the responsibility of subclasses via `#newBucket`.";
$core.addMethod(
$core.method({
selector: "bucketOfElement:",
protocol: "accessing",
args: ["anObject"],
source: "bucketOfElement: anObject\x0a\x09<inlineJS: '\x0a\x09\x09var hash = $self.hashBlock(anObject);\x0a\x09\x09if (!hash) return null;\x0a\x09\x09var buckets = $self.buckets,\x0a\x09\x09\x09bucket = buckets[hash];\x0a\x09\x09if (!bucket) { bucket = buckets[hash] = $self._newBucket(); }\x0a\x09\x09return bucket;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var hash = $self.hashBlock(anObject);\x0a\x09\x09if (!hash) return null;\x0a\x09\x09var buckets = $self.buckets,\x0a\x09\x09\x09bucket = buckets[hash];\x0a\x09\x09if (!bucket) { bucket = buckets[hash] = $self._newBucket(); }\x0a\x09\x09return bucket;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var hash = $self.hashBlock(anObject);
		if (!hash) return null;
		var buckets = $self.buckets,
			bucket = buckets[hash];
		if (!bucket) { bucket = buckets[hash] = $self._newBucket(); }
		return bucket;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"bucketOfElement:",{anObject:anObject})});
}; }),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "do:",
protocol: "enumerating",
args: ["aBlock"],
source: "do: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09var buckets = $self.buckets;\x0a\x09\x09var keys = Object.keys(buckets);\x0a\x09\x09for (var i = 0; i < keys.length; ++i) { buckets[keys[i]]._do_(aBlock); }\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var buckets = $self.buckets;\x0a\x09\x09var keys = Object.keys(buckets);\x0a\x09\x09for (var i = 0; i < keys.length; ++i) { buckets[keys[i]]._do_(aBlock); }\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var buckets = $self.buckets;
		var keys = Object.keys(buckets);
		for (var i = 0; i < keys.length; ++i) { buckets[keys[i]]._do_(aBlock); }
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock})});
}; }),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "hashBlock:",
protocol: "accessing",
args: ["aBlock"],
source: "hashBlock: aBlock\x0a\x09hashBlock := aBlock",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
$self.hashBlock=aBlock;
return self;

}; }),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09self removeAll",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "removeAll"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self._removeAll();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "newBucket",
protocol: "private",
args: [],
source: "newBucket\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"newBucket",{})});
}; }),
$globals.BucketStore);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: "adding/removing",
args: [],
source: "removeAll\x0a\x09<inlineJS: '$self.buckets = Object.create(null);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$self.buckets = Object.create(null);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.buckets = Object.create(null);;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{})});
}; }),
$globals.BucketStore);


$core.addMethod(
$core.method({
selector: "hashBlock:",
protocol: "instance creation",
args: ["aBlock"],
source: "hashBlock: aBlock\x0a\x09^ self new\x0a\x09\x09hashBlock: aBlock;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["hashBlock:", "new", "yourself"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._hashBlock_(aBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"hashBlock:",{aBlock:aBlock})});
}; }),
$globals.BucketStore.a$cls);


$core.addClass("ArrayBucketStore", $globals.BucketStore, "Kernel-Collections");
$globals.ArrayBucketStore.comment="I am a concrete `BucketStore` with buckets being instance of `Array`.";
$core.addMethod(
$core.method({
selector: "newBucket",
protocol: "private",
args: [],
source: "newBucket\x0a\x09^ #()",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [];

}; }),
$globals.ArrayBucketStore);



$core.addClass("Collection", $globals.Object, "Kernel-Collections");
$globals.Collection.comment="I am the abstract superclass of all classes that represent a group of elements.\x0a\x0aI provide a set of useful methods to the Collection hierarchy such as enumerating and converting methods.";
$core.addMethod(
$core.method({
selector: ",",
protocol: "copying",
args: ["aCollection"],
source: ", aCollection\x0a\x09^ self copy\x0a\x09\x09addAll: aCollection;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["addAll:", "copy", "yourself"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._copy();
$recv($1)._addAll_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,",",{aCollection:aCollection})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "add:",
protocol: "adding/removing",
args: ["anObject"],
source: "add: anObject\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "addAll:",
protocol: "adding/removing",
args: ["aCollection"],
source: "addAll: aCollection\x0a\x09aCollection do: [ :each |\x0a\x09\x09self add: each ].\x0a\x09^ aCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "add:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return aCollection;
}, function($ctx1) {$ctx1.fill(self,"addAll:",{aCollection:aCollection})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "allSatisfy:",
protocol: "enumerating",
args: ["aBlock"],
source: "allSatisfy: aBlock\x0a\x09\x22Evaluate aBlock with the elements of the receiver.\x0a\x09If aBlock returns false for any element return false.\x0a\x09Otherwise return true.\x22\x0a\x0a\x09self do: [ :each | (aBlock value: each) ifFalse: [ ^ false ] ].\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "ifFalse:", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if(!$core.assert($recv(aBlock)._value_(each))){
throw $early=[false];
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"allSatisfy:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "anyOne",
protocol: "accessing",
args: [],
source: "anyOne\x0a\x09\x22Answer a representative sample of the receiver. This method can\x0a\x09be helpful when needing to preinfer the nature of the contents of \x0a\x09semi-homogeneous collections.\x22\x0a\x0a\x09self ifEmpty: [ self error: 'Collection is empty' ].\x0a\x09self do: [ :each | ^ each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifEmpty:", "error:", "do:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$self._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
return $self._error_("Collection is empty");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$self._do_((function(each){
throw $early=[each];

}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"anyOne",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "anySatisfy:",
protocol: "enumerating",
args: ["aBlock"],
source: "anySatisfy: aBlock\x0a\x09\x22Evaluate aBlock with the elements of the receiver.\x0a\x09If aBlock returns true for any element return true.\x0a\x09Otherwise return false.\x22\x0a\x0a\x09self do: [ :each | (aBlock value: each) ifTrue: [ ^ true ] ].\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "ifTrue:", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(aBlock)._value_(each))){
throw $early=[true];
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return false;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"anySatisfy:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asArray",
protocol: "converting",
args: [],
source: "asArray\x0a\x09^ Array withAll: self",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["withAll:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Array)._withAll_(self);
}, function($ctx1) {$ctx1.fill(self,"asArray",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ self asArray collect: [ :each | each asJavaScriptObject ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "asArray", "asJavaScriptObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asArray())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._asJavaScriptObject();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptObject",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asOrderedCollection",
protocol: "converting",
args: [],
source: "asOrderedCollection\x0a\x09^ self asArray",
referencedClasses: [],
pragmas: [],
messageSends: ["asArray"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._asArray();
}, function($ctx1) {$ctx1.fill(self,"asOrderedCollection",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asSet",
protocol: "converting",
args: [],
source: "asSet\x0a\x09^ Set withAll: self",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["withAll:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Set)._withAll_(self);
}, function($ctx1) {$ctx1.fill(self,"asSet",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: "enumerating",
args: ["aBlock"],
source: "collect: aBlock\x0a\x09| stream |\x0a\x09stream := self class new writeStream.\x0a\x09self do: [ :each |\x0a\x09\x09stream nextPut: (aBlock value: each) ].\x0a\x09^ stream contents",
referencedClasses: [],
pragmas: [],
messageSends: ["writeStream", "new", "class", "do:", "nextPut:", "value:", "contents"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$recv($recv($self._class())._new())._writeStream();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(stream)._nextPut_($recv(aBlock)._value_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock,stream:stream})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyEmpty",
protocol: "copying",
args: [],
source: "copyEmpty\x0a\x09^ self class new",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._new();
}, function($ctx1) {$ctx1.fill(self,"copyEmpty",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWith:",
protocol: "copying",
args: ["anObject"],
source: "copyWith: anObject\x0a\x09^ self copy add: anObject; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "copy", "yourself"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._copy();
$recv($1)._add_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"copyWith:",{anObject:anObject})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWithAll:",
protocol: "copying",
args: ["aCollection"],
source: "copyWithAll: aCollection\x0a\x09self deprecatedAPI: 'Use #, instead.'.\x0a\x09^ self, aCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", ","]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #, instead.");
return $self.__comma(aCollection);
}, function($ctx1) {$ctx1.fill(self,"copyWithAll:",{aCollection:aCollection})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWithout:",
protocol: "copying",
args: ["anObject"],
source: "copyWithout: anObject\x0a\x09\x22Answer a copy of the receiver that does not contain\x0a\x09any occurrences of anObject.\x22\x0a\x0a\x09^ self reject: [ :each | each = anObject ]",
referencedClasses: [],
pragmas: [],
messageSends: ["reject:", "="]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"copyWithout:",{anObject:anObject})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "copyWithoutAll:",
protocol: "copying",
args: ["aCollection"],
source: "copyWithoutAll: aCollection\x0a\x09\x22Answer a copy of the receiver that does not contain any elements\x0a\x09equal to those in aCollection.\x22\x0a\x0a\x09^ self reject: [ :each | aCollection includes: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["reject:", "includes:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aCollection)._includes_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"copyWithoutAll:",{aCollection:aCollection})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09^ self collect: [ :each | each deepCopy ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "deepCopy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._deepCopy();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "detect:",
protocol: "enumerating",
args: ["aBlock"],
source: "detect: aBlock\x0a\x09^ self detect: aBlock ifNone: [ self errorNotFound ]",
referencedClasses: [],
pragmas: [],
messageSends: ["detect:ifNone:", "errorNotFound"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._detect_ifNone_(aBlock,(function(){
return $core.withContext(function($ctx2) {
return $self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"detect:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: "enumerating",
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09self do: [ :each | (aBlock value: each) ifTrue: [ ^each ] ].\x0a\x09^ anotherBlock value",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "ifTrue:", "value:", "value"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(aBlock)._value_(each))){
throw $early=[each];
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(anotherBlock)._value();
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "do:",
protocol: "enumerating",
args: ["aBlock"],
source: "do: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "do:separatedBy:",
protocol: "enumerating",
args: ["aBlock", "anotherBlock"],
source: "do: aBlock separatedBy: anotherBlock\x0a\x09| actionBeforeElement |\x0a\x09actionBeforeElement := [ actionBeforeElement := anotherBlock ].\x0a\x09self do: [ :each |\x0a\x09\x09actionBeforeElement value.\x0a\x09\x09aBlock value: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "value", "value:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
var actionBeforeElement;
return $core.withContext(function($ctx1) {
actionBeforeElement=(function(){
actionBeforeElement=anotherBlock;
return actionBeforeElement;

});
$self._do_((function(each){
return $core.withContext(function($ctx2) {
$recv(actionBeforeElement)._value();
return $recv(aBlock)._value_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"do:separatedBy:",{aBlock:aBlock,anotherBlock:anotherBlock,actionBeforeElement:actionBeforeElement})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "errorNotFound",
protocol: "error handling",
args: [],
source: "errorNotFound\x0a\x09self error: 'Object is not in the collection'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Object is not in the collection");
return self;
}, function($ctx1) {$ctx1.fill(self,"errorNotFound",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifEmpty:",
protocol: "testing",
args: ["aBlock"],
source: "ifEmpty: aBlock\x0a\x09\x22Evaluate the given block with the receiver as argument, answering its value if the receiver is empty, otherwise answer the receiver. \x0a\x09Note that the fact that this method returns its argument in case the receiver is not empty allows one to write expressions like the following ones: \x0a\x09\x09self classifyMethodAs:\x0a\x09\x09\x09(myProtocol ifEmpty: ['As yet unclassified'])\x22\x0a\x09^ self isEmpty\x0a\x09\x09ifTrue: \x22aBlock\x22 [ aBlock value ]\x0a\x09\x09ifFalse: [ self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isEmpty())){
return $recv(aBlock)._value();
} else {
return self;
}
}, function($ctx1) {$ctx1.fill(self,"ifEmpty:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifEmpty:ifNotEmpty:",
protocol: "testing",
args: ["aBlock", "anotherBlock"],
source: "ifEmpty: aBlock ifNotEmpty: anotherBlock\x0a\x09^ self isEmpty\x0a\x09\x09ifTrue: \x22aBlock\x22 [ aBlock value ]\x0a\x09\x09ifFalse: [ anotherBlock value: self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", "value", "value:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isEmpty())){
return $recv(aBlock)._value();
} else {
return $recv(anotherBlock)._value_(self);
}
}, function($ctx1) {$ctx1.fill(self,"ifEmpty:ifNotEmpty:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifNotEmpty:",
protocol: "testing",
args: ["aBlock"],
source: "ifNotEmpty: aBlock\x0a\x09^ self notEmpty\x0a\x09\x09ifTrue: [ aBlock value: self ]\x0a\x09\x09ifFalse: [ self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "notEmpty", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._notEmpty())){
return $recv(aBlock)._value_(self);
} else {
return self;
}
}, function($ctx1) {$ctx1.fill(self,"ifNotEmpty:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "ifNotEmpty:ifEmpty:",
protocol: "testing",
args: ["aBlock", "anotherBlock"],
source: "ifNotEmpty: aBlock ifEmpty: anotherBlock\x0a\x09^ self notEmpty\x0a\x09\x09ifTrue: [ aBlock value: self ]\x0a\x09\x09ifFalse: \x22anotherBlock\x22 [ anotherBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "notEmpty", "value:", "value"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._notEmpty())){
return $recv(aBlock)._value_(self);
} else {
return $recv(anotherBlock)._value();
}
}, function($ctx1) {$ctx1.fill(self,"ifNotEmpty:ifEmpty:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: "testing",
args: ["anObject"],
source: "includes: anObject\x0a\x09^ self anySatisfy: [ :each | each = anObject ]",
referencedClasses: [],
pragmas: [],
messageSends: ["anySatisfy:", "="]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "inject:into:",
protocol: "enumerating",
args: ["anObject", "aBlock"],
source: "inject: anObject into: aBlock\x0a\x09| result |\x0a\x09result := anObject.\x0a\x09self do: [ :each |\x0a\x09\x09result := aBlock value: result value: each ].\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "value:value:"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
result=anObject;
$self._do_((function(each){
return $core.withContext(function($ctx2) {
result=$recv(aBlock)._value_value_(result,each);
return result;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"inject:into:",{anObject:anObject,aBlock:aBlock,result:result})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "intersection:",
protocol: "enumerating",
args: ["aCollection"],
source: "intersection: aCollection\x0a\x09\x22Answer the set theoretic intersection of two collections.\x22\x0a\x0a\x09| set outputSet |\x0a\x09\x0a\x09set := self asSet.\x0a\x09outputSet := Set new.\x0a\x09\x0a\x09aCollection do: [ :each |\x0a\x09\x09((set includes: each) and: [ (outputSet includes: each) not ])\x0a\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09outputSet add: each ]].\x0a\x09\x09\x0a\x09^ self class withAll: outputSet asArray",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["asSet", "new", "do:", "ifTrue:", "and:", "includes:", "not", "add:", "withAll:", "class", "asArray"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var set,outputSet;
return $core.withContext(function($ctx1) {
var $1;
set=$self._asSet();
outputSet=$recv($globals.Set)._new();
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert([$recv(set)._includes_(each)
,$ctx2.sendIdx["includes:"]=1
][0])){
$1=$recv($recv(outputSet)._includes_(each))._not();
} else {
$1=false;
}
if($core.assert($1)){
return $recv(outputSet)._add_(each);
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv($self._class())._withAll_($recv(outputSet)._asArray());
}, function($ctx1) {$ctx1.fill(self,"intersection:",{aCollection:aCollection,set:set,outputSet:outputSet})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "isEmpty",
protocol: "testing",
args: [],
source: "isEmpty\x0a\x09^ self size = 0",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._size()).__eq((0));
}, function($ctx1) {$ctx1.fill(self,"isEmpty",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "noneSatisfy:",
protocol: "enumerating",
args: ["aBlock"],
source: "noneSatisfy: aBlock\x0a\x09\x22Evaluate aBlock with the elements of the receiver.\x0a\x09If aBlock returns false for all elements return true.\x0a\x09Otherwise return false\x22\x0a\x0a\x09self do: [ :item | (aBlock value: item) ifTrue: [ ^ false ] ].\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "ifTrue:", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$self._do_((function(item){
return $core.withContext(function($ctx2) {
if($core.assert($recv(aBlock)._value_(item))){
throw $early=[false];
}
}, function($ctx2) {$ctx2.fillBlock({item:item},$ctx1,1)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"noneSatisfy:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "notEmpty",
protocol: "testing",
args: [],
source: "notEmpty\x0a\x09^ self isEmpty not",
referencedClasses: [],
pragmas: [],
messageSends: ["not", "isEmpty"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._isEmpty())._not();
}, function($ctx1) {$ctx1.fill(self,"notEmpty",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "occurrencesOf:",
protocol: "accessing",
args: ["anObject"],
source: "occurrencesOf: anObject\x0a\x09\x22Answer how many of the receiver's elements are equal to anObject.\x22\x0a\x0a\x09| tally |\x0a\x09tally := 0.\x0a\x09self do: [ :each | anObject = each ifTrue: [ tally := tally + 1 ]].\x0a\x09^ tally",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "ifTrue:", "=", "+"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
var tally;
return $core.withContext(function($ctx1) {
tally=(0);
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(anObject).__eq(each))){
tally=$recv(tally).__plus((1));
return tally;
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return tally;
}, function($ctx1) {$ctx1.fill(self,"occurrencesOf:",{anObject:anObject,tally:tally})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: "streaming",
args: ["aStream"],
source: "putOn: aStream\x0a\x09self do: [ :each | each putOn: aStream ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "putOn:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._putOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "reject:",
protocol: "enumerating",
args: ["aBlock"],
source: "reject: aBlock\x0a\x09^ self select: [ :each | (aBlock value: each) = false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "=", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(aBlock)._value_(each)).__eq(false);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"reject:",{aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "remove:",
protocol: "adding/removing",
args: ["anObject"],
source: "remove: anObject\x0a\x09^ self remove: anObject ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:ifAbsent:", "errorNotFound"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._remove_ifAbsent_(anObject,(function(){
return $core.withContext(function($ctx2) {
return $self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"remove:",{anObject:anObject})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: "adding/removing",
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: "adding/removing",
args: [],
source: "removeAll\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "select:",
protocol: "enumerating",
args: ["aBlock"],
source: "select: aBlock\x0a\x09| stream |\x0a\x09stream := self class new writeStream.\x0a\x09self do: [ :each |\x0a\x09\x09(aBlock value: each) ifTrue: [\x0a\x09\x09stream nextPut: each ] ].\x0a\x09^ stream contents",
referencedClasses: [],
pragmas: [],
messageSends: ["writeStream", "new", "class", "do:", "ifTrue:", "value:", "nextPut:", "contents"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$recv($recv($self._class())._new())._writeStream();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(aBlock)._value_(each))){
return $recv(stream)._nextPut_(each);
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock,stream:stream})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "select:thenCollect:",
protocol: "enumerating",
args: ["selectBlock", "collectBlock"],
source: "select: selectBlock thenCollect: collectBlock\x0a\x09| stream |\x0a\x09stream := self class new writeStream.\x0a\x09self do: [ :each |\x0a\x09\x09(selectBlock value: each) ifTrue: [\x0a\x09\x09stream nextPut: (collectBlock value: each) ] ].\x0a\x09^ stream contents",
referencedClasses: [],
pragmas: [],
messageSends: ["writeStream", "new", "class", "do:", "ifTrue:", "value:", "nextPut:", "contents"]
}, function ($methodClass){ return function (selectBlock,collectBlock){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$recv($recv($self._class())._new())._writeStream();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert([$recv(selectBlock)._value_(each)
,$ctx2.sendIdx["value:"]=1
][0])){
return $recv(stream)._nextPut_($recv(collectBlock)._value_(each));
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"select:thenCollect:",{selectBlock:selectBlock,collectBlock:collectBlock,stream:stream})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09^ self collect: [ :each | each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._collect_((function(each){
return each;

}));
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "shortenedPrintString",
protocol: "printing",
args: [],
source: "shortenedPrintString\x0a\x09^ self size <= 1\x0a\x09\x09ifTrue: [ self printString ]\x0a\x09\x09ifFalse: [ (self copyEmpty copyWith: self anyOne) printString, ' ... ', (self size - 1) asString, ' more items' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "<=", "size", "printString", ",", "copyWith:", "copyEmpty", "anyOne", "asString", "-"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__lt_eq((1)))){
return [$self._printString()
,$ctx1.sendIdx["printString"]=1
][0];
} else {
return [$recv([$recv($recv($recv($recv($self._copyEmpty())._copyWith_($self._anyOne()))._printString()).__comma(" ... ")).__comma($recv($recv($self._size()).__minus((1)))._asString())
,$ctx1.sendIdx[","]=2
][0]).__comma(" more items")
,$ctx1.sendIdx[","]=1
][0];
}
}, function($ctx1) {$ctx1.fill(self,"shortenedPrintString",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "single",
protocol: "accessing",
args: [],
source: "single\x0a\x09\x22Answer a single element.\x0a\x09Raise an error if collection holds less or more than one element.\x22\x0a\x0a\x09self ifEmpty: [ self error: 'Collection is empty' ].\x0a\x09self size > 1 ifTrue: [ self error: 'Collection holds more than one element' ].\x0a\x09^ self anyOne",
referencedClasses: [],
pragmas: [],
messageSends: ["ifEmpty:", "error:", "ifTrue:", ">", "size", "anyOne"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
return [$self._error_("Collection is empty")
,$ctx2.sendIdx["error:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($recv($self._size()).__gt((1)))){
$self._error_("Collection holds more than one element");
}
return $self._anyOne();
}, function($ctx1) {$ctx1.fill(self,"single",{})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{})});
}; }),
$globals.Collection);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'collection'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "collection";

}; }),
$globals.Collection.a$cls);

$core.addMethod(
$core.method({
selector: "new:",
protocol: "instance creation",
args: ["anInteger"],
source: "new: anInteger\x0a\x09^ self new",
referencedClasses: [],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._new();
}, function($ctx1) {$ctx1.fill(self,"new:",{anInteger:anInteger})});
}; }),
$globals.Collection.a$cls);

$core.addMethod(
$core.method({
selector: "with:",
protocol: "instance creation",
args: ["anObject"],
source: "with: anObject\x0a\x09\x09^ self new\x0a\x09\x09add: anObject;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "new", "yourself"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._add_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:",{anObject:anObject})});
}; }),
$globals.Collection.a$cls);

$core.addMethod(
$core.method({
selector: "with:with:",
protocol: "instance creation",
args: ["anObject", "anotherObject"],
source: "with: anObject with: anotherObject\x0a\x09\x09^ self new\x0a\x09\x09add: anObject;\x0a\x09\x09add: anotherObject;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "new", "yourself"]
}, function ($methodClass){ return function (anObject,anotherObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
[$recv($1)._add_(anObject)
,$ctx1.sendIdx["add:"]=1
][0];
$recv($1)._add_(anotherObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:",{anObject:anObject,anotherObject:anotherObject})});
}; }),
$globals.Collection.a$cls);

$core.addMethod(
$core.method({
selector: "with:with:with:",
protocol: "instance creation",
args: ["firstObject", "secondObject", "thirdObject"],
source: "with: firstObject with: secondObject with: thirdObject\x0a\x09\x09^ self new\x0a\x09\x09add: firstObject;\x0a\x09\x09add: secondObject;\x0a\x09\x09add: thirdObject;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "new", "yourself"]
}, function ($methodClass){ return function (firstObject,secondObject,thirdObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
[$recv($1)._add_(firstObject)
,$ctx1.sendIdx["add:"]=1
][0];
[$recv($1)._add_(secondObject)
,$ctx1.sendIdx["add:"]=2
][0];
$recv($1)._add_(thirdObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:with:",{firstObject:firstObject,secondObject:secondObject,thirdObject:thirdObject})});
}; }),
$globals.Collection.a$cls);

$core.addMethod(
$core.method({
selector: "withAll:",
protocol: "instance creation",
args: ["aCollection"],
source: "withAll: aCollection\x0a\x09\x09^ self new\x0a\x09\x09addAll: aCollection;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["addAll:", "new", "yourself"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._addAll_(aCollection);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"withAll:",{aCollection:aCollection})});
}; }),
$globals.Collection.a$cls);


$core.addClass("AssociativeCollection", $globals.Collection, "Kernel-Collections");
$globals.AssociativeCollection.comment="I am a base class for object-indexed collections (Dictionary et.al.).";
$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["anAssociativeCollection"],
source: "= anAssociativeCollection\x0a\x09^ self class = anAssociativeCollection class and: [\x0a\x09\x09self size = anAssociativeCollection size and: [\x0a\x09\x09\x09| comparisons |\x0a\x09\x09\x09comparisons := OrderedCollection new.\x0a\x09\x09\x09(self associations allSatisfy: [ :each |\x0a\x09\x09\x09\x09anAssociativeCollection at: each key\x0a\x09\x09\x09\x09\x09ifPresent: [ :otherValue | comparisons add: { each value. otherValue }. true ]\x0a\x09\x09\x09\x09\x09ifAbsent: [ false ] ]) and: [\x0a\x09\x09\x09\x09\x09\x09comparisons allSatisfy: [ :each | each first = each second ] ] ] ]",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["and:", "=", "class", "size", "new", "allSatisfy:", "associations", "at:ifPresent:ifAbsent:", "key", "add:", "value", "first", "second"]
}, function ($methodClass){ return function (anAssociativeCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq($recv(anAssociativeCollection)._class())
,$ctx1.sendIdx["="]=1
][0])){
if($core.assert([$recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__eq($recv(anAssociativeCollection)._size())
,$ctx1.sendIdx["="]=2
][0])){
var comparisons;
comparisons=$recv($globals.OrderedCollection)._new();
if($core.assert([$recv($self._associations())._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(anAssociativeCollection)._at_ifPresent_ifAbsent_($recv(each)._key(),(function(otherValue){
return $core.withContext(function($ctx3) {
$recv(comparisons)._add_([$recv(each)._value(),otherValue]);
return true;
}, function($ctx3) {$ctx3.fillBlock({otherValue:otherValue},$ctx2,4)});
}),(function(){
return false;

}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}))
,$ctx1.sendIdx["allSatisfy:"]=1
][0])){
return $recv(comparisons)._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._first()).__eq($recv(each)._second());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,7)});
}));
} else {
return false;
}
} else {
return false;
}
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{anAssociativeCollection:anAssociativeCollection})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "add:",
protocol: "adding/removing",
args: ["anAssociation"],
source: "add: anAssociation\x0a\x09self at: anAssociation key put: anAssociation value",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "key", "value"]
}, function ($methodClass){ return function (anAssociation){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._at_put_($recv(anAssociation)._key(),$recv(anAssociation)._value());
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anAssociation:anAssociation})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "addAll:",
protocol: "adding/removing",
args: ["anAssociativeCollection"],
source: "addAll: anAssociativeCollection\x0a\x09super addAll: anAssociativeCollection associations.\x0a\x09^ anAssociativeCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["addAll:", "associations"]
}, function ($methodClass){ return function (anAssociativeCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._addAll_.call($self,$recv(anAssociativeCollection)._associations()))
,$ctx1.supercall = false
][0];
return anAssociativeCollection;
}, function($ctx1) {$ctx1.fill(self,"addAll:",{anAssociativeCollection:anAssociativeCollection})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "asDictionary",
protocol: "converting",
args: [],
source: "asDictionary\x0a\x09^ Dictionary from: self associations",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["from:", "associations"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Dictionary)._from_($self._associations());
}, function($ctx1) {$ctx1.fill(self,"asDictionary",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "asHashedCollection",
protocol: "converting",
args: [],
source: "asHashedCollection\x0a\x09^ HashedCollection from: self associations",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["from:", "associations"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.HashedCollection)._from_($self._associations());
}, function($ctx1) {$ctx1.fill(self,"asHashedCollection",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09| hash |\x0a\x09hash := HashedCollection new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09hash at: key put: value asJavaScriptObject ].\x0a\x09^ hash",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["new", "keysAndValuesDo:", "at:put:", "asJavaScriptObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var hash;
return $core.withContext(function($ctx1) {
hash=$recv($globals.HashedCollection)._new();
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(hash)._at_put_(key,$recv(value)._asJavaScriptObject());
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return hash;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptObject",{hash:hash})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "associations",
protocol: "accessing",
args: [],
source: "associations\x0a\x09| associations |\x0a\x09associations := #().\x0a\x09self associationsDo: [ :each | associations add: each ].\x0a\x09^ associations",
referencedClasses: [],
pragmas: [],
messageSends: ["associationsDo:", "add:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var associations;
return $core.withContext(function($ctx1) {
associations=[];
$self._associationsDo_((function(each){
return $core.withContext(function($ctx2) {
return $recv(associations)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return associations;
}, function($ctx1) {$ctx1.fill(self,"associations",{associations:associations})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "associationsDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "associationsDo: aBlock\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09aBlock value: (Association key: key value: value) ]",
referencedClasses: ["Association"],
pragmas: [],
messageSends: ["keysAndValuesDo:", "value:", "key:value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_($recv($globals.Association)._key_value_(key,value));
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"associationsDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: "accessing",
args: ["aKey", "aBlock", "anotherBlock"],
source: "at: aKey ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09\x22Lookup the given key in the receiver.\x0a\x09If it is present, answer the value of evaluating the oneArgBlock \x0a\x09with the value associated with the key, otherwise answer the value \x0a\x09of absentBlock.\x22\x0a\x09\x0a\x09^ (self includesKey: aKey)\x0a\x09\x09ifTrue: [ aBlock value: (self at: aKey) ]\x0a\x09\x09ifFalse: [ anotherBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "includesKey:", "value:", "at:", "value"]
}, function ($methodClass){ return function (aKey,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._includesKey_(aKey))){
return $recv(aBlock)._value_($self._at_(aKey));
} else {
return $recv(anotherBlock)._value();
}
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{aKey:aKey,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: "enumerating",
args: ["aBlock"],
source: "collect: aBlock\x0a\x09| newDict |\x0a\x09newDict := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09newDict at: key put: (aBlock value: value) ].\x0a\x09^ newDict",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "keysAndValuesDo:", "at:put:", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var newDict;
return $core.withContext(function($ctx1) {
newDict=$recv($self._class())._new();
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(newDict)._at_put_(key,$recv(aBlock)._value_(value));
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return newDict;
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock,newDict:newDict})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09| copy |\x0a\x09copy := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09copy at: key put: value deepCopy ].\x0a\x09^ copy",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "keysAndValuesDo:", "at:put:", "deepCopy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var copy;
return $core.withContext(function($ctx1) {
copy=$recv($self._class())._new();
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(copy)._at_put_(key,$recv(value)._deepCopy());
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return copy;
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{copy:copy})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: "enumerating",
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09^ self values detect: aBlock ifNone: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["detect:ifNone:", "values"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._values())._detect_ifNone_(aBlock,anotherBlock);
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "do:",
protocol: "enumerating",
args: ["aBlock"],
source: "do: aBlock\x0a\x09self valuesDo: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["valuesDo:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._valuesDo_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: "enumerating",
args: ["anObject"],
source: "includes: anObject\x0a\x09^ self values includes: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["includes:", "values"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._values())._includes_(anObject);
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: "testing",
args: ["aKey"],
source: "includesKey: aKey\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aKey){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: "accessing",
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09^ self keys \x0a\x09\x09detect: [ :each | (self at: each) = anObject ] \x0a\x09\x09ifNone: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["detect:ifNone:", "keys", "=", "at:"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._keys())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv($self._at_(each)).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),aBlock);
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keyAtValue:",
protocol: "accessing",
args: ["anObject"],
source: "keyAtValue: anObject\x0a\x09^ self keyAtValue: anObject ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
pragmas: [],
messageSends: ["keyAtValue:ifAbsent:", "errorNotFound"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._keyAtValue_ifAbsent_(anObject,(function(){
return $core.withContext(function($ctx2) {
return $self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"keyAtValue:",{anObject:anObject})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keyAtValue:ifAbsent:",
protocol: "accessing",
args: ["anObject", "aBlock"],
source: "keyAtValue: anObject ifAbsent: aBlock\x0a\x09^ self indexOf: anObject ifAbsent: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["indexOf:ifAbsent:"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._indexOf_ifAbsent_(anObject,aBlock);
}, function($ctx1) {$ctx1.fill(self,"keyAtValue:ifAbsent:",{anObject:anObject,aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keys",
protocol: "accessing",
args: [],
source: "keys\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"keys",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keysAndValuesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "keysAndValuesDo: aBlock\x0a\x09self keysDo: [ :each |\x0a\x09\x09aBlock value: each value: (self at: each) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["keysDo:", "value:value:", "at:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._keysDo_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(each,$self._at_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"keysAndValuesDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "keysDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "keysDo: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"keysDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: ' ('.\x0a\x09self associations\x0a\x09\x09do: [ :each | each printOn: aStream ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' , ' ].\x0a\x09aStream nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "do:separatedBy:", "associations"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.sendIdx["printOn:"]=1,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_(" (")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$recv($self._associations())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$recv(aStream)._nextPutAll_(" , ")
,$ctx2.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: "adding/removing",
args: ["aKey", "aBlock"],
source: "remove: aKey ifAbsent: aBlock\x0a\x09^ self removeKey: aKey ifAbsent: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["removeKey:ifAbsent:"]
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._removeKey_ifAbsent_(aKey,aBlock);
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: "adding/removing",
args: [],
source: "removeAll\x0a\x09^ self keys do: [ :each | self removeKey: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "keys", "removeKey:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._keys())._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._removeKey_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"removeAll",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "removeKey:",
protocol: "adding/removing",
args: ["aKey"],
source: "removeKey: aKey\x0a\x09^ self remove: aKey",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:"]
}, function ($methodClass){ return function (aKey){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._remove_(aKey);
}, function($ctx1) {$ctx1.fill(self,"removeKey:",{aKey:aKey})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "removeKey:ifAbsent:",
protocol: "adding/removing",
args: ["aKey", "aBlock"],
source: "removeKey: aKey ifAbsent: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"removeKey:ifAbsent:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "select:",
protocol: "enumerating",
args: ["aBlock"],
source: "select: aBlock\x0a\x09| newDict |\x0a\x09newDict := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09(aBlock value: value) ifTrue: [ newDict at: key put: value ]].\x0a\x09^ newDict",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "keysAndValuesDo:", "ifTrue:", "value:", "at:put:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var newDict;
return $core.withContext(function($ctx1) {
newDict=$recv($self._class())._new();
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
if($core.assert($recv(aBlock)._value_(value))){
return $recv(newDict)._at_put_(key,value);
}
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return newDict;
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock,newDict:newDict})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "select:thenCollect:",
protocol: "enumerating",
args: ["selectBlock", "collectBlock"],
source: "select: selectBlock thenCollect: collectBlock\x0a\x09| newDict |\x0a\x09newDict := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09(selectBlock value: value) ifTrue: [ newDict at: key put: (collectBlock value: value) ]].\x0a\x09^ newDict",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "keysAndValuesDo:", "ifTrue:", "value:", "at:put:"]
}, function ($methodClass){ return function (selectBlock,collectBlock){
var self=this,$self=this;
var newDict;
return $core.withContext(function($ctx1) {
newDict=$recv($self._class())._new();
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
if($core.assert([$recv(selectBlock)._value_(value)
,$ctx2.sendIdx["value:"]=1
][0])){
return $recv(newDict)._at_put_(key,$recv(collectBlock)._value_(value));
}
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return newDict;
}, function($ctx1) {$ctx1.fill(self,"select:thenCollect:",{selectBlock:selectBlock,collectBlock:collectBlock,newDict:newDict})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09| copy |\x0a\x09copy := self class new.\x0a\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09copy at: key put: value ].\x0a\x09^ copy",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "keysAndValuesDo:", "at:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var copy;
return $core.withContext(function($ctx1) {
copy=$recv($self._class())._new();
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(copy)._at_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return copy;
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{copy:copy})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "shortenedPrintString",
protocol: "printing",
args: [],
source: "shortenedPrintString\x0a\x09^ self size <= 1\x0a\x09\x09ifTrue: [ self printString ]\x0a\x09\x09ifFalse: [ | key | key := self keys anyOne. (self copyEmpty at: key put: (self at: key); yourself) printString, ' ... ', (self size - 1) asString, ' more items' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "<=", "size", "printString", "anyOne", "keys", ",", "at:put:", "copyEmpty", "at:", "yourself", "asString", "-"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__lt_eq((1)))){
return [$self._printString()
,$ctx1.sendIdx["printString"]=1
][0];
} else {
var key;
key=$recv($self._keys())._anyOne();
$1=$self._copyEmpty();
$recv($1)._at_put_(key,$self._at_(key));
return [$recv([$recv($recv($recv($recv($1)._yourself())._printString()).__comma(" ... ")).__comma($recv($recv($self._size()).__minus((1)))._asString())
,$ctx1.sendIdx[","]=2
][0]).__comma(" more items")
,$ctx1.sendIdx[","]=1
][0];
}
}, function($ctx1) {$ctx1.fill(self,"shortenedPrintString",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09^ self keys size",
referencedClasses: [],
pragmas: [],
messageSends: ["size", "keys"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._keys())._size();
}, function($ctx1) {$ctx1.fill(self,"size",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "values",
protocol: "accessing",
args: [],
source: "values\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"values",{})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "valuesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "valuesDo: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"valuesDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "withIndexDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "withIndexDo: aBlock\x0a\x09self keysAndValuesDo: [ :key :value | aBlock value: value value: key ]",
referencedClasses: [],
pragmas: [],
messageSends: ["keysAndValuesDo:", "value:value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(value,key);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"withIndexDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollection);


$core.addMethod(
$core.method({
selector: "from:",
protocol: "instance creation",
args: ["aCollection"],
source: "from: aCollection\x0a\x09| newCollection |\x0a\x09newCollection := self new.\x0a\x09aCollection do: [ :each | newCollection add: each ].\x0a\x09^ newCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "do:", "add:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var newCollection;
return $core.withContext(function($ctx1) {
newCollection=$self._new();
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return newCollection;
}, function($ctx1) {$ctx1.fill(self,"from:",{aCollection:aCollection,newCollection:newCollection})});
}; }),
$globals.AssociativeCollection.a$cls);

$core.addMethod(
$core.method({
selector: "fromPairs:",
protocol: "instance creation",
args: ["aCollection"],
source: "fromPairs: aCollection\x0a\x09\x22This message is poorly named and has been replaced by #from:\x22\x0a\x09^ self from: aCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["from:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._from_(aCollection);
}, function($ctx1) {$ctx1.fill(self,"fromPairs:",{aCollection:aCollection})});
}; }),
$globals.AssociativeCollection.a$cls);

$core.addMethod(
$core.method({
selector: "newFromPairs:",
protocol: "instance creation",
args: ["aCollection"],
source: "newFromPairs: aCollection\x0a\x09\x22Accept an array of elements where every two elements form an \x0a\x09association - the odd element being the key, and the even element the value.\x22\x0a\x09\x0a\x09| newCollection |\x0a\x09\x0a\x09aCollection size even ifFalse: [ \x0a\x09\x09self error: '#newFromPairs only accepts arrays of an even length' ].\x0a\x09\x09\x0a\x09newCollection := self new.\x0a\x09( 1 to: aCollection size by: 2 ) do: [ :each | \x0a\x09\x09newCollection at: (aCollection at: each) put: (aCollection at: each + 1) ].\x0a\x09\x09\x0a\x09^ newCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "even", "size", "error:", "new", "do:", "to:by:", "at:put:", "at:", "+"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var newCollection;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv([$recv(aCollection)._size()
,$ctx1.sendIdx["size"]=1
][0])._even())){
$self._error_("#newFromPairs only accepts arrays of an even length");
}
newCollection=$self._new();
$recv((1)._to_by_($recv(aCollection)._size(),(2)))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._at_put_([$recv(aCollection)._at_(each)
,$ctx2.sendIdx["at:"]=1
][0],$recv(aCollection)._at_($recv(each).__plus((1))));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return newCollection;
}, function($ctx1) {$ctx1.fill(self,"newFromPairs:",{aCollection:aCollection,newCollection:newCollection})});
}; }),
$globals.AssociativeCollection.a$cls);


$core.addClass("Dictionary", $globals.AssociativeCollection, "Kernel-Collections");
$core.setSlots($globals.Dictionary, ["keys", "values"]);
$globals.Dictionary.comment="I represent a set of elements that can be viewed from one of two perspectives: a set of associations,\x0aor a container of values that are externally named where the name can be any object that responds to `=`.\x0a\x0aThe external name is referred to as the key.";
$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "accessing",
args: ["aKey", "aBlock"],
source: "at: aKey ifAbsent: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09var index = $self._positionOfKey_(aKey);\x0a\x09\x09return index >=0 ? $self.values[index] : aBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var index = $self._positionOfKey_(aKey);\x0a\x09\x09return index >=0 ? $self.values[index] : aBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var index = $self._positionOfKey_(aKey);
		return index >=0 ? $self.values[index] : aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: "accessing",
args: ["aKey", "aValue"],
source: "at: aKey put: aValue\x0a\x09<inlineJS: '\x0a\x09\x09var index = $self._positionOfKey_(aKey);\x0a\x09\x09if(index === -1) {\x0a\x09\x09\x09var keys = $self.keys;\x0a\x09\x09\x09index = keys.length;\x0a\x09\x09\x09keys.push(aKey);\x0a\x09\x09}\x0a\x0a\x09\x09return $self.values[index] = aValue;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var index = $self._positionOfKey_(aKey);\x0a\x09\x09if(index === -1) {\x0a\x09\x09\x09var keys = $self.keys;\x0a\x09\x09\x09index = keys.length;\x0a\x09\x09\x09keys.push(aKey);\x0a\x09\x09}\x0a\x0a\x09\x09return $self.values[index] = aValue;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aKey,aValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var index = $self._positionOfKey_(aKey);
		if(index === -1) {
			var keys = $self.keys;
			index = keys.length;
			keys.push(aKey);
		}

		return $self.values[index] = aValue;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{aKey:aKey,aValue:aValue})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: "testing",
args: ["aKey"],
source: "includesKey: aKey\x0a\x09<inlineJS: 'return $self._positionOfKey_(aKey) >= 0;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self._positionOfKey_(aKey) >= 0;"]]],
messageSends: []
}, function ($methodClass){ return function (aKey){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._positionOfKey_(aKey) >= 0;;
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: "accessing",
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09| index |\x0a\x09index := values \x0a\x09\x09indexOf: anObject \x0a\x09\x09ifAbsent: [ 0 ].\x0a\x09^ index = 0 \x0a\x09\x09ifTrue: [ aBlock value ] \x0a\x09\x09ifFalse: [ keys at: index ]",
referencedClasses: [],
pragmas: [],
messageSends: ["indexOf:ifAbsent:", "ifTrue:ifFalse:", "=", "value", "at:"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
var index;
return $core.withContext(function($ctx1) {
index=$recv($self.values)._indexOf_ifAbsent_(anObject,(function(){
return (0);

}));
if($core.assert($recv(index).__eq((0)))){
return $recv(aBlock)._value();
} else {
return $recv($self.keys)._at_(index);
}
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock,index:index})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09keys := #().\x0a\x09values := #()",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.keys=[];
$self.values=[];
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "keys",
protocol: "accessing",
args: [],
source: "keys\x0a\x09^ keys copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.keys)._copy();
}, function($ctx1) {$ctx1.fill(self,"keys",{})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "keysAndValuesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "keysAndValuesDo: aBlock\x0a\x09^ keys with: values do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["with:do:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.keys)._with_do_($self.values,aBlock);
}, function($ctx1) {$ctx1.fill(self,"keysAndValuesDo:",{aBlock:aBlock})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "keysDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "keysDo: aBlock\x0a\x09^ keys do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.keys)._do_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"keysDo:",{aBlock:aBlock})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "positionOfKey:",
protocol: "private",
args: ["anObject"],
source: "positionOfKey: anObject\x0a\x09<inlineJS: '\x0a\x09\x09var keys = $self.keys;\x0a\x09\x09for(var i=0;i<keys.length;i++){\x0a\x09\x09\x09if(keys[i].__eq(anObject)) { return i;}\x0a\x09\x09}\x0a\x09\x09return -1;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var keys = $self.keys;\x0a\x09\x09for(var i=0;i<keys.length;i++){\x0a\x09\x09\x09if(keys[i].__eq(anObject)) { return i;}\x0a\x09\x09}\x0a\x09\x09return -1;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var keys = $self.keys;
		for(var i=0;i<keys.length;i++){
			if(keys[i].__eq(anObject)) { return i;}
		}
		return -1;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"positionOfKey:",{anObject:anObject})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: "adding/removing",
args: [],
source: "removeAll\x0a\x09keys removeAll.\x0a\x09values removeAll",
referencedClasses: [],
pragmas: [],
messageSends: ["removeAll"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv($self.keys)._removeAll()
,$ctx1.sendIdx["removeAll"]=1
][0];
$recv($self.values)._removeAll();
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "removeKey:ifAbsent:",
protocol: "adding/removing",
args: ["aKey", "aBlock"],
source: "removeKey: aKey ifAbsent: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09var index = $self._positionOfKey_(aKey);\x0a\x09\x09if(index === -1) {\x0a\x09\x09\x09return aBlock._value()\x0a\x09\x09} else {\x0a\x09\x09\x09var keys = $self.keys, values = $self.values;\x0a\x09\x09\x09var value = values[index], l = keys.length;\x0a\x09\x09\x09keys[index] = keys[l-1];\x0a\x09\x09\x09keys.pop();\x0a\x09\x09\x09values[index] = values[l-1];\x0a\x09\x09\x09values.pop();\x0a\x09\x09\x09return value;\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var index = $self._positionOfKey_(aKey);\x0a\x09\x09if(index === -1) {\x0a\x09\x09\x09return aBlock._value()\x0a\x09\x09} else {\x0a\x09\x09\x09var keys = $self.keys, values = $self.values;\x0a\x09\x09\x09var value = values[index], l = keys.length;\x0a\x09\x09\x09keys[index] = keys[l-1];\x0a\x09\x09\x09keys.pop();\x0a\x09\x09\x09values[index] = values[l-1];\x0a\x09\x09\x09values.pop();\x0a\x09\x09\x09return value;\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var index = $self._positionOfKey_(aKey);
		if(index === -1) {
			return aBlock._value()
		} else {
			var keys = $self.keys, values = $self.values;
			var value = values[index], l = keys.length;
			keys[index] = keys[l-1];
			keys.pop();
			values[index] = values[l-1];
			values.pop();
			return value;
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeKey:ifAbsent:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "values",
protocol: "accessing",
args: [],
source: "values\x0a\x09^ values",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.values;

}; }),
$globals.Dictionary);

$core.addMethod(
$core.method({
selector: "valuesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "valuesDo: aBlock\x0a\x09^ values do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.values)._do_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"valuesDo:",{aBlock:aBlock})});
}; }),
$globals.Dictionary);



$core.addClass("HashedCollection", $globals.AssociativeCollection, "Kernel-Collections");
$globals.HashedCollection.comment="I am a traditional JavaScript object, or a Smalltalk `Dictionary`.\x0a\x0aUnlike a `Dictionary`, I can only have strings as keys.";
$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "accessing",
args: [],
source: "asJavaScriptSource\x0a\x09^ String streamContents: [ :str |\x0a\x09\x09str nextPut: '{'.\x0a\x09\x09self keysAndValuesDo: [ :key :value |\x0a\x09\x09\x09str nextPutAll: key asJavaScriptSource; nextPut: ':'; nextPutAll: value asJavaScriptSource; nextPut: ',' ].\x0a\x09\x09str skip: -1; nextPut: '}' ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "keysAndValuesDo:", "nextPutAll:", "asJavaScriptSource", "skip:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
[$recv(str)._nextPut_("{")
,$ctx2.sendIdx["nextPut:"]=1
][0];
$self._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx3) {
[$recv(str)._nextPutAll_([$recv(key)._asJavaScriptSource()
,$ctx3.sendIdx["asJavaScriptSource"]=1
][0])
,$ctx3.sendIdx["nextPutAll:"]=1
][0];
[$recv(str)._nextPut_(":")
,$ctx3.sendIdx["nextPut:"]=2
][0];
$recv(str)._nextPutAll_($recv(value)._asJavaScriptSource());
return [$recv(str)._nextPut_(",")
,$ctx3.sendIdx["nextPut:"]=3
][0];
}, function($ctx3) {$ctx3.fillBlock({key:key,value:value},$ctx2,2)});
}));
$recv(str)._skip_((-1));
return $recv(str)._nextPut_("}");
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "accessing",
args: ["aKey", "aBlock"],
source: "at: aKey ifAbsent: aBlock\x0a\x09^ (self includesKey: aKey)\x0a\x09\x09ifTrue: [ self basicAt: aKey ]\x0a\x09\x09ifFalse: [ aBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "includesKey:", "basicAt:", "value"]
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._includesKey_(aKey))){
return $self._basicAt_(aKey);
} else {
return $recv(aBlock)._value();
}
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: "accessing",
args: ["aKey", "aValue"],
source: "at: aKey put: aValue\x0a\x09^ self basicAt: aKey put: aValue",
referencedClasses: [],
pragmas: [],
messageSends: ["basicAt:put:"]
}, function ($methodClass){ return function (aKey,aValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._basicAt_put_(aKey,aValue);
}, function($ctx1) {$ctx1.fill(self,"at:put:",{aKey:aKey,aValue:aValue})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "includesKey:",
protocol: "testing",
args: ["aKey"],
source: "includesKey: aKey\x0a\x09<inlineJS: 'return self.hasOwnProperty(aKey)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.hasOwnProperty(aKey)"]]],
messageSends: []
}, function ($methodClass){ return function (aKey){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.hasOwnProperty(aKey);
return self;
}, function($ctx1) {$ctx1.fill(self,"includesKey:",{aKey:aKey})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "keys",
protocol: "accessing",
args: [],
source: "keys\x0a\x09<inlineJS: 'return Object.keys(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Object.keys(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Object.keys(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"keys",{})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "keysDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "keysDo: aBlock\x0a\x09self keys do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "keys"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._keys())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"keysDo:",{aBlock:aBlock})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "removeKey:ifAbsent:",
protocol: "adding/removing",
args: ["aKey", "aBlock"],
source: "removeKey: aKey ifAbsent: aBlock\x0a\x09^ self\x0a\x09\x09at: aKey\x0a\x09\x09ifPresent: [ :removed | self basicDelete: aKey. removed ]\x0a\x09\x09ifAbsent: [ aBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:", "basicDelete:", "value"]
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_ifPresent_ifAbsent_(aKey,(function(removed){
return $core.withContext(function($ctx2) {
$self._basicDelete_(aKey);
return removed;
}, function($ctx2) {$ctx2.fillBlock({removed:removed},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"removeKey:ifAbsent:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "values",
protocol: "accessing",
args: [],
source: "values\x0a\x09<inlineJS: '\x0a\x09\x09return $self._keys().map(function(key){\x0a\x09\x09\x09return $self._at_(key);\x0a\x09\x09});\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return $self._keys().map(function(key){\x0a\x09\x09\x09return $self._at_(key);\x0a\x09\x09});\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return $self._keys().map(function(key){
			return $self._at_(key);
		});
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"values",{})});
}; }),
$globals.HashedCollection);

$core.addMethod(
$core.method({
selector: "valuesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "valuesDo: aBlock\x0a\x09self values do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "values"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._values())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"valuesDo:",{aBlock:aBlock})});
}; }),
$globals.HashedCollection);



$core.addClass("SequenceableCollection", $globals.Collection, "Kernel-Collections");
$globals.SequenceableCollection.comment="I am an IndexableCollection\x0awith numeric indexes starting with 1.";
$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["aCollection"],
source: "= aCollection\x0a\x09(self class = aCollection class and: [\x0a\x09\x09self size = aCollection size ]) ifFalse: [ ^ false ].\x0a\x09self withIndexDo: [ :each :i |\x0a\x09\x09\x09\x09(aCollection at: i) = each ifFalse: [ ^ false ]].\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "and:", "=", "class", "size", "withIndexDo:", "at:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
if($core.assert([$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq($recv(aCollection)._class())
,$ctx1.sendIdx["="]=1
][0])){
$1=[$recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__eq($recv(aCollection)._size())
,$ctx1.sendIdx["="]=2
][0];
} else {
$1=false;
}
if(!$core.assert($1)){
return false;
}
$self._withIndexDo_((function(each,i){
return $core.withContext(function($ctx2) {
if(!$core.assert($recv($recv(aCollection)._at_(i)).__eq(each))){
throw $early=[false];
}
}, function($ctx2) {$ctx2.fillBlock({each:each,i:i},$ctx1,3)});
}));
return true;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"=",{aCollection:aCollection})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "addLast:",
protocol: "adding/removing",
args: ["anObject"],
source: "addLast: anObject\x0a\x09self add: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["add:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._add_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"addLast:",{anObject:anObject})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "allButFirst",
protocol: "accessing",
args: [],
source: "allButFirst\x0a\x09^ self copyFrom: 2 to: self size",
referencedClasses: [],
pragmas: [],
messageSends: ["copyFrom:to:", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._copyFrom_to_((2),$self._size());
}, function($ctx1) {$ctx1.fill(self,"allButFirst",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "allButLast",
protocol: "accessing",
args: [],
source: "allButLast\x0a\x09^ self copyFrom: 1 to: self size - 1",
referencedClasses: [],
pragmas: [],
messageSends: ["copyFrom:to:", "-", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._copyFrom_to_((1),$recv($self._size()).__minus((1)));
}, function($ctx1) {$ctx1.fill(self,"allButLast",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "anyOne",
protocol: "accessing",
args: [],
source: "anyOne\x0a\x09^ self at: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_((1));
}, function($ctx1) {$ctx1.fill(self,"anyOne",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "atRandom",
protocol: "accessing",
args: [],
source: "atRandom\x0a\x09^ self at: self size atRandom",
referencedClasses: [],
pragmas: [],
messageSends: ["at:", "atRandom", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_($recv($self._size())._atRandom());
}, function($ctx1) {$ctx1.fill(self,"atRandom",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "beginsWith:",
protocol: "testing",
args: ["prefix"],
source: "beginsWith: prefix\x0a\x09self size < prefix size ifTrue: [ ^ false ].\x0a\x09^ (self first: prefix size) = prefix",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "<", "size", "=", "first:"]
}, function ($methodClass){ return function (prefix){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__lt([$recv(prefix)._size()
,$ctx1.sendIdx["size"]=2
][0]))){
return false;
}
return $recv($self._first_($recv(prefix)._size())).__eq(prefix);
}, function($ctx1) {$ctx1.fill(self,"beginsWith:",{prefix:prefix})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "copyFrom:to:",
protocol: "copying",
args: ["anIndex", "anotherIndex"],
source: "copyFrom: anIndex to: anotherIndex\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anIndex,anotherIndex){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"copyFrom:to:",{anIndex:anIndex,anotherIndex:anotherIndex})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "copyWithFirst:",
protocol: "copying",
args: ["anObject"],
source: "copyWithFirst: anObject\x0a\x09^ (self class with: anObject) addAll: self; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["addAll:", "with:", "class", "yourself"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($self._class())._with_(anObject);
$recv($1)._addAll_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"copyWithFirst:",{anObject:anObject})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "endsWith:",
protocol: "testing",
args: ["suffix"],
source: "endsWith: suffix\x0a\x09self size < suffix size ifTrue: [ ^ false ].\x0a\x09^ (self last: suffix size) = suffix",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "<", "size", "=", "last:"]
}, function ($methodClass){ return function (suffix){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__lt([$recv(suffix)._size()
,$ctx1.sendIdx["size"]=2
][0]))){
return false;
}
return $recv($self._last_($recv(suffix)._size())).__eq(suffix);
}, function($ctx1) {$ctx1.fill(self,"endsWith:",{suffix:suffix})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "first",
protocol: "accessing",
args: [],
source: "first\x0a\x09^ self at: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_((1));
}, function($ctx1) {$ctx1.fill(self,"first",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "first:",
protocol: "accessing",
args: ["aNumber"],
source: "first: aNumber\x0a\x09\x22Answer the first `aNumber` elements of the receiver.\x0a\x09Raise an error if there are not enough elements in the receiver.\x22\x0a\x0a\x09self size < aNumber ifTrue: [ self error: 'Invalid number of elements' ].\x0a\x0a\x09^ self copyFrom: 1 to: aNumber",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "<", "size", "error:", "copyFrom:to:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self._size()).__lt(aNumber))){
$self._error_("Invalid number of elements");
}
return $self._copyFrom_to_((1),aNumber);
}, function($ctx1) {$ctx1.fill(self,"first:",{aNumber:aNumber})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "fourth",
protocol: "accessing",
args: [],
source: "fourth\x0a\x09^ self at: 4",
referencedClasses: [],
pragmas: [],
messageSends: ["at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_((4));
}, function($ctx1) {$ctx1.fill(self,"fourth",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: "testing",
args: ["anObject"],
source: "includes: anObject\x0a\x09^ (self indexOf: anObject ifAbsent: [ nil ]) notNil",
referencedClasses: [],
pragmas: [],
messageSends: ["notNil", "indexOf:ifAbsent:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._indexOf_ifAbsent_(anObject,(function(){
return nil;

})))._notNil();
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:startingAt:",
protocol: "accessing",
args: ["anObject", "start"],
source: "indexOf: anObject startingAt: start\x0a\x09\x22Answer the index of the first occurence of anElement after start\x0a\x09within the receiver. If the receiver does not contain anElement,\x0a\x09answer 0.\x22\x0a\x09^ self indexOf: anObject startingAt: start ifAbsent: [ 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["indexOf:startingAt:ifAbsent:"]
}, function ($methodClass){ return function (anObject,start){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._indexOf_startingAt_ifAbsent_(anObject,start,(function(){
return (0);

}));
}, function($ctx1) {$ctx1.fill(self,"indexOf:startingAt:",{anObject:anObject,start:start})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "indexOf:startingAt:ifAbsent:",
protocol: "accessing",
args: ["anObject", "start", "aBlock"],
source: "indexOf: anObject startingAt: start ifAbsent: aBlock\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anObject,start,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:startingAt:ifAbsent:",{anObject:anObject,start:start,aBlock:aBlock})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "last",
protocol: "accessing",
args: [],
source: "last\x0a\x09^ self at: self size",
referencedClasses: [],
pragmas: [],
messageSends: ["at:", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_($self._size());
}, function($ctx1) {$ctx1.fill(self,"last",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "last:",
protocol: "accessing",
args: ["aNumber"],
source: "last: aNumber\x0a\x09\x22Answer the last aNumber elements of the receiver.\x0a\x09Raise an error if there are not enough elements in the receiver.\x22\x0a\x0a\x09self size < aNumber ifTrue: [ self error: 'Invalid number of elements' ].\x0a\x0a\x09^ self copyFrom: self size - aNumber + 1 to: self size",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "<", "size", "error:", "copyFrom:to:", "+", "-"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__lt(aNumber))){
$self._error_("Invalid number of elements");
}
return $self._copyFrom_to_($recv($recv([$self._size()
,$ctx1.sendIdx["size"]=2
][0]).__minus(aNumber)).__plus((1)),$self._size());
}, function($ctx1) {$ctx1.fill(self,"last:",{aNumber:aNumber})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "newStream",
protocol: "streaming",
args: [],
source: "newStream\x0a\x09^ self streamClass on: self",
referencedClasses: [],
pragmas: [],
messageSends: ["on:", "streamClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._streamClass())._on_(self);
}, function($ctx1) {$ctx1.fill(self,"newStream",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "pairsCollect:",
protocol: "enumerating",
args: ["aBlock"],
source: "pairsCollect: aBlock\x0a\x09\x22Evaluate aBlock with my elements taken two at a time,\x0a\x09and return an Array with the results\x22\x0a\x0a\x09\x22(#(1 'fred' 2 'charlie' 3 'elmer') pairsCollect: [:a :b | b, ' is number ', a printString]) >>> #('fred is number 1' 'charlie is number 2' 'elmer is number 3')\x22\x0a\x0a\x09^ (1 to: self size // 2) collect: [ :index |\x0a\x09\x09aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "to:", "//", "size", "value:value:", "at:", "-", "*"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv((1)._to_($recv($self._size()).__slash_slash((2))))._collect_((function(index){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_([$self._at_($recv([(2).__star(index)
,$ctx2.sendIdx["*"]=1
][0]).__minus((1)))
,$ctx2.sendIdx["at:"]=1
][0],$self._at_((2).__star(index)));
}, function($ctx2) {$ctx2.fillBlock({index:index},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"pairsCollect:",{aBlock:aBlock})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "pairsDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "pairsDo: aBlock\x0a\x09\x22Evaluate aBlock with my elements taken two at a time.\x0a\x09If there's an odd number of items, ignore the last one.\x0a\x09Allows use of a flattened array for things that naturally group into pairs.\x0a\x09See also pairsCollect:\x22\x0a\x0a\x09\x22(#(1 'fred' 2 'charlie' 3 'elmer') pairsDo: [:a :b | Transcript cr; show: b, ' is number ', a printString]) >>> #(1 'fred' 2 'charlie' 3 'elmer')\x22\x0a\x0a\x091 to: self size // 2 do: [ :index |\x0a\x09\x09aBlock value: (self at: 2 * index - 1) value: (self at: 2 * index) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["to:do:", "//", "size", "value:value:", "at:", "-", "*"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
(1)._to_do_($recv($self._size()).__slash_slash((2)),(function(index){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_([$self._at_($recv([(2).__star(index)
,$ctx2.sendIdx["*"]=1
][0]).__minus((1)))
,$ctx2.sendIdx["at:"]=1
][0],$self._at_((2).__star(index)));
}, function($ctx2) {$ctx2.fillBlock({index:index},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"pairsDo:",{aBlock:aBlock})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "readStream",
protocol: "streaming",
args: [],
source: "readStream\x0a\x09\x22For Pharo compatibility\x22\x0a\x09\x0a\x09^ self stream",
referencedClasses: [],
pragmas: [],
messageSends: ["stream"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._stream();
}, function($ctx1) {$ctx1.fill(self,"readStream",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "removeLast",
protocol: "adding/removing",
args: [],
source: "removeLast\x0a\x09^ self remove: self last",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._remove_($self._last());
}, function($ctx1) {$ctx1.fill(self,"removeLast",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "reverseDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "reverseDo: aBlock\x0a\x09self reversed do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "reversed"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._reversed())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"reverseDo:",{aBlock:aBlock})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "reversed",
protocol: "converting",
args: [],
source: "reversed\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"reversed",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "second",
protocol: "accessing",
args: [],
source: "second\x0a\x09^ self at: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_((2));
}, function($ctx1) {$ctx1.fill(self,"second",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "stream",
protocol: "streaming",
args: [],
source: "stream\x0a\x09^ self newStream",
referencedClasses: [],
pragmas: [],
messageSends: ["newStream"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._newStream();
}, function($ctx1) {$ctx1.fill(self,"stream",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "streamClass",
protocol: "streaming",
args: [],
source: "streamClass\x0a\x09^ self class streamClass",
referencedClasses: [],
pragmas: [],
messageSends: ["streamClass", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._streamClass();
}, function($ctx1) {$ctx1.fill(self,"streamClass",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "third",
protocol: "accessing",
args: [],
source: "third\x0a\x09^ self at: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_((3));
}, function($ctx1) {$ctx1.fill(self,"third",{})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "writeStream",
protocol: "streaming",
args: [],
source: "writeStream\x0a\x09\x22For Pharo compatibility\x22\x0a\x09\x0a\x09^ self stream",
referencedClasses: [],
pragmas: [],
messageSends: ["stream"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._stream();
}, function($ctx1) {$ctx1.fill(self,"writeStream",{})});
}; }),
$globals.SequenceableCollection);


$core.addMethod(
$core.method({
selector: "streamClass",
protocol: "accessing",
args: [],
source: "streamClass\x0a\x09\x09^ Stream",
referencedClasses: ["Stream"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Stream;

}; }),
$globals.SequenceableCollection.a$cls);

$core.addMethod(
$core.method({
selector: "streamContents:",
protocol: "streaming",
args: ["aBlock"],
source: "streamContents: aBlock\x0a\x09| stream |\x0a\x09stream := (self streamClass on: self new).\x0a\x09aBlock value: stream.\x0a\x09^ stream contents",
referencedClasses: [],
pragmas: [],
messageSends: ["on:", "streamClass", "new", "value:", "contents"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$recv($self._streamClass())._on_($self._new());
$recv(aBlock)._value_(stream);
return $recv(stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"streamContents:",{aBlock:aBlock,stream:stream})});
}; }),
$globals.SequenceableCollection.a$cls);


$core.addClass("Array", $globals.SequenceableCollection, "Kernel-Collections");
$globals.Array.comment="I represent a collection of objects ordered by the collector. The size of arrays is dynamic.\x0a\x0aI am directly mapped to JavaScript Number.\x0a\x0a*Note* In Amber, `OrderedCollection` is an alias for `Array`.";
$core.addMethod(
$core.method({
selector: "add:",
protocol: "adding/removing",
args: ["anObject"],
source: "add: anObject\x0a\x09<inlineJS: 'self.push(anObject); return anObject;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.push(anObject); return anObject;"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.push(anObject); return anObject;;
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "addAll:",
protocol: "adding/removing",
args: ["aCollection"],
source: "addAll: aCollection\x0a<inlineJS: '\x0a\x09if (Array.isArray(aCollection) && aCollection.length < 65000) self.push.apply(self, aCollection);\x0a\x09else $globals.Array.superclass.fn.prototype._addAll_.call($self, aCollection);\x0a\x09return aCollection;\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09if (Array.isArray(aCollection) && aCollection.length < 65000) self.push.apply(self, aCollection);\x0a\x09else $globals.Array.superclass.fn.prototype._addAll_.call($self, aCollection);\x0a\x09return aCollection;"]]],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	if (Array.isArray(aCollection) && aCollection.length < 65000) self.push.apply(self, aCollection);
	else $globals.Array.superclass.fn.prototype._addAll_.call($self, aCollection);
	return aCollection;;
return self;
}, function($ctx1) {$ctx1.fill(self,"addAll:",{aCollection:aCollection})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "addFirst:",
protocol: "adding/removing",
args: ["anObject"],
source: "addFirst: anObject\x0a\x09<inlineJS: 'self.unshift(anObject); return anObject;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.unshift(anObject); return anObject;"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.unshift(anObject); return anObject;;
return self;
}, function($ctx1) {$ctx1.fill(self,"addFirst:",{anObject:anObject})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "allIn:",
protocol: "enumerating",
args: ["aBlock"],
source: "allIn: aBlock\x0a\x09^ aBlock valueWithPossibleArguments:\x0a\x09\x09\x22collect to match #in: behaviour\x22\x0a\x09\x09(self collect: [ :each | each in: [ :x | x ] ])",
referencedClasses: [],
pragmas: [],
messageSends: ["valueWithPossibleArguments:", "collect:", "in:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._valueWithPossibleArguments_($self._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._in_((function(x){
return x;

}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})));
}, function($ctx1) {$ctx1.fill(self,"allIn:",{aBlock:aBlock})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "appendToString:",
protocol: "copying",
args: ["aString"],
source: "appendToString: aString\x0a<inlineJS: '\x0a\x09for (var i = 0, l = $self.length; i < l; ++i) {\x0a\x09\x09var el = $self[i];\x0a\x09\x09if ((typeof el === \x22string\x22) || $recv(el)._isString()) {\x0a\x09\x09\x09if (el.length === 1) { aString += el; continue; }\x0a\x09\x09}\x0a\x09\x09$self._error_(\x22Not a character.\x22);\x0a\x09}\x0a\x09return aString'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09for (var i = 0, l = $self.length; i < l; ++i) {\x0a\x09\x09var el = $self[i];\x0a\x09\x09if ((typeof el === \x22string\x22) || $recv(el)._isString()) {\x0a\x09\x09\x09if (el.length === 1) { aString += el; continue; }\x0a\x09\x09}\x0a\x09\x09$self._error_(\x22Not a character.\x22);\x0a\x09}\x0a\x09return aString"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	for (var i = 0, l = $self.length; i < l; ++i) {
		var el = $self[i];
		if ((typeof el === "string") || $recv(el)._isString()) {
			if (el.length === 1) { aString += el; continue; }
		}
		$self._error_("Not a character.");
	}
	return aString;
return self;
}, function($ctx1) {$ctx1.fill(self,"appendToString:",{aString:aString})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ '[', ((self collect: [:each | each asJavaScriptSource ]) join: ', '), ']'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "join:", "collect:", "asJavaScriptSource"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv("[".__comma($recv($self._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._asJavaScriptSource();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._join_(", "))).__comma("]")
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: "accessing",
args: ["anIndex", "anObject"],
source: "at: anIndex put: anObject\x0a\x09<inlineJS: 'return self[anIndex - 1] = anObject'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self[anIndex - 1] = anObject"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self[anIndex - 1] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{anIndex:anIndex,anObject:anObject})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: "enumerating",
args: ["aBlock"],
source: "collect: aBlock\x0a\x09\x22Optimized version\x22\x0a\x09\x0a\x09<inlineJS: 'return self.map(function(each) {return aBlock._value_(each)})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.map(function(each) {return aBlock._value_(each)})"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.map(function(each) {return aBlock._value_(each)});
return self;
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "copyFrom:to:",
protocol: "copying",
args: ["anIndex", "anotherIndex"],
source: "copyFrom: anIndex to: anotherIndex\x0a<inlineJS: '\x0a\x09if (anIndex >= 1 && anotherIndex <= self.length) {\x0a\x09\x09return self.slice(anIndex - 1, anotherIndex);\x0a\x09} else {\x0a\x09\x09self._at_(anIndex);\x0a\x09\x09self._at_(self.length + 1);\x0a\x09\x09throw new Error(\x22Incorrect indexes in #copyFrom:to: not caught by #at:\x22);\x0a\x09}\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09if (anIndex >= 1 && anotherIndex <= self.length) {\x0a\x09\x09return self.slice(anIndex - 1, anotherIndex);\x0a\x09} else {\x0a\x09\x09self._at_(anIndex);\x0a\x09\x09self._at_(self.length + 1);\x0a\x09\x09throw new Error(\x22Incorrect indexes in #copyFrom:to: not caught by #at:\x22);\x0a\x09}"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,anotherIndex){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	if (anIndex >= 1 && anotherIndex <= self.length) {
		return self.slice(anIndex - 1, anotherIndex);
	} else {
		self._at_(anIndex);
		self._at_(self.length + 1);
		throw new Error("Incorrect indexes in #copyFrom:to: not caught by #at:");
	};
return self;
}, function($ctx1) {$ctx1.fill(self,"copyFrom:to:",{anIndex:anIndex,anotherIndex:anotherIndex})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "join:",
protocol: "enumerating",
args: ["aString"],
source: "join: aString\x0a\x09<inlineJS: 'return self.join(aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.join(aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.join(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"join:",{aString:aString})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: ' ('.\x0a\x09self \x0a\x09\x09do: [ :each | each printOn: aStream ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' ' ].\x0a\x09aStream nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "do:separatedBy:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.sendIdx["printOn:"]=1,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_(" (")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$self._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$recv(aStream)._nextPutAll_(" ")
,$ctx2.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: "adding/removing",
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09| index |\x0a\x09index := self indexOf: anObject ifAbsent: [ 0 ].\x0a\x09^ index = 0\x0a\x09\x09ifFalse: [ self removeIndex: index. anObject ]\x0a\x09\x09ifTrue: [ aBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["indexOf:ifAbsent:", "ifFalse:ifTrue:", "=", "removeIndex:", "value"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
var index;
return $core.withContext(function($ctx1) {
index=$self._indexOf_ifAbsent_(anObject,(function(){
return (0);

}));
if($core.assert($recv(index).__eq((0)))){
return $recv(aBlock)._value();
} else {
$self._removeIndex_(index);
return anObject;
}
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock,index:index})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: "adding/removing",
args: [],
source: "removeAll\x0a\x09<inlineJS: 'self.length = 0'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.length = 0"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.length = 0;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeFrom:to:",
protocol: "adding/removing",
args: ["aNumber", "anotherNumber"],
source: "removeFrom: aNumber to: anotherNumber\x0a\x09<inlineJS: 'self.splice(aNumber -1, anotherNumber - aNumber + 1)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.splice(aNumber -1, anotherNumber - aNumber + 1)"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber,anotherNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.splice(aNumber -1, anotherNumber - aNumber + 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeFrom:to:",{aNumber:aNumber,anotherNumber:anotherNumber})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeIndex:",
protocol: "adding/removing",
args: ["anInteger"],
source: "removeIndex: anInteger\x0a\x09<inlineJS: 'self.splice(anInteger - 1, 1)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["self.splice(anInteger - 1, 1)"]]],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
self.splice(anInteger - 1, 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeIndex:",{anInteger:anInteger})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "removeLast",
protocol: "adding/removing",
args: [],
source: "removeLast\x0a\x09<inlineJS: 'return self.pop();'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.pop();"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.pop();;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeLast",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "reversed",
protocol: "converting",
args: [],
source: "reversed\x0a\x09<inlineJS: 'return self.slice().reverse()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.slice().reverse()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.slice().reverse();
return self;
}, function($ctx1) {$ctx1.fill(self,"reversed",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "select:",
protocol: "enumerating",
args: ["aBlock"],
source: "select: aBlock\x0a\x09\x22Optimized version\x22\x0a\x09\x0a\x09<inlineJS: 'return self.filter(function(each) {return aBlock._value_(each)})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.filter(function(each) {return aBlock._value_(each)})"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.filter(function(each) {return aBlock._value_(each)});
return self;
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09<inlineJS: 'return self.slice()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.slice()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.slice();
return self;
}, function($ctx1) {$ctx1.fill(self,"shallowCopy",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sort",
protocol: "enumerating",
args: [],
source: "sort\x0a\x09^ self sort: [ :a :b | a < b ]",
referencedClasses: [],
pragmas: [],
messageSends: ["sort:", "<"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._sort_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv(a).__lt(b);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"sort",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sort:",
protocol: "enumerating",
args: ["aBlock"],
source: "sort: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09return self.sort(function(a, b) {\x0a\x09\x09\x09if(aBlock._value_value_(a,b)) {return -1} else {return 1}\x0a\x09\x09})\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return self.sort(function(a, b) {\x0a\x09\x09\x09if(aBlock._value_value_(a,b)) {return -1} else {return 1}\x0a\x09\x09})\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return self.sort(function(a, b) {
			if(aBlock._value_value_(a,b)) {return -1} else {return 1}
		})
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"sort:",{aBlock:aBlock})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sorted",
protocol: "enumerating",
args: [],
source: "sorted\x0a\x09^ self copy sort",
referencedClasses: [],
pragmas: [],
messageSends: ["sort", "copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._copy())._sort();
}, function($ctx1) {$ctx1.fill(self,"sorted",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "sorted:",
protocol: "enumerating",
args: ["aBlock"],
source: "sorted: aBlock\x0a\x09^ self copy sort: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["sort:", "copy"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._copy())._sort_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"sorted:",{aBlock:aBlock})});
}; }),
$globals.Array);


$core.addMethod(
$core.method({
selector: "new:",
protocol: "instance creation",
args: ["anInteger"],
source: "new: anInteger\x0a\x09<inlineJS: 'return new Array(anInteger)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new Array(anInteger)"]]],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new Array(anInteger);
return self;
}, function($ctx1) {$ctx1.fill(self,"new:",{anInteger:anInteger})});
}; }),
$globals.Array.a$cls);

$core.addMethod(
$core.method({
selector: "with:",
protocol: "instance creation",
args: ["anObject"],
source: "with: anObject\x0a\x09\x09^ (self new: 1)\x0a\x09\x09at: 1 put: anObject;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "new:", "yourself"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new_((1));
$recv($1)._at_put_((1),anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:",{anObject:anObject})});
}; }),
$globals.Array.a$cls);

$core.addMethod(
$core.method({
selector: "with:with:",
protocol: "instance creation",
args: ["anObject", "anObject2"],
source: "with: anObject with: anObject2\x0a\x09\x09^ (self new: 2)\x0a\x09\x09at: 1 put: anObject;\x0a\x09\x09at: 2 put: anObject2;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "new:", "yourself"]
}, function ($methodClass){ return function (anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new_((2));
[$recv($1)._at_put_((1),anObject)
,$ctx1.sendIdx["at:put:"]=1
][0];
$recv($1)._at_put_((2),anObject2);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:",{anObject:anObject,anObject2:anObject2})});
}; }),
$globals.Array.a$cls);

$core.addMethod(
$core.method({
selector: "with:with:with:",
protocol: "instance creation",
args: ["anObject", "anObject2", "anObject3"],
source: "with: anObject with: anObject2 with: anObject3\x0a\x09\x09^ (self new: 3)\x0a\x09\x09at: 1 put: anObject;\x0a\x09\x09at: 2 put: anObject2;\x0a\x09\x09at: 3 put: anObject3;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "new:", "yourself"]
}, function ($methodClass){ return function (anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new_((3));
[$recv($1)._at_put_((1),anObject)
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($1)._at_put_((2),anObject2)
,$ctx1.sendIdx["at:put:"]=2
][0];
$recv($1)._at_put_((3),anObject3);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"with:with:with:",{anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.Array.a$cls);

$core.addMethod(
$core.method({
selector: "withAll:",
protocol: "instance creation",
args: ["aCollection"],
source: "withAll: aCollection\x0a\x09| instance index |\x0a\x09index := 1.\x0a\x09instance := self new: aCollection size.\x0a\x09aCollection do: [ :each |\x0a\x09\x09instance at: index put: each.\x0a\x09\x09index := index + 1 ].\x0a\x09^ instance",
referencedClasses: [],
pragmas: [],
messageSends: ["new:", "size", "do:", "at:put:", "+"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var instance,index;
return $core.withContext(function($ctx1) {
index=(1);
instance=$self._new_($recv(aCollection)._size());
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
$recv(instance)._at_put_(index,each);
index=$recv(index).__plus((1));
return index;
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return instance;
}, function($ctx1) {$ctx1.fill(self,"withAll:",{aCollection:aCollection,instance:instance,index:index})});
}; }),
$globals.Array.a$cls);


$core.addClass("String", $globals.SequenceableCollection, "Kernel-Collections");
$globals.String.comment="I am an indexed collection of Characters. Unlike most Smalltalk dialects, Amber doesn't provide the Character class. Instead, elements of a String are single character strings.\x0a\x0aString inherits many useful methods from its hierarchy, such as\x0a\x09`Collection >> #,`";
$core.addMethod(
$core.method({
selector: ",",
protocol: "copying",
args: ["aString"],
source: ", aString\x0a\x09<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09\x09String(self) + aString :\x0a\x09\x09$recv(aString)._appendToString_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09\x09String(self) + aString :\x0a\x09\x09$recv(aString)._appendToString_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
		String(self) + aString :
		$recv(aString)._appendToString_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,",",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "<",
protocol: "comparing",
args: ["aString"],
source: "< aString\x0a<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09String(self) < aString :\x0a\x09$recv(aString)._isStringLessThanSelf_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09String(self) < aString :\x0a\x09$recv(aString)._isStringLessThanSelf_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
	String(self) < aString :
	$recv(aString)._isStringLessThanSelf_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,"<",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "<=",
protocol: "comparing",
args: ["aString"],
source: "<= aString\x0a<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09String(self) <= aString :\x0a\x09$recv(aString)._isStringLessThanOrEqualToSelf_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09String(self) <= aString :\x0a\x09$recv(aString)._isStringLessThanOrEqualToSelf_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
	String(self) <= aString :
	$recv(aString)._isStringLessThanOrEqualToSelf_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,"<=",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["aString"],
source: "= aString\x0a<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09String(self) === aString :\x0a\x09$recv(aString)._isStringEqualToSelf_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09String(self) === aString :\x0a\x09$recv(aString)._isStringEqualToSelf_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
	String(self) === aString :
	$recv(aString)._isStringEqualToSelf_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,"=",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "==",
protocol: "comparing",
args: ["aString"],
source: "== aString\x0a<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09String(self) === aString :\x0a\x09$recv(aString)._isStringEqualToSelf_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09String(self) === aString :\x0a\x09$recv(aString)._isStringEqualToSelf_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
	String(self) === aString :
	$recv(aString)._isStringEqualToSelf_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,"==",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: ">",
protocol: "comparing",
args: ["aString"],
source: "> aString\x0a<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09String(self) > aString :\x0a\x09$recv(aString)._isStringGreaterThanSelf_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09String(self) > aString :\x0a\x09$recv(aString)._isStringGreaterThanSelf_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
	String(self) > aString :
	$recv(aString)._isStringGreaterThanSelf_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,">",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: ">=",
protocol: "comparing",
args: ["aString"],
source: ">= aString\x0a<inlineJS: 'return typeof aString === \x22string\x22 ?\x0a\x09String(self) >= aString :\x0a\x09$recv(aString)._isStringGreaterThanOrEqualSelf_(String(self))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof aString === \x22string\x22 ?\x0a\x09String(self) >= aString :\x0a\x09$recv(aString)._isStringGreaterThanOrEqualSelf_(String(self))"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof aString === "string" ?
	String(self) >= aString :
	$recv(aString)._isStringGreaterThanOrEqualSelf_(String(self));
return self;
}, function($ctx1) {$ctx1.fill(self,">=",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "add:",
protocol: "adding/removing",
args: ["anObject"],
source: "add: anObject\x0a\x09self errorReadOnly",
referencedClasses: [],
pragmas: [],
messageSends: ["errorReadOnly"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "appendToString:",
protocol: "copying",
args: ["aString"],
source: "appendToString: aString\x0a\x09<inlineJS: 'return aString + self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString + self"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString + self;
return self;
}, function($ctx1) {$ctx1.fill(self,"appendToString:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asJavaScriptMethodName",
protocol: "converting",
args: [],
source: "asJavaScriptMethodName\x0a\x09<inlineJS: 'return $core.st2js(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.st2js(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.st2js(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptMethodName",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09<inlineJS: '\x0a\x09\x09if(self.search(/^[a-zA-Z0-9_:.$ ]*$/) == -1)\x0a\x09\x09\x09return \x22\x5c\x22\x22 + self.replace(/[\x5cx00-\x5cx1f\x22\x5c\x5c\x5cx7f-\x5cx9f]/g, function(ch){var c=ch.charCodeAt(0);return \x22\x5c\x5cx\x22+(\x220\x22+c.toString(16)).slice(-2)}) + \x22\x5c\x22\x22;\x0a\x09\x09else\x0a\x09\x09\x09return \x22\x5c\x22\x22 + self + \x22\x5c\x22\x22;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if(self.search(/^[a-zA-Z0-9_:.$ ]*$/) == -1)\x0a\x09\x09\x09return \x22\x5c\x22\x22 + self.replace(/[\x5cx00-\x5cx1f\x22\x5c\x5c\x5cx7f-\x5cx9f]/g, function(ch){var c=ch.charCodeAt(0);return \x22\x5c\x5cx\x22+(\x220\x22+c.toString(16)).slice(-2)}) + \x22\x5c\x22\x22;\x0a\x09\x09else\x0a\x09\x09\x09return \x22\x5c\x22\x22 + self + \x22\x5c\x22\x22;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if(self.search(/^[a-zA-Z0-9_:.$ ]*$/) == -1)
			return "\"" + self.replace(/[\x00-\x1f"\\\x7f-\x9f]/g, function(ch){var c=ch.charCodeAt(0);return "\\x"+("0"+c.toString(16)).slice(-2)}) + "\"";
		else
			return "\"" + self + "\"";
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asLowercase",
protocol: "converting",
args: [],
source: "asLowercase\x0a\x09<inlineJS: 'return self.toLowerCase()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toLowerCase()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toLowerCase();
return self;
}, function($ctx1) {$ctx1.fill(self,"asLowercase",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asMutator",
protocol: "converting",
args: [],
source: "asMutator\x0a\x09\x22Answer a setter selector. For example,\x0a\x09#name asMutator returns #name:\x22\x0a\x0a\x09self last = ':' ifFalse: [  ^ self, ':' ].\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "=", "last", ","]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv($self._last()).__eq(":"))){
return $self.__comma(":");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"asMutator",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asNumber",
protocol: "converting",
args: [],
source: "asNumber\x0a\x09<inlineJS: 'return Number(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Number(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Number(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asNumber",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asRegexp",
protocol: "converting",
args: [],
source: "asRegexp\x0a\x09^ RegularExpression fromString: self",
referencedClasses: ["RegularExpression"],
pragmas: [],
messageSends: ["fromString:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.RegularExpression)._fromString_(self);
}, function($ctx1) {$ctx1.fill(self,"asRegexp",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSymbol",
protocol: "converting",
args: [],
source: "asSymbol\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSymbolPrintOn:",
protocol: "printing",
args: ["aStream"],
source: "asSymbolPrintOn: aStream\x0a\x09aStream nextPutAll: '#'.\x0a\x09self asString isSelector\x0a\x09\x09ifTrue: [ aStream nextPut: self ]\x0a\x09\x09ifFalse: [ self printOn: aStream ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "ifTrue:ifFalse:", "isSelector", "asString", "nextPut:", "printOn:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_("#");
if($core.assert($recv($self._asString())._isSelector())){
$recv(aStream)._nextPut_(self);
} else {
$self._printOn_(aStream);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"asSymbolPrintOn:",{aStream:aStream})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asUppercase",
protocol: "converting",
args: [],
source: "asUppercase\x0a\x09<inlineJS: 'return self.toUpperCase()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toUpperCase()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toUpperCase();
return self;
}, function($ctx1) {$ctx1.fill(self,"asUppercase",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asciiValue",
protocol: "accessing",
args: [],
source: "asciiValue\x0a\x09<inlineJS: 'return self.charCodeAt(0);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.charCodeAt(0);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.charCodeAt(0);;
return self;
}, function($ctx1) {$ctx1.fill(self,"asciiValue",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "accessing",
args: ["anIndex", "aBlock"],
source: "at: anIndex ifAbsent: aBlock\x0a\x09<inlineJS: 'return String(self)[anIndex - 1] || aBlock._value()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return String(self)[anIndex - 1] || aBlock._value()"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return String(self)[anIndex - 1] || aBlock._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{anIndex:anIndex,aBlock:aBlock})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: "accessing",
args: ["anIndex", "aBlock", "anotherBlock"],
source: "at: anIndex ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09<inlineJS: '\x0a\x09\x09var result = String(self)[anIndex - 1];\x0a\x09\x09return result ? aBlock._value_(result) : anotherBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var result = String(self)[anIndex - 1];\x0a\x09\x09return result ? aBlock._value_(result) : anotherBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var result = String(self)[anIndex - 1];
		return result ? aBlock._value_(result) : anotherBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{anIndex:anIndex,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: "accessing",
args: ["anIndex", "anObject"],
source: "at: anIndex put: anObject\x0a\x09self errorReadOnly",
referencedClasses: [],
pragmas: [],
messageSends: ["errorReadOnly"]
}, function ($methodClass){ return function (anIndex,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{anIndex:anIndex,anObject:anObject})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "capitalized",
protocol: "converting",
args: [],
source: "capitalized\x0a\x09^ self ifNotEmpty: [ self first asUppercase, self allButFirst ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", ",", "asUppercase", "first", "allButFirst"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($self._first())._asUppercase()).__comma($self._allButFirst());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"capitalized",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "charCodeAt:",
protocol: "accessing",
args: ["anInteger"],
source: "charCodeAt: anInteger\x0a\x09<inlineJS: 'return self.charCodeAt(anInteger - 1)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.charCodeAt(anInteger - 1)"]]],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.charCodeAt(anInteger - 1);
return self;
}, function($ctx1) {$ctx1.fill(self,"charCodeAt:",{anInteger:anInteger})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "copyFrom:to:",
protocol: "copying",
args: ["anIndex", "anotherIndex"],
source: "copyFrom: anIndex to: anotherIndex\x0a\x09<inlineJS: 'return self.substring(anIndex - 1, anotherIndex)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.substring(anIndex - 1, anotherIndex)"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,anotherIndex){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.substring(anIndex - 1, anotherIndex);
return self;
}, function($ctx1) {$ctx1.fill(self,"copyFrom:to:",{anIndex:anIndex,anotherIndex:anotherIndex})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "copyWithFirst:",
protocol: "copying",
args: ["anObject"],
source: "copyWithFirst: anObject\x0a\x09(anObject isString and: [ anObject size = 1 ]) \x22character is one-char string in JS\x22\x0a\x09\x09ifFalse: [ self error: 'Cannot put ', anObject class name, ' in a String' ].\x0a\x09^ anObject, self",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "and:", "isString", "=", "size", "error:", ",", "name", "class"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($recv(anObject)._isString())){
$1=$recv($recv(anObject)._size()).__eq((1));
} else {
$1=false;
}
if(!$core.assert($1)){
$self._error_([$recv(["Cannot put ".__comma($recv($recv(anObject)._class())._name())
,$ctx1.sendIdx[","]=2
][0]).__comma(" in a String")
,$ctx1.sendIdx[","]=1
][0]);
}
return $recv(anObject).__comma(self);
}, function($ctx1) {$ctx1.fill(self,"copyWithFirst:",{anObject:anObject})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "crlfSanitized",
protocol: "converting",
args: [],
source: "crlfSanitized\x0a\x09^ self lines join: String lf",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["join:", "lines", "lf"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._lines())._join_($recv($globals.String)._lf());
}, function($ctx1) {$ctx1.fill(self,"crlfSanitized",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "deepCopy",
protocol: "copying",
args: [],
source: "deepCopy\x0a\x09^ self shallowCopy",
referencedClasses: [],
pragmas: [],
messageSends: ["shallowCopy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._shallowCopy();
}, function($ctx1) {$ctx1.fill(self,"deepCopy",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "errorReadOnly",
protocol: "error handling",
args: [],
source: "errorReadOnly\x0a\x09self error: 'Object is read-only'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Object is read-only");
return self;
}, function($ctx1) {$ctx1.fill(self,"errorReadOnly",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "escaped",
protocol: "converting",
args: [],
source: "escaped\x0a\x09<inlineJS: 'return escape(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return escape(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return escape(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"escaped",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "includesSubString:",
protocol: "testing",
args: ["subString"],
source: "includesSubString: subString\x0a\x09<inlineJS: 'return self.indexOf(subString) != -1'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.indexOf(subString) != -1"]]],
messageSends: []
}, function ($methodClass){ return function (subString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.indexOf(subString) != -1;
return self;
}, function($ctx1) {$ctx1.fill(self,"includesSubString:",{subString:subString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isCapitalized",
protocol: "testing",
args: [],
source: "isCapitalized\x0a\x09^ self first asUppercase == self first",
referencedClasses: [],
pragmas: [],
messageSends: ["==", "asUppercase", "first"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv([$self._first()
,$ctx1.sendIdx["first"]=1
][0])._asUppercase()).__eq_eq($self._first());
}, function($ctx1) {$ctx1.fill(self,"isCapitalized",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isSelector",
protocol: "testing",
args: [],
source: "isSelector\x0a<inlineJS:\x0a\x09'return !!self.match(/^([a-zA-Z][a-zA-Z0-9]*|[\x5c\x5c+*/=><,@%~|&-]+|([a-zA-Z][a-zA-Z0-9]*\x5c:)+)$/)'\x0a>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return !!self.match(/^([a-zA-Z][a-zA-Z0-9]*|[\x5c\x5c+*/=><,@%~|&-]+|([a-zA-Z][a-zA-Z0-9]*\x5c:)+)$/)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return !!self.match(/^([a-zA-Z][a-zA-Z0-9]*|[\\+*/=><,@%~|&-]+|([a-zA-Z][a-zA-Z0-9]*\:)+)$/);
return self;
}, function($ctx1) {$ctx1.fill(self,"isSelector",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isString",
protocol: "testing",
args: [],
source: "isString\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isStringEqualToSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringEqualToSelf: aString\x0a\x09<inlineJS: 'return aString === String(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString === String(self)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString === String(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"isStringEqualToSelf:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isStringGreaterThanOrEqualToSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringGreaterThanOrEqualToSelf: aString\x0a\x09<inlineJS: 'return aString >= self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString >= self"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString >= self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isStringGreaterThanOrEqualToSelf:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isStringGreaterThanSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringGreaterThanSelf: aString\x0a\x09<inlineJS: 'return aString > self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString > self"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString > self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isStringGreaterThanSelf:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isStringLessThanOrEqualToSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringLessThanOrEqualToSelf: aString\x0a\x09<inlineJS: 'return aString <= self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString <= self"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString <= self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isStringLessThanOrEqualToSelf:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isStringLessThanSelf:",
protocol: "comparing",
args: ["aString"],
source: "isStringLessThanSelf: aString\x0a\x09<inlineJS: 'return aString < self'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString < self"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString < self;
return self;
}, function($ctx1) {$ctx1.fill(self,"isStringLessThanSelf:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "isVowel",
protocol: "testing",
args: [],
source: "isVowel\x0a\x09\x22Answer true if the receiver is a one character string containing a voyel\x22\x0a\x09\x0a\x09^ self size = 1 and: [ 'aeiou' includes: self asLowercase ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "=", "size", "includes:", "asLowercase"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self._size()).__eq((1)))){
return "aeiou"._includes_($self._asLowercase());
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"isVowel",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "join:",
protocol: "split join",
args: ["aCollection"],
source: "join: aCollection\x0a\x09^ String\x0a\x09\x09streamContents: [ :stream | aCollection\x0a\x09\x09\x09\x09do: [ :each | stream nextPutAll: each asString ]\x0a\x09\x09\x09\x09separatedBy: [ stream nextPutAll: self ]]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "do:separatedBy:", "nextPutAll:", "asString"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
return $recv(aCollection)._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return [$recv(stream)._nextPutAll_($recv(each)._asString())
,$ctx3.sendIdx["nextPutAll:"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPutAll_(self);
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"join:",{aCollection:aCollection})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "lineIndicesDo:",
protocol: "split join",
args: ["aBlock"],
source: "lineIndicesDo: aBlock\x0a\x09\x22execute aBlock with 3 arguments for each line:\x0a\x09- start index of line\x0a\x09- end index of line without line delimiter\x0a\x09- end index of line including line delimiter(s) CR, LF or CRLF\x22\x0a\x09\x0a\x09| cr lf start sz nextLF nextCR |\x0a\x09start := 1.\x0a\x09sz := self size.\x0a\x09cr := String cr.\x0a\x09nextCR := self indexOf: cr startingAt: 1.\x0a\x09lf := String lf.\x0a\x09nextLF := self indexOf: lf startingAt: 1.\x0a\x09[ start <= sz ] whileTrue: [ \x0a\x09\x09(nextLF = 0 and: [ nextCR = 0 ])\x0a\x09\x09\x09ifTrue: [ \x22No more CR, nor LF, the string is over\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: sz value: sz.\x0a\x09\x09\x09\x09\x09^ self ].\x0a\x09\x09(nextCR = 0 or: [ 0 < nextLF and: [ nextLF < nextCR ] ])\x0a\x09\x09\x09ifTrue: [ \x22Found a LF\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: nextLF - 1 value: nextLF.\x0a\x09\x09\x09\x09\x09start := 1 + nextLF.\x0a\x09\x09\x09\x09\x09nextLF := self indexOf: lf startingAt: start ]\x0a\x09\x09\x09ifFalse: [ 1 + nextCR = nextLF\x0a\x09\x09\x09\x09ifTrue: [ \x22Found a CR-LF pair\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: nextCR - 1 value: nextLF.\x0a\x09\x09\x09\x09\x09start := 1 + nextLF.\x0a\x09\x09\x09\x09\x09nextCR := self indexOf: cr startingAt: start.\x0a\x09\x09\x09\x09\x09nextLF := self indexOf: lf startingAt: start ]\x0a\x09\x09\x09\x09ifFalse: [ \x22Found a CR\x22\x0a\x09\x09\x09\x09\x09aBlock value: start value: nextCR - 1 value: nextCR.\x0a\x09\x09\x09\x09\x09start := 1 + nextCR.\x0a\x09\x09\x09\x09\x09nextCR := self indexOf: cr startingAt: start ] ]]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["size", "cr", "indexOf:startingAt:", "lf", "whileTrue:", "<=", "ifTrue:", "and:", "=", "value:value:value:", "ifTrue:ifFalse:", "or:", "<", "-", "+"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var cr,lf,start,sz,nextLF,nextCR;
return $core.withContext(function($ctx1) {
var $1,$2;
var $early={};
try {
start=(1);
sz=$self._size();
cr=$recv($globals.String)._cr();
nextCR=[$self._indexOf_startingAt_(cr,(1))
,$ctx1.sendIdx["indexOf:startingAt:"]=1
][0];
lf=$recv($globals.String)._lf();
nextLF=[$self._indexOf_startingAt_(lf,(1))
,$ctx1.sendIdx["indexOf:startingAt:"]=2
][0];
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(start).__lt_eq(sz);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
if($core.assert([$recv(nextLF).__eq((0))
,$ctx2.sendIdx["="]=1
][0])){
$1=[$recv(nextCR).__eq((0))
,$ctx2.sendIdx["="]=2
][0];
} else {
$1=false;
}
if($core.assert($1)){
[$recv(aBlock)._value_value_value_(start,sz,sz)
,$ctx2.sendIdx["value:value:value:"]=1
][0];
throw $early=[self];
}
if($core.assert([$recv(nextCR).__eq((0))
,$ctx2.sendIdx["="]=3
][0])){
$2=true;
} else {
if($core.assert([(0).__lt(nextLF)
,$ctx2.sendIdx["<"]=1
][0])){
$2=$recv(nextLF).__lt(nextCR);
} else {
$2=false;
}
}
if($core.assert($2)){
[$recv(aBlock)._value_value_value_(start,[$recv(nextLF).__minus((1))
,$ctx2.sendIdx["-"]=1
][0],nextLF)
,$ctx2.sendIdx["value:value:value:"]=2
][0];
start=[(1).__plus(nextLF)
,$ctx2.sendIdx["+"]=1
][0];
nextLF=[$self._indexOf_startingAt_(lf,start)
,$ctx2.sendIdx["indexOf:startingAt:"]=3
][0];
return nextLF;
} else {
if($core.assert($recv([(1).__plus(nextCR)
,$ctx2.sendIdx["+"]=2
][0]).__eq(nextLF))){
[$recv(aBlock)._value_value_value_(start,[$recv(nextCR).__minus((1))
,$ctx2.sendIdx["-"]=2
][0],nextLF)
,$ctx2.sendIdx["value:value:value:"]=3
][0];
start=[(1).__plus(nextLF)
,$ctx2.sendIdx["+"]=3
][0];
nextCR=[$self._indexOf_startingAt_(cr,start)
,$ctx2.sendIdx["indexOf:startingAt:"]=4
][0];
nextLF=[$self._indexOf_startingAt_(lf,start)
,$ctx2.sendIdx["indexOf:startingAt:"]=5
][0];
return nextLF;
} else {
$recv(aBlock)._value_value_value_(start,$recv(nextCR).__minus((1)),nextCR);
start=(1).__plus(nextCR);
nextCR=$self._indexOf_startingAt_(cr,start);
return nextCR;
}
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"lineIndicesDo:",{aBlock:aBlock,cr:cr,lf:lf,start:start,sz:sz,nextLF:nextLF,nextCR:nextCR})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "lineNumber:",
protocol: "split join",
args: ["anIndex"],
source: "lineNumber: anIndex\x0a\x09\x22Answer a string containing the characters in the given line number.\x22\x0a\x0a\x09| lineCount |\x0a\x09lineCount := 0.\x0a\x09self lineIndicesDo: [ :start :endWithoutDelimiters :end |\x0a\x09\x09(lineCount := lineCount + 1) = anIndex ifTrue: [ ^ self copyFrom: start to: endWithoutDelimiters ]].\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: ["lineIndicesDo:", "ifTrue:", "=", "+", "copyFrom:to:"]
}, function ($methodClass){ return function (anIndex){
var self=this,$self=this;
var lineCount;
return $core.withContext(function($ctx1) {
var $early={};
try {
lineCount=(0);
$self._lineIndicesDo_((function(start,endWithoutDelimiters,end){
return $core.withContext(function($ctx2) {
lineCount=$recv(lineCount).__plus((1));
if($core.assert($recv(lineCount).__eq(anIndex))){
throw $early=[$self._copyFrom_to_(start,endWithoutDelimiters)];
}
}, function($ctx2) {$ctx2.fillBlock({start:start,endWithoutDelimiters:endWithoutDelimiters,end:end},$ctx1,1)});
}));
return nil;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"lineNumber:",{anIndex:anIndex,lineCount:lineCount})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "lines",
protocol: "split join",
args: [],
source: "lines\x0a\x09\x22Answer an array of lines composing this receiver without the line ending delimiters.\x22\x0a<inlineJS: '\x0a\x09var result = self.split(/\x5cr\x5cn|\x5cr|\x5cn/);\x0a\x09if (!result[result.length-1]) result.pop();\x0a\x09return result;\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09var result = self.split(/\x5cr\x5cn|\x5cr|\x5cn/);\x0a\x09if (!result[result.length-1]) result.pop();\x0a\x09return result;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	var result = self.split(/\r\n|\r|\n/);
	if (!result[result.length-1]) result.pop();
	return result;;
return self;
}, function($ctx1) {$ctx1.fill(self,"lines",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "linesDo:",
protocol: "split join",
args: ["aBlock"],
source: "linesDo: aBlock\x0a\x09\x22Execute aBlock with each line in this string. The terminating line\x0a\x09delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock\x22\x0a\x0a\x09self lines do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "lines"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._lines())._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"linesDo:",{aBlock:aBlock})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "match:",
protocol: "regular expressions",
args: ["aRegexp"],
source: "match: aRegexp\x0a\x09<inlineJS: 'return self.search(aRegexp) != -1'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.search(aRegexp) != -1"]]],
messageSends: []
}, function ($methodClass){ return function (aRegexp){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.search(aRegexp) != -1;
return self;
}, function($ctx1) {$ctx1.fill(self,"match:",{aRegexp:aRegexp})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "matchesOf:",
protocol: "regular expressions",
args: ["aRegularExpression"],
source: "matchesOf: aRegularExpression\x0a\x09<inlineJS: 'return self.match(aRegularExpression)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.match(aRegularExpression)"]]],
messageSends: []
}, function ($methodClass){ return function (aRegularExpression){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.match(aRegularExpression);
return self;
}, function($ctx1) {$ctx1.fill(self,"matchesOf:",{aRegularExpression:aRegularExpression})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "printNl",
protocol: "printing",
args: [],
source: "printNl\x0a\x09<inlineJS: 'console.log(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["console.log(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
console.log(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"printNl",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream \x0a\x09\x09nextPutAll: '''';\x0a\x09\x09nextPutAll: (self replace: '''' with: '''''');\x0a\x09\x09nextPutAll: ''''",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "replace:with:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._nextPutAll_("'")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aStream)._nextPutAll_($self._replace_with_("'","''"))
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv(aStream)._nextPutAll_("'");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: "streaming",
args: ["aStream"],
source: "putOn: aStream\x0a\x09aStream nextPutString: self",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutString:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutString_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "remove:",
protocol: "adding/removing",
args: ["anObject"],
source: "remove: anObject\x0a\x09self errorReadOnly",
referencedClasses: [],
pragmas: [],
messageSends: ["errorReadOnly"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:",{anObject:anObject})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: "adding/removing",
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09self errorReadOnly",
referencedClasses: [],
pragmas: [],
messageSends: ["errorReadOnly"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._errorReadOnly();
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "replace:with:",
protocol: "regular expressions",
args: ["aString", "anotherString"],
source: "replace: aString with: anotherString\x0a\x09^ self replaceRegexp: (RegularExpression fromString: aString flag: 'g') with: anotherString",
referencedClasses: ["RegularExpression"],
pragmas: [],
messageSends: ["replaceRegexp:with:", "fromString:flag:"]
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._replaceRegexp_with_($recv($globals.RegularExpression)._fromString_flag_(aString,"g"),anotherString);
}, function($ctx1) {$ctx1.fill(self,"replace:with:",{aString:aString,anotherString:anotherString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "replaceRegexp:with:",
protocol: "regular expressions",
args: ["aRegexp", "aString"],
source: "replaceRegexp: aRegexp with: aString\x0a\x09<inlineJS: 'return self.replace(aRegexp, aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.replace(aRegexp, aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aRegexp,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.replace(aRegexp, aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"replaceRegexp:with:",{aRegexp:aRegexp,aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "reversed",
protocol: "converting",
args: [],
source: "reversed\x0a\x09<inlineJS: 'return self.split(\x22\x22).reverse().join(\x22\x22)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.split(\x22\x22).reverse().join(\x22\x22)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.split("").reverse().join("");
return self;
}, function($ctx1) {$ctx1.fill(self,"reversed",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "shallowCopy",
protocol: "copying",
args: [],
source: "shallowCopy\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "shortenedPrintString",
protocol: "printing",
args: [],
source: "shortenedPrintString\x0a\x09^ self printString size > 30\x0a\x09\x09ifTrue: [ (self printString copyFrom: 1 to: 30), '...''' ]\x0a\x09\x09ifFalse: [ self printString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", ">", "size", "printString", ",", "copyFrom:to:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv([$self._printString()
,$ctx1.sendIdx["printString"]=1
][0])._size()).__gt((30)))){
return $recv($recv([$self._printString()
,$ctx1.sendIdx["printString"]=2
][0])._copyFrom_to_((1),(30))).__comma("...'");
} else {
return $self._printString();
}
}, function($ctx1) {$ctx1.fill(self,"shortenedPrintString",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "subStrings:",
protocol: "split join",
args: ["aString"],
source: "subStrings: aString\x0a\x09^ self tokenize: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["tokenize:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._tokenize_(aString);
}, function($ctx1) {$ctx1.fill(self,"subStrings:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "symbolPrintString",
protocol: "printing",
args: [],
source: "symbolPrintString\x0a\x09^ String streamContents: [ :str | self asSymbolPrintOn: str ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "asSymbolPrintOn:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $self._asSymbolPrintOn_(str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"symbolPrintString",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "tokenize:",
protocol: "split join",
args: ["aString"],
source: "tokenize: aString\x0a\x09<inlineJS: 'return self.split(aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.split(aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.split(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"tokenize:",{aString:aString})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimBoth",
protocol: "regular expressions",
args: [],
source: "trimBoth\x0a\x09^ self trimBoth: '\x5cs'",
referencedClasses: [],
pragmas: [],
messageSends: ["trimBoth:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._trimBoth_("\x5cs");
}, function($ctx1) {$ctx1.fill(self,"trimBoth",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimBoth:",
protocol: "regular expressions",
args: ["separators"],
source: "trimBoth: separators\x0a\x09^ (self trimLeft: separators) trimRight: separators",
referencedClasses: [],
pragmas: [],
messageSends: ["trimRight:", "trimLeft:"]
}, function ($methodClass){ return function (separators){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._trimLeft_(separators))._trimRight_(separators);
}, function($ctx1) {$ctx1.fill(self,"trimBoth:",{separators:separators})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimLeft",
protocol: "regular expressions",
args: [],
source: "trimLeft\x0a\x09^ self trimLeft: '\x5cs'",
referencedClasses: [],
pragmas: [],
messageSends: ["trimLeft:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._trimLeft_("\x5cs");
}, function($ctx1) {$ctx1.fill(self,"trimLeft",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimLeft:",
protocol: "regular expressions",
args: ["separators"],
source: "trimLeft: separators\x0a\x09^ self replaceRegexp: (RegularExpression fromString: '^[', separators, ']+' flag: 'g') with: ''",
referencedClasses: ["RegularExpression"],
pragmas: [],
messageSends: ["replaceRegexp:with:", "fromString:flag:", ","]
}, function ($methodClass){ return function (separators){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._replaceRegexp_with_($recv($globals.RegularExpression)._fromString_flag_([$recv("^[".__comma(separators)).__comma("]+")
,$ctx1.sendIdx[","]=1
][0],"g"),"");
}, function($ctx1) {$ctx1.fill(self,"trimLeft:",{separators:separators})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimRight",
protocol: "regular expressions",
args: [],
source: "trimRight\x0a\x09^ self trimRight: '\x5cs'",
referencedClasses: [],
pragmas: [],
messageSends: ["trimRight:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._trimRight_("\x5cs");
}, function($ctx1) {$ctx1.fill(self,"trimRight",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "trimRight:",
protocol: "regular expressions",
args: ["separators"],
source: "trimRight: separators\x0a\x09^ self replaceRegexp: (RegularExpression fromString: '[', separators, ']+$' flag: 'g') with: ''",
referencedClasses: ["RegularExpression"],
pragmas: [],
messageSends: ["replaceRegexp:with:", "fromString:flag:", ","]
}, function ($methodClass){ return function (separators){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._replaceRegexp_with_($recv($globals.RegularExpression)._fromString_flag_([$recv("[".__comma(separators)).__comma("]+$")
,$ctx1.sendIdx[","]=1
][0],"g"),"");
}, function($ctx1) {$ctx1.fill(self,"trimRight:",{separators:separators})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "unescaped",
protocol: "converting",
args: [],
source: "unescaped\x0a\x09<inlineJS: 'return unescape(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return unescape(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return unescape(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"unescaped",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriComponentDecoded",
protocol: "converting",
args: [],
source: "uriComponentDecoded\x0a\x09<inlineJS: 'return decodeURIComponent(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return decodeURIComponent(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return decodeURIComponent(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriComponentDecoded",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriComponentEncoded",
protocol: "converting",
args: [],
source: "uriComponentEncoded\x0a\x09<inlineJS: 'return encodeURIComponent(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return encodeURIComponent(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return encodeURIComponent(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriComponentEncoded",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriDecoded",
protocol: "converting",
args: [],
source: "uriDecoded\x0a\x09<inlineJS: 'return decodeURI(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return decodeURI(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return decodeURI(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriDecoded",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "uriEncoded",
protocol: "converting",
args: [],
source: "uriEncoded\x0a\x09<inlineJS: 'return encodeURI(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return encodeURI(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return encodeURI(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"uriEncoded",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "evaluating",
args: ["anObject"],
source: "value: anObject \x0a\x09^ anObject perform: self",
referencedClasses: [],
pragmas: [],
messageSends: ["perform:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._perform_(self);
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject})});
}; }),
$globals.String);


$core.addMethod(
$core.method({
selector: "cr",
protocol: "accessing",
args: [],
source: "cr\x0a\x09<inlineJS: 'return \x22\x5cr\x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return \x22\x5cr\x22"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "\r";
return self;
}, function($ctx1) {$ctx1.fill(self,"cr",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "crlf",
protocol: "accessing",
args: [],
source: "crlf\x0a\x09<inlineJS: 'return \x22\x5cr\x5cn\x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return \x22\x5cr\x5cn\x22"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "\r\n";
return self;
}, function($ctx1) {$ctx1.fill(self,"crlf",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "esc",
protocol: "accessing",
args: [],
source: "esc\x0a\x09^ self fromCharCode: 27",
referencedClasses: [],
pragmas: [],
messageSends: ["fromCharCode:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._fromCharCode_((27));
}, function($ctx1) {$ctx1.fill(self,"esc",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "fromCharCode:",
protocol: "instance creation",
args: ["anInteger"],
source: "fromCharCode: anInteger\x0a\x09<inlineJS: 'return String.fromCharCode(anInteger)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return String.fromCharCode(anInteger)"]]],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return String.fromCharCode(anInteger);
return self;
}, function($ctx1) {$ctx1.fill(self,"fromCharCode:",{anInteger:anInteger})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "fromString:",
protocol: "instance creation",
args: ["aString"],
source: "fromString: aString\x0a\x09\x09<inlineJS: 'return String(aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return String(aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return String(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "lf",
protocol: "accessing",
args: [],
source: "lf\x0a\x09<inlineJS: 'return \x22\x5cn\x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return \x22\x5cn\x22"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "\n";
return self;
}, function($ctx1) {$ctx1.fill(self,"lf",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "random",
protocol: "random",
args: [],
source: "random\x0a\x09\x22Returns random alphanumeric string beginning with letter\x22\x0a\x09<inlineJS: 'return ((10+22*Math.random())/32).toString(32).slice(2);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return ((10+22*Math.random())/32).toString(32).slice(2);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return ((10+22*Math.random())/32).toString(32).slice(2);;
return self;
}, function($ctx1) {$ctx1.fill(self,"random",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "randomNotIn:",
protocol: "random",
args: ["aString"],
source: "randomNotIn: aString\x0a\x09| result |\x0a\x09[ result := self random. aString includesSubString: result ] whileTrue.\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["whileTrue", "random", "includesSubString:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
result=$self._random();
return $recv(aString)._includesSubString_(result);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue();
return result;
}, function($ctx1) {$ctx1.fill(self,"randomNotIn:",{aString:aString,result:result})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "space",
protocol: "accessing",
args: [],
source: "space\x0a\x09<inlineJS: 'return \x22 \x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return \x22 \x22"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return " ";
return self;
}, function($ctx1) {$ctx1.fill(self,"space",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "streamClass",
protocol: "accessing",
args: [],
source: "streamClass\x0a\x09\x09^ StringStream",
referencedClasses: ["StringStream"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.StringStream;

}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "tab",
protocol: "accessing",
args: [],
source: "tab\x0a\x09<inlineJS: 'return \x22\x5ct\x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return \x22\x5ct\x22"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "\t";
return self;
}, function($ctx1) {$ctx1.fill(self,"tab",{})});
}; }),
$globals.String.a$cls);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "instance creation",
args: ["aUTFCharCode"],
source: "value: aUTFCharCode\x0a\x0a\x09<inlineJS: 'return String.fromCharCode(aUTFCharCode);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return String.fromCharCode(aUTFCharCode);"]]],
messageSends: []
}, function ($methodClass){ return function (aUTFCharCode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return String.fromCharCode(aUTFCharCode);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:",{aUTFCharCode:aUTFCharCode})});
}; }),
$globals.String.a$cls);


$core.addClass("Set", $globals.Collection, "Kernel-Collections");
$core.setSlots($globals.Set, ["defaultBucket", "slowBucketStores", "fastBuckets", "size"]);
$globals.Set.comment="I represent an unordered set of objects without duplicates.\x0a\x0a## Implementation notes\x0a\x0aI put elements into different stores based on their type.\x0aThe goal is to store some elements into native JS object property names to be fast.\x0a\x0aIf an unboxed element has typeof 'string', 'boolean' or 'number', or an element is nil, null or undefined,\x0aI store it as a property name in an empty (== Object.create(null)) JS object, different for each type\x0a(for simplicity, nil/null/undefined is treated as one and included with the two booleans).\x0a\x0aIf element happen to be an object, I try to store them in `ArrayBucketStore`. I have two of them by default,\x0aone hashed using the Smalltalk class name, the other one using the JS constructor name. It is possible to have more or less\x0ainstances of `ArrayBucketStores`, see `#initializeSlowBucketStores`.\x0a\x0aAs a last resort, if none of the `ArrayBucketStore` instances can find a suitable bucket, the `defaultBucket` is used,\x0awhich is an `Array`.";
$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["aCollection"],
source: "= aCollection\x0a\x09^ self class = aCollection class and: [\x0a\x09\x09self size = aCollection size and: [\x0a\x09\x09\x09self allSatisfy: [ :each | aCollection includes: each ] ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "=", "class", "size", "allSatisfy:", "includes:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq($recv(aCollection)._class())
,$ctx1.sendIdx["="]=1
][0])){
if($core.assert($recv([$self._size()
,$ctx1.sendIdx["size"]=1
][0]).__eq($recv(aCollection)._size()))){
return $self._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aCollection)._includes_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
} else {
return false;
}
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{aCollection:aCollection})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "add:",
protocol: "adding/removing",
args: ["anObject"],
source: "add: anObject\x0a\x09| bucket |\x0a\x09bucket := self bucketsOfElement: anObject.\x0a\x09^ bucket second\x0a\x09\x09ifNil: [\x0a\x09\x09\x09| object slowBucket |\x0a\x09\x09\x09object := bucket first.\x0a\x09\x09\x09slowBucket := bucket third.\x0a\x09\x09\x09slowBucket \x0a\x09\x09\x09\x09indexOf: object \x0a\x09\x09\x09\x09ifAbsent: [ \x0a\x09\x09\x09\x09\x09slowBucket add: object. \x0a\x09\x09\x09\x09\x09size := size + 1 ].\x0a\x09\x09\x09object ]\x0a\x09\x09ifNotNil: [ :primitiveBucket | \x0a\x09\x09\x09self \x0a\x09\x09\x09\x09add: bucket first \x0a\x09\x09\x09\x09in: primitiveBucket ]",
referencedClasses: [],
pragmas: [],
messageSends: ["bucketsOfElement:", "ifNil:ifNotNil:", "second", "first", "third", "indexOf:ifAbsent:", "add:", "+", "add:in:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
var bucket;
return $core.withContext(function($ctx1) {
var $1;
bucket=$self._bucketsOfElement_(anObject);
$1=$recv(bucket)._second();
if($1 == null || $1.a$nil){
var object,slowBucket;
object=[$recv(bucket)._first()
,$ctx1.sendIdx["first"]=1
][0];
slowBucket=$recv(bucket)._third();
$recv(slowBucket)._indexOf_ifAbsent_(object,(function(){
return $core.withContext(function($ctx2) {
$recv(slowBucket)._add_(object);
$self.size=$recv($self.size).__plus((1));
return $self.size;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return object;
} else {
var primitiveBucket;
primitiveBucket=$1;
return $self._add_in_($recv(bucket)._first(),primitiveBucket);
}
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject,bucket:bucket})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "add:in:",
protocol: "private",
args: ["anObject", "anotherObject"],
source: "add: anObject in: anotherObject\x0a\x09<inlineJS: '\x0a\x09\x09if (anObject in anotherObject.store) { return anObject; }\x0a\x09\x09$self.size++;\x0a\x09\x09anotherObject.store[anObject] = true;\x0a\x09\x09return anObject;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if (anObject in anotherObject.store) { return anObject; }\x0a\x09\x09$self.size++;\x0a\x09\x09anotherObject.store[anObject] = true;\x0a\x09\x09return anObject;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,anotherObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if (anObject in anotherObject.store) { return anObject; }
		$self.size++;
		anotherObject.store[anObject] = true;
		return anObject;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"add:in:",{anObject:anObject,anotherObject:anotherObject})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "bucketsOfElement:",
protocol: "private",
args: ["anObject"],
source: "bucketsOfElement: anObject\x0a\x09\x22Find the appropriate bucket for `anObject`.\x0a\x09For optimization purposes, directly answer an array with: \x0a\x09- the object to be store\x0a\x09- the primitive bucket\x0a\x09- the slow bucket\x22\x0a\x09\x0a\x09<inlineJS: '\x0a\x09\x09// include nil to well-known objects under \x22boolean\x22 fastBucket\x0a\x09\x09if (anObject == null || anObject.a$nil) return [ null, $self.fastBuckets.boolean ];\x0a\x09\x09\x0a\x09\x09var prim = anObject.valueOf();\x0a\x09\x09if (typeof prim === \x22object\x22 || typeof prim === \x22function\x22 || !$self.fastBuckets[typeof prim]) {\x0a\x09\x09\x09var bucket = null;\x0a\x09\x09\x09$self.slowBucketStores.some(function (store) {\x0a\x09\x09\x09\x09return bucket = store._bucketOfElement_(anObject);\x0a\x09\x09\x09});\x0a\x09\x09\x09return [ anObject, null, bucket || $self.defaultBucket ];\x0a\x09\x09}\x0a\x09\x09return [ prim, $self.fastBuckets[typeof prim] ];\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09// include nil to well-known objects under \x22boolean\x22 fastBucket\x0a\x09\x09if (anObject == null || anObject.a$nil) return [ null, $self.fastBuckets.boolean ];\x0a\x09\x09\x0a\x09\x09var prim = anObject.valueOf();\x0a\x09\x09if (typeof prim === \x22object\x22 || typeof prim === \x22function\x22 || !$self.fastBuckets[typeof prim]) {\x0a\x09\x09\x09var bucket = null;\x0a\x09\x09\x09$self.slowBucketStores.some(function (store) {\x0a\x09\x09\x09\x09return bucket = store._bucketOfElement_(anObject);\x0a\x09\x09\x09});\x0a\x09\x09\x09return [ anObject, null, bucket || $self.defaultBucket ];\x0a\x09\x09}\x0a\x09\x09return [ prim, $self.fastBuckets[typeof prim] ];\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		// include nil to well-known objects under "boolean" fastBucket
		if (anObject == null || anObject.a$nil) return [ null, $self.fastBuckets.boolean ];
		
		var prim = anObject.valueOf();
		if (typeof prim === "object" || typeof prim === "function" || !$self.fastBuckets[typeof prim]) {
			var bucket = null;
			$self.slowBucketStores.some(function (store) {
				return bucket = store._bucketOfElement_(anObject);
			});
			return [ anObject, null, bucket || $self.defaultBucket ];
		}
		return [ prim, $self.fastBuckets[typeof prim] ];
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"bucketsOfElement:",{anObject:anObject})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "classNameOf:",
protocol: "private",
args: ["anObject"],
source: "classNameOf: anObject\x0a\x09\x22Answer the class name of `anObject`, or `undefined` \x0a\x09if `anObject` is not an Smalltalk object\x22\x0a\x09\x0a\x09<inlineJS: 'return anObject.a$cls != null && anObject.a$cls.name'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return anObject.a$cls != null && anObject.a$cls.name"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return anObject.a$cls != null && anObject.a$cls.name;
return self;
}, function($ctx1) {$ctx1.fill(self,"classNameOf:",{anObject:anObject})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "collect:",
protocol: "enumerating",
args: ["aBlock"],
source: "collect: aBlock\x0a\x09| collection |\x0a\x09collection := self class new.\x0a\x09self do: [ :each | collection add: (aBlock value: each) ].\x0a\x09^ collection",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "do:", "add:", "value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var collection;
return $core.withContext(function($ctx1) {
collection=$recv($self._class())._new();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(collection)._add_($recv(aBlock)._value_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return collection;
}, function($ctx1) {$ctx1.fill(self,"collect:",{aBlock:aBlock,collection:collection})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "do:",
protocol: "enumerating",
args: ["aBlock"],
source: "do: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09var el, keys, i;\x0a\x09\x09el = $self.fastBuckets;\x0a\x09\x09keys = Object.keys(el);\x0a\x09\x09for (i = 0; i < keys.length; ++i) {\x0a\x09\x09\x09var fastBucket = el[keys[i]], fn = fastBucket.fn, store = Object.keys(fastBucket.store);\x0a\x09\x09\x09if (fn) { for (var j = 0; j < store.length; ++j) { aBlock._value_(fn(store[j])); } }\x0a\x09\x09\x09else { store._do_(aBlock); }\x0a\x09\x09}\x0a\x09\x09el = $self.slowBucketStores;\x0a\x09\x09for (i = 0; i < el.length; ++i) { el[i]._do_(aBlock); }\x0a\x09\x09$self.defaultBucket._do_(aBlock);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var el, keys, i;\x0a\x09\x09el = $self.fastBuckets;\x0a\x09\x09keys = Object.keys(el);\x0a\x09\x09for (i = 0; i < keys.length; ++i) {\x0a\x09\x09\x09var fastBucket = el[keys[i]], fn = fastBucket.fn, store = Object.keys(fastBucket.store);\x0a\x09\x09\x09if (fn) { for (var j = 0; j < store.length; ++j) { aBlock._value_(fn(store[j])); } }\x0a\x09\x09\x09else { store._do_(aBlock); }\x0a\x09\x09}\x0a\x09\x09el = $self.slowBucketStores;\x0a\x09\x09for (i = 0; i < el.length; ++i) { el[i]._do_(aBlock); }\x0a\x09\x09$self.defaultBucket._do_(aBlock);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var el, keys, i;
		el = $self.fastBuckets;
		keys = Object.keys(el);
		for (i = 0; i < keys.length; ++i) {
			var fastBucket = el[keys[i]], fn = fastBucket.fn, store = Object.keys(fastBucket.store);
			if (fn) { for (var j = 0; j < store.length; ++j) { aBlock._value_(fn(store[j])); } }
			else { store._do_(aBlock); }
		}
		el = $self.slowBucketStores;
		for (i = 0; i < el.length; ++i) { el[i]._do_(aBlock); }
		$self.defaultBucket._do_(aBlock);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "includes:",
protocol: "testing",
args: ["anObject"],
source: "includes: anObject\x0a\x09| bucket |\x0a\x09bucket := self bucketsOfElement: anObject.\x0a\x09^ bucket second\x0a\x09\x09ifNil: [ bucket third includes: bucket first ]\x0a\x09\x09ifNotNil: [ :primitiveBucket | self includes: bucket first in: primitiveBucket ]",
referencedClasses: [],
pragmas: [],
messageSends: ["bucketsOfElement:", "ifNil:ifNotNil:", "second", "includes:", "third", "first", "includes:in:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
var bucket;
return $core.withContext(function($ctx1) {
var $1;
bucket=$self._bucketsOfElement_(anObject);
$1=$recv(bucket)._second();
if($1 == null || $1.a$nil){
return $recv($recv(bucket)._third())._includes_([$recv(bucket)._first()
,$ctx1.sendIdx["first"]=1
][0]);
} else {
var primitiveBucket;
primitiveBucket=$1;
return $self._includes_in_($recv(bucket)._first(),primitiveBucket);
}
}, function($ctx1) {$ctx1.fill(self,"includes:",{anObject:anObject,bucket:bucket})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "includes:in:",
protocol: "private",
args: ["anObject", "anotherObject"],
source: "includes: anObject in: anotherObject\x0a\x09<inlineJS: 'return anObject in anotherObject.store'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return anObject in anotherObject.store"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,anotherObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return anObject in anotherObject.store;
return self;
}, function($ctx1) {$ctx1.fill(self,"includes:in:",{anObject:anObject,anotherObject:anotherObject})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09\x0a\x09defaultBucket := #().\x0a\x09self\x0a\x09\x09initializeSlowBucketStores;\x0a\x09\x09removeAll",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "initializeSlowBucketStores", "removeAll"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.defaultBucket=[];
$self._initializeSlowBucketStores();
$self._removeAll();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "initializeSlowBucketStores",
protocol: "initialization",
args: [],
source: "initializeSlowBucketStores\x0a\x09slowBucketStores := {\x0a\x09\x09ArrayBucketStore hashBlock: [ :x | self classNameOf: x ].\x0a\x09\x09ArrayBucketStore hashBlock: [ :x | self jsConstructorNameOf: x ]\x0a\x09}",
referencedClasses: ["ArrayBucketStore"],
pragmas: [],
messageSends: ["hashBlock:", "classNameOf:", "jsConstructorNameOf:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.slowBucketStores=[[$recv($globals.ArrayBucketStore)._hashBlock_((function(x){
return $core.withContext(function($ctx2) {
return $self._classNameOf_(x);
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}))
,$ctx1.sendIdx["hashBlock:"]=1
][0],$recv($globals.ArrayBucketStore)._hashBlock_((function(x){
return $core.withContext(function($ctx2) {
return $self._jsConstructorNameOf_(x);
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,2)});
}))];
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeSlowBucketStores",{})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "jsConstructorNameOf:",
protocol: "private",
args: ["anObject"],
source: "jsConstructorNameOf: anObject\x0a\x09<inlineJS: 'return anObject.constructor && anObject.constructor.name'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return anObject.constructor && anObject.constructor.name"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return anObject.constructor && anObject.constructor.name;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsConstructorNameOf:",{anObject:anObject})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09\x0a\x09aStream nextPutAll: ' ('.\x0a\x09self \x0a\x09\x09do: [ :each | each printOn: aStream ]\x0a\x09\x09separatedBy: [ aStream nextPutAll: ' ' ].\x0a\x09aStream nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "do:separatedBy:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.sendIdx["printOn:"]=1,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_(" (")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$self._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printOn_(aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$recv(aStream)._nextPutAll_(" ")
,$ctx2.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "remove:ifAbsent:",
protocol: "adding/removing",
args: ["anObject", "aBlock"],
source: "remove: anObject ifAbsent: aBlock\x0a\x09| bucket |\x0a\x09bucket := self bucketsOfElement: anObject.\x0a\x09^ bucket second\x0a\x09\x09ifNil: [ | obj | obj := bucket first. bucket third remove: obj ifAbsent: [ ^aBlock value ]. size := size - 1. obj ]\x0a\x09\x09ifNotNil: [ :primitiveBucket | self remove: bucket first in: primitiveBucket ifAbsent: aBlock ]",
referencedClasses: [],
pragmas: [],
messageSends: ["bucketsOfElement:", "ifNil:ifNotNil:", "second", "first", "remove:ifAbsent:", "third", "value", "-", "remove:in:ifAbsent:"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
var bucket;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
bucket=$self._bucketsOfElement_(anObject);
$1=$recv(bucket)._second();
if($1 == null || $1.a$nil){
var obj;
obj=[$recv(bucket)._first()
,$ctx1.sendIdx["first"]=1
][0];
$recv($recv(bucket)._third())._remove_ifAbsent_(obj,(function(){
return $core.withContext(function($ctx2) {
throw $early=[$recv(aBlock)._value()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$self.size=$recv($self.size).__minus((1));
return obj;
} else {
var primitiveBucket;
primitiveBucket=$1;
return $self._remove_in_ifAbsent_($recv(bucket)._first(),primitiveBucket,aBlock);
}
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"remove:ifAbsent:",{anObject:anObject,aBlock:aBlock,bucket:bucket})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "remove:in:ifAbsent:",
protocol: "private",
args: ["anObject", "anotherObject", "aBlock"],
source: "remove: anObject in: anotherObject ifAbsent: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09if (anObject in anotherObject.store) {\x0a\x09\x09\x09delete anotherObject.store[anObject];\x0a\x09\x09\x09$self.size--;\x0a\x09\x09\x09return anObject;\x0a\x09\x09} else {\x0a\x09\x09\x09return aBlock._value();\x0a\x09\x09}'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09if (anObject in anotherObject.store) {\x0a\x09\x09\x09delete anotherObject.store[anObject];\x0a\x09\x09\x09$self.size--;\x0a\x09\x09\x09return anObject;\x0a\x09\x09} else {\x0a\x09\x09\x09return aBlock._value();\x0a\x09\x09}"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,anotherObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		if (anObject in anotherObject.store) {
			delete anotherObject.store[anObject];
			$self.size--;
			return anObject;
		} else {
			return aBlock._value();
		};
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:in:ifAbsent:",{anObject:anObject,anotherObject:anotherObject,aBlock:aBlock})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "removeAll",
protocol: "adding/removing",
args: [],
source: "removeAll\x0a\x09<inlineJS: '\x0a\x09\x09$self.fastBuckets = {\x0a\x09\x09\x09\x22boolean\x22: { store: Object.create(null), fn: function (x) { return {\x22true\x22: true, \x22false\x22: false, \x22null\x22: null}[x]; } },\x0a\x09\x09\x09\x22number\x22: { store: Object.create(null), fn: Number },\x0a\x09\x09\x09\x22string\x22: { store: Object.create(null) }\x0a\x09\x09};\x0a\x09\x09$self.slowBucketStores.forEach(function (x) { x._removeAll(); });\x0a\x09\x09$self.defaultBucket._removeAll();\x0a\x09\x09$self.size = 0;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09$self.fastBuckets = {\x0a\x09\x09\x09\x22boolean\x22: { store: Object.create(null), fn: function (x) { return {\x22true\x22: true, \x22false\x22: false, \x22null\x22: null}[x]; } },\x0a\x09\x09\x09\x22number\x22: { store: Object.create(null), fn: Number },\x0a\x09\x09\x09\x22string\x22: { store: Object.create(null) }\x0a\x09\x09};\x0a\x09\x09$self.slowBucketStores.forEach(function (x) { x._removeAll(); });\x0a\x09\x09$self.defaultBucket._removeAll();\x0a\x09\x09$self.size = 0;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		$self.fastBuckets = {
			"boolean": { store: Object.create(null), fn: function (x) { return {"true": true, "false": false, "null": null}[x]; } },
			"number": { store: Object.create(null), fn: Number },
			"string": { store: Object.create(null) }
		};
		$self.slowBucketStores.forEach(function (x) { x._removeAll(); });
		$self.defaultBucket._removeAll();
		$self.size = 0;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeAll",{})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "select:",
protocol: "enumerating",
args: ["aBlock"],
source: "select: aBlock\x0a\x09| collection |\x0a\x09collection := self class new.\x0a\x09self do: [ :each |\x0a\x09\x09(aBlock value: each) ifTrue: [\x0a\x09\x09\x09collection add: each ] ].\x0a\x09^ collection",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "do:", "ifTrue:", "value:", "add:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var collection;
return $core.withContext(function($ctx1) {
collection=$recv($self._class())._new();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(aBlock)._value_(each))){
return $recv(collection)._add_(each);
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return collection;
}, function($ctx1) {$ctx1.fill(self,"select:",{aBlock:aBlock,collection:collection})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "select:thenCollect:",
protocol: "enumerating",
args: ["selectBlock", "collectBlock"],
source: "select: selectBlock thenCollect: collectBlock\x0a\x09| collection |\x0a\x09collection := self class new.\x0a\x09self do: [ :each |\x0a\x09\x09(selectBlock value: each) ifTrue: [\x0a\x09\x09\x09collection add: (collectBlock value: each) ] ].\x0a\x09^ collection",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "do:", "ifTrue:", "value:", "add:"]
}, function ($methodClass){ return function (selectBlock,collectBlock){
var self=this,$self=this;
var collection;
return $core.withContext(function($ctx1) {
collection=$recv($self._class())._new();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert([$recv(selectBlock)._value_(each)
,$ctx2.sendIdx["value:"]=1
][0])){
return $recv(collection)._add_($recv(collectBlock)._value_(each));
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return collection;
}, function($ctx1) {$ctx1.fill(self,"select:thenCollect:",{selectBlock:selectBlock,collectBlock:collectBlock,collection:collection})});
}; }),
$globals.Set);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09^ size",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.size;

}; }),
$globals.Set);



$core.addClass("ProtoStream", $globals.Object, "Kernel-Collections");
$globals.ProtoStream.comment="I am the abstract base for different accessor for a sequence of objects. This sequence is referred to as my \x22contents\x22.\x0aMy instances are read/write streams modifying the contents.";
$core.addMethod(
$core.method({
selector: "<<",
protocol: "writing",
args: ["anObject"],
source: "<< anObject\x0a\x09self write: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["write:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._write_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"<<",{anObject:anObject})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "atEnd",
protocol: "testing",
args: [],
source: "atEnd\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"atEnd",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "atStart",
protocol: "testing",
args: [],
source: "atStart\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"atStart",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "contents",
protocol: "accessing",
args: [],
source: "contents\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"contents",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "do:",
protocol: "enumerating",
args: ["aBlock"],
source: "do: aBlock\x0a\x09[ self atEnd ] whileFalse: [ aBlock value: self next ]",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", "atEnd", "value:", "next"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_($self._next());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "isEmpty",
protocol: "testing",
args: [],
source: "isEmpty\x0a\x09^ self atStart and: [ self atEnd ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "atStart", "atEnd"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._atStart())){
return $self._atEnd();
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"isEmpty",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "next",
protocol: "reading",
args: [],
source: "next\x0a\x09^ self atEnd\x0a\x09\x09ifTrue: [ nil ]\x0a\x09\x09ifFalse: [ self subclassResponsibility ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._atEnd())){
return nil;
} else {
return $self._subclassResponsibility();
}
}, function($ctx1) {$ctx1.fill(self,"next",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: "writing",
args: ["anObject"],
source: "nextPut: anObject\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{anObject:anObject})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPutAll:",
protocol: "writing",
args: ["aCollection"],
source: "nextPutAll: aCollection\x0a\x09aCollection do: [ :each |\x0a\x09\x09self nextPut: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "nextPut:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._nextPut_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAll:",{aCollection:aCollection})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "nextPutString:",
protocol: "writing",
args: ["aString"],
source: "nextPutString: aString\x0a\x09self nextPut: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPut:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nextPut_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutString:",{aString:aString})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "peek",
protocol: "reading",
args: [],
source: "peek\x0a\x09^ self atEnd\x0a\x09\x09ifTrue: [ nil ]\x0a\x09\x09ifFalse: [ self subclassResponsibility ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._atEnd())){
return nil;
} else {
return $self._subclassResponsibility();
}
}, function($ctx1) {$ctx1.fill(self,"peek",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "reset",
protocol: "actions",
args: [],
source: "reset\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"reset",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "resetContents",
protocol: "actions",
args: [],
source: "resetContents\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"resetContents",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "setToEnd",
protocol: "positioning",
args: [],
source: "setToEnd\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"setToEnd",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "setToStart",
protocol: "positioning",
args: [],
source: "setToStart\x0a\x09self reset",
referencedClasses: [],
pragmas: [],
messageSends: ["reset"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._reset();
return self;
}, function($ctx1) {$ctx1.fill(self,"setToStart",{})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "write:",
protocol: "writing",
args: ["anObject"],
source: "write: anObject\x0a\x09anObject putOn: self",
referencedClasses: [],
pragmas: [],
messageSends: ["putOn:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anObject)._putOn_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"write:",{anObject:anObject})});
}; }),
$globals.ProtoStream);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aCollection"],
source: "on: aCollection\x0a\x09\x09^ self new\x0a\x09\x09setCollection: aCollection;\x0a\x09\x09setStreamSize: aCollection size;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["setCollection:", "new", "setStreamSize:", "size", "yourself"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._setCollection_(aCollection);
$recv($1)._setStreamSize_($recv(aCollection)._size());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aCollection:aCollection})});
}; }),
$globals.ProtoStream.a$cls);


$core.addClass("Stream", $globals.ProtoStream, "Kernel-Collections");
$core.setSlots($globals.Stream, ["collection", "position", "streamSize"]);
$globals.Stream.comment="I represent an accessor for a sequence of objects. This sequence is referred to as my \x22contents\x22.\x0aMy instances are read/write streams to the contents sequence collection.";
$core.addMethod(
$core.method({
selector: "atEnd",
protocol: "testing",
args: [],
source: "atEnd\x0a\x09^ self position = self size",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "position", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._position()).__eq($self._size());
}, function($ctx1) {$ctx1.fill(self,"atEnd",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "atStart",
protocol: "testing",
args: [],
source: "atStart\x0a\x09^ self position = 0",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "position"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._position()).__eq((0));
}, function($ctx1) {$ctx1.fill(self,"atStart",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "close",
protocol: "actions",
args: [],
source: "close",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "collection",
protocol: "accessing",
args: [],
source: "collection\x0a\x09^ collection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.collection;

}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "contents",
protocol: "accessing",
args: [],
source: "contents\x0a\x09^ self collection\x0a\x09\x09copyFrom: 1\x0a\x09\x09to: self streamSize",
referencedClasses: [],
pragmas: [],
messageSends: ["copyFrom:to:", "collection", "streamSize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._collection())._copyFrom_to_((1),$self._streamSize());
}, function($ctx1) {$ctx1.fill(self,"contents",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "flush",
protocol: "actions",
args: [],
source: "flush",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "isEmpty",
protocol: "testing",
args: [],
source: "isEmpty\x0a\x09^ self size = 0",
referencedClasses: [],
pragmas: [],
messageSends: ["=", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._size()).__eq((0));
}, function($ctx1) {$ctx1.fill(self,"isEmpty",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "next",
protocol: "reading",
args: [],
source: "next\x0a\x09^ self atEnd\x0a\x09\x09ifTrue: [ nil ]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09self position: self position + 1.\x0a\x09\x09\x09collection at: self position ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "atEnd", "position:", "+", "position", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._atEnd())){
return nil;
} else {
$self._position_($recv([$self._position()
,$ctx1.sendIdx["position"]=1
][0]).__plus((1)));
return $recv($self.collection)._at_($self._position());
}
}, function($ctx1) {$ctx1.fill(self,"next",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "next:",
protocol: "reading",
args: ["anInteger"],
source: "next: anInteger\x0a\x09| tempCollection |\x0a\x09tempCollection := self collection class new.\x0a\x09anInteger timesRepeat: [\x0a\x09\x09self atEnd ifFalse: [\x0a\x09\x09tempCollection add: self next ]].\x0a\x09^ tempCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "collection", "timesRepeat:", "ifFalse:", "atEnd", "add:", "next"]
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
var tempCollection;
return $core.withContext(function($ctx1) {
tempCollection=$recv($recv($self._collection())._class())._new();
$recv(anInteger)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
if(!$core.assert($self._atEnd())){
return $recv(tempCollection)._add_($self._next());
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return tempCollection;
}, function($ctx1) {$ctx1.fill(self,"next:",{anInteger:anInteger,tempCollection:tempCollection})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: "writing",
args: ["anObject"],
source: "nextPut: anObject\x0a\x09self position: self position + 1.\x0a\x09self collection at: self position put: anObject.\x0a\x09self setStreamSize: (self streamSize max: self position)",
referencedClasses: [],
pragmas: [],
messageSends: ["position:", "+", "position", "at:put:", "collection", "setStreamSize:", "max:", "streamSize"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._position_($recv([$self._position()
,$ctx1.sendIdx["position"]=1
][0]).__plus((1)));
$recv($self._collection())._at_put_([$self._position()
,$ctx1.sendIdx["position"]=2
][0],anObject);
$self._setStreamSize_($recv($self._streamSize())._max_($self._position()));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{anObject:anObject})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "peek",
protocol: "reading",
args: [],
source: "peek\x0a\x09^ self atEnd ifFalse: [\x0a\x09\x09self collection at: self position + 1 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "atEnd", "at:", "collection", "+", "position"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($self._atEnd())){
return $recv($self._collection())._at_($recv($self._position()).__plus((1)));
}
}, function($ctx1) {$ctx1.fill(self,"peek",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "position",
protocol: "accessing",
args: [],
source: "position\x0a\x09^ position ifNil: [ position := 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.position;
if($1 == null || $1.a$nil){
$self.position=(0);
return $self.position;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"position",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "position:",
protocol: "accessing",
args: ["anInteger"],
source: "position: anInteger\x0a\x09position := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.position=anInteger;
return self;

}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "reset",
protocol: "actions",
args: [],
source: "reset\x0a\x09self position: 0",
referencedClasses: [],
pragmas: [],
messageSends: ["position:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._position_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"reset",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "resetContents",
protocol: "actions",
args: [],
source: "resetContents\x0a\x09self reset.\x0a\x09self setStreamSize: 0",
referencedClasses: [],
pragmas: [],
messageSends: ["reset", "setStreamSize:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._reset();
$self._setStreamSize_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"resetContents",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "setCollection:",
protocol: "accessing",
args: ["aCollection"],
source: "setCollection: aCollection\x0a\x09collection := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.collection=aCollection;
return self;

}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "setStreamSize:",
protocol: "accessing",
args: ["anInteger"],
source: "setStreamSize: anInteger\x0a\x09streamSize := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.streamSize=anInteger;
return self;

}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "setToEnd",
protocol: "positioning",
args: [],
source: "setToEnd\x0a\x09self position: self size",
referencedClasses: [],
pragmas: [],
messageSends: ["position:", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._position_($self._size());
return self;
}, function($ctx1) {$ctx1.fill(self,"setToEnd",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09^ self streamSize",
referencedClasses: [],
pragmas: [],
messageSends: ["streamSize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._streamSize();
}, function($ctx1) {$ctx1.fill(self,"size",{})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "skip:",
protocol: "positioning",
args: ["anInteger"],
source: "skip: anInteger\x0a\x09self position: ((self position + anInteger) min: self size max: 0)",
referencedClasses: [],
pragmas: [],
messageSends: ["position:", "min:max:", "+", "position", "size"]
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._position_($recv($recv($self._position()).__plus(anInteger))._min_max_($self._size(),(0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"skip:",{anInteger:anInteger})});
}; }),
$globals.Stream);

$core.addMethod(
$core.method({
selector: "streamSize",
protocol: "accessing",
args: [],
source: "streamSize\x0a\x09^ streamSize",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.streamSize;

}; }),
$globals.Stream);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aCollection"],
source: "on: aCollection\x0a\x09\x09^ self new\x0a\x09\x09setCollection: aCollection;\x0a\x09\x09setStreamSize: aCollection size;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["setCollection:", "new", "setStreamSize:", "size", "yourself"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._setCollection_(aCollection);
$recv($1)._setStreamSize_($recv(aCollection)._size());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aCollection:aCollection})});
}; }),
$globals.Stream.a$cls);


$core.addClass("StringStream", $globals.Stream, "Kernel-Collections");
$globals.StringStream.comment="I am a Stream specific to `String` objects.";
$core.addMethod(
$core.method({
selector: "cr",
protocol: "writing",
args: [],
source: "cr\x0a\x09^ self nextPutAll: String cr",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["nextPutAll:", "cr"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._nextPutAll_($recv($globals.String)._cr());
}, function($ctx1) {$ctx1.fill(self,"cr",{})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "crlf",
protocol: "writing",
args: [],
source: "crlf\x0a\x09^ self nextPutAll: String crlf",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["nextPutAll:", "crlf"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._nextPutAll_($recv($globals.String)._crlf());
}, function($ctx1) {$ctx1.fill(self,"crlf",{})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "lf",
protocol: "writing",
args: [],
source: "lf\x0a\x09^ self nextPutAll: String lf",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["nextPutAll:", "lf"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._nextPutAll_($recv($globals.String)._lf());
}, function($ctx1) {$ctx1.fill(self,"lf",{})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "next:",
protocol: "reading",
args: ["anInteger"],
source: "next: anInteger\x0a\x09| tempCollection |\x0a\x09tempCollection := self collection class new.\x0a\x09anInteger timesRepeat: [\x0a\x09\x09self atEnd ifFalse: [\x0a\x09\x09tempCollection := tempCollection, self next ]].\x0a\x09^ tempCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "class", "collection", "timesRepeat:", "ifFalse:", "atEnd", ",", "next"]
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
var tempCollection;
return $core.withContext(function($ctx1) {
tempCollection=$recv($recv($self._collection())._class())._new();
$recv(anInteger)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
if(!$core.assert($self._atEnd())){
tempCollection=$recv(tempCollection).__comma($self._next());
return tempCollection;
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return tempCollection;
}, function($ctx1) {$ctx1.fill(self,"next:",{anInteger:anInteger,tempCollection:tempCollection})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: "writing",
args: ["aString"],
source: "nextPut: aString\x0a\x09self nextPutAll: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nextPutAll_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{aString:aString})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "nextPutAll:",
protocol: "writing",
args: ["aString"],
source: "nextPutAll: aString\x0a\x09| pre post |\x0a\x09self position = self collection size ifTrue: [ self setCollection: self collection, aString ] ifFalse: [\x0a\x09\x09pre := self collection copyFrom: 1 to: self position.\x0a\x09\x09post := self collection copyFrom: (self position + 1 + aString size) to: self collection size.\x0a\x09\x09self setCollection: pre, aString, post\x0a\x09].\x0a\x09self position: self position + aString size.\x0a\x09self setStreamSize: (self streamSize max: self position)",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "=", "position", "size", "collection", "setCollection:", ",", "copyFrom:to:", "+", "position:", "setStreamSize:", "max:", "streamSize"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var pre,post;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$self._position()
,$ctx1.sendIdx["position"]=1
][0]).__eq([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._size()
,$ctx1.sendIdx["size"]=1
][0]))){
[$self._setCollection_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0]).__comma(aString)
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["setCollection:"]=1
][0];
} else {
pre=[$recv([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])._copyFrom_to_((1),[$self._position()
,$ctx1.sendIdx["position"]=2
][0])
,$ctx1.sendIdx["copyFrom:to:"]=1
][0];
post=$recv([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])._copyFrom_to_([$recv([$recv([$self._position()
,$ctx1.sendIdx["position"]=3
][0]).__plus((1))
,$ctx1.sendIdx["+"]=2
][0]).__plus([$recv(aString)._size()
,$ctx1.sendIdx["size"]=2
][0])
,$ctx1.sendIdx["+"]=1
][0],[$recv($self._collection())._size()
,$ctx1.sendIdx["size"]=3
][0]);
$self._setCollection_([$recv($recv(pre).__comma(aString)).__comma(post)
,$ctx1.sendIdx[","]=2
][0]);
}
$self._position_($recv([$self._position()
,$ctx1.sendIdx["position"]=4
][0]).__plus($recv(aString)._size()));
$self._setStreamSize_($recv($self._streamSize())._max_($self._position()));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAll:",{aString:aString,pre:pre,post:post})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "nextPutString:",
protocol: "writing",
args: ["aString"],
source: "nextPutString: aString\x0a\x09self nextPutAll: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nextPutAll_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutString:",{aString:aString})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "print:",
protocol: "writing",
args: ["anObject"],
source: "print: anObject\x0a\x09anObject printOn: self",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anObject)._printOn_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"print:",{anObject:anObject})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "printSymbol:",
protocol: "writing",
args: ["anObject"],
source: "printSymbol: anObject\x0a\x09anObject asSymbolPrintOn: self",
referencedClasses: [],
pragmas: [],
messageSends: ["asSymbolPrintOn:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anObject)._asSymbolPrintOn_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"printSymbol:",{anObject:anObject})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "space",
protocol: "writing",
args: [],
source: "space\x0a\x09self nextPut: ' '",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPut:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nextPut_(" ");
return self;
}, function($ctx1) {$ctx1.fill(self,"space",{})});
}; }),
$globals.StringStream);

$core.addMethod(
$core.method({
selector: "tab",
protocol: "writing",
args: [],
source: "tab\x0a\x09^ self nextPutAll: String tab",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["nextPutAll:", "tab"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._nextPutAll_($recv($globals.String)._tab());
}, function($ctx1) {$ctx1.fill(self,"tab",{})});
}; }),
$globals.StringStream);



$core.addClass("Queue", $globals.Object, "Kernel-Collections");
$core.setSlots($globals.Queue, ["read", "readIndex", "write"]);
$globals.Queue.comment="I am a one-sided queue.\x0a\x0a## Usage\x0a\x0aUse `#nextPut:` to add items to the queue.\x0aUse `#next` or `#nextIfAbsent:` to get (and remove) the next item in the queue.\x0a\x0a## Implementation notes\x0a\x0aA Queue uses two OrderedCollections inside,\x0a`read` is at the front, is not modified and only read using `readIndex`.\x0a`write` is at the back and is appended new items.\x0aWhen `read` is exhausted, `write` is promoted to `read` and new `write` is created.\x0a\x0aAs a consequence, no data moving is done by me, write appending may do data moving\x0awhen growing `write`, but this is left to engine to implement as good as it chooses to.";
$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09read := OrderedCollection new.\x0a\x09write := OrderedCollection new.\x0a\x09readIndex := 1",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.read=[$recv($globals.OrderedCollection)._new()
,$ctx1.sendIdx["new"]=1
][0];
$self.write=$recv($globals.OrderedCollection)._new();
$self.readIndex=(1);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Queue);

$core.addMethod(
$core.method({
selector: "next",
protocol: "accessing",
args: [],
source: "next\x0a\x09^ self nextIfAbsent: [ self error: 'Cannot read from empty Queue.' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextIfAbsent:", "error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._nextIfAbsent_((function(){
return $core.withContext(function($ctx2) {
return $self._error_("Cannot read from empty Queue.");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"next",{})});
}; }),
$globals.Queue);

$core.addMethod(
$core.method({
selector: "nextIfAbsent:",
protocol: "accessing",
args: ["aBlock"],
source: "nextIfAbsent: aBlock\x0a\x09| result |\x0a\x09result := read at: readIndex ifAbsent: [\x0a\x09\x09write ifEmpty: [\x0a\x09\x09\x09readIndex > 1 ifTrue: [ read := #(). readIndex := 1 ].\x0a\x09\x09\x09^ aBlock value ].\x0a\x09\x09read := write.\x0a\x09\x09readIndex := 1.\x0a\x09\x09write := OrderedCollection new.\x0a\x09\x09read first ].\x0a\x09read at: readIndex put: nil.\x0a\x09readIndex := readIndex + 1.\x0a\x09^ result",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["at:ifAbsent:", "ifEmpty:", "ifTrue:", ">", "value", "new", "first", "at:put:", "+"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
var $early={};
try {
result=$recv($self.read)._at_ifAbsent_($self.readIndex,(function(){
return $core.withContext(function($ctx2) {
$recv($self.write)._ifEmpty_((function(){
return $core.withContext(function($ctx3) {
if($core.assert($recv($self.readIndex).__gt((1)))){
$self.read=[];
$self.readIndex=(1);
$self.readIndex;
}
throw $early=[$recv(aBlock)._value()];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
$self.read=$self.write;
$self.readIndex=(1);
$self.write=$recv($globals.OrderedCollection)._new();
return $recv($self.read)._first();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv($self.read)._at_put_($self.readIndex,nil);
$self.readIndex=$recv($self.readIndex).__plus((1));
return result;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"nextIfAbsent:",{aBlock:aBlock,result:result})});
}; }),
$globals.Queue);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: "accessing",
args: ["anObject"],
source: "nextPut: anObject\x0a\x09write add: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["add:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.write)._add_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{anObject:anObject})});
}; }),
$globals.Queue);



$core.addClass("RegularExpression", $globals.Object, "Kernel-Collections");
$globals.RegularExpression.comment="I represent a regular expression object. My instances are JavaScript `RegExp` object.";
$core.addMethod(
$core.method({
selector: "compile:",
protocol: "evaluating",
args: ["aString"],
source: "compile: aString\x0a\x09<inlineJS: 'return self.compile(aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.compile(aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.compile(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"compile:",{aString:aString})});
}; }),
$globals.RegularExpression);

$core.addMethod(
$core.method({
selector: "exec:",
protocol: "evaluating",
args: ["aString"],
source: "exec: aString\x0a\x09<inlineJS: 'return self.exec(aString) || nil'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.exec(aString) || nil"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.exec(aString) || nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"exec:",{aString:aString})});
}; }),
$globals.RegularExpression);

$core.addMethod(
$core.method({
selector: "test:",
protocol: "evaluating",
args: ["aString"],
source: "test: aString\x0a\x09<inlineJS: 'return self.test(aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.test(aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.test(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"test:",{aString:aString})});
}; }),
$globals.RegularExpression);


$core.addMethod(
$core.method({
selector: "fromString:",
protocol: "instance creation",
args: ["aString"],
source: "fromString: aString\x0a\x09\x09^ self fromString: aString flag: ''",
referencedClasses: [],
pragmas: [],
messageSends: ["fromString:flag:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._fromString_flag_(aString,"");
}, function($ctx1) {$ctx1.fill(self,"fromString:",{aString:aString})});
}; }),
$globals.RegularExpression.a$cls);

$core.addMethod(
$core.method({
selector: "fromString:flag:",
protocol: "instance creation",
args: ["aString", "anotherString"],
source: "fromString: aString flag: anotherString\x0a\x09<inlineJS: 'return new RegExp(aString, anotherString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new RegExp(aString, anotherString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new RegExp(aString, anotherString);
return self;
}, function($ctx1) {$ctx1.fill(self,"fromString:flag:",{aString:aString,anotherString:anotherString})});
}; }),
$globals.RegularExpression.a$cls);


$core.addTrait("TKeyValueCollection", "Kernel-Collections");
$core.addMethod(
$core.method({
selector: "at:",
protocol: "accessing",
args: ["anIndex"],
source: "at: anIndex\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value stored at anIndex.\x0a\x09Otherwise, raise an error.\x22\x0a\x0a\x09^ self at: anIndex ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "errorNotFound"]
}, function ($methodClass){ return function (anIndex){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_ifAbsent_(anIndex,(function(){
return $core.withContext(function($ctx2) {
return $self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"at:",{anIndex:anIndex})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "accessing",
args: ["anIndex", "aBlock"],
source: "at: anIndex ifAbsent: aBlock\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value stored at anIndex.\x0a\x09Otherwise, answer the value of aBlock.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anIndex,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{anIndex:anIndex,aBlock:aBlock})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "at:ifAbsentPut:",
protocol: "accessing",
args: ["aKey", "aBlock"],
source: "at: aKey ifAbsentPut: aBlock\x0a\x09^ self at: aKey ifAbsent: [\x0a\x09\x09self at: aKey put: aBlock value ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "at:put:", "value"]
}, function ($methodClass){ return function (aKey,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_ifAbsent_(aKey,(function(){
return $core.withContext(function($ctx2) {
return $self._at_put_(aKey,$recv(aBlock)._value());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsentPut:",{aKey:aKey,aBlock:aBlock})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:",
protocol: "accessing",
args: ["anIndex", "aBlock"],
source: "at: anIndex ifPresent: aBlock\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value of evaluating aBlock with the value stored at anIndex.\x0a\x09Otherwise, answer nil.\x22\x0a\x0a\x09^ self at: anIndex ifPresent: aBlock ifAbsent: [ nil ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:"]
}, function ($methodClass){ return function (anIndex,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._at_ifPresent_ifAbsent_(anIndex,aBlock,(function(){
return nil;

}));
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:",{anIndex:anIndex,aBlock:aBlock})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: "accessing",
args: ["anIndex", "aBlock", "anotherBlock"],
source: "at: anIndex ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09\x22Lookup the given index in the receiver.\x0a\x09If it is present, answer the value of evaluating aBlock with the value stored at anIndex.\x0a\x09Otherwise, answer the value of anotherBlock.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anIndex,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{anIndex:anIndex,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: "accessing",
args: ["anIndex", "anObject"],
source: "at: anIndex put: anObject\x0a\x09\x22Store anObject under the given index in the receiver.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anIndex,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{anIndex:anIndex,anObject:anObject})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "indexOf:",
protocol: "accessing",
args: ["anObject"],
source: "indexOf: anObject\x0a\x09\x22Lookup index at which anObject is stored in the receiver.\x0a\x09If not present, raise an error.\x22\x0a\x0a\x09^ self indexOf: anObject ifAbsent: [ self errorNotFound ]",
referencedClasses: [],
pragmas: [],
messageSends: ["indexOf:ifAbsent:", "errorNotFound"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._indexOf_ifAbsent_(anObject,(function(){
return $core.withContext(function($ctx2) {
return $self._errorNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"indexOf:",{anObject:anObject})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: "accessing",
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09\x22Lookup index at which anObject is stored in the receiver.\x0a\x09If not present, return value of executing aBlock.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "with:do:",
protocol: "enumerating",
args: ["anotherCollection", "aBlock"],
source: "with: anotherCollection do: aBlock\x0a\x09\x22Calls aBlock with every value from self\x0a\x09and with indetically-indexed value from anotherCollection\x22\x0a\x0a\x09self withIndexDo: [ :each :index |\x0a\x09\x09aBlock value: each value: (anotherCollection at: index) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["withIndexDo:", "value:value:", "at:"]
}, function ($methodClass){ return function (anotherCollection,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._withIndexDo_((function(each,index){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(each,$recv(anotherCollection)._at_(index));
}, function($ctx2) {$ctx2.fillBlock({each:each,index:index},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"with:do:",{anotherCollection:anotherCollection,aBlock:aBlock})});
}; }),
$globals.TKeyValueCollection);

$core.addMethod(
$core.method({
selector: "withIndexDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "withIndexDo: aBlock\x0a\x09\x22Calls aBlock with every value from self\x0a\x09and with its index as the second argument\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"withIndexDo:",{aBlock:aBlock})});
}; }),
$globals.TKeyValueCollection);


$core.addTrait("TNativeZeroBasedCollection", "Kernel-Collections");
$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "accessing",
args: ["anIndex", "aBlock"],
source: "at: anIndex ifAbsent: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09return anIndex >= 1 && anIndex <= self.length\x0a\x09\x09\x09? self[anIndex - 1]\x0a\x09\x09\x09: aBlock._value()\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return anIndex >= 1 && anIndex <= self.length\x0a\x09\x09\x09? self[anIndex - 1]\x0a\x09\x09\x09: aBlock._value()\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return anIndex >= 1 && anIndex <= self.length
			? self[anIndex - 1]
			: aBlock._value()
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{anIndex:anIndex,aBlock:aBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: "accessing",
args: ["anIndex", "aBlock", "anotherBlock"],
source: "at: anIndex ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09<inlineJS: '\x0a\x09\x09return anIndex >= 1 && anIndex <= self.length\x0a\x09\x09\x09? aBlock._value_(self[anIndex - 1])\x0a\x09\x09\x09: anotherBlock._value()\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return anIndex >= 1 && anIndex <= self.length\x0a\x09\x09\x09? aBlock._value_(self[anIndex - 1])\x0a\x09\x09\x09: anotherBlock._value()\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anIndex,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return anIndex >= 1 && anIndex <= self.length
			? aBlock._value_(self[anIndex - 1])
			: anotherBlock._value()
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{anIndex:anIndex,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "detect:ifNone:",
protocol: "enumerating",
args: ["aBlock", "anotherBlock"],
source: "detect: aBlock ifNone: anotherBlock\x0a\x09<inlineJS: '\x0a\x09\x09for(var i = 0; i < self.length; i++)\x0a\x09\x09\x09if(aBlock._value_(self[i]))\x0a\x09\x09\x09\x09return self[i];\x0a\x09\x09return anotherBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09for(var i = 0; i < self.length; i++)\x0a\x09\x09\x09if(aBlock._value_(self[i]))\x0a\x09\x09\x09\x09return self[i];\x0a\x09\x09return anotherBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		for(var i = 0; i < self.length; i++)
			if(aBlock._value_(self[i]))
				return self[i];
		return anotherBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"detect:ifNone:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "do:",
protocol: "enumerating",
args: ["aBlock"],
source: "do: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09aBlock._value_(self[i]);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09aBlock._value_(self[i]);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		for(var i=0; i < self.length; i++) {
			aBlock._value_(self[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"do:",{aBlock:aBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "indexOf:ifAbsent:",
protocol: "accessing",
args: ["anObject", "aBlock"],
source: "indexOf: anObject ifAbsent: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09if($recv(self[i]).__eq(anObject)) {return i+1}\x0a\x09\x09};\x0a\x09\x09return aBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09if($recv(self[i]).__eq(anObject)) {return i+1}\x0a\x09\x09};\x0a\x09\x09return aBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		for(var i=0; i < self.length; i++) {
			if($recv(self[i]).__eq(anObject)) {return i+1}
		};
		return aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:ifAbsent:",{anObject:anObject,aBlock:aBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "indexOf:startingAt:ifAbsent:",
protocol: "accessing",
args: ["anObject", "start", "aBlock"],
source: "indexOf: anObject startingAt: start ifAbsent: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09for(var i=start - 1; i < self.length; i++){\x0a\x09\x09\x09if($recv(self[i]).__eq(anObject)) {return i+1}\x0a\x09\x09}\x0a\x09\x09return aBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09for(var i=start - 1; i < self.length; i++){\x0a\x09\x09\x09if($recv(self[i]).__eq(anObject)) {return i+1}\x0a\x09\x09}\x0a\x09\x09return aBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,start,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		for(var i=start - 1; i < self.length; i++){
			if($recv(self[i]).__eq(anObject)) {return i+1}
		}
		return aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"indexOf:startingAt:ifAbsent:",{anObject:anObject,start:start,aBlock:aBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "single",
protocol: "accessing",
args: [],
source: "single\x0a<inlineJS: '\x0a\x09if (self.length == 0) throw new Error(\x22Collection is empty\x22);\x0a\x09if (self.length > 1) throw new Error(\x22Collection holds more than one element.\x22);\x0a\x09return self[0];\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09if (self.length == 0) throw new Error(\x22Collection is empty\x22);\x0a\x09if (self.length > 1) throw new Error(\x22Collection holds more than one element.\x22);\x0a\x09return self[0];"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	if (self.length == 0) throw new Error("Collection is empty");
	if (self.length > 1) throw new Error("Collection holds more than one element.");
	return self[0];;
return self;
}, function($ctx1) {$ctx1.fill(self,"single",{})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09<inlineJS: 'return self.length'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.length"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.length;
return self;
}, function($ctx1) {$ctx1.fill(self,"size",{})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "with:do:",
protocol: "enumerating",
args: ["anotherCollection", "aBlock"],
source: "with: anotherCollection do: aBlock\x0a\x09<inlineJS: '\x0a\x09    $recv(anotherCollection)._first_(0); // #guardSequenceableCollection\x0a\x09\x09for(var i=0; i<self.length; i++) {\x0a\x09\x09\x09aBlock._value_value_(self[i], anotherCollection[i]);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09    $recv(anotherCollection)._first_(0); // #guardSequenceableCollection\x0a\x09\x09for(var i=0; i<self.length; i++) {\x0a\x09\x09\x09aBlock._value_value_(self[i], anotherCollection[i]);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anotherCollection,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	    $recv(anotherCollection)._first_(0); // #guardSequenceableCollection
		for(var i=0; i<self.length; i++) {
			aBlock._value_value_(self[i], anotherCollection[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"with:do:",{anotherCollection:anotherCollection,aBlock:aBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.addMethod(
$core.method({
selector: "withIndexDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "withIndexDo: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09aBlock._value_value_(self[i], i+1);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09for(var i=0; i < self.length; i++) {\x0a\x09\x09\x09aBlock._value_value_(self[i], i+1);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		for(var i=0; i < self.length; i++) {
			aBlock._value_value_(self[i], i+1);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"withIndexDo:",{aBlock:aBlock})});
}; }),
$globals.TNativeZeroBasedCollection);

$core.setTraitComposition([{trait: $globals.TKeyValueCollection}], $globals.AssociativeCollection);
$core.setTraitComposition([{trait: $globals.TKeyValueCollection}], $globals.SequenceableCollection);
$core.setTraitComposition([{trait: $globals.TNativeZeroBasedCollection}], $globals.Array);
$core.setTraitComposition([{trait: $globals.TNativeZeroBasedCollection}], $globals.String);

});

define('amber/core/Kernel-Classes',["amber/boot", "require", "amber/core/Kernel-Collections", "amber/core/Kernel-Helpers", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Classes");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("Behavior", $globals.Object, "Kernel-Classes");
$core.setSlots($globals.Behavior, ["organization", "slots", "fn", "superclass"]);
$globals.Behavior.comment="I am the superclass of all class objects.\x0a\x0aIn addition to BehaviorBody, I define superclass/subclass relationships and instantiation.\x0a\x0aI define the protocol for creating instances of a class with `#basicNew` and `#new` (see `boot.js` for class constructors details).\x0a\x0aMy instances know about the subclass/superclass relationships between classes and contain the description that instances are created from.\x0a\x0aI also provide iterating over the class hierarchy.";
$core.addMethod(
$core.method({
selector: "allSelectors",
protocol: "accessing",
args: [],
source: "allSelectors\x0a\x09^ self allSuperclasses\x0a\x09\x09inject: self selectors\x0a\x09\x09into: [ :acc :each | acc addAll: each selectors; yourself ]",
referencedClasses: [],
pragmas: [],
messageSends: ["inject:into:", "allSuperclasses", "selectors", "addAll:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._allSuperclasses())._inject_into_([$self._selectors()
,$ctx1.sendIdx["selectors"]=1
][0],(function(acc,each){
return $core.withContext(function($ctx2) {
$recv(acc)._addAll_($recv(each)._selectors());
return $recv(acc)._yourself();
}, function($ctx2) {$ctx2.fillBlock({acc:acc,each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"allSelectors",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSubclasses",
protocol: "accessing",
args: [],
source: "allSubclasses\x0a\x09\x22Answer an collection of the receiver's and the receiver's descendent's subclasses. \x22\x0a\x0a\x09^ Array streamContents: [ :str | self allSubclassesDo: [ :each | str nextPut: each ] ]",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "allSubclassesDo:", "nextPut:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Array)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $self._allSubclassesDo_((function(each){
return $core.withContext(function($ctx3) {
return $recv(str)._nextPut_(each);
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"allSubclasses",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSubclassesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "allSubclassesDo: aBlock\x0a\x09\x22Evaluate the argument, aBlock, for each of the receiver's subclasses.\x22\x0a\x0a<inlineJS: '$core.traverseClassTree(self, function(subclass) {\x0a\x09if (subclass !== self) aBlock._value_(subclass);\x0a})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$core.traverseClassTree(self, function(subclass) {\x0a\x09if (subclass !== self) aBlock._value_(subclass);\x0a})"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$core.traverseClassTree(self, function(subclass) {
	if (subclass !== self) aBlock._value_(subclass);
});
return self;
}, function($ctx1) {$ctx1.fill(self,"allSubclassesDo:",{aBlock:aBlock})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "allSuperclasses",
protocol: "accessing",
args: [],
source: "allSuperclasses\x0a\x09\x0a\x09self superclass ifNil: [ ^ #() ].\x0a\x09\x0a\x09^ self superclass allSuperclasses copyWithFirst: self superclass",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "superclass", "copyWithFirst:", "allSuperclasses"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._superclass()
,$ctx1.sendIdx["superclass"]=1
][0];
if($1 == null || $1.a$nil){
return [];
} else {
$1;
}
return $recv($recv([$self._superclass()
,$ctx1.sendIdx["superclass"]=2
][0])._allSuperclasses())._copyWithFirst_($self._superclass());
}, function($ctx1) {$ctx1.fill(self,"allSuperclasses",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "alternateConstructorViaSelector:",
protocol: "instance creation",
args: ["aSelector"],
source: "alternateConstructorViaSelector: aSelector\x0a\x09^ BlockClosure\x0a\x09\x09javaScriptConstructorFor: self prototype\x0a\x09\x09initializingVia: (self >> aSelector) fn",
referencedClasses: ["BlockClosure"],
pragmas: [],
messageSends: ["javaScriptConstructorFor:initializingVia:", "prototype", "fn", ">>"]
}, function ($methodClass){ return function (aSelector){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.BlockClosure)._javaScriptConstructorFor_initializingVia_($self._prototype(),$recv($self.__gt_gt(aSelector))._fn());
}, function($ctx1) {$ctx1.fill(self,"alternateConstructorViaSelector:",{aSelector:aSelector})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "applySuperConstructorOn:withArguments:",
protocol: "accessing",
args: ["anObject", "anArray"],
source: "applySuperConstructorOn: anObject withArguments: anArray\x0a\x09<inlineJS: '\x0a\x09\x09Object.getPrototypeOf($self.fn.prototype).constructor\x0a\x09\x09.apply(anObject, anArray)\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09Object.getPrototypeOf($self.fn.prototype).constructor\x0a\x09\x09.apply(anObject, anArray)\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		Object.getPrototypeOf($self.fn.prototype).constructor
		.apply(anObject, anArray)
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"applySuperConstructorOn:withArguments:",{anObject:anObject,anArray:anArray})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "basicNew",
protocol: "instance creation",
args: [],
source: "basicNew\x0a\x09<inlineJS: 'return new self.fn()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new self.fn()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new self.fn();
return self;
}, function($ctx1) {$ctx1.fill(self,"basicNew",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "basicOrganization",
protocol: "accessing",
args: [],
source: "basicOrganization\x0a\x09^ organization",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.organization;

}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "basicOrganization:",
protocol: "accessing",
args: ["aClassOrganizer"],
source: "basicOrganization: aClassOrganizer\x0a\x09organization := aClassOrganizer",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClassOrganizer){
var self=this,$self=this;
$self.organization=aClassOrganizer;
return self;

}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "beJavaScriptSubclassOf:",
protocol: "accessing",
args: ["aJavaScriptFunction"],
source: "beJavaScriptSubclassOf: aJavaScriptFunction\x0a\x09\x22Reparent the JS constructor's prototype to aJavaScriptFunction's one,\x0a\x09plus bookkeeping. That way I stay part of (simulated) Smalltalk hierarchy,\x0a\x09but my instances will physically be instanceof aJavaScriptFunction.\x22\x0a\x0a\x09self makeJavaScriptConstructorSubclassOf: aJavaScriptFunction.\x0a\x09Smalltalk core detachClass: self",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["makeJavaScriptConstructorSubclassOf:", "detachClass:", "core"]
}, function ($methodClass){ return function (aJavaScriptFunction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._makeJavaScriptConstructorSubclassOf_(aJavaScriptFunction);
$recv($recv($globals.Smalltalk)._core())._detachClass_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"beJavaScriptSubclassOf:",{aJavaScriptFunction:aJavaScriptFunction})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "canUnderstand:",
protocol: "testing",
args: ["aSelector"],
source: "canUnderstand: aSelector\x0a\x09^ (self lookupSelector: aSelector) notNil",
referencedClasses: [],
pragmas: [],
messageSends: ["notNil", "lookupSelector:"]
}, function ($methodClass){ return function (aSelector){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._lookupSelector_(aSelector))._notNil();
}, function($ctx1) {$ctx1.fill(self,"canUnderstand:",{aSelector:aSelector})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "includesBehavior:",
protocol: "testing",
args: ["aClass"],
source: "includesBehavior: aClass\x0a\x09^ self == aClass or: [\x0a\x09\x09\x09self inheritsFrom: aClass ]",
referencedClasses: [],
pragmas: [],
messageSends: ["or:", "==", "inheritsFrom:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self.__eq_eq(aClass))){
return true;
} else {
return $self._inheritsFrom_(aClass);
}
}, function($ctx1) {$ctx1.fill(self,"includesBehavior:",{aClass:aClass})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "inheritsFrom:",
protocol: "testing",
args: ["aClass"],
source: "inheritsFrom: aClass\x0a\x09^ self superclass\x0a\x09\x09ifNil: [ false ]\x0a\x09\x09ifNotNil: [ :superClass | superClass includesBehavior: aClass ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "superclass", "includesBehavior:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._superclass();
if($1 == null || $1.a$nil){
return false;
} else {
var superClass;
superClass=$1;
return $recv(superClass)._includesBehavior_(aClass);
}
}, function($ctx1) {$ctx1.fill(self,"inheritsFrom:",{aClass:aClass})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "isBehavior",
protocol: "testing",
args: [],
source: "isBehavior\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "javaScriptConstructor",
protocol: "accessing",
args: [],
source: "javaScriptConstructor\x0a\x09\x22Answer the JS constructor used to instantiate. See kernel-language.js\x22\x0a\x09\x0a\x09^ fn",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.fn;

}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "javaScriptConstructor:",
protocol: "accessing",
args: ["aJavaScriptFunction"],
source: "javaScriptConstructor: aJavaScriptFunction\x0a\x09\x22Set the JS constructor used to instantiate.\x0a\x09See the JS counter-part in boot.js `$core.setClassConstructor'\x22\x0a\x09\x0a\x09Smalltalk core setClassConstructor: self to: aJavaScriptFunction",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["setClassConstructor:to:", "core"]
}, function ($methodClass){ return function (aJavaScriptFunction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._core())._setClassConstructor_to_(self,aJavaScriptFunction);
return self;
}, function($ctx1) {$ctx1.fill(self,"javaScriptConstructor:",{aJavaScriptFunction:aJavaScriptFunction})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "javascriptConstructor",
protocol: "accessing",
args: [],
source: "javascriptConstructor\x0a\x09self deprecatedAPI: 'Use #javaScriptConstructor instead.'.\x0a\x09^ self javaScriptConstructor",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "javaScriptConstructor"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #javaScriptConstructor instead.");
return $self._javaScriptConstructor();
}, function($ctx1) {$ctx1.fill(self,"javascriptConstructor",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "javascriptConstructor:",
protocol: "accessing",
args: ["aJavaScriptFunction"],
source: "javascriptConstructor: aJavaScriptFunction\x0a\x09self deprecatedAPI: 'Use #javaScriptConstructor: instead.'.\x0a\x09^ self javaScriptConstructor: aJavaScriptFunction",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "javaScriptConstructor:"]
}, function ($methodClass){ return function (aJavaScriptFunction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #javaScriptConstructor: instead.");
return $self._javaScriptConstructor_(aJavaScriptFunction);
}, function($ctx1) {$ctx1.fill(self,"javascriptConstructor:",{aJavaScriptFunction:aJavaScriptFunction})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "lookupSelector:",
protocol: "accessing",
args: ["selector"],
source: "lookupSelector: selector\x0a\x09\x22Look up the given selector in my methodDictionary.\x0a\x09Return the corresponding method if found.\x0a\x09Otherwise chase the superclass chain and try again.\x0a\x09Return nil if no method is found.\x22\x0a\x09\x0a\x09<inlineJS: 'return $self.methods[selector]'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self.methods[selector]"]]],
messageSends: []
}, function ($methodClass){ return function (selector){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.methods[selector];
return self;
}, function($ctx1) {$ctx1.fill(self,"lookupSelector:",{selector:selector})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "makeJavaScriptConstructorSubclassOf:",
protocol: "private",
args: ["javaScriptClass"],
source: "makeJavaScriptConstructorSubclassOf: javaScriptClass\x0a\x09<inlineJS: '\x0a\x09\x09Object.setPrototypeOf($self.fn.prototype, javaScriptClass.prototype);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09Object.setPrototypeOf($self.fn.prototype, javaScriptClass.prototype);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (javaScriptClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		Object.setPrototypeOf($self.fn.prototype, javaScriptClass.prototype);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"makeJavaScriptConstructorSubclassOf:",{javaScriptClass:javaScriptClass})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09^ self basicNew initialize",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "basicNew"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._basicNew())._initialize();
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "prototype",
protocol: "accessing",
args: [],
source: "prototype\x0a\x09^ self javaScriptConstructor prototype",
referencedClasses: [],
pragmas: [],
messageSends: ["prototype", "javaScriptConstructor"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._javaScriptConstructor())._prototype();
}, function($ctx1) {$ctx1.fill(self,"prototype",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "slots",
protocol: "accessing",
args: [],
source: "slots\x0a\x09^ slots",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.slots;

}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "subclasses",
protocol: "accessing",
args: [],
source: "subclasses\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"subclasses",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "superPrototype",
protocol: "accessing",
args: [],
source: "superPrototype\x0a\x09<inlineJS: 'return Object.getPrototypeOf($self.fn.prototype)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Object.getPrototypeOf($self.fn.prototype)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Object.getPrototypeOf($self.fn.prototype);
return self;
}, function($ctx1) {$ctx1.fill(self,"superPrototype",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "superclass",
protocol: "accessing",
args: [],
source: "superclass\x0a\x09^ superclass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.superclass;

}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: "accessing",
args: [],
source: "theMetaClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"theMetaClass",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "theNonMetaClass",
protocol: "accessing",
args: [],
source: "theNonMetaClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"theNonMetaClass",{})});
}; }),
$globals.Behavior);

$core.addMethod(
$core.method({
selector: "withAllSubclasses",
protocol: "accessing",
args: [],
source: "withAllSubclasses\x0a\x09^ self allSubclasses copyWithFirst: self",
referencedClasses: [],
pragmas: [],
messageSends: ["copyWithFirst:", "allSubclasses"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._allSubclasses())._copyWithFirst_(self);
}, function($ctx1) {$ctx1.fill(self,"withAllSubclasses",{})});
}; }),
$globals.Behavior);



$core.addClass("Class", $globals.Behavior, "Kernel-Classes");
$core.setSlots($globals.Class, ["package", "subclasses"]);
$globals.Class.comment="I am __the__ class object.\x0a\x0aMy instances are the classes of the system.\x0aClass creation is done throught a `ClassBuilder` instance.";
$core.addMethod(
$core.method({
selector: "basicPackage:",
protocol: "accessing",
args: ["aPackage"],
source: "basicPackage: aPackage\x0a\x09package := aPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
$self.package=aPackage;
return self;

}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'class'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "class";

}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream | stream\x0a\x09\x09print: self superclass; write: ' subclass: '; printSymbol: self name; lf;\x0a\x09\x09write: (self traitCompositionDefinition ifNotEmpty: [ :tcd | { String tab. 'uses: '. tcd. String lf }]);\x0a\x09\x09tab; write: {'slots: {'. ('. ' join: (self instanceVariableNames collect: #symbolPrintString)). '}'}; lf;\x0a\x09\x09tab; write: 'package: '; print: self category ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "print:", "superclass", "write:", "printSymbol:", "name", "lf", "ifNotEmpty:", "traitCompositionDefinition", "tab", "join:", "collect:", "instanceVariableNames", "category"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._print_($self._superclass())
,$ctx2.sendIdx["print:"]=1
][0];
[$recv(stream)._write_(" subclass: ")
,$ctx2.sendIdx["write:"]=1
][0];
$recv(stream)._printSymbol_($self._name());
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=1
][0];
[$recv(stream)._write_($recv($self._traitCompositionDefinition())._ifNotEmpty_((function(tcd){
return $core.withContext(function($ctx3) {
return [[$recv($globals.String)._tab()
,$ctx3.sendIdx["tab"]=1
][0],"uses: ",tcd,[$recv($globals.String)._lf()
,$ctx3.sendIdx["lf"]=2
][0]];
}, function($ctx3) {$ctx3.fillBlock({tcd:tcd},$ctx2,2)});
})))
,$ctx2.sendIdx["write:"]=2
][0];
[$recv(stream)._tab()
,$ctx2.sendIdx["tab"]=2
][0];
[$recv(stream)._write_(["slots: {",". "._join_($recv($self._instanceVariableNames())._collect_("symbolPrintString")),"}"])
,$ctx2.sendIdx["write:"]=3
][0];
$recv(stream)._lf();
$recv(stream)._tab();
$recv(stream)._write_("package: ");
return $recv(stream)._print_($self._category());
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{})});
}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "includingPossibleMetaDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "includingPossibleMetaDo: aBlock\x0a\x0a\x09aBlock value: self.\x0a\x09aBlock value: self theMetaClass",
referencedClasses: [],
pragmas: [],
messageSends: ["value:", "theMetaClass"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aBlock)._value_(self)
,$ctx1.sendIdx["value:"]=1
][0];
$recv(aBlock)._value_($self._theMetaClass());
return self;
}, function($ctx1) {$ctx1.fill(self,"includingPossibleMetaDo:",{aBlock:aBlock})});
}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "isClass",
protocol: "testing",
args: [],
source: "isClass\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09^ package",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.package;

}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "provided",
protocol: "converting",
args: [],
source: "provided\x0a\x09\x22Returns JS proxy that allows to access 'static API', as in\x0a\x09  Number provided EPSILON\x0a\x09that forwards to (wrapped JS) constructor function.\x22\x0a\x09\x0a\x09^ self javaScriptConstructor provided",
referencedClasses: [],
pragmas: [],
messageSends: ["provided", "javaScriptConstructor"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._javaScriptConstructor())._provided();
}, function($ctx1) {$ctx1.fill(self,"provided",{})});
}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "rename:",
protocol: "accessing",
args: ["aString"],
source: "rename: aString\x0a\x09ClassBuilder new renameClass: self to: aString",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["renameClass:to:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.ClassBuilder)._new())._renameClass_to_(self,aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"rename:",{aString:aString})});
}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "subclasses",
protocol: "accessing",
args: [],
source: "subclasses\x0a\x09^ subclasses copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.subclasses)._copy();
}, function($ctx1) {$ctx1.fill(self,"subclasses",{})});
}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: "accessing",
args: [],
source: "theMetaClass\x0a\x09^ self class",
referencedClasses: [],
pragmas: [],
messageSends: ["class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._class();
}, function($ctx1) {$ctx1.fill(self,"theMetaClass",{})});
}; }),
$globals.Class);



$core.addClass("Metaclass", $globals.Behavior, "Kernel-Classes");
$core.setSlots($globals.Metaclass, ["instanceClass"]);
$globals.Metaclass.comment="I am the root of the class hierarchy.\x0a\x0aMy instances are metaclasses, one for each real class, and have a single instance, which they hold onto: the class that they are the metaclass of.";
$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ '$globals.', self instanceClass name, '.a$cls'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "name", "instanceClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv("$globals.".__comma($recv($self._instanceClass())._name())).__comma(".a$cls")
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream | stream\x0a\x09\x09print: self;\x0a\x09\x09write: (self traitCompositionDefinition\x0a\x09\x09\x09ifEmpty: [' ']\x0a\x09\x09\x09ifNotEmpty: [ :tcd | { String lf. String tab. 'uses: '. tcd. String lf. String tab }]);\x0a\x09\x09write: {'slots: {'. ('. ' join: (self instanceVariableNames collect: #symbolPrintString)). '}'} ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "print:", "write:", "ifEmpty:ifNotEmpty:", "traitCompositionDefinition", "lf", "tab", "join:", "collect:", "instanceVariableNames"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._print_(self);
[$recv(stream)._write_($recv($self._traitCompositionDefinition())._ifEmpty_ifNotEmpty_((function(){
return " ";

}),(function(tcd){
return $core.withContext(function($ctx3) {
return [[$recv($globals.String)._lf()
,$ctx3.sendIdx["lf"]=1
][0],[$recv($globals.String)._tab()
,$ctx3.sendIdx["tab"]=1
][0],"uses: ",tcd,$recv($globals.String)._lf(),$recv($globals.String)._tab()];
}, function($ctx3) {$ctx3.fillBlock({tcd:tcd},$ctx2,3)});
})))
,$ctx2.sendIdx["write:"]=1
][0];
return $recv(stream)._write_(["slots: {",". "._join_($recv($self._instanceVariableNames())._collect_("symbolPrintString")),"}"]);
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "instanceClass",
protocol: "accessing",
args: [],
source: "instanceClass\x0a\x09^ instanceClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.instanceClass;

}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "instanceVariableNames:",
protocol: "accessing",
args: ["aString"],
source: "instanceVariableNames: aString\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self slots: aString instanceVariablesStringAsSlotList",
referencedClasses: [],
pragmas: [],
messageSends: ["slots:", "instanceVariablesStringAsSlotList"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._slots_($recv(aString)._instanceVariablesStringAsSlotList());
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNames:",{aString:aString})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "isMetaclass",
protocol: "testing",
args: [],
source: "isMetaclass\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09^ self instanceClass name, ' class'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "name", "instanceClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._instanceClass())._name()).__comma(" class");
}, function($ctx1) {$ctx1.fill(self,"name",{})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09^ self instanceClass package",
referencedClasses: [],
pragmas: [],
messageSends: ["package", "instanceClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._instanceClass())._package();
}, function($ctx1) {$ctx1.fill(self,"package",{})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "slots:",
protocol: "accessing",
args: ["aCollection"],
source: "slots: aCollection\x0a\x09ClassBuilder new\x0a\x09\x09class: self slots: aCollection.\x0a\x09^ self",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["class:slots:", "new"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.ClassBuilder)._new())._class_slots_(self,aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"slots:",{aCollection:aCollection})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "subclasses",
protocol: "accessing",
args: [],
source: "subclasses\x0a\x09^ Smalltalk core metaSubclasses: self",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["metaSubclasses:", "core"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._core())._metaSubclasses_(self);
}, function($ctx1) {$ctx1.fill(self,"subclasses",{})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: "accessing",
args: [],
source: "theMetaClass\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "theNonMetaClass",
protocol: "accessing",
args: [],
source: "theNonMetaClass\x0a\x09^ self instanceClass",
referencedClasses: [],
pragmas: [],
messageSends: ["instanceClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._instanceClass();
}, function($ctx1) {$ctx1.fill(self,"theNonMetaClass",{})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "uses:instanceVariableNames:",
protocol: "accessing",
args: ["aTraitCompositionDescription", "aString"],
source: "uses: aTraitCompositionDescription instanceVariableNames: aString\x0a\x09\x22Kept for file-in compatibility.\x22\x0a\x09^ self uses: aTraitCompositionDescription slots: aString instanceVariablesStringAsSlotList",
referencedClasses: [],
pragmas: [],
messageSends: ["uses:slots:", "instanceVariablesStringAsSlotList"]
}, function ($methodClass){ return function (aTraitCompositionDescription,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._uses_slots_(aTraitCompositionDescription,$recv(aString)._instanceVariablesStringAsSlotList());
}, function($ctx1) {$ctx1.fill(self,"uses:instanceVariableNames:",{aTraitCompositionDescription:aTraitCompositionDescription,aString:aString})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "uses:slots:",
protocol: "accessing",
args: ["aTraitCompositionDescription", "aCollection"],
source: "uses: aTraitCompositionDescription slots: aCollection\x0a\x09self\x0a\x09\x09slots: aCollection;\x0a\x09\x09setTraitComposition: aTraitCompositionDescription asTraitComposition.\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: ["slots:", "setTraitComposition:", "asTraitComposition"]
}, function ($methodClass){ return function (aTraitCompositionDescription,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._slots_(aCollection);
$self._setTraitComposition_($recv(aTraitCompositionDescription)._asTraitComposition());
return self;
}, function($ctx1) {$ctx1.fill(self,"uses:slots:",{aTraitCompositionDescription:aTraitCompositionDescription,aCollection:aCollection})});
}; }),
$globals.Metaclass);



$core.addClass("ClassBuilder", $globals.Object, "Kernel-Classes");
$globals.ClassBuilder.comment="I am responsible for compiling new classes or modifying existing classes in the system.\x0a\x0aRather than using me directly to compile a class, use `Class >> subclass:instanceVariableNames:package:`.";
$core.addMethod(
$core.method({
selector: "addSubclassOf:named:instanceVariableNames:package:",
protocol: "class definition",
args: ["aClass", "className", "aCollection", "packageName"],
source: "addSubclassOf: aClass named: className instanceVariableNames: aCollection package: packageName\x0a\x09self deprecatedAPI: 'Use #addSubclass:named:slots:package: instead.'.\x0a\x09^ self\x0a\x09\x09addSubclassOf: aClass\x0a\x09\x09named: className\x0a\x09\x09slots: aCollection\x0a\x09\x09package: packageName",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "addSubclassOf:named:slots:package:"]
}, function ($methodClass){ return function (aClass,className,aCollection,packageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #addSubclass:named:slots:package: instead.");
return $self._addSubclassOf_named_slots_package_(aClass,className,aCollection,packageName);
}, function($ctx1) {$ctx1.fill(self,"addSubclassOf:named:instanceVariableNames:package:",{aClass:aClass,className:className,aCollection:aCollection,packageName:packageName})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "addSubclassOf:named:slots:package:",
protocol: "class definition",
args: ["aClass", "className", "aCollection", "packageName"],
source: "addSubclassOf: aClass named: className slots: aCollection package: packageName\x0a\x09| theClass thePackage |\x0a\x09\x0a\x09theClass := Smalltalk globals at: className.\x0a\x09thePackage := Package named: packageName.\x0a\x09\x0a\x09theClass ifNotNil: [\x0a\x09\x09theClass package: thePackage.\x0a\x09\x09theClass superclass == aClass\x0a\x09\x09\x09ifFalse: [ ^ self\x0a\x09\x09\x09\x09migrateClassNamed: className\x0a\x09\x09\x09\x09superclass: aClass\x0a\x09\x09\x09\x09slots: aCollection\x0a\x09\x09\x09\x09package: packageName ] ].\x0a\x09\x09\x0a\x09^ (self\x0a\x09\x09basicAddSubclassOf: aClass\x0a\x09\x09named: className\x0a\x09\x09slots: aCollection\x0a\x09\x09package: packageName) recompile; yourself",
referencedClasses: ["Smalltalk", "Package"],
pragmas: [],
messageSends: ["at:", "globals", "named:", "ifNotNil:", "package:", "ifFalse:", "==", "superclass", "migrateClassNamed:superclass:slots:package:", "recompile", "basicAddSubclassOf:named:slots:package:", "yourself"]
}, function ($methodClass){ return function (aClass,className,aCollection,packageName){
var self=this,$self=this;
var theClass,thePackage;
return $core.withContext(function($ctx1) {
var $1,$2;
theClass=$recv($recv($globals.Smalltalk)._globals())._at_(className);
thePackage=$recv($globals.Package)._named_(packageName);
$1=theClass;
if($1 == null || $1.a$nil){
$1;
} else {
$recv(theClass)._package_(thePackage);
if(!$core.assert($recv($recv(theClass)._superclass()).__eq_eq(aClass))){
return $self._migrateClassNamed_superclass_slots_package_(className,aClass,aCollection,packageName);
}
}
$2=$self._basicAddSubclassOf_named_slots_package_(aClass,className,aCollection,packageName);
$recv($2)._recompile();
return $recv($2)._yourself();
}, function($ctx1) {$ctx1.fill(self,"addSubclassOf:named:slots:package:",{aClass:aClass,className:className,aCollection:aCollection,packageName:packageName,theClass:theClass,thePackage:thePackage})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "addTraitNamed:package:",
protocol: "class definition",
args: ["traitName", "packageName"],
source: "addTraitNamed: traitName package: packageName\x0a\x09| theTrait thePackage |\x0a\x09\x0a\x09theTrait := Smalltalk globals at: traitName.\x0a\x09thePackage := Package named: packageName.\x0a\x09\x0a\x09theTrait ifNotNil: [ ^ theTrait package: thePackage; recompile; yourself ].\x0a\x09\x09\x0a\x09theTrait := self\x0a\x09\x09basicAddTraitNamed: traitName\x0a\x09\x09package: packageName.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassAdded new\x0a\x09\x09\x09theClass: theTrait;\x0a\x09\x09\x09yourself).\x0a\x09\x0a\x09^ theTrait",
referencedClasses: ["Smalltalk", "Package", "SystemAnnouncer", "ClassAdded"],
pragmas: [],
messageSends: ["at:", "globals", "named:", "ifNotNil:", "package:", "recompile", "yourself", "basicAddTraitNamed:package:", "announce:", "current", "theClass:", "new"]
}, function ($methodClass){ return function (traitName,packageName){
var self=this,$self=this;
var theTrait,thePackage;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
theTrait=$recv($recv($globals.Smalltalk)._globals())._at_(traitName);
thePackage=$recv($globals.Package)._named_(packageName);
$1=theTrait;
if($1 == null || $1.a$nil){
$1;
} else {
$2=theTrait;
$recv($2)._package_(thePackage);
$recv($2)._recompile();
return [$recv($2)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0];
}
theTrait=$self._basicAddTraitNamed_package_(traitName,packageName);
$3=$recv($globals.SystemAnnouncer)._current();
$4=$recv($globals.ClassAdded)._new();
$recv($4)._theClass_(theTrait);
$recv($3)._announce_($recv($4)._yourself());
return theTrait;
}, function($ctx1) {$ctx1.fill(self,"addTraitNamed:package:",{traitName:traitName,packageName:packageName,theTrait:theTrait,thePackage:thePackage})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicAddSubclassOf:named:slots:package:",
protocol: "private",
args: ["aClass", "aString", "aCollection", "packageName"],
source: "basicAddSubclassOf: aClass named: aString slots: aCollection package: packageName\x0a\x09<inlineJS: '\x0a\x09\x09var klass = $core.addClass(aString, aClass, packageName);\x0a\x09\x09$core.setSlots(klass, aCollection);\x0a\x09\x09return klass;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var klass = $core.addClass(aString, aClass, packageName);\x0a\x09\x09$core.setSlots(klass, aCollection);\x0a\x09\x09return klass;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aClass,aString,aCollection,packageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var klass = $core.addClass(aString, aClass, packageName);
		$core.setSlots(klass, aCollection);
		return klass;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAddSubclassOf:named:slots:package:",{aClass:aClass,aString:aString,aCollection:aCollection,packageName:packageName})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicAddTraitNamed:package:",
protocol: "private",
args: ["aString", "anotherString"],
source: "basicAddTraitNamed: aString package: anotherString\x0a\x09<inlineJS: 'return $core.addTrait(aString, anotherString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.addTrait(aString, anotherString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.addTrait(aString, anotherString);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAddTraitNamed:package:",{aString:aString,anotherString:anotherString})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicClass:slots:",
protocol: "private",
args: ["aClass", "aCollection"],
source: "basicClass: aClass slots: aCollection\x0a\x0a\x09aClass isMetaclass ifFalse: [ self error: aClass name, ' is not a metaclass' ].\x0a\x09Smalltalk core setSlots: aClass to: aCollection",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["ifFalse:", "isMetaclass", "error:", ",", "name", "setSlots:to:", "core"]
}, function ($methodClass){ return function (aClass,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(aClass)._isMetaclass())){
$self._error_($recv($recv(aClass)._name()).__comma(" is not a metaclass"));
}
$recv($recv($globals.Smalltalk)._core())._setSlots_to_(aClass,aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicClass:slots:",{aClass:aClass,aCollection:aCollection})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicRemoveClass:",
protocol: "private",
args: ["aClass"],
source: "basicRemoveClass: aClass\x0a\x09<inlineJS: '$core.removeClass(aClass)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$core.removeClass(aClass)"]]],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$core.removeClass(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRemoveClass:",{aClass:aClass})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicRenameClass:to:",
protocol: "private",
args: ["aClass", "aString"],
source: "basicRenameClass: aClass to: aString\x0a\x09<inlineJS: '\x0a\x09\x09$globals[aString] = aClass;\x0a\x09\x09delete $globals[aClass.name];\x0a\x09\x09aClass.name = aString;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09$globals[aString] = aClass;\x0a\x09\x09delete $globals[aClass.name];\x0a\x09\x09aClass.name = aString;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aClass,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		$globals[aString] = aClass;
		delete $globals[aClass.name];
		aClass.name = aString;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRenameClass:to:",{aClass:aClass,aString:aString})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "basicSwapClassNames:with:",
protocol: "private",
args: ["aClass", "anotherClass"],
source: "basicSwapClassNames: aClass with: anotherClass\x0a\x09<inlineJS: '\x0a\x09\x09var tmp = aClass.name;\x0a\x09\x09aClass.name = anotherClass.name;\x0a\x09\x09anotherClass.name = tmp;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var tmp = aClass.name;\x0a\x09\x09aClass.name = anotherClass.name;\x0a\x09\x09anotherClass.name = tmp;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aClass,anotherClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var tmp = aClass.name;
		aClass.name = anotherClass.name;
		anotherClass.name = tmp;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicSwapClassNames:with:",{aClass:aClass,anotherClass:anotherClass})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "class:slots:",
protocol: "class definition",
args: ["aClass", "aCollection"],
source: "class: aClass slots: aCollection\x0a\x09self basicClass: aClass slots: aCollection.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassDefinitionChanged new\x0a\x09\x09\x09theClass: aClass;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassDefinitionChanged"],
pragmas: [],
messageSends: ["basicClass:slots:", "announce:", "current", "theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self._basicClass_slots_(aClass,aCollection);
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ClassDefinitionChanged)._new();
$recv($2)._theClass_(aClass);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"class:slots:",{aClass:aClass,aCollection:aCollection})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "copyClass:named:",
protocol: "copying",
args: ["aClass", "className"],
source: "copyClass: aClass named: className\x0a\x09| newClass |\x0a\x0a\x09newClass := self\x0a\x09\x09addSubclassOf: aClass superclass\x0a\x09\x09named: className\x0a\x09\x09slots: aClass slots copy\x0a\x09\x09package: aClass package name.\x0a\x0a\x09self copyClass: aClass to: newClass.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassAdded new\x0a\x09\x09\x09theClass: newClass;\x0a\x09\x09\x09yourself).\x0a\x09\x0a\x09^ newClass",
referencedClasses: ["SystemAnnouncer", "ClassAdded"],
pragmas: [],
messageSends: ["addSubclassOf:named:slots:package:", "superclass", "copy", "slots", "name", "package", "copyClass:to:", "announce:", "current", "theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass,className){
var self=this,$self=this;
var newClass;
return $core.withContext(function($ctx1) {
var $1,$2;
newClass=$self._addSubclassOf_named_slots_package_($recv(aClass)._superclass(),className,$recv($recv(aClass)._slots())._copy(),$recv($recv(aClass)._package())._name());
$self._copyClass_to_(aClass,newClass);
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ClassAdded)._new();
$recv($2)._theClass_(newClass);
$recv($1)._announce_($recv($2)._yourself());
return newClass;
}, function($ctx1) {$ctx1.fill(self,"copyClass:named:",{aClass:aClass,className:className,newClass:newClass})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "copyClass:to:",
protocol: "copying",
args: ["aClass", "anotherClass"],
source: "copyClass: aClass to: anotherClass\x0a\x0a\x09anotherClass comment: aClass comment.\x0a\x0a\x09aClass methodDictionary valuesDo: [ :each |\x0a\x09\x09each origin = aClass ifTrue: [\x0a\x09\x09\x09Compiler new install: each source forClass: anotherClass protocol: each protocol ] ].\x0a\x09anotherClass setTraitComposition: aClass traitComposition.\x0a\x0a\x09self basicClass: anotherClass class slots: aClass class slots copy.\x0a\x0a\x09aClass class methodDictionary valuesDo: [ :each |\x0a\x09\x09each origin = aClass class ifTrue: [\x0a\x09\x09\x09Compiler new install: each source forClass: anotherClass class protocol: each protocol ] ].\x0a\x09anotherClass class setTraitComposition: aClass class traitComposition",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["comment:", "comment", "valuesDo:", "methodDictionary", "ifTrue:", "=", "origin", "install:forClass:protocol:", "new", "source", "protocol", "setTraitComposition:", "traitComposition", "basicClass:slots:", "class", "copy", "slots"]
}, function ($methodClass){ return function (aClass,anotherClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anotherClass)._comment_($recv(aClass)._comment());
[$recv([$recv(aClass)._methodDictionary()
,$ctx1.sendIdx["methodDictionary"]=1
][0])._valuesDo_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert([$recv([$recv(each)._origin()
,$ctx2.sendIdx["origin"]=1
][0]).__eq(aClass)
,$ctx2.sendIdx["="]=1
][0])){
return [$recv([$recv($globals.Compiler)._new()
,$ctx2.sendIdx["new"]=1
][0])._install_forClass_protocol_([$recv(each)._source()
,$ctx2.sendIdx["source"]=1
][0],anotherClass,[$recv(each)._protocol()
,$ctx2.sendIdx["protocol"]=1
][0])
,$ctx2.sendIdx["install:forClass:protocol:"]=1
][0];
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["valuesDo:"]=1
][0];
[$recv(anotherClass)._setTraitComposition_([$recv(aClass)._traitComposition()
,$ctx1.sendIdx["traitComposition"]=1
][0])
,$ctx1.sendIdx["setTraitComposition:"]=1
][0];
$self._basicClass_slots_([$recv(anotherClass)._class()
,$ctx1.sendIdx["class"]=1
][0],$recv($recv([$recv(aClass)._class()
,$ctx1.sendIdx["class"]=2
][0])._slots())._copy());
$recv($recv([$recv(aClass)._class()
,$ctx1.sendIdx["class"]=3
][0])._methodDictionary())._valuesDo_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv($recv(each)._origin()).__eq([$recv(aClass)._class()
,$ctx2.sendIdx["class"]=4
][0]))){
return $recv($recv($globals.Compiler)._new())._install_forClass_protocol_($recv(each)._source(),[$recv(anotherClass)._class()
,$ctx2.sendIdx["class"]=5
][0],$recv(each)._protocol());
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$recv([$recv(anotherClass)._class()
,$ctx1.sendIdx["class"]=6
][0])._setTraitComposition_($recv($recv(aClass)._class())._traitComposition());
return self;
}, function($ctx1) {$ctx1.fill(self,"copyClass:to:",{aClass:aClass,anotherClass:anotherClass})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "migrateClass:superclass:",
protocol: "class migration",
args: ["aClass", "anotherClass"],
source: "migrateClass: aClass superclass: anotherClass\x0a\x09^ self\x0a\x09\x09migrateClassNamed: aClass name\x0a\x09\x09superclass: anotherClass\x0a\x09\x09slots: aClass slots\x0a\x09\x09package: aClass package name",
referencedClasses: [],
pragmas: [],
messageSends: ["migrateClassNamed:superclass:slots:package:", "name", "slots", "package"]
}, function ($methodClass){ return function (aClass,anotherClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._migrateClassNamed_superclass_slots_package_([$recv(aClass)._name()
,$ctx1.sendIdx["name"]=1
][0],anotherClass,$recv(aClass)._slots(),$recv($recv(aClass)._package())._name());
}, function($ctx1) {$ctx1.fill(self,"migrateClass:superclass:",{aClass:aClass,anotherClass:anotherClass})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "migrateClassNamed:superclass:instanceVariableNames:package:",
protocol: "class migration",
args: ["className", "aClass", "aCollection", "packageName"],
source: "migrateClassNamed: className superclass: aClass instanceVariableNames: aCollection package: packageName\x0a\x09self deprecatedAPI: 'Use #migrateClassNamed:superclass:slots:package: instead.'.\x0a\x09^ self\x0a\x09\x09migrateClassNamed: className\x0a\x09\x09superclass: aClass\x0a\x09\x09slots: aCollection\x0a\x09\x09package: packageName",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "migrateClassNamed:superclass:slots:package:"]
}, function ($methodClass){ return function (className,aClass,aCollection,packageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #migrateClassNamed:superclass:slots:package: instead.");
return $self._migrateClassNamed_superclass_slots_package_(className,aClass,aCollection,packageName);
}, function($ctx1) {$ctx1.fill(self,"migrateClassNamed:superclass:instanceVariableNames:package:",{className:className,aClass:aClass,aCollection:aCollection,packageName:packageName})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "migrateClassNamed:superclass:slots:package:",
protocol: "class migration",
args: ["className", "aClass", "aCollection", "packageName"],
source: "migrateClassNamed: className superclass: aClass slots: aCollection package: packageName\x0a\x09| oldClass newClass tmp |\x0a\x09\x0a\x09tmp := 'new*', className.\x0a\x09oldClass := Smalltalk globals at: className.\x0a\x09\x0a\x09newClass := self\x0a\x09\x09addSubclassOf: aClass\x0a\x09\x09named: tmp\x0a\x09\x09slots: aCollection\x0a\x09\x09package: packageName.\x0a\x0a\x09self basicSwapClassNames: oldClass with: newClass.\x0a\x0a\x09[ self copyClass: oldClass to: newClass ]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :exception |\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09basicSwapClassNames: oldClass with: newClass;\x0a\x09\x09\x09\x09basicRemoveClass: newClass.\x0a\x09\x09\x09\x09SystemAnnouncer current announce: (ClassRenamed new\x0a\x09\x09\x09\x09\x09theClass: oldClass;\x0a\x09\x09\x09\x09\x09yourself).\x0a\x09\x09\x09\x09exception pass ].\x0a\x0a\x09self\x0a\x09\x09rawRenameClass: oldClass to: tmp;\x0a\x09\x09rawRenameClass: newClass to: className.\x0a\x0a\x09oldClass subclasses \x0a\x09\x09do: [ :each | self migrateClass: each superclass: newClass ].\x0a\x0a\x09self basicRemoveClass: oldClass.\x0a\x09\x0a\x09SystemAnnouncer current announce: (ClassMigrated new\x0a\x09\x09theClass: newClass;\x0a\x09\x09oldClass: oldClass;\x0a\x09\x09yourself).\x0a\x09\x0a\x09^ newClass",
referencedClasses: ["Smalltalk", "Error", "SystemAnnouncer", "ClassRenamed", "ClassMigrated"],
pragmas: [],
messageSends: [",", "at:", "globals", "addSubclassOf:named:slots:package:", "basicSwapClassNames:with:", "on:do:", "copyClass:to:", "basicRemoveClass:", "announce:", "current", "theClass:", "new", "yourself", "pass", "rawRenameClass:to:", "do:", "subclasses", "migrateClass:superclass:", "oldClass:"]
}, function ($methodClass){ return function (className,aClass,aCollection,packageName){
var self=this,$self=this;
var oldClass,newClass,tmp;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
tmp="new*".__comma(className);
oldClass=$recv($recv($globals.Smalltalk)._globals())._at_(className);
newClass=$self._addSubclassOf_named_slots_package_(aClass,tmp,aCollection,packageName);
[$self._basicSwapClassNames_with_(oldClass,newClass)
,$ctx1.sendIdx["basicSwapClassNames:with:"]=1
][0];
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._copyClass_to_(oldClass,newClass);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(exception){
return $core.withContext(function($ctx2) {
$self._basicSwapClassNames_with_(oldClass,newClass);
[$self._basicRemoveClass_(newClass)
,$ctx2.sendIdx["basicRemoveClass:"]=1
][0];
$1=[$recv($globals.SystemAnnouncer)._current()
,$ctx2.sendIdx["current"]=1
][0];
$2=[$recv($globals.ClassRenamed)._new()
,$ctx2.sendIdx["new"]=1
][0];
[$recv($2)._theClass_(oldClass)
,$ctx2.sendIdx["theClass:"]=1
][0];
[$recv($1)._announce_([$recv($2)._yourself()
,$ctx2.sendIdx["yourself"]=1
][0])
,$ctx2.sendIdx["announce:"]=1
][0];
return $recv(exception)._pass();
}, function($ctx2) {$ctx2.fillBlock({exception:exception},$ctx1,2)});
}));
[$self._rawRenameClass_to_(oldClass,tmp)
,$ctx1.sendIdx["rawRenameClass:to:"]=1
][0];
$self._rawRenameClass_to_(newClass,className);
$recv($recv(oldClass)._subclasses())._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._migrateClass_superclass_(each,newClass);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$self._basicRemoveClass_(oldClass);
$3=$recv($globals.SystemAnnouncer)._current();
$4=$recv($globals.ClassMigrated)._new();
$recv($4)._theClass_(newClass);
$recv($4)._oldClass_(oldClass);
$recv($3)._announce_($recv($4)._yourself());
return newClass;
}, function($ctx1) {$ctx1.fill(self,"migrateClassNamed:superclass:slots:package:",{className:className,aClass:aClass,aCollection:aCollection,packageName:packageName,oldClass:oldClass,newClass:newClass,tmp:tmp})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "rawRenameClass:to:",
protocol: "private",
args: ["aClass", "aString"],
source: "rawRenameClass: aClass to: aString\x0a\x09<inlineJS: '\x0a\x09\x09$globals[aString] = aClass;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09$globals[aString] = aClass;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aClass,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		$globals[aString] = aClass;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"rawRenameClass:to:",{aClass:aClass,aString:aString})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "renameClass:to:",
protocol: "class migration",
args: ["aClass", "className"],
source: "renameClass: aClass to: className\x0a\x09self basicRenameClass: aClass to: className.\x0a\x09\x0a\x09\x22Recompile the class to fix potential issues with super sends\x22\x0a\x09aClass recompile.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassRenamed new\x0a\x09\x09\x09theClass: aClass;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassRenamed"],
pragmas: [],
messageSends: ["basicRenameClass:to:", "recompile", "announce:", "current", "theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass,className){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self._basicRenameClass_to_(aClass,className);
$recv(aClass)._recompile();
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ClassRenamed)._new();
$recv($2)._theClass_(aClass);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"renameClass:to:",{aClass:aClass,className:className})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "superclass:subclass:",
protocol: "class definition",
args: ["aClass", "className"],
source: "superclass: aClass subclass: className\x0a\x09^ self superclass: aClass subclass: className slots: #() package: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["superclass:subclass:slots:package:"]
}, function ($methodClass){ return function (aClass,className){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._superclass_subclass_slots_package_(aClass,className,[],nil);
}, function($ctx1) {$ctx1.fill(self,"superclass:subclass:",{aClass:aClass,className:className})});
}; }),
$globals.ClassBuilder);

$core.addMethod(
$core.method({
selector: "superclass:subclass:slots:package:",
protocol: "class definition",
args: ["aClass", "className", "aCollection", "packageName"],
source: "superclass: aClass subclass: className slots: aCollection package: packageName\x0a\x09| newClass |\x0a\x09\x0a\x09newClass := self addSubclassOf: aClass\x0a\x09\x09named: className slots: aCollection\x0a\x09\x09package: (packageName ifNil: [ 'unclassified' ]).\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassAdded new\x0a\x09\x09\x09theClass: newClass;\x0a\x09\x09\x09yourself).\x0a\x09\x0a\x09^ newClass",
referencedClasses: ["SystemAnnouncer", "ClassAdded"],
pragmas: [],
messageSends: ["addSubclassOf:named:slots:package:", "ifNil:", "announce:", "current", "theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass,className,aCollection,packageName){
var self=this,$self=this;
var newClass;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
if(packageName == null || packageName.a$nil){
$1="unclassified";
} else {
$1=packageName;
}
newClass=$self._addSubclassOf_named_slots_package_(aClass,className,aCollection,$1);
$2=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.ClassAdded)._new();
$recv($3)._theClass_(newClass);
$recv($2)._announce_($recv($3)._yourself());
return newClass;
}, function($ctx1) {$ctx1.fill(self,"superclass:subclass:slots:package:",{aClass:aClass,className:className,aCollection:aCollection,packageName:packageName,newClass:newClass})});
}; }),
$globals.ClassBuilder);


$core.addMethod(
$core.method({
selector: "sortClasses:",
protocol: "as yet unclassified",
args: ["aCollection"],
source: "sortClasses: aCollection\x0a\x09| root members |\x0a\x09root := {nil. {}}.\x0a\x09members := HashedCollection new.\x0a\x09aCollection do: [ :each | members at: each name put: {each. {}} ].\x0a\x09(aCollection asArray sorted: [ :a :b | a name <= b name ]) do: [ :each |\x0a\x09\x09| target |\x0a\x09\x09target := members\x0a\x09\x09\x09at: (each superclass ifNotNil: [ :superklass | superklass name ])\x0a\x09\x09\x09ifAbsent: [ root ].\x0a\x09\x09target second add: (members at: each name) ].\x0a\x09^ root second",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["new", "do:", "at:put:", "name", "sorted:", "asArray", "<=", "at:ifAbsent:", "ifNotNil:", "superclass", "add:", "second", "at:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var root,members;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
root=[nil,[]];
members=$recv($globals.HashedCollection)._new();
[$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(members)._at_put_([$recv(each)._name()
,$ctx2.sendIdx["name"]=1
][0],[each,[]]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
$recv($recv($recv(aCollection)._asArray())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv(a)._name()
,$ctx2.sendIdx["name"]=2
][0]).__lt_eq([$recv(b)._name()
,$ctx2.sendIdx["name"]=3
][0]);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,2)});
})))._do_((function(each){
var target;
return $core.withContext(function($ctx2) {
$1=members;
$2=$recv(each)._superclass();
if($2 == null || $2.a$nil){
$3=$2;
} else {
var superklass;
superklass=$2;
$3=[$recv(superklass)._name()
,$ctx2.sendIdx["name"]=4
][0];
}
target=$recv($1)._at_ifAbsent_($3,(function(){
return root;

}));
return $recv([$recv(target)._second()
,$ctx2.sendIdx["second"]=1
][0])._add_($recv(members)._at_($recv(each)._name()));
}, function($ctx2) {$ctx2.fillBlock({each:each,target:target},$ctx1,3)});
}));
return $recv(root)._second();
}, function($ctx1) {$ctx1.fill(self,"sortClasses:",{aCollection:aCollection,root:root,members:members})});
}; }),
$globals.ClassBuilder.a$cls);


$core.addTrait("TBehaviorDefaults", "Kernel-Classes");
$core.addMethod(
$core.method({
selector: "allSubclassesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "allSubclassesDo: aBlock\x0a\x09\x22Default for non-classes; to be able to send #allSubclassesDo: to any class / trait.\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return self;

}; }),
$globals.TBehaviorDefaults);

$core.addMethod(
$core.method({
selector: "includingPossibleMetaDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "includingPossibleMetaDo: aBlock\x0a\x09\x22Default for non-classes.\x22\x0a\x09aBlock value: self",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"includingPossibleMetaDo:",{aBlock:aBlock})});
}; }),
$globals.TBehaviorDefaults);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.TBehaviorDefaults);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09self name\x0a\x09\x09ifNil: [ super printOn: aStream ]\x0a\x09\x09ifNotNil: [ :name | aStream nextPutAll: name ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "name", "printOn:", "nextPutAll:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._name();
if($1 == null || $1.a$nil){
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.supercall = false
][0];
} else {
var name;
name=$1;
$recv(aStream)._nextPutAll_(name);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.TBehaviorDefaults);

$core.addMethod(
$core.method({
selector: "slots",
protocol: "accessing",
args: [],
source: "slots\x0a\x09\x22Default for non-classes; to be able to send #slots to any class / trait.\x22\x0a\x09^ #()",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [];

}; }),
$globals.TBehaviorDefaults);

$core.addMethod(
$core.method({
selector: "superclass",
protocol: "accessing",
args: [],
source: "superclass\x0a\x09\x22Default for non-classes; to be able to send #superclass to any class / trait.\x22\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.TBehaviorDefaults);

$core.addMethod(
$core.method({
selector: "traitUsers",
protocol: "accessing",
args: [],
source: "traitUsers\x0a\x09\x22Default for non-traits; to be able to send #traitUsers to any class / trait\x22\x0a\x09^ #()",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [];

}; }),
$globals.TBehaviorDefaults);


$core.addTrait("TBehaviorProvider", "Kernel-Classes");
$globals.TBehaviorProvider.comment="I have method dictionary, slots and organization.";
$core.addMethod(
$core.method({
selector: ">>",
protocol: "accessing",
args: ["aString"],
source: ">> aString\x0a\x09^ self methodAt: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["methodAt:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._methodAt_(aString);
}, function($ctx1) {$ctx1.fill(self,">>",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "addCompiledMethod:",
protocol: "compiling",
args: ["aMethod"],
source: "addCompiledMethod: aMethod\x0a\x09| oldMethod announcement |\x0a\x09\x0a\x09oldMethod := self methodDictionary\x0a\x09\x09at: aMethod selector\x0a\x09\x09ifAbsent: [ nil ].\x0a\x09\x0a\x09self basicAddCompiledMethod: aMethod.\x0a\x09\x0a\x09announcement := oldMethod\x0a\x09\x09ifNil: [\x0a\x09\x09\x09MethodAdded new\x0a\x09\x09\x09\x09\x09method: aMethod;\x0a\x09\x09\x09\x09\x09yourself ]\x0a\x09\x09ifNotNil: [\x0a\x09\x09\x09MethodModified new\x0a\x09\x09\x09\x09\x09oldMethod: oldMethod;\x0a\x09\x09\x09\x09\x09method: aMethod;\x0a\x09\x09\x09\x09\x09yourself ].\x0a\x09\x09\x09\x09\x09\x0a\x09\x09\x09\x09\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09\x09\x09announce: announcement",
referencedClasses: ["MethodAdded", "MethodModified", "SystemAnnouncer"],
pragmas: [],
messageSends: ["at:ifAbsent:", "methodDictionary", "selector", "basicAddCompiledMethod:", "ifNil:ifNotNil:", "method:", "new", "yourself", "oldMethod:", "announce:", "current"]
}, function ($methodClass){ return function (aMethod){
var self=this,$self=this;
var oldMethod,announcement;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
oldMethod=$recv($self._methodDictionary())._at_ifAbsent_($recv(aMethod)._selector(),(function(){
return nil;

}));
$self._basicAddCompiledMethod_(aMethod);
$1=oldMethod;
if($1 == null || $1.a$nil){
$2=[$recv($globals.MethodAdded)._new()
,$ctx1.sendIdx["new"]=1
][0];
[$recv($2)._method_(aMethod)
,$ctx1.sendIdx["method:"]=1
][0];
announcement=[$recv($2)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0];
} else {
$3=$recv($globals.MethodModified)._new();
$recv($3)._oldMethod_(oldMethod);
$recv($3)._method_(aMethod);
announcement=$recv($3)._yourself();
}
$recv($recv($globals.SystemAnnouncer)._current())._announce_(announcement);
return self;
}, function($ctx1) {$ctx1.fill(self,"addCompiledMethod:",{aMethod:aMethod,oldMethod:oldMethod,announcement:announcement})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "allInstanceVariableNames",
protocol: "accessing",
args: [],
source: "allInstanceVariableNames\x0a\x09^ self allSlots select: #isString",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "allSlots"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._allSlots())._select_("isString");
}, function($ctx1) {$ctx1.fill(self,"allInstanceVariableNames",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "allSlotNames",
protocol: "accessing",
args: [],
source: "allSlotNames\x0a\x09^ self allSlots",
referencedClasses: [],
pragmas: [],
messageSends: ["allSlots"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._allSlots();
}, function($ctx1) {$ctx1.fill(self,"allSlotNames",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "allSlots",
protocol: "accessing",
args: [],
source: "allSlots\x0a\x09| result |\x0a\x09result := self slots copy.\x0a\x09self superclass ifNotNil: [ :s | result addAll: s allSlots ].\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["copy", "slots", "ifNotNil:", "superclass", "addAll:", "allSlots"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
var $1;
result=$recv($self._slots())._copy();
$1=$self._superclass();
if($1 == null || $1.a$nil){
$1;
} else {
var s;
s=$1;
$recv(result)._addAll_($recv(s)._allSlots());
}
return result;
}, function($ctx1) {$ctx1.fill(self,"allSlots",{result:result})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "basicAddCompiledMethod:",
protocol: "private",
args: ["aMethod"],
source: "basicAddCompiledMethod: aMethod\x0a\x09<inlineJS: '$core.addMethod(aMethod, self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$core.addMethod(aMethod, self)"]]],
messageSends: []
}, function ($methodClass){ return function (aMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$core.addMethod(aMethod, self);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicAddCompiledMethod:",{aMethod:aMethod})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "basicRemoveCompiledMethod:",
protocol: "private",
args: ["aMethod"],
source: "basicRemoveCompiledMethod: aMethod\x0a\x09<inlineJS: '$core.removeMethod(aMethod,self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$core.removeMethod(aMethod,self)"]]],
messageSends: []
}, function ($methodClass){ return function (aMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$core.removeMethod(aMethod,self);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicRemoveCompiledMethod:",{aMethod:aMethod})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "compile:protocol:",
protocol: "compiling",
args: ["aString", "anotherString"],
source: "compile: aString protocol: anotherString\x0a\x09^ Compiler new\x0a\x09\x09install: aString\x0a\x09\x09forClass: self\x0a\x09\x09protocol: anotherString",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["install:forClass:protocol:", "new"]
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Compiler)._new())._install_forClass_protocol_(aString,self,anotherString);
}, function($ctx1) {$ctx1.fill(self,"compile:protocol:",{aString:aString,anotherString:anotherString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "includesSelector:",
protocol: "testing",
args: ["aString"],
source: "includesSelector: aString\x0a\x09^ self methodDictionary includesKey: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["includesKey:", "methodDictionary"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methodDictionary())._includesKey_(aString);
}, function($ctx1) {$ctx1.fill(self,"includesSelector:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "instanceVariableNames",
protocol: "accessing",
args: [],
source: "instanceVariableNames\x0a\x09^ self slots select: #isString",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "slots"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._slots())._select_("isString");
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNames",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methodAt:",
protocol: "accessing",
args: ["aString"],
source: "methodAt: aString\x0a\x09^ self methodDictionary at: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["at:", "methodDictionary"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methodDictionary())._at_(aString);
}, function($ctx1) {$ctx1.fill(self,"methodAt:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methodDictionary",
protocol: "accessing",
args: [],
source: "methodDictionary\x0a\x09<inlineJS: 'var dict = $globals.HashedCollection._new();\x0a\x09var methods = self.methods;\x0a\x09Object.keys(methods).forEach(function(i) {\x0a\x09\x09if(methods[i].selector) {\x0a\x09\x09\x09dict._at_put_(methods[i].selector, methods[i]);\x0a\x09\x09}\x0a\x09});\x0a\x09return dict'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["var dict = $globals.HashedCollection._new();\x0a\x09var methods = self.methods;\x0a\x09Object.keys(methods).forEach(function(i) {\x0a\x09\x09if(methods[i].selector) {\x0a\x09\x09\x09dict._at_put_(methods[i].selector, methods[i]);\x0a\x09\x09}\x0a\x09});\x0a\x09return dict"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var dict = $globals.HashedCollection._new();
	var methods = self.methods;
	Object.keys(methods).forEach(function(i) {
		if(methods[i].selector) {
			dict._at_put_(methods[i].selector, methods[i]);
		}
	});
	return dict;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodDictionary",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methodOrganizationEnter:andLeave:",
protocol: "accessing",
args: ["aMethod", "oldMethod"],
source: "methodOrganizationEnter: aMethod andLeave: oldMethod\x0a\x09aMethod ifNotNil: [\x0a\x09\x09self organization addElement: aMethod protocol ].\x0a\x09\x0a\x09oldMethod ifNotNil: [\x0a\x09\x09self removeProtocolIfEmpty: oldMethod protocol ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "addElement:", "organization", "protocol", "removeProtocolIfEmpty:"]
}, function ($methodClass){ return function (aMethod,oldMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(aMethod == null || aMethod.a$nil){
aMethod;
} else {
$recv($self._organization())._addElement_([$recv(aMethod)._protocol()
,$ctx1.sendIdx["protocol"]=1
][0]);
}
if(oldMethod == null || oldMethod.a$nil){
oldMethod;
} else {
$self._removeProtocolIfEmpty_($recv(oldMethod)._protocol());
}
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOrganizationEnter:andLeave:",{aMethod:aMethod,oldMethod:oldMethod})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methodTemplate",
protocol: "accessing",
args: [],
source: "methodTemplate\x0a\x09^ String streamContents: [ :stream | stream \x0a\x09\x09write: 'messageSelectorAndArgumentNames'; lf;\x0a\x09\x09tab; write: '\x22comment stating purpose of message\x22'; lf;\x0a\x09\x09lf;\x0a\x09\x09tab; write: '| temporary variable names |'; lf;\x0a\x09\x09tab; write: 'statements' ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "lf", "tab"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._write_("messageSelectorAndArgumentNames")
,$ctx2.sendIdx["write:"]=1
][0];
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=1
][0];
[$recv(stream)._tab()
,$ctx2.sendIdx["tab"]=1
][0];
[$recv(stream)._write_("\x22comment stating purpose of message\x22")
,$ctx2.sendIdx["write:"]=2
][0];
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=2
][0];
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=3
][0];
[$recv(stream)._tab()
,$ctx2.sendIdx["tab"]=2
][0];
[$recv(stream)._write_("| temporary variable names |")
,$ctx2.sendIdx["write:"]=3
][0];
$recv(stream)._lf();
$recv(stream)._tab();
return $recv(stream)._write_("statements");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"methodTemplate",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methods",
protocol: "accessing",
args: [],
source: "methods\x0a\x09^ self methodDictionary values",
referencedClasses: [],
pragmas: [],
messageSends: ["values", "methodDictionary"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methodDictionary())._values();
}, function($ctx1) {$ctx1.fill(self,"methods",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methodsInProtocol:",
protocol: "accessing",
args: ["aString"],
source: "methodsInProtocol: aString\x0a\x09^ self methods select: [ :each | each protocol = aString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "methods", "=", "protocol"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methods())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._protocol()).__eq(aString);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"methodsInProtocol:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "organization",
protocol: "accessing",
args: [],
source: "organization\x0a\x09^ self basicOrganization ifNil: [\x0a\x09\x09self basicOrganization: (ClassOrganizer on: self).\x0a\x09\x09self basicOrganization ]",
referencedClasses: ["ClassOrganizer"],
pragmas: [],
messageSends: ["ifNil:", "basicOrganization", "basicOrganization:", "on:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._basicOrganization()
,$ctx1.sendIdx["basicOrganization"]=1
][0];
if($1 == null || $1.a$nil){
$self._basicOrganization_($recv($globals.ClassOrganizer)._on_(self));
return $self._basicOrganization();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"organization",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "ownMethods",
protocol: "accessing",
args: [],
source: "ownMethods\x0a\x09\x22Answer the methods of the receiver that are not package extensions\x0a\x09nor obtained via trait composition\x22\x0a\x0a\x09^ (self ownProtocols \x0a\x09\x09inject: OrderedCollection new\x0a\x09\x09into: [ :acc :each | acc, (self ownMethodsInProtocol: each) ])\x0a\x09\x09\x09sorted: [ :a :b | a selector <= b selector ]",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["sorted:", "inject:into:", "ownProtocols", "new", ",", "ownMethodsInProtocol:", "<=", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._ownProtocols())._inject_into_($recv($globals.OrderedCollection)._new(),(function(acc,each){
return $core.withContext(function($ctx2) {
return $recv(acc).__comma($self._ownMethodsInProtocol_(each));
}, function($ctx2) {$ctx2.fillBlock({acc:acc,each:each},$ctx1,1)});
})))._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv(a)._selector()
,$ctx2.sendIdx["selector"]=1
][0]).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethods",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "ownMethodsInProtocol:",
protocol: "accessing",
args: ["aString"],
source: "ownMethodsInProtocol: aString\x0a\x09^ (self methodsInProtocol: aString) select: [ :each | each origin = self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "methodsInProtocol:", "=", "origin"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methodsInProtocol_(aString))._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._origin()).__eq(self);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethodsInProtocol:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "ownProtocols",
protocol: "accessing",
args: [],
source: "ownProtocols\x0a\x09\x22Answer the protocols of the receiver that are not package extensions\x22\x0a\x0a\x09^ self protocols reject: [ :each |\x0a\x09\x09each match: '^\x5c*' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["reject:", "protocols", "match:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._protocols())._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^\x5c*");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownProtocols",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "packageOfProtocol:",
protocol: "accessing",
args: ["aString"],
source: "packageOfProtocol: aString\x0a\x09\x22Answer the package the method of receiver belongs to:\x0a\x09- if it is an extension method, answer the corresponding package\x0a\x09- else answer the receiver's package\x22\x0a\x09\x0a\x09(aString beginsWith: '*') ifFalse: [\x0a\x09\x09^ self package ].\x0a\x09\x09\x0a\x09^ Package \x0a\x09\x09named: aString allButFirst\x0a\x09\x09ifAbsent: [ nil ]",
referencedClasses: ["Package"],
pragmas: [],
messageSends: ["ifFalse:", "beginsWith:", "package", "named:ifAbsent:", "allButFirst"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(aString)._beginsWith_("*"))){
return $self._package();
}
return $recv($globals.Package)._named_ifAbsent_($recv(aString)._allButFirst(),(function(){
return nil;

}));
}, function($ctx1) {$ctx1.fill(self,"packageOfProtocol:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "protocols",
protocol: "accessing",
args: [],
source: "protocols\x0a\x09^ self organization elements asArray sorted",
referencedClasses: [],
pragmas: [],
messageSends: ["sorted", "asArray", "elements", "organization"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($self._organization())._elements())._asArray())._sorted();
}, function($ctx1) {$ctx1.fill(self,"protocols",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "protocolsDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "protocolsDo: aBlock\x0a\x09\x22Execute aBlock for each method protocol with\x0a\x09its collection of methods in the sort order of protocol name.\x22\x0a\x0a\x09| methodsByProtocol |\x0a\x09methodsByProtocol := HashedCollection new.\x0a\x09self methodDictionary valuesDo: [ :m |\x0a\x09\x09(methodsByProtocol at: m protocol ifAbsentPut: [ Array new ])\x0a\x09\x09\x09add: m ].\x0a\x09self protocols do: [ :protocol |\x0a\x09\x09aBlock value: protocol value: (methodsByProtocol at: protocol) ]",
referencedClasses: ["HashedCollection", "Array"],
pragmas: [],
messageSends: ["new", "valuesDo:", "methodDictionary", "add:", "at:ifAbsentPut:", "protocol", "do:", "protocols", "value:value:", "at:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var methodsByProtocol;
return $core.withContext(function($ctx1) {
methodsByProtocol=[$recv($globals.HashedCollection)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($self._methodDictionary())._valuesDo_((function(m){
return $core.withContext(function($ctx2) {
return $recv($recv(methodsByProtocol)._at_ifAbsentPut_($recv(m)._protocol(),(function(){
return $core.withContext(function($ctx3) {
return $recv($globals.Array)._new();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
})))._add_(m);
}, function($ctx2) {$ctx2.fillBlock({m:m},$ctx1,1)});
}));
$recv($self._protocols())._do_((function(protocol){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_value_(protocol,$recv(methodsByProtocol)._at_(protocol));
}, function($ctx2) {$ctx2.fillBlock({protocol:protocol},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"protocolsDo:",{aBlock:aBlock,methodsByProtocol:methodsByProtocol})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "recompile",
protocol: "compiling",
args: [],
source: "recompile\x0a\x09^ Compiler new recompile: self",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["recompile:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Compiler)._new())._recompile_(self);
}, function($ctx1) {$ctx1.fill(self,"recompile",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "removeCompiledMethod:",
protocol: "compiling",
args: ["aMethod"],
source: "removeCompiledMethod: aMethod\x0a\x09self basicRemoveCompiledMethod: aMethod.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (MethodRemoved new\x0a\x09\x09\x09method: aMethod;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "MethodRemoved"],
pragmas: [],
messageSends: ["basicRemoveCompiledMethod:", "announce:", "current", "method:", "new", "yourself"]
}, function ($methodClass){ return function (aMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self._basicRemoveCompiledMethod_(aMethod);
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.MethodRemoved)._new();
$recv($2)._method_(aMethod);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"removeCompiledMethod:",{aMethod:aMethod})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "removeProtocolIfEmpty:",
protocol: "accessing",
args: ["aString"],
source: "removeProtocolIfEmpty: aString\x0a\x09self methods\x0a\x09\x09detect: [ :each | each protocol = aString ]\x0a\x09\x09ifNone: [ self organization removeElement: aString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["detect:ifNone:", "methods", "=", "protocol", "removeElement:", "organization"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._methods())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._protocol()).__eq(aString);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv($self._organization())._removeElement_(aString);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeProtocolIfEmpty:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "selectors",
protocol: "accessing",
args: [],
source: "selectors\x0a\x09^ self methodDictionary keys",
referencedClasses: [],
pragmas: [],
messageSends: ["keys", "methodDictionary"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methodDictionary())._keys();
}, function($ctx1) {$ctx1.fill(self,"selectors",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "setTraitComposition:",
protocol: "compiling",
args: ["aTraitComposition"],
source: "setTraitComposition: aTraitComposition\x0a\x09<inlineJS: '$core.setTraitComposition(aTraitComposition._asJavaScriptObject(), self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$core.setTraitComposition(aTraitComposition._asJavaScriptObject(), self)"]]],
messageSends: []
}, function ($methodClass){ return function (aTraitComposition){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$core.setTraitComposition(aTraitComposition._asJavaScriptObject(), self);
return self;
}, function($ctx1) {$ctx1.fill(self,"setTraitComposition:",{aTraitComposition:aTraitComposition})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "slotNames",
protocol: "accessing",
args: [],
source: "slotNames\x0a\x09^ self slots",
referencedClasses: [],
pragmas: [],
messageSends: ["slots"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._slots();
}, function($ctx1) {$ctx1.fill(self,"slotNames",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "traitComposition",
protocol: "accessing",
args: [],
source: "traitComposition\x0a\x09^ (self basicAt: 'traitComposition')\x0a\x09\x09ifNil: [ #() ]\x0a\x09\x09ifNotNil: [ :aCollection | aCollection collect: [ :each | TraitTransformation fromJSON: each ] ]",
referencedClasses: ["TraitTransformation"],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "basicAt:", "collect:", "fromJSON:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._basicAt_("traitComposition");
if($1 == null || $1.a$nil){
return [];
} else {
var aCollection;
aCollection=$1;
return $recv(aCollection)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.TraitTransformation)._fromJSON_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
}
}, function($ctx1) {$ctx1.fill(self,"traitComposition",{})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "traitCompositionDefinition",
protocol: "accessing",
args: [],
source: "traitCompositionDefinition\x0a\x09^ self traitComposition ifNotEmpty: [ :traitComposition |\x0a\x09\x09String streamContents: [ :str |\x0a\x09\x09\x09str write: '{'.\x0a\x09\x09\x09traitComposition\x0a\x09\x09\x09\x09do: [ :each | str write: each definition ]\x0a\x09\x09\x09\x09separatedBy: [ str write: '. ' ].\x0a\x09\x09\x09str write: '}' ] ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["ifNotEmpty:", "traitComposition", "streamContents:", "write:", "do:separatedBy:", "definition"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._traitComposition())._ifNotEmpty_((function(traitComposition){
return $core.withContext(function($ctx2) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx3) {
[$recv(str)._write_("{")
,$ctx3.sendIdx["write:"]=1
][0];
$recv(traitComposition)._do_separatedBy_((function(each){
return $core.withContext(function($ctx4) {
return [$recv(str)._write_($recv(each)._definition())
,$ctx4.sendIdx["write:"]=2
][0];
}, function($ctx4) {$ctx4.fillBlock({each:each},$ctx3,3)});
}),(function(){
return $core.withContext(function($ctx4) {
return [$recv(str)._write_(". ")
,$ctx4.sendIdx["write:"]=3
][0];
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,4)});
}));
return $recv(str)._write_("}");
}, function($ctx3) {$ctx3.fillBlock({str:str},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({traitComposition:traitComposition},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"traitCompositionDefinition",{})});
}; }),
$globals.TBehaviorProvider);


$core.addTrait("TMasterBehavior", "Kernel-Classes");
$globals.TMasterBehavior.comment="I am the behavior on the instance-side of the browser.\x0a\x0aI define things like package, category, name, comment etc.\x0aas opposed to derived behaviors (metaclass, class trait, ...)\x0athat relate to me.";
$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ '$globals.', self name",
referencedClasses: [],
pragmas: [],
messageSends: [",", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "$globals.".__comma($self._name());
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "browse",
protocol: "browsing",
args: [],
source: "browse\x0a\x09Finder findClass: self",
referencedClasses: ["Finder"],
pragmas: [],
messageSends: ["findClass:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._findClass_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"browse",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "category",
protocol: "accessing",
args: [],
source: "category\x0a\x09^ self package ifNil: [ 'Unclassified' ] ifNotNil: [ self package name ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "package", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._package()
,$ctx1.sendIdx["package"]=1
][0];
if($1 == null || $1.a$nil){
return "Unclassified";
} else {
return $recv($self._package())._name();
}
}, function($ctx1) {$ctx1.fill(self,"category",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Every master behavior should define a class tag.\x22\x0a\x09^ self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._subclassResponsibility();
}, function($ctx1) {$ctx1.fill(self,"classTag",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "comment",
protocol: "accessing",
args: [],
source: "comment\x0a\x09^ (self basicAt: 'comment') ifNil: [ '' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "basicAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._basicAt_("comment");
if($1 == null || $1.a$nil){
return "";
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"comment",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "comment:",
protocol: "accessing",
args: ["aString"],
source: "comment: aString\x0a\x09self basicAt: 'comment' put: aString.\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassCommentChanged new\x0a\x09\x09\x09theClass: self;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassCommentChanged"],
pragmas: [],
messageSends: ["basicAt:put:", "announce:", "current", "theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self._basicAt_put_("comment",aString);
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ClassCommentChanged)._new();
$recv($2)._theClass_(self);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"comment:",{aString:aString})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "definedMethods",
protocol: "accessing",
args: [],
source: "definedMethods\x0a\x09\x22Answers methods of me and derived 'meta' part if present\x22\x0a\x09| methods |\x0a\x09methods := self methods.\x0a\x09self theMetaClass\x0a\x09\x09ifNil: [ ^ methods ]\x0a\x09\x09ifNotNil: [ :meta | ^ methods, meta methods ]",
referencedClasses: [],
pragmas: [],
messageSends: ["methods", "ifNil:ifNotNil:", "theMetaClass", ","]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var methods;
return $core.withContext(function($ctx1) {
var $1;
methods=[$self._methods()
,$ctx1.sendIdx["methods"]=1
][0];
$1=$self._theMetaClass();
if($1 == null || $1.a$nil){
return methods;
} else {
var meta;
meta=$1;
return $recv(methods).__comma($recv(meta)._methods());
}
return self;
}, function($ctx1) {$ctx1.fill(self,"definedMethods",{methods:methods})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "enterOrganization",
protocol: "accessing",
args: [],
source: "enterOrganization\x0a\x09Smalltalk ifNotNil: [\x0a\x09\x09(self basicAt: 'category')\x0a\x09\x09\x09ifNil: [ self basicPackage: nil ]\x0a\x09\x09\x09ifNotNil: [ :category |\x0a\x09\x09\x09\x09\x22Amber has 1-1 correspondence between cat and pkg, atm\x22\x0a\x09\x09\x09\x09self basicPackage: (Package named: category).\x0a\x09\x09\x09\x09self package organization addElement: self ] ]",
referencedClasses: ["Smalltalk", "Package"],
pragmas: [],
messageSends: ["ifNotNil:", "ifNil:ifNotNil:", "basicAt:", "basicPackage:", "named:", "addElement:", "organization", "package"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$globals.Smalltalk;
if($1 == null || $1.a$nil){
$1;
} else {
$2=$self._basicAt_("category");
if($2 == null || $2.a$nil){
[$self._basicPackage_(nil)
,$ctx1.sendIdx["basicPackage:"]=1
][0];
} else {
var category;
category=$2;
$self._basicPackage_($recv($globals.Package)._named_(category));
$recv($recv($self._package())._organization())._addElement_(self);
}
}
return self;
}, function($ctx1) {$ctx1.fill(self,"enterOrganization",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "leaveOrganization",
protocol: "accessing",
args: [],
source: "leaveOrganization\x0a\x09Smalltalk ifNotNil: [\x0a\x09\x09self package organization removeElement: self ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["ifNotNil:", "removeElement:", "organization", "package"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$globals.Smalltalk;
if($1 == null || $1.a$nil){
$1;
} else {
$recv($recv($self._package())._organization())._removeElement_(self);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"leaveOrganization",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09<inlineJS: 'return self.name'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.name"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.name;
return self;
}, function($ctx1) {$ctx1.fill(self,"name",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "package:",
protocol: "accessing",
args: ["aPackage"],
source: "package: aPackage\x0a\x09| oldPackage |\x0a\x09\x0a\x09self package = aPackage ifTrue: [ ^ self ].\x0a\x09\x0a\x09oldPackage := self package.\x0a\x09\x0a\x09self\x0a\x09\x09leaveOrganization;\x0a\x09\x09basicAt: 'category' put: aPackage name;\x0a\x09\x09enterOrganization.\x0a\x0a\x09SystemAnnouncer current announce: (ClassMoved new\x0a\x09\x09theClass: self;\x0a\x09\x09oldPackage: oldPackage;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassMoved"],
pragmas: [],
messageSends: ["ifTrue:", "=", "package", "leaveOrganization", "basicAt:put:", "name", "enterOrganization", "announce:", "current", "theClass:", "new", "oldPackage:", "yourself"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var oldPackage;
return $core.withContext(function($ctx1) {
var $1,$2;
if($core.assert($recv([$self._package()
,$ctx1.sendIdx["package"]=1
][0]).__eq(aPackage))){
return self;
}
oldPackage=$self._package();
$self._leaveOrganization();
$self._basicAt_put_("category",$recv(aPackage)._name());
$self._enterOrganization();
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ClassMoved)._new();
$recv($2)._theClass_(self);
$recv($2)._oldPackage_(oldPackage);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"package:",{aPackage:aPackage,oldPackage:oldPackage})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "theNonMetaClass",
protocol: "accessing",
args: [],
source: "theNonMetaClass\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.TMasterBehavior);


$core.addClass("Trait", $globals.Object, "Kernel-Classes");
$core.setSlots($globals.Trait, ["organization", "package", "traitUsers"]);
$core.addMethod(
$core.method({
selector: "-",
protocol: "composition",
args: ["anArray"],
source: "- anArray\x0a\x09^ self asTraitTransformation - anArray",
referencedClasses: [],
pragmas: [],
messageSends: ["-", "asTraitTransformation"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asTraitTransformation()).__minus(anArray);
}, function($ctx1) {$ctx1.fill(self,"-",{anArray:anArray})});
}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "@",
protocol: "composition",
args: ["anArrayOfAssociations"],
source: "@ anArrayOfAssociations\x0a\x09^ self asTraitTransformation @ anArrayOfAssociations",
referencedClasses: [],
pragmas: [],
messageSends: ["@", "asTraitTransformation"]
}, function ($methodClass){ return function (anArrayOfAssociations){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asTraitTransformation()).__at(anArrayOfAssociations);
}, function($ctx1) {$ctx1.fill(self,"@",{anArrayOfAssociations:anArrayOfAssociations})});
}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "asTraitComposition",
protocol: "converting",
args: [],
source: "asTraitComposition\x0a\x09^ self asTraitTransformation asTraitComposition",
referencedClasses: [],
pragmas: [],
messageSends: ["asTraitComposition", "asTraitTransformation"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asTraitTransformation())._asTraitComposition();
}, function($ctx1) {$ctx1.fill(self,"asTraitComposition",{})});
}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "asTraitTransformation",
protocol: "converting",
args: [],
source: "asTraitTransformation\x0a\x09^ TraitTransformation on: self",
referencedClasses: ["TraitTransformation"],
pragmas: [],
messageSends: ["on:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.TraitTransformation)._on_(self);
}, function($ctx1) {$ctx1.fill(self,"asTraitTransformation",{})});
}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "basicOrganization",
protocol: "accessing",
args: [],
source: "basicOrganization\x0a\x09^ organization",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.organization;

}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "basicOrganization:",
protocol: "accessing",
args: ["aClassOrganizer"],
source: "basicOrganization: aClassOrganizer\x0a\x09organization := aClassOrganizer",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClassOrganizer){
var self=this,$self=this;
$self.organization=aClassOrganizer;
return self;

}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "basicPackage:",
protocol: "accessing",
args: ["aPackage"],
source: "basicPackage: aPackage\x0a\x09package := aPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
$self.package=aPackage;
return self;

}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09^ 'trait'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "trait";

}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream | stream\x0a\x09\x09write: 'Trait named: '; printSymbol: self name; lf;\x0a\x09\x09write: (self traitCompositionDefinition ifNotEmpty: [ :tcd | { String tab. 'uses: '. tcd. String lf }]);\x0a\x09\x09tab; write: 'package: '; print: self category ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "printSymbol:", "name", "lf", "ifNotEmpty:", "traitCompositionDefinition", "tab", "print:", "category"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._write_("Trait named: ")
,$ctx2.sendIdx["write:"]=1
][0];
$recv(stream)._printSymbol_($self._name());
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=1
][0];
[$recv(stream)._write_($recv($self._traitCompositionDefinition())._ifNotEmpty_((function(tcd){
return $core.withContext(function($ctx3) {
return [[$recv($globals.String)._tab()
,$ctx3.sendIdx["tab"]=1
][0],"uses: ",tcd,$recv($globals.String)._lf()];
}, function($ctx3) {$ctx3.fillBlock({tcd:tcd},$ctx2,2)});
})))
,$ctx2.sendIdx["write:"]=2
][0];
$recv(stream)._tab();
$recv(stream)._write_("package: ");
return $recv(stream)._print_($self._category());
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{})});
}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09^ package",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.package;

}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "theMetaClass",
protocol: "accessing",
args: [],
source: "theMetaClass\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.Trait);

$core.addMethod(
$core.method({
selector: "traitUsers",
protocol: "accessing",
args: [],
source: "traitUsers\x0a\x09^ traitUsers copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.traitUsers)._copy();
}, function($ctx1) {$ctx1.fill(self,"traitUsers",{})});
}; }),
$globals.Trait);


$core.addMethod(
$core.method({
selector: "named:package:",
protocol: "instance creation",
args: ["aString", "anotherString"],
source: "named: aString package: anotherString\x0a\x09^ ClassBuilder new addTraitNamed: aString package: anotherString",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["addTraitNamed:package:", "new"]
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._addTraitNamed_package_(aString,anotherString);
}, function($ctx1) {$ctx1.fill(self,"named:package:",{aString:aString,anotherString:anotherString})});
}; }),
$globals.Trait.a$cls);

$core.addMethod(
$core.method({
selector: "named:uses:package:",
protocol: "instance creation",
args: ["aString", "aTraitCompositionDescription", "anotherString"],
source: "named: aString uses: aTraitCompositionDescription package: anotherString\x0a\x09| trait |\x0a\x09trait := self named: aString package: anotherString.\x0a\x09trait setTraitComposition: aTraitCompositionDescription asTraitComposition.\x0a\x09^ trait",
referencedClasses: [],
pragmas: [],
messageSends: ["named:package:", "setTraitComposition:", "asTraitComposition"]
}, function ($methodClass){ return function (aString,aTraitCompositionDescription,anotherString){
var self=this,$self=this;
var trait;
return $core.withContext(function($ctx1) {
trait=$self._named_package_(aString,anotherString);
$recv(trait)._setTraitComposition_($recv(aTraitCompositionDescription)._asTraitComposition());
return trait;
}, function($ctx1) {$ctx1.fill(self,"named:uses:package:",{aString:aString,aTraitCompositionDescription:aTraitCompositionDescription,anotherString:anotherString,trait:trait})});
}; }),
$globals.Trait.a$cls);


$core.addClass("TraitTransformation", $globals.Object, "Kernel-Classes");
$core.setSlots($globals.TraitTransformation, ["trait", "aliases", "exclusions"]);
$globals.TraitTransformation.comment="I am a single step in trait composition.\x0a\x0aI represent one trait including its aliases and exclusions.";
$core.addMethod(
$core.method({
selector: "-",
protocol: "composition",
args: ["anArray"],
source: "- anArray\x0a\x09^ self copy addExclusions: anArray; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["addExclusions:", "copy", "yourself"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._copy();
$recv($1)._addExclusions_(anArray);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"-",{anArray:anArray})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "@",
protocol: "composition",
args: ["anArrayOfAssociations"],
source: "@ anArrayOfAssociations\x0a\x09^ self copy addAliases: anArrayOfAssociations; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["addAliases:", "copy", "yourself"]
}, function ($methodClass){ return function (anArrayOfAssociations){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._copy();
$recv($1)._addAliases_(anArrayOfAssociations);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"@",{anArrayOfAssociations:anArrayOfAssociations})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "addAliases:",
protocol: "accessing",
args: ["anArrayOfAssociations"],
source: "addAliases: anArrayOfAssociations\x0a\x09anArrayOfAssociations do: [ :each |\x0a\x09\x09| key |\x0a\x09\x09key := each key.\x0a\x09\x09aliases at: key\x0a\x09\x09\x09ifPresent: [ self error: 'Cannot use same alias name twice.' ]\x0a\x09\x09\x09ifAbsent: [ aliases at: key put: each value ] ].\x0a\x09^ anArrayOfAssociations",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "key", "at:ifPresent:ifAbsent:", "error:", "at:put:", "value"]
}, function ($methodClass){ return function (anArrayOfAssociations){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anArrayOfAssociations)._do_((function(each){
var key;
return $core.withContext(function($ctx2) {
key=$recv(each)._key();
return $recv($self.aliases)._at_ifPresent_ifAbsent_(key,(function(){
return $core.withContext(function($ctx3) {
return $self._error_("Cannot use same alias name twice.");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return $recv($self.aliases)._at_put_(key,$recv(each)._value());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each,key:key},$ctx1,1)});
}));
return anArrayOfAssociations;
}, function($ctx1) {$ctx1.fill(self,"addAliases:",{anArrayOfAssociations:anArrayOfAssociations})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "addExclusions:",
protocol: "accessing",
args: ["anArray"],
source: "addExclusions: anArray\x0a\x09exclusions addAll: anArray.\x0a\x09^ anArray",
referencedClasses: [],
pragmas: [],
messageSends: ["addAll:"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.exclusions)._addAll_(anArray);
return anArray;
}, function($ctx1) {$ctx1.fill(self,"addExclusions:",{anArray:anArray})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "aliases",
protocol: "accessing",
args: [],
source: "aliases\x0a\x09^ aliases",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.aliases;

}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ #{\x0a\x09\x09'trait' -> self trait.\x0a\x09\x09'aliases' -> self aliases.\x0a\x09\x09'exclusions' -> self exclusions asArray sorted }",
referencedClasses: [],
pragmas: [],
messageSends: ["trait", "aliases", "sorted", "asArray", "exclusions"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $globals.HashedCollection._newFromPairs_(["trait",$self._trait(),"aliases",$self._aliases(),"exclusions",$recv($recv($self._exclusions())._asArray())._sorted()]);
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptObject",{})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09^ String streamContents: [ :str | str write: {\x0a\x09\x09'{trait: '. self trait asJavaScriptSource.\x0a\x09\x09self aliases ifNotEmpty: [ :al |\x0a\x09\x09\x09{', aliases: '. al asJSONString} ].\x0a\x09\x09self exclusions ifNotEmpty: [ :ex |\x0a\x09\x09\x09{', exclusions: '. ex asArray sorted asJavaScriptSource} ].\x0a\x09\x09'}' } ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "asJavaScriptSource", "trait", "ifNotEmpty:", "aliases", "asJSONString", "exclusions", "sorted", "asArray"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $recv(str)._write_(["{trait: ",[$recv($self._trait())._asJavaScriptSource()
,$ctx2.sendIdx["asJavaScriptSource"]=1
][0],[$recv($self._aliases())._ifNotEmpty_((function(al){
return $core.withContext(function($ctx3) {
return [", aliases: ",$recv(al)._asJSONString()];
}, function($ctx3) {$ctx3.fillBlock({al:al},$ctx2,2)});
}))
,$ctx2.sendIdx["ifNotEmpty:"]=1
][0],$recv($self._exclusions())._ifNotEmpty_((function(ex){
return $core.withContext(function($ctx3) {
return [", exclusions: ",$recv($recv($recv(ex)._asArray())._sorted())._asJavaScriptSource()];
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,3)});
})),"}"]);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "asTraitComposition",
protocol: "converting",
args: [],
source: "asTraitComposition\x0a\x09^ { self }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [self];

}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "asTraitTransformation",
protocol: "converting",
args: [],
source: "asTraitTransformation\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ String streamContents: [ :str |\x0a\x09\x09str print: self trait.\x0a\x09\x09self aliases ifNotEmpty: [ :al |\x0a\x09\x09\x09str write: ' @ {'.\x0a\x09\x09\x09al associations\x0a\x09\x09\x09\x09do: [ :each | str printSymbol: each key; write: ' -> '; printSymbol: each value ]\x0a\x09\x09\x09\x09separatedBy: [ str write: '. ' ].\x0a\x09\x09\x09str write: '}' ].\x0a\x09\x09self exclusions ifNotEmpty: [ :ex |\x0a\x09\x09\x09str write: ' - #('.\x0a\x09\x09\x09ex asArray sorted \x0a\x09\x09\x09\x09do: [ :each | str write: each symbolPrintString allButFirst ]\x0a\x09\x09\x09\x09separatedBy: [ str space ].\x0a\x09\x09\x09str write: ')' ] ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "print:", "trait", "ifNotEmpty:", "aliases", "write:", "do:separatedBy:", "associations", "printSymbol:", "key", "value", "exclusions", "sorted", "asArray", "allButFirst", "symbolPrintString", "space"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
$recv(str)._print_($self._trait());
[$recv($self._aliases())._ifNotEmpty_((function(al){
return $core.withContext(function($ctx3) {
[$recv(str)._write_(" @ {")
,$ctx3.sendIdx["write:"]=1
][0];
[$recv($recv(al)._associations())._do_separatedBy_((function(each){
return $core.withContext(function($ctx4) {
[$recv(str)._printSymbol_($recv(each)._key())
,$ctx4.sendIdx["printSymbol:"]=1
][0];
[$recv(str)._write_(" -> ")
,$ctx4.sendIdx["write:"]=2
][0];
return $recv(str)._printSymbol_($recv(each)._value());
}, function($ctx4) {$ctx4.fillBlock({each:each},$ctx3,3)});
}),(function(){
return $core.withContext(function($ctx4) {
return [$recv(str)._write_(". ")
,$ctx4.sendIdx["write:"]=3
][0];
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,4)});
}))
,$ctx3.sendIdx["do:separatedBy:"]=1
][0];
return [$recv(str)._write_("}")
,$ctx3.sendIdx["write:"]=4
][0];
}, function($ctx3) {$ctx3.fillBlock({al:al},$ctx2,2)});
}))
,$ctx2.sendIdx["ifNotEmpty:"]=1
][0];
return $recv($self._exclusions())._ifNotEmpty_((function(ex){
return $core.withContext(function($ctx3) {
[$recv(str)._write_(" - #(")
,$ctx3.sendIdx["write:"]=5
][0];
$recv($recv($recv(ex)._asArray())._sorted())._do_separatedBy_((function(each){
return $core.withContext(function($ctx4) {
return [$recv(str)._write_($recv($recv(each)._symbolPrintString())._allButFirst())
,$ctx4.sendIdx["write:"]=6
][0];
}, function($ctx4) {$ctx4.fillBlock({each:each},$ctx3,6)});
}),(function(){
return $core.withContext(function($ctx4) {
return $recv(str)._space();
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,7)});
}));
return $recv(str)._write_(")");
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,5)});
}));
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "exclusions",
protocol: "accessing",
args: [],
source: "exclusions\x0a\x09^ exclusions",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.exclusions;

}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09aliases := #{}.\x0a\x09exclusions := Set new.\x0a\x09trait := nil",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.aliases=$globals.HashedCollection._newFromPairs_([]);
$self.exclusions=$recv($globals.Set)._new();
$self.trait=nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "postCopy",
protocol: "copying",
args: [],
source: "postCopy\x0a\x09aliases := aliases copy.\x0a\x09exclusions := exclusions copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.aliases=[$recv($self.aliases)._copy()
,$ctx1.sendIdx["copy"]=1
][0];
$self.exclusions=$recv($self.exclusions)._copy();
return self;
}, function($ctx1) {$ctx1.fill(self,"postCopy",{})});
}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "trait",
protocol: "accessing",
args: [],
source: "trait\x0a\x09^ trait",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.trait;

}; }),
$globals.TraitTransformation);

$core.addMethod(
$core.method({
selector: "trait:",
protocol: "accessing",
args: ["anObject"],
source: "trait: anObject\x0a\x09trait := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.trait=anObject;
return self;

}; }),
$globals.TraitTransformation);


$core.addMethod(
$core.method({
selector: "fromJSON:",
protocol: "instance creation",
args: ["aJSObject"],
source: "fromJSON: aJSObject\x0a\x09^ super new\x0a\x09\x09trait: (aJSObject at: #trait);\x0a\x09\x09addAliases: (Smalltalk readJSObject: (aJSObject at: #aliases ifAbsent: [#{}])) associations;\x0a\x09\x09addExclusions: (aJSObject at: #exclusions ifAbsent: [#()]);\x0a\x09\x09yourself",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["trait:", "new", "at:", "addAliases:", "associations", "readJSObject:", "at:ifAbsent:", "addExclusions:", "yourself"]
}, function ($methodClass){ return function (aJSObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._new.call($self))
,$ctx1.supercall = false
][0];
$recv($1)._trait_($recv(aJSObject)._at_("trait"));
$recv($1)._addAliases_($recv($recv($globals.Smalltalk)._readJSObject_([$recv(aJSObject)._at_ifAbsent_("aliases",(function(){
return $globals.HashedCollection._newFromPairs_([]);

}))
,$ctx1.sendIdx["at:ifAbsent:"]=1
][0]))._associations());
$recv($1)._addExclusions_($recv(aJSObject)._at_ifAbsent_("exclusions",(function(){
return [];

})));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"fromJSON:",{aJSObject:aJSObject})});
}; }),
$globals.TraitTransformation.a$cls);

$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aTrait"],
source: "on: aTrait\x0a\x09^ super new trait: aTrait; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["trait:", "new", "yourself"]
}, function ($methodClass){ return function (aTrait){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._new.call($self))
,$ctx1.supercall = false
][0];
$recv($1)._trait_(aTrait);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aTrait:aTrait})});
}; }),
$globals.TraitTransformation.a$cls);

$core.setTraitComposition([{trait: $globals.TBehaviorDefaults}, {trait: $globals.TBehaviorProvider}], $globals.Behavior);
$core.setTraitComposition([{trait: $globals.TMasterBehavior}, {trait: $globals.TSubclassable}], $globals.Class);
$core.setTraitComposition([{trait: $globals.TBehaviorDefaults}, {trait: $globals.TBehaviorProvider}, {trait: $globals.TMasterBehavior}], $globals.Trait);

$core.addMethod(
$core.method({
selector: "asTraitComposition",
protocol: "*Kernel-Classes",
args: [],
source: "asTraitComposition\x0a\x09\x22not implemented yet, noop atm\x22\x0a\x09^ self collect: [ :each | each asTraitTransformation ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "asTraitTransformation"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._asTraitTransformation();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"asTraitComposition",{})});
}; }),
$globals.Array);

$core.addMethod(
$core.method({
selector: "instanceVariablesStringAsSlotList",
protocol: "*Kernel-Classes",
args: [],
source: "instanceVariablesStringAsSlotList\x0a\x09^ (self tokenize: ' ') reject: [ :each | each isEmpty ]",
referencedClasses: [],
pragmas: [],
messageSends: ["reject:", "tokenize:", "isEmpty"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._tokenize_(" "))._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isEmpty();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"instanceVariablesStringAsSlotList",{})});
}; }),
$globals.String);

});

define('amber/core/Kernel-Methods',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Methods");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("BlockClosure", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.BlockClosure, ["prototype", "length"]);
$globals.BlockClosure.comment="I represent a lexical closure.\x0aI am is directly mapped to JavaScript Function.\x0a\x0a## API\x0a\x0a1. Evaluation\x0a\x0a    My instances get evaluated with the `#value*` methods in the 'evaluating' protocol.\x0a\x0a    Example: ` [ :x | x + 1 ] value: 3 \x22Answers 4\x22 `\x0a\x0a2. Control structures\x0a\x0a    Blocks are used (together with `Boolean`) for control structures (methods in the `controlling` protocol).\x0a\x0a    Example: `aBlock whileTrue: [ ... ]`\x0a\x0a3. Error handling\x0a\x0a    I provide the `#on:do:` method for handling exceptions.\x0a\x0a    Example: ` aBlock on: MessageNotUnderstood do: [ :ex | ... ] `";
$core.addMethod(
$core.method({
selector: "applyTo:arguments:",
protocol: "evaluating",
args: ["anObject", "aCollection"],
source: "applyTo: anObject arguments: aCollection\x0a\x09<inlineJS: 'return self.apply(anObject, aCollection)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.apply(anObject, aCollection)"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.apply(anObject, aCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"applyTo:arguments:",{anObject:anObject,aCollection:aCollection})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "asCompiledMethod:",
protocol: "converting",
args: ["aString"],
source: "asCompiledMethod: aString\x0a\x09<inlineJS: 'return $core.method({selector:aString, fn:self});'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.method({selector:aString, fn:self});"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.method({selector:aString, fn:self});;
return self;
}, function($ctx1) {$ctx1.fill(self,"asCompiledMethod:",{aString:aString})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "asJavaScriptSource",
protocol: "converting",
args: [],
source: "asJavaScriptSource\x0a\x09<inlineJS: 'return $self.toString();'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self.toString();"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.toString();;
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptSource",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "compiledSource",
protocol: "accessing",
args: [],
source: "compiledSource\x0a\x09<inlineJS: 'return self.toString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.toString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"compiledSource",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "currySelf",
protocol: "converting",
args: [],
source: "currySelf\x0a\x09\x22Transforms [ :selfarg :x :y | stcode ] block\x0a\x09which represents JS function (selfarg, x, y, ...) {jscode}\x0a\x09into function (x, y, ...) {jscode} that takes selfarg from 'this'.\x0a\x09IOW, it is usable as JS method and first arg takes the receiver.\x22\x0a\x09\x0a\x09<inlineJS: '\x0a\x09\x09return function () {\x0a\x09\x09\x09var args = [ this ];\x0a\x09\x09\x09args.push.apply(args, arguments);\x0a\x09\x09\x09return self.apply(null, args);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return function () {\x0a\x09\x09\x09var args = [ this ];\x0a\x09\x09\x09args.push.apply(args, arguments);\x0a\x09\x09\x09return self.apply(null, args);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return function () {
			var args = [ this ];
			args.push.apply(args, arguments);
			return self.apply(null, args);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"currySelf",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "ensure:",
protocol: "evaluating",
args: ["aBlock"],
source: "ensure: aBlock\x0a\x09<inlineJS: 'try{return $self._value()}finally{aBlock._value()}'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["try{return $self._value()}finally{aBlock._value()}"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
try{return $self._value()}finally{aBlock._value()};
return self;
}, function($ctx1) {$ctx1.fill(self,"ensure:",{aBlock:aBlock})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "fork",
protocol: "timeout/interval",
args: [],
source: "fork\x0a\x09ForkPool default fork: self",
referencedClasses: ["ForkPool"],
pragmas: [],
messageSends: ["fork:", "default"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.ForkPool)._default())._fork_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"fork",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "new",
protocol: "evaluating",
args: [],
source: "new\x0a\x09\x22Use the receiver as a JS constructor.\x0a\x09*Do not* use this method to instanciate Smalltalk objects!\x22\x0a\x09<inlineJS: 'return new self()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new self()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new self();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newValue:",
protocol: "evaluating",
args: ["anObject"],
source: "newValue: anObject\x0a\x09^ self newWithValues: { anObject }",
referencedClasses: [],
pragmas: [],
messageSends: ["newWithValues:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._newWithValues_([anObject]);
}, function($ctx1) {$ctx1.fill(self,"newValue:",{anObject:anObject})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newValue:value:",
protocol: "evaluating",
args: ["anObject", "anObject2"],
source: "newValue: anObject value: anObject2\x0a\x09^ self newWithValues: { anObject. anObject2 }.",
referencedClasses: [],
pragmas: [],
messageSends: ["newWithValues:"]
}, function ($methodClass){ return function (anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._newWithValues_([anObject,anObject2]);
}, function($ctx1) {$ctx1.fill(self,"newValue:value:",{anObject:anObject,anObject2:anObject2})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newValue:value:value:",
protocol: "evaluating",
args: ["anObject", "anObject2", "anObject3"],
source: "newValue: anObject value: anObject2 value: anObject3\x0a\x09^ self newWithValues: { anObject. anObject2. anObject3 }.",
referencedClasses: [],
pragmas: [],
messageSends: ["newWithValues:"]
}, function ($methodClass){ return function (anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._newWithValues_([anObject,anObject2,anObject3]);
}, function($ctx1) {$ctx1.fill(self,"newValue:value:value:",{anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "newWithValues:",
protocol: "evaluating",
args: ["aCollection"],
source: "newWithValues: aCollection\x0a\x09\x22Simulates JS new operator by combination of Object.create and .apply\x22\x0a\x09<inlineJS: '\x0a\x09\x09var object = Object.create(self.prototype);\x0a\x09\x09var result = self.apply(object, aCollection);\x0a\x09\x09return typeof result === \x22object\x22 ? result : object;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var object = Object.create(self.prototype);\x0a\x09\x09var result = self.apply(object, aCollection);\x0a\x09\x09return typeof result === \x22object\x22 ? result : object;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var object = Object.create(self.prototype);
		var result = self.apply(object, aCollection);
		return typeof result === "object" ? result : object;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"newWithValues:",{aCollection:aCollection})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "numArgs",
protocol: "accessing",
args: [],
source: "numArgs\x0a\x09^ length",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.length;

}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "on:do:",
protocol: "error handling",
args: ["anErrorClass", "aBlock"],
source: "on: anErrorClass do: aBlock\x0a\x09^ Smalltalk try: self ifTrue: [ :err | err isKindOf: anErrorClass ] catch: aBlock",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["try:ifTrue:catch:", "isKindOf:"]
}, function ($methodClass){ return function (anErrorClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._try_ifTrue_catch_(self,(function(err){
return $core.withContext(function($ctx2) {
return $recv(err)._isKindOf_(anErrorClass);
}, function($ctx2) {$ctx2.fillBlock({err:err},$ctx1,1)});
}),aBlock);
}, function($ctx1) {$ctx1.fill(self,"on:do:",{anErrorClass:anErrorClass,aBlock:aBlock})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "prototype",
protocol: "accessing",
args: [],
source: "prototype\x0a\x09^ prototype",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.prototype;

}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "provided",
protocol: "converting",
args: [],
source: "provided\x0a\x09\x22Returns JS proxy that allows to access 'static API', as in\x0a\x09  require provided resolve: ...\x0a\x09or\x0a\x09  XMLHttpRequest provided DONE\x22\x0a\x09\x0a\x09^ JSObjectProxy on: self",
referencedClasses: ["JSObjectProxy"],
pragmas: [],
messageSends: ["on:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.JSObjectProxy)._on_(self);
}, function($ctx1) {$ctx1.fill(self,"provided",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "timeToRun",
protocol: "evaluating",
args: [],
source: "timeToRun\x0a\x09\x22Answer the number of milliseconds taken to execute this block.\x22\x0a\x0a\x09^ Date millisecondsToRun: self",
referencedClasses: ["Date"],
pragmas: [],
messageSends: ["millisecondsToRun:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Date)._millisecondsToRun_(self);
}, function($ctx1) {$ctx1.fill(self,"timeToRun",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "tryCatch:",
protocol: "error handling",
args: ["aBlock"],
source: "tryCatch: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09try {\x0a\x09\x09\x09return $self._value();\x0a\x09\x09} catch(error) {\x0a\x09\x09\x09// pass non-local returns undetected\x0a\x09\x09\x09if (Array.isArray(error) && error.length === 1) throw error;\x0a\x09\x09\x09return aBlock._value_(error);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09try {\x0a\x09\x09\x09return $self._value();\x0a\x09\x09} catch(error) {\x0a\x09\x09\x09// pass non-local returns undetected\x0a\x09\x09\x09if (Array.isArray(error) && error.length === 1) throw error;\x0a\x09\x09\x09return aBlock._value_(error);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		try {
			return $self._value();
		} catch(error) {
			// pass non-local returns undetected
			if (Array.isArray(error) && error.length === 1) throw error;
			return aBlock._value_(error);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"tryCatch:",{aBlock:aBlock})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "tryIfTrue:catch:",
protocol: "error handling",
args: ["anotherBlock", "aBlock"],
source: "tryIfTrue: anotherBlock catch: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09try {\x0a\x09\x09\x09return $self._value();\x0a\x09\x09} catch(error) {\x0a\x09\x09\x09// pass non-local returns undetected\x0a\x09\x09\x09if (Array.isArray(error) && error.length === 1) throw error;\x0a\x09\x09\x09if (!anotherBlock._value_(error)) throw error;\x0a\x09\x09\x09return aBlock._value_(error);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09try {\x0a\x09\x09\x09return $self._value();\x0a\x09\x09} catch(error) {\x0a\x09\x09\x09// pass non-local returns undetected\x0a\x09\x09\x09if (Array.isArray(error) && error.length === 1) throw error;\x0a\x09\x09\x09if (!anotherBlock._value_(error)) throw error;\x0a\x09\x09\x09return aBlock._value_(error);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (anotherBlock,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		try {
			return $self._value();
		} catch(error) {
			// pass non-local returns undetected
			if (Array.isArray(error) && error.length === 1) throw error;
			if (!anotherBlock._value_(error)) throw error;
			return aBlock._value_(error);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"tryIfTrue:catch:",{anotherBlock:anotherBlock,aBlock:aBlock})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value",
protocol: "evaluating",
args: [],
source: "value\x0a\x09<inlineJS: 'return self();'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self();"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self();;
return self;
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "evaluating",
args: ["anArg"],
source: "value: anArg\x0a\x09<inlineJS: 'return self(anArg);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self(anArg);"]]],
messageSends: []
}, function ($methodClass){ return function (anArg){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self(anArg);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:",{anArg:anArg})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:",
protocol: "evaluating",
args: ["firstArg", "secondArg"],
source: "value: firstArg value: secondArg\x0a\x09<inlineJS: 'return self(firstArg, secondArg);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self(firstArg, secondArg);"]]],
messageSends: []
}, function ($methodClass){ return function (firstArg,secondArg){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self(firstArg, secondArg);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:value:",{firstArg:firstArg,secondArg:secondArg})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:value:",
protocol: "evaluating",
args: ["firstArg", "secondArg", "thirdArg"],
source: "value: firstArg value: secondArg value: thirdArg\x0a\x09<inlineJS: 'return self(firstArg, secondArg, thirdArg);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self(firstArg, secondArg, thirdArg);"]]],
messageSends: []
}, function ($methodClass){ return function (firstArg,secondArg,thirdArg){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self(firstArg, secondArg, thirdArg);;
return self;
}, function($ctx1) {$ctx1.fill(self,"value:value:value:",{firstArg:firstArg,secondArg:secondArg,thirdArg:thirdArg})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithInterval:",
protocol: "timeout/interval",
args: ["aNumber"],
source: "valueWithInterval: aNumber\x0a\x09<inlineJS: '\x0a\x09\x09var interval = setInterval(self, aNumber);\x0a\x09\x09return $globals.Timeout._on_(interval);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var interval = setInterval(self, aNumber);\x0a\x09\x09return $globals.Timeout._on_(interval);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var interval = setInterval(self, aNumber);
		return $globals.Timeout._on_(interval);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"valueWithInterval:",{aNumber:aNumber})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithPossibleArguments:",
protocol: "evaluating",
args: ["aCollection"],
source: "valueWithPossibleArguments: aCollection\x0a\x09<inlineJS: 'return self.apply(null, aCollection);'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.apply(null, aCollection);"]]],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.apply(null, aCollection);;
return self;
}, function($ctx1) {$ctx1.fill(self,"valueWithPossibleArguments:",{aCollection:aCollection})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithTimeout:",
protocol: "timeout/interval",
args: ["aNumber"],
source: "valueWithTimeout: aNumber\x0a\x09<inlineJS: '\x0a\x09\x09var timeout = setTimeout(self, aNumber);\x0a\x09\x09return $globals.Timeout._on_(timeout);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var timeout = setTimeout(self, aNumber);\x0a\x09\x09return $globals.Timeout._on_(timeout);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var timeout = setTimeout(self, aNumber);
		return $globals.Timeout._on_(timeout);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"valueWithTimeout:",{aNumber:aNumber})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileFalse",
protocol: "controlling",
args: [],
source: "whileFalse\x0a\x09self whileFalse: []",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._whileFalse_((function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"whileFalse",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileFalse:",
protocol: "controlling",
args: ["aBlock"],
source: "whileFalse: aBlock\x0a\x09<inlineJS: 'while(!$core.assert($self._value())) {aBlock._value()}'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["while(!$core.assert($self._value())) {aBlock._value()}"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
while(!$core.assert($self._value())) {aBlock._value()};
return self;
}, function($ctx1) {$ctx1.fill(self,"whileFalse:",{aBlock:aBlock})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileTrue",
protocol: "controlling",
args: [],
source: "whileTrue\x0a\x09self whileTrue: []",
referencedClasses: [],
pragmas: [],
messageSends: ["whileTrue:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._whileTrue_((function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"whileTrue",{})});
}; }),
$globals.BlockClosure);

$core.addMethod(
$core.method({
selector: "whileTrue:",
protocol: "controlling",
args: ["aBlock"],
source: "whileTrue: aBlock\x0a\x09<inlineJS: 'while($core.assert($self._value())) {aBlock._value()}'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["while($core.assert($self._value())) {aBlock._value()}"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
while($core.assert($self._value())) {aBlock._value()};
return self;
}, function($ctx1) {$ctx1.fill(self,"whileTrue:",{aBlock:aBlock})});
}; }),
$globals.BlockClosure);


$core.addMethod(
$core.method({
selector: "javaScriptConstructorFor:initializingVia:",
protocol: "instance creation",
args: ["aPrototype", "aMethodBlock"],
source: "javaScriptConstructorFor: aPrototype initializingVia: aMethodBlock\x0a\x09<inlineJS: '\x0a\x09\x09function Ctr () {\x0a\x09\x09\x09aMethodBlock.apply(this, arguments);\x0a\x09\x09}\x0a\x09\x09Ctr.prototype = aPrototype;\x0a\x09\x09return Ctr;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09function Ctr () {\x0a\x09\x09\x09aMethodBlock.apply(this, arguments);\x0a\x09\x09}\x0a\x09\x09Ctr.prototype = aPrototype;\x0a\x09\x09return Ctr;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aPrototype,aMethodBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		function Ctr () {
			aMethodBlock.apply(this, arguments);
		}
		Ctr.prototype = aPrototype;
		return Ctr;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"javaScriptConstructorFor:initializingVia:",{aPrototype:aPrototype,aMethodBlock:aMethodBlock})});
}; }),
$globals.BlockClosure.a$cls);


$core.addClass("CompiledMethod", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.CompiledMethod, ["args", "instantiateFn", "fn", "messageSends", "pragmas", "owner", "methodClass", "protocol", "referencedClasses", "selector", "source"]);
$globals.CompiledMethod.comment="I represent a class method of the system. I hold the source and compiled code of a class method.\x0a\x0a## API\x0aMy instances can be accessed using `Behavior >> #methodAt:`\x0a\x0a    Object methodAt: 'asString'\x0a\x0aSource code access:\x0a\x0a\x09(String methodAt: 'lines') source\x0a\x0aReferenced classes:\x0a\x0a\x09(String methodAt: 'lines') referencedClasses\x0a\x0aMessages sent from an instance:\x0a\x09\x0a\x09(String methodAt: 'lines') messageSends";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ args ifNil: [ #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.args;
if($1 == null || $1.a$nil){
return [];
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09^ self asStringForClass: self methodClass",
referencedClasses: [],
pragmas: [],
messageSends: ["asStringForClass:", "methodClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._asStringForClass_($self._methodClass());
}, function($ctx1) {$ctx1.fill(self,"asString",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "asStringForClass:",
protocol: "converting",
args: ["aClass"],
source: "asStringForClass: aClass\x0a\x09| result |\x0a\x09result := aClass name.\x0a\x09self methodClass = aClass \x0a\x09\x09ifFalse: [ result := result, ' (', (self methodClass ifNil: [ 'nil' ] ifNotNil: [ self methodClass name ]), ')'].\x0a\x09(self origin = aClass | (self origin = self methodClass)) \x0a\x09\x09ifFalse: [ result := result, ' /', (self origin ifNil: [ 'nil' ] ifNotNil: [ self origin name ]), '/'].\x0a\x09^ result, ' >> ', self selector symbolPrintString",
referencedClasses: [],
pragmas: [],
messageSends: ["name", "ifFalse:", "=", "methodClass", ",", "ifNil:ifNotNil:", "|", "origin", "symbolPrintString", "selector"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6;
result=[$recv(aClass)._name()
,$ctx1.sendIdx["name"]=1
][0];
if(!$core.assert([$recv([$self._methodClass()
,$ctx1.sendIdx["methodClass"]=1
][0]).__eq(aClass)
,$ctx1.sendIdx["="]=1
][0])){
$1=[$recv(result).__comma(" (")
,$ctx1.sendIdx[","]=3
][0];
$2=[$self._methodClass()
,$ctx1.sendIdx["methodClass"]=2
][0];
if($2 == null || $2.a$nil){
$3="nil";
} else {
$3=[$recv([$self._methodClass()
,$ctx1.sendIdx["methodClass"]=3
][0])._name()
,$ctx1.sendIdx["name"]=2
][0];
}
result=[$recv([$recv($1).__comma($3)
,$ctx1.sendIdx[","]=2
][0]).__comma(")")
,$ctx1.sendIdx[","]=1
][0];
result;
}
if(!$core.assert($recv([$recv([$self._origin()
,$ctx1.sendIdx["origin"]=1
][0]).__eq(aClass)
,$ctx1.sendIdx["="]=2
][0]).__or($recv([$self._origin()
,$ctx1.sendIdx["origin"]=2
][0]).__eq($self._methodClass())))){
$4=[$recv(result).__comma(" /")
,$ctx1.sendIdx[","]=6
][0];
$5=[$self._origin()
,$ctx1.sendIdx["origin"]=3
][0];
if($5 == null || $5.a$nil){
$6="nil";
} else {
$6=$recv($self._origin())._name();
}
result=[$recv([$recv($4).__comma($6)
,$ctx1.sendIdx[","]=5
][0]).__comma("/")
,$ctx1.sendIdx[","]=4
][0];
result;
}
return [$recv($recv(result).__comma(" >> ")).__comma($recv($self._selector())._symbolPrintString())
,$ctx1.sendIdx[","]=7
][0];
}, function($ctx1) {$ctx1.fill(self,"asStringForClass:",{aClass:aClass,result:result})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "basicPragmas",
protocol: "accessing",
args: [],
source: "basicPragmas\x0a\x09^ pragmas ifNil: [ #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.pragmas;
if($1 == null || $1.a$nil){
return [];
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"basicPragmas",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "browse",
protocol: "browsing",
args: [],
source: "browse\x0a\x09Finder findMethod: self",
referencedClasses: ["Finder"],
pragmas: [],
messageSends: ["findMethod:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._findMethod_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"browse",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "category",
protocol: "accessing",
args: [],
source: "category\x0a\x09^ self protocol",
referencedClasses: [],
pragmas: [],
messageSends: ["protocol"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._protocol();
}, function($ctx1) {$ctx1.fill(self,"category",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "defaultProtocol",
protocol: "defaults",
args: [],
source: "defaultProtocol\x0a\x09^ 'as yet unclassified'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "as yet unclassified";

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "fn",
protocol: "accessing",
args: [],
source: "fn\x0a\x09^ fn",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.fn;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "instantiateFn",
protocol: "accessing",
args: [],
source: "instantiateFn\x0a\x09^ instantiateFn",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.instantiateFn;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "instantiateFn:",
protocol: "accessing",
args: ["anObject"],
source: "instantiateFn: anObject\x0a\x09instantiateFn := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.instantiateFn=anObject;
return self;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isCompiledMethod",
protocol: "testing",
args: [],
source: "isCompiledMethod\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isOverridden",
protocol: "testing",
args: [],
source: "isOverridden\x0a    self methodClass allSubclassesDo: [ :each |\x0a\x09    (each includesSelector: selector)\x0a        \x09ifTrue: [ ^ true ] ].\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: ["allSubclassesDo:", "methodClass", "ifTrue:", "includesSelector:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv($self._methodClass())._allSubclassesDo_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(each)._includesSelector_($self.selector))){
throw $early=[true];
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return false;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"isOverridden",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "isOverride",
protocol: "testing",
args: [],
source: "isOverride\x0a\x09| superclass |\x0a    \x0a    superclass := self methodClass superclass.\x0a\x09superclass ifNil: [ ^ false ].\x0a\x09\x0a    ^ (self methodClass superclass lookupSelector: self selector) notNil",
referencedClasses: [],
pragmas: [],
messageSends: ["superclass", "methodClass", "ifNil:", "notNil", "lookupSelector:", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var superclass;
return $core.withContext(function($ctx1) {
var $1;
superclass=[$recv([$self._methodClass()
,$ctx1.sendIdx["methodClass"]=1
][0])._superclass()
,$ctx1.sendIdx["superclass"]=1
][0];
$1=superclass;
if($1 == null || $1.a$nil){
return false;
} else {
$1;
}
return $recv($recv($recv($self._methodClass())._superclass())._lookupSelector_($self._selector()))._notNil();
}, function($ctx1) {$ctx1.fill(self,"isOverride",{superclass:superclass})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: "accessing",
args: [],
source: "messageSends\x0a\x09^ messageSends",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.messageSends;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "methodClass",
protocol: "accessing",
args: [],
source: "methodClass\x0a\x09^ methodClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.methodClass;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "origin",
protocol: "accessing",
args: [],
source: "origin\x0a\x09^ owner",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.owner;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09\x22Answer the package the receiver belongs to:\x0a\x09- if it is an extension method, answer the corresponding package\x0a\x09- else answer the `methodClass` package\x22\x0a\x09\x0a\x09^ self origin ifNotNil: [ :class | class packageOfProtocol: self protocol ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "origin", "packageOfProtocol:", "protocol"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._origin();
if($1 == null || $1.a$nil){
return $1;
} else {
var class_;
class_=$1;
return $recv(class_)._packageOfProtocol_($self._protocol());
}
}, function($ctx1) {$ctx1.fill(self,"package",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "pragmas",
protocol: "accessing",
args: [],
source: "pragmas\x0a\x09^ self basicPragmas collect: [ :each | Message selector: each first arguments: each second ]",
referencedClasses: ["Message"],
pragmas: [],
messageSends: ["collect:", "basicPragmas", "selector:arguments:", "first", "second"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._basicPragmas())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.Message)._selector_arguments_($recv(each)._first(),$recv(each)._second());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"pragmas",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "pragmas:",
protocol: "accessing",
args: ["anArrayOfMessages"],
source: "pragmas: anArrayOfMessages\x0a\x09pragmas := anArrayOfMessages collect: [ :each | { each selector. each arguments } ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "selector", "arguments"]
}, function ($methodClass){ return function (anArrayOfMessages){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.pragmas=$recv(anArrayOfMessages)._collect_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each)._selector(),$recv(each)._arguments()];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"pragmas:",{anArrayOfMessages:anArrayOfMessages})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "protocol",
protocol: "accessing",
args: [],
source: "protocol\x0a\x09^ protocol ifNil: [ self defaultProtocol ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "defaultProtocol"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.protocol;
if($1 == null || $1.a$nil){
return $self._defaultProtocol();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"protocol",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "protocol:",
protocol: "accessing",
args: ["aString"],
source: "protocol: aString\x0a\x09| oldProtocol |\x0a\x09oldProtocol := self protocol.\x0a\x09protocol := aString.\x0a\x0a\x09oldProtocol ifNotNil: [\x0a\x09\x09SystemAnnouncer current announce: (MethodMoved new\x0a\x09\x09\x09method: self;\x0a\x09\x09\x09oldProtocol: oldProtocol;\x0a\x09\x09\x09yourself) ].\x0a\x0a\x09self origin ifNotNil: [ :origin |\x0a\x09\x09origin organization addElement: aString.\x0a\x09\x09origin removeProtocolIfEmpty: oldProtocol ]",
referencedClasses: ["SystemAnnouncer", "MethodMoved"],
pragmas: [],
messageSends: ["protocol", "ifNotNil:", "announce:", "current", "method:", "new", "oldProtocol:", "yourself", "origin", "addElement:", "organization", "removeProtocolIfEmpty:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var oldProtocol;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
oldProtocol=$self._protocol();
$self.protocol=aString;
$1=oldProtocol;
if($1 == null || $1.a$nil){
$1;
} else {
$2=$recv($globals.SystemAnnouncer)._current();
$3=$recv($globals.MethodMoved)._new();
$recv($3)._method_(self);
$recv($3)._oldProtocol_(oldProtocol);
$recv($2)._announce_($recv($3)._yourself());
}
$4=$self._origin();
if($4 == null || $4.a$nil){
$4;
} else {
var origin;
origin=$4;
$recv($recv(origin)._organization())._addElement_(aString);
$recv(origin)._removeProtocolIfEmpty_(oldProtocol);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"protocol:",{aString:aString,oldProtocol:oldProtocol})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "referencedClasses",
protocol: "accessing",
args: [],
source: "referencedClasses\x0a\x09^ referencedClasses",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.referencedClasses;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "sendTo:arguments:",
protocol: "evaluating",
args: ["anObject", "aCollection"],
source: "sendTo: anObject arguments: aCollection\x0a\x09^ self fn applyTo: anObject arguments: aCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["applyTo:arguments:", "fn"]
}, function ($methodClass){ return function (anObject,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._fn())._applyTo_arguments_(anObject,aCollection);
}, function($ctx1) {$ctx1.fill(self,"sendTo:arguments:",{anObject:anObject,aCollection:aCollection})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "source",
protocol: "accessing",
args: [],
source: "source\x0a\x09^ source ifNil: [ '' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.source;
if($1 == null || $1.a$nil){
return "";
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"source",{})});
}; }),
$globals.CompiledMethod);

$core.addMethod(
$core.method({
selector: "source:",
protocol: "accessing",
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.source=aString;
return self;

}; }),
$globals.CompiledMethod);



$core.addClass("ForkPool", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.ForkPool, ["poolSize", "maxPoolSize", "queue", "worker"]);
$globals.ForkPool.comment="I am responsible for handling forked blocks.\x0aThe pool size sets the maximum concurrent forked blocks.\x0a\x0a## API\x0a\x0aThe default instance is accessed with `#default`.\x0aThe maximum concurrent forked blocks can be set with `#maxPoolSize:`.\x0a\x0aForking is done via `BlockClosure >> #fork`";
$core.addMethod(
$core.method({
selector: "addWorker",
protocol: "private",
args: [],
source: "addWorker\x0a\x09worker valueWithTimeout: 0.\x0a\x09poolSize := poolSize + 1",
referencedClasses: [],
pragmas: [],
messageSends: ["valueWithTimeout:", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.worker)._valueWithTimeout_((0));
$self.poolSize=$recv($self.poolSize).__plus((1));
return self;
}, function($ctx1) {$ctx1.fill(self,"addWorker",{})});
}; }),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "defaultMaxPoolSize",
protocol: "defaults",
args: [],
source: "defaultMaxPoolSize\x0a\x09^ self class defaultMaxPoolSize",
referencedClasses: [],
pragmas: [],
messageSends: ["defaultMaxPoolSize", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._defaultMaxPoolSize();
}, function($ctx1) {$ctx1.fill(self,"defaultMaxPoolSize",{})});
}; }),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "fork:",
protocol: "actions",
args: ["aBlock"],
source: "fork: aBlock\x0a\x09poolSize < self maxPoolSize ifTrue: [ self addWorker ].\x0a\x09queue nextPut: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "<", "maxPoolSize", "addWorker", "nextPut:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self.poolSize).__lt($self._maxPoolSize()))){
$self._addWorker();
}
$recv($self.queue)._nextPut_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"fork:",{aBlock:aBlock})});
}; }),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09\x0a\x09poolSize := 0.\x0a\x09queue := Queue new.\x0a\x09worker := self makeWorker",
referencedClasses: ["Queue"],
pragmas: [],
messageSends: ["initialize", "new", "makeWorker"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.poolSize=(0);
$self.queue=$recv($globals.Queue)._new();
$self.worker=$self._makeWorker();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "makeWorker",
protocol: "initialization",
args: [],
source: "makeWorker\x0a\x09| sentinel |\x0a\x09sentinel := Object new.\x0a\x09^ [ | block |\x0a\x09\x09poolSize := poolSize - 1.\x0a\x09\x09block := queue nextIfAbsent: [ sentinel ].\x0a\x09\x09block == sentinel ifFalse: [\x0a\x09\x09\x09[ block value ] ensure: [ self addWorker ] ]]",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "-", "nextIfAbsent:", "ifFalse:", "==", "ensure:", "value", "addWorker"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var sentinel;
return $core.withContext(function($ctx1) {
sentinel=$recv($globals.Object)._new();
return (function(){
var block;
return $core.withContext(function($ctx2) {
$self.poolSize=$recv($self.poolSize).__minus((1));
block=$recv($self.queue)._nextIfAbsent_((function(){
return sentinel;

}));
if(!$core.assert($recv(block).__eq_eq(sentinel))){
return $recv((function(){
return $core.withContext(function($ctx3) {
return $recv(block)._value();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}))._ensure_((function(){
return $core.withContext(function($ctx3) {
return $self._addWorker();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,5)});
}));
}
}, function($ctx2) {$ctx2.fillBlock({block:block},$ctx1,1)});
});
}, function($ctx1) {$ctx1.fill(self,"makeWorker",{sentinel:sentinel})});
}; }),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "maxPoolSize",
protocol: "accessing",
args: [],
source: "maxPoolSize\x0a\x09^ maxPoolSize ifNil: [ self defaultMaxPoolSize ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "defaultMaxPoolSize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.maxPoolSize;
if($1 == null || $1.a$nil){
return $self._defaultMaxPoolSize();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"maxPoolSize",{})});
}; }),
$globals.ForkPool);

$core.addMethod(
$core.method({
selector: "maxPoolSize:",
protocol: "accessing",
args: ["anInteger"],
source: "maxPoolSize: anInteger\x0a\x09maxPoolSize := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.maxPoolSize=anInteger;
return self;

}; }),
$globals.ForkPool);


$core.setSlots($globals.ForkPool.a$cls, ["default"]);
$core.addMethod(
$core.method({
selector: "default",
protocol: "accessing",
args: [],
source: "default\x0a\x09^ default ifNil: [ default := self new ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.default;
if($1 == null || $1.a$nil){
$self.default=$self._new();
return $self.default;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"default",{})});
}; }),
$globals.ForkPool.a$cls);

$core.addMethod(
$core.method({
selector: "defaultMaxPoolSize",
protocol: "accessing",
args: [],
source: "defaultMaxPoolSize\x0a\x09^ 100",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (100);

}; }),
$globals.ForkPool.a$cls);

$core.addMethod(
$core.method({
selector: "resetDefault",
protocol: "accessing",
args: [],
source: "resetDefault\x0a\x09default := nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
$self.default=nil;
return self;

}; }),
$globals.ForkPool.a$cls);


$core.addClass("Message", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.Message, ["selector", "arguments"]);
$globals.Message.comment="In general, the system does not use instances of me for efficiency reasons.\x0aHowever, when a message is not understood by its receiver, the interpreter will make up an instance of it in order to capture the information involved in an actual message transmission.\x0aThis instance is sent it as an argument with the message `#doesNotUnderstand:` to the receiver.\x0a\x0aSee boot.js, `messageNotUnderstood` and its counterpart `Object >> #doesNotUnderstand:`\x0a\x0a## API\x0a\x0aBesides accessing methods, `#sendTo:` provides a convenient way to send a message to an object.";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ arguments",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.arguments;

}; }),
$globals.Message);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: "accessing",
args: ["anArray"],
source: "arguments: anArray\x0a\x09arguments := anArray",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
$self.arguments=anArray;
return self;

}; }),
$globals.Message);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream\x0a\x09\x09nextPutAll: '(';\x0a\x09\x09nextPutAll: self selector;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "selector"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_("(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aStream)._nextPutAll_($self._selector())
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Message);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.Message);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.Message);

$core.addMethod(
$core.method({
selector: "sendTo:",
protocol: "actions",
args: ["anObject"],
source: "sendTo: anObject\x0a\x09^ anObject perform: self selector withArguments: self arguments",
referencedClasses: [],
pragmas: [],
messageSends: ["perform:withArguments:", "selector", "arguments"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._perform_withArguments_($self._selector(),$self._arguments());
}, function($ctx1) {$ctx1.fill(self,"sendTo:",{anObject:anObject})});
}; }),
$globals.Message);


$core.addMethod(
$core.method({
selector: "selector:arguments:",
protocol: "instance creation",
args: ["aString", "anArray"],
source: "selector: aString arguments: anArray\x0a\x09^ self new\x0a\x09\x09selector: aString;\x0a\x09\x09arguments: anArray;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["selector:", "new", "arguments:", "yourself"]
}, function ($methodClass){ return function (aString,anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._selector_(aString);
$recv($1)._arguments_(anArray);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"selector:arguments:",{aString:aString,anArray:anArray})});
}; }),
$globals.Message.a$cls);

$core.addMethod(
$core.method({
selector: "selector:arguments:notUnderstoodBy:",
protocol: "dnu handling",
args: ["aString", "anArray", "anObject"],
source: "selector: aString arguments: anArray notUnderstoodBy: anObject\x0a\x09\x22Creates the message and passes it to #doesNotUnderstand:.\x0a\x09Used by kernel to handle MNU.\x22\x0a\x09^ anObject doesNotUnderstand:\x0a\x09\x09(self selector: aString arguments: anArray)",
referencedClasses: [],
pragmas: [],
messageSends: ["doesNotUnderstand:", "selector:arguments:"]
}, function ($methodClass){ return function (aString,anArray,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._doesNotUnderstand_($self._selector_arguments_(aString,anArray));
}, function($ctx1) {$ctx1.fill(self,"selector:arguments:notUnderstoodBy:",{aString:aString,anArray:anArray,anObject:anObject})});
}; }),
$globals.Message.a$cls);


$core.addClass("MessageSend", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.MessageSend, ["receiver", "message"]);
$globals.MessageSend.comment="I encapsulate message sends to objects. Arguments can be either predefined or supplied when the message send is performed. \x0a\x0a## API\x0a\x0aUse `#value` to perform a message send with its predefined arguments and `#value:*` if additonal arguments have to supplied.";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ message arguments",
referencedClasses: [],
pragmas: [],
messageSends: ["arguments"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.message)._arguments();
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: "accessing",
args: ["anArray"],
source: "arguments: anArray\x0a\x09message arguments: anArray",
referencedClasses: [],
pragmas: [],
messageSends: ["arguments:"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.message)._arguments_(anArray);
return self;
}, function($ctx1) {$ctx1.fill(self,"arguments:",{anArray:anArray})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09message := Message new",
referencedClasses: ["Message"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.message=$recv($globals.Message)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream\x0a\x09\x09nextPutAll: '(';\x0a\x09\x09nextPutAll: self receiver;\x0a\x09\x09nextPutAll: ' >> ';\x0a\x09\x09nextPutAll: self selector;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "receiver", "selector"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_("(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aStream)._nextPutAll_($self._receiver())
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$recv(aStream)._nextPutAll_(" >> ")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
[$recv(aStream)._nextPutAll_($self._selector())
,$ctx1.sendIdx["nextPutAll:"]=4
][0];
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: "accessing",
args: ["anObject"],
source: "receiver: anObject\x0a\x09receiver := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.receiver=anObject;
return self;

}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ message selector",
referencedClasses: [],
pragmas: [],
messageSends: ["selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.message)._selector();
}, function($ctx1) {$ctx1.fill(self,"selector",{})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09message selector: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["selector:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.message)._selector_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"selector:",{aString:aString})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value",
protocol: "evaluating",
args: [],
source: "value\x0a\x09^ message sendTo: self receiver",
referencedClasses: [],
pragmas: [],
messageSends: ["sendTo:", "receiver"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.message)._sendTo_($self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "evaluating",
args: ["anObject"],
source: "value: anObject\x0a\x09^ message \x0a\x09\x09arguments: { anObject };\x0a\x09\x09sendTo: self receiver",
referencedClasses: [],
pragmas: [],
messageSends: ["arguments:", "sendTo:", "receiver"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.message;
$recv($1)._arguments_([anObject]);
return $recv($1)._sendTo_($self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value:value:",
protocol: "evaluating",
args: ["firstArgument", "secondArgument"],
source: "value: firstArgument value: secondArgument\x0a\x09^ message \x0a\x09\x09arguments: { firstArgument. secondArgument };\x0a\x09\x09sendTo: self receiver",
referencedClasses: [],
pragmas: [],
messageSends: ["arguments:", "sendTo:", "receiver"]
}, function ($methodClass){ return function (firstArgument,secondArgument){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.message;
$recv($1)._arguments_([firstArgument,secondArgument]);
return $recv($1)._sendTo_($self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value:value:",{firstArgument:firstArgument,secondArgument:secondArgument})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "value:value:value:",
protocol: "evaluating",
args: ["firstArgument", "secondArgument", "thirdArgument"],
source: "value: firstArgument value: secondArgument value: thirdArgument\x0a\x09^ message \x0a\x09\x09arguments: { firstArgument. secondArgument. thirdArgument };\x0a\x09\x09sendTo: self receiver",
referencedClasses: [],
pragmas: [],
messageSends: ["arguments:", "sendTo:", "receiver"]
}, function ($methodClass){ return function (firstArgument,secondArgument,thirdArgument){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.message;
$recv($1)._arguments_([firstArgument,secondArgument,thirdArgument]);
return $recv($1)._sendTo_($self._receiver());
}, function($ctx1) {$ctx1.fill(self,"value:value:value:",{firstArgument:firstArgument,secondArgument:secondArgument,thirdArgument:thirdArgument})});
}; }),
$globals.MessageSend);

$core.addMethod(
$core.method({
selector: "valueWithPossibleArguments:",
protocol: "evaluating",
args: ["anArray"],
source: "valueWithPossibleArguments: anArray\x0a\x09self arguments: anArray.\x0a\x09^ self value",
referencedClasses: [],
pragmas: [],
messageSends: ["arguments:", "value"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._arguments_(anArray);
return $self._value();
}, function($ctx1) {$ctx1.fill(self,"valueWithPossibleArguments:",{anArray:anArray})});
}; }),
$globals.MessageSend);



$core.addClass("MethodContext", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.MethodContext, ["receiver", "evaluatedSelector", "homeContext", "index", "locals", "outerContext", "selector", "sendIdx", "supercall"]);
$globals.MethodContext.comment="I hold all the dynamic state associated with the execution of either a method activation resulting from a message send. I am used to build the call stack while debugging.\x0a\x0aMy instances are JavaScript `SmalltalkMethodContext` objects defined in `boot.js`.";
$core.addMethod(
$core.method({
selector: "basicReceiver",
protocol: "accessing",
args: [],
source: "basicReceiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "evaluatedSelector",
protocol: "accessing",
args: [],
source: "evaluatedSelector\x0a\x09^ evaluatedSelector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.evaluatedSelector;

}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "home",
protocol: "accessing",
args: [],
source: "home\x0a\x09^ homeContext ifNotNil: [ :c | c hydrated ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "hydrated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.homeContext;
if($1 == null || $1.a$nil){
return $1;
} else {
var c;
c=$1;
return $recv(c)._hydrated();
}
}, function($ctx1) {$ctx1.fill(self,"home",{})});
}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "hydrated",
protocol: "accessing",
args: [],
source: "hydrated\x0a\x09<inlineJS: 'if (!$self.selector && !$self.outerContext) $self.setup(self); return self;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["if (!$self.selector && !$self.outerContext) $self.setup(self); return self;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if (!$self.selector && !$self.outerContext) $self.setup(self); return self;;
return self;
}, function($ctx1) {$ctx1.fill(self,"hydrated",{})});
}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "index",
protocol: "accessing",
args: [],
source: "index\x0a\x09^ index ifNil: [ 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.index;
if($1 == null || $1.a$nil){
return (0);
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"index",{})});
}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "locals",
protocol: "accessing",
args: [],
source: "locals\x0a\x09^ locals",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.locals;

}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "outerContext",
protocol: "accessing",
args: [],
source: "outerContext\x0a\x09^ outerContext ifNil: [ self home ] ifNotNil: [ :c | c hydrated ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "home", "hydrated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.outerContext;
if($1 == null || $1.a$nil){
return $self._home();
} else {
var c;
c=$1;
return $recv(c)._hydrated();
}
}, function($ctx1) {$ctx1.fill(self,"outerContext",{})});
}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector ifNotNil: [ Smalltalk core js2st: selector ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["ifNotNil:", "js2st:", "core"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.selector;
if($1 == null || $1.a$nil){
return $1;
} else {
return $recv($recv($globals.Smalltalk)._core())._js2st_($self.selector);
}
}, function($ctx1) {$ctx1.fill(self,"selector",{})});
}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: "accessing",
args: [],
source: "sendIndexes\x0a\x09^ sendIdx",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.sendIdx;

}; }),
$globals.MethodContext);

$core.addMethod(
$core.method({
selector: "supercall",
protocol: "accessing",
args: [],
source: "supercall\x0a\x09^ supercall = true",
referencedClasses: [],
pragmas: [],
messageSends: ["="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.supercall).__eq(true);
}, function($ctx1) {$ctx1.fill(self,"supercall",{})});
}; }),
$globals.MethodContext);



$core.addClass("NativeFunction", $globals.Object, "Kernel-Methods");
$globals.NativeFunction.comment="I am a wrapper around native functions, such as `WebSocket`.\x0aFor 'normal' functions (whose constructor is the JavaScript `Function` object), use `BlockClosure`.\x0a\x0a## API\x0a\x0aSee the class-side `instance creation` methods for instance creation.\x0a\x0aCreated instances will most probably be instance of `JSObjectProxy`.\x0a\x0a## Usage example:\x0a\x0a\x09| ws |\x0a\x09ws := NativeFunction constructor: 'WebSocket' value: 'ws://localhost'.\x0a\x09ws at: 'onopen' put: [ ws send: 'hey there from Amber' ]";

$core.addMethod(
$core.method({
selector: "constructorNamed:",
protocol: "instance creation",
args: ["aString"],
source: "constructorNamed: aString\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return new nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:",{aString:aString})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorNamed:value:",
protocol: "instance creation",
args: ["aString", "anObject"],
source: "constructorNamed: aString value: anObject\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return new nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:value:",{aString:aString,anObject:anObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorNamed:value:value:",
protocol: "instance creation",
args: ["aString", "anObject", "anObject2"],
source: "constructorNamed: aString value: anObject value: anObject2\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return new nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorNamed:value:value:value:",
protocol: "instance creation",
args: ["aString", "anObject", "anObject2", "anObject3"],
source: "constructorNamed: aString value: anObject value: anObject2 value: anObject3\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return new nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorNamed:value:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorOf:",
protocol: "instance creation",
args: ["nativeFunc"],
source: "constructorOf: nativeFunc\x0a\x09<inlineJS: '\x0a\x09\x09return new nativeFunc();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return new nativeFunc();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:",{nativeFunc:nativeFunc})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorOf:value:",
protocol: "instance creation",
args: ["nativeFunc", "anObject"],
source: "constructorOf: nativeFunc value: anObject\x0a\x09<inlineJS: '\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return new nativeFunc(anObject);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:value:",{nativeFunc:nativeFunc,anObject:anObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorOf:value:value:",
protocol: "instance creation",
args: ["nativeFunc", "anObject", "anObject2"],
source: "constructorOf: nativeFunc value: anObject value: anObject2\x0a\x09<inlineJS: '\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return new nativeFunc(anObject,anObject2);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "constructorOf:value:value:value:",
protocol: "instance creation",
args: ["nativeFunc", "anObject", "anObject2", "anObject3"],
source: "constructorOf: nativeFunc value: anObject value: anObject2 value: anObject3\x0a\x09<inlineJS: '\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return new nativeFunc(anObject,anObject2, anObject3);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return new nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"constructorOf:value:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "exists:",
protocol: "testing",
args: ["aString"],
source: "exists: aString\x0a\x09^ Platform includesGlobal: aString",
referencedClasses: ["Platform"],
pragmas: [],
messageSends: ["includesGlobal:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Platform)._includesGlobal_(aString);
}, function($ctx1) {$ctx1.fill(self,"exists:",{aString:aString})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionNamed:",
protocol: "function calling",
args: ["aString"],
source: "functionNamed: aString\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals[aString];\x0a\x09\x09return nativeFunc();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals[aString];\x0a\x09\x09return nativeFunc();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals[aString];
		return nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:",{aString:aString})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionNamed:value:",
protocol: "function calling",
args: ["aString", "anObject"],
source: "functionNamed: aString value: anObject\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return nativeFunc(anObject);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return nativeFunc(anObject);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:value:",{aString:aString,anObject:anObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionNamed:value:value:",
protocol: "function calling",
args: ["aString", "anObject", "anObject2"],
source: "functionNamed: aString value: anObject value: anObject2\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return nativeFunc(anObject,anObject2);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return nativeFunc(anObject,anObject2);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionNamed:value:value:value:",
protocol: "function calling",
args: ["aString", "anObject", "anObject2", "anObject3"],
source: "functionNamed: aString value: anObject value: anObject2 value: anObject3\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return nativeFunc(anObject,anObject2, anObject3);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return nativeFunc(anObject,anObject2, anObject3);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:value:value:value:",{aString:aString,anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionNamed:valueWithArgs:",
protocol: "function calling",
args: ["aString", "args"],
source: "functionNamed: aString valueWithArgs: args\x0a\x09<inlineJS: '\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, null, args);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var nativeFunc=$globals.Platform._globals()[aString];\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, null, args);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var nativeFunc=$globals.Platform._globals()[aString];
		return Function.prototype.apply.call(nativeFunc, null, args);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionNamed:valueWithArgs:",{aString:aString,args:args})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionOf:",
protocol: "function calling",
args: ["nativeFunc"],
source: "functionOf: nativeFunc\x0a\x09<inlineJS: '\x0a\x09\x09return nativeFunc();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return nativeFunc();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:",{nativeFunc:nativeFunc})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionOf:value:",
protocol: "function calling",
args: ["nativeFunc", "anObject"],
source: "functionOf: nativeFunc value: anObject\x0a\x09<inlineJS: '\x0a\x09\x09return nativeFunc(anObject);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return nativeFunc(anObject);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc(anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:value:",{nativeFunc:nativeFunc,anObject:anObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionOf:value:value:",
protocol: "function calling",
args: ["nativeFunc", "anObject", "anObject2"],
source: "functionOf: nativeFunc value: anObject value: anObject2\x0a\x09<inlineJS: '\x0a\x09\x09return nativeFunc(anObject,anObject2);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return nativeFunc(anObject,anObject2);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc(anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionOf:value:value:value:",
protocol: "function calling",
args: ["nativeFunc", "anObject", "anObject2", "anObject3"],
source: "functionOf: nativeFunc value: anObject value: anObject2 value: anObject3\x0a\x09<inlineJS: '\x0a\x09\x09return nativeFunc(anObject,anObject2, anObject3);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return nativeFunc(anObject,anObject2, anObject3);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return nativeFunc(anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:value:value:value:",{nativeFunc:nativeFunc,anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "functionOf:valueWithArgs:",
protocol: "function calling",
args: ["nativeFunc", "args"],
source: "functionOf: nativeFunc valueWithArgs: args\x0a\x09<inlineJS: '\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, null, args);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, null, args);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.apply.call(nativeFunc, null, args);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"functionOf:valueWithArgs:",{nativeFunc:nativeFunc,args:args})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "isNativeFunction:",
protocol: "testing",
args: ["anObject"],
source: "isNativeFunction: anObject\x0a\x09<inlineJS: 'return typeof anObject === \x22function\x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof anObject === \x22function\x22"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof anObject === "function";
return self;
}, function($ctx1) {$ctx1.fill(self,"isNativeFunction:",{anObject:anObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "methodOf:this:",
protocol: "method calling",
args: ["nativeFunc", "thisObject"],
source: "methodOf: nativeFunc this: thisObject\x0a\x09<inlineJS: '\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,thisObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:",{nativeFunc:nativeFunc,thisObject:thisObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "methodOf:this:value:",
protocol: "method calling",
args: ["nativeFunc", "thisObject", "anObject"],
source: "methodOf: nativeFunc this: thisObject value: anObject\x0a\x09<inlineJS: '\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject, anObject);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject, anObject);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,thisObject,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject, anObject);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:value:",{nativeFunc:nativeFunc,thisObject:thisObject,anObject:anObject})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "methodOf:this:value:value:",
protocol: "method calling",
args: ["nativeFunc", "thisObject", "anObject", "anObject2"],
source: "methodOf: nativeFunc this: thisObject value: anObject value: anObject2\x0a\x09<inlineJS: '\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,thisObject,anObject,anObject2){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:value:value:",{nativeFunc:nativeFunc,thisObject:thisObject,anObject:anObject,anObject2:anObject2})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "methodOf:this:value:value:value:",
protocol: "method calling",
args: ["nativeFunc", "thisObject", "anObject", "anObject2", "anObject3"],
source: "methodOf: nativeFunc this: thisObject value: anObject value: anObject2 value: anObject3\x0a\x09<inlineJS: '\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2, anObject3);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2, anObject3);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,thisObject,anObject,anObject2,anObject3){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.call.call(nativeFunc, thisObject,anObject,anObject2, anObject3);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:value:value:value:",{nativeFunc:nativeFunc,thisObject:thisObject,anObject:anObject,anObject2:anObject2,anObject3:anObject3})});
}; }),
$globals.NativeFunction.a$cls);

$core.addMethod(
$core.method({
selector: "methodOf:this:valueWithArgs:",
protocol: "method calling",
args: ["nativeFunc", "thisObject", "args"],
source: "methodOf: nativeFunc this: thisObject valueWithArgs: args\x0a\x09<inlineJS: '\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, thisObject, args);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return Function.prototype.apply.call(nativeFunc, thisObject, args);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (nativeFunc,thisObject,args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return Function.prototype.apply.call(nativeFunc, thisObject, args);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"methodOf:this:valueWithArgs:",{nativeFunc:nativeFunc,thisObject:thisObject,args:args})});
}; }),
$globals.NativeFunction.a$cls);


$core.addTrait("TMethodContext", "Kernel-Methods");
$core.addMethod(
$core.method({
selector: "asString",
protocol: "converting",
args: [],
source: "asString\x0a\x09^ self isBlockContext\x0a\x09\x09ifTrue: [ 'a block (in ', self methodContext asString, ')' ]\x0a\x09\x09ifFalse: [ self method\x0a\x09\x09\x09ifNotNil: [ :method | method asStringForClass: self receiver class ]\x0a\x09\x09\x09ifNil: [ 'missing method ', self selector symbolPrintString ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isBlockContext", ",", "asString", "methodContext", "ifNotNil:ifNil:", "method", "asStringForClass:", "class", "receiver", "symbolPrintString", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($self._isBlockContext())){
return [$recv(["a block (in ".__comma($recv($self._methodContext())._asString())
,$ctx1.sendIdx[","]=2
][0]).__comma(")")
,$ctx1.sendIdx[","]=1
][0];
} else {
$1=$self._method();
if($1 == null || $1.a$nil){
return "missing method ".__comma($recv($self._selector())._symbolPrintString());
} else {
var method;
method=$1;
return $recv(method)._asStringForClass_($recv($self._receiver())._class());
}
}
}, function($ctx1) {$ctx1.fill(self,"asString",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "basicReceiver",
protocol: "accessing",
args: [],
source: "basicReceiver\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"basicReceiver",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "findContextSuchThat:",
protocol: "accessing",
args: ["testBlock"],
source: "findContextSuchThat: testBlock\x0a\x09\x22Search self and my sender chain for first one that satisfies `testBlock`.  \x0a\x09Answer `nil` if none satisfy\x22\x0a\x0a\x09| context |\x0a\x09\x0a\x09context := self.\x0a\x09[ context isNil] whileFalse: [\x0a\x09\x09(testBlock value: context) \x0a\x09\x09\x09ifTrue: [ ^ context ].\x0a\x09\x09context := context outerContext ].\x0a\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", "isNil", "ifTrue:", "value:", "outerContext"]
}, function ($methodClass){ return function (testBlock){
var self=this,$self=this;
var context;
return $core.withContext(function($ctx1) {
var $early={};
try {
context=self;
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(context)._isNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
if($core.assert($recv(testBlock)._value_(context))){
throw $early=[context];
}
context=$recv(context)._outerContext();
return context;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return nil;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"findContextSuchThat:",{testBlock:testBlock,context:context})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "home",
protocol: "accessing",
args: [],
source: "home\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"home",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "index",
protocol: "accessing",
args: [],
source: "index\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"index",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "isBlockContext",
protocol: "testing",
args: [],
source: "isBlockContext\x0a\x09\x22Block context do not have selectors.\x22\x0a\x09\x0a\x09^ self selector isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["isNil", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._selector())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isBlockContext",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "locals",
protocol: "accessing",
args: [],
source: "locals\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"locals",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "method",
protocol: "accessing",
args: [],
source: "method\x0a\x09| method lookupClass receiverClass supercall |\x0a\x09\x0a\x09self methodContext ifNil: [ ^ nil ].\x0a\x0a\x09receiverClass := self methodContext receiver class.\x0a\x09method := receiverClass lookupSelector: self methodContext selector.\x0a\x09supercall := self outerContext \x0a\x09\x09ifNil: [ false ]\x0a\x09\x09ifNotNil: [ :outer | outer supercall ].\x0a\x0a\x09^ supercall\x0a\x09\x09ifFalse: [ method ]\x0a\x09\x09ifTrue: [ method methodClass superclass lookupSelector: self methodContext selector ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "methodContext", "class", "receiver", "lookupSelector:", "selector", "ifNil:ifNotNil:", "outerContext", "supercall", "ifFalse:ifTrue:", "superclass", "methodClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var method,lookupClass,receiverClass,supercall;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$self._methodContext()
,$ctx1.sendIdx["methodContext"]=1
][0];
if($1 == null || $1.a$nil){
return nil;
} else {
$1;
}
receiverClass=$recv($recv([$self._methodContext()
,$ctx1.sendIdx["methodContext"]=2
][0])._receiver())._class();
method=[$recv(receiverClass)._lookupSelector_([$recv([$self._methodContext()
,$ctx1.sendIdx["methodContext"]=3
][0])._selector()
,$ctx1.sendIdx["selector"]=1
][0])
,$ctx1.sendIdx["lookupSelector:"]=1
][0];
$2=$self._outerContext();
if($2 == null || $2.a$nil){
supercall=false;
} else {
var outer;
outer=$2;
supercall=$recv(outer)._supercall();
}
if($core.assert(supercall)){
return $recv($recv($recv(method)._methodClass())._superclass())._lookupSelector_($recv($self._methodContext())._selector());
} else {
return method;
}
}, function($ctx1) {$ctx1.fill(self,"method",{method:method,lookupClass:lookupClass,receiverClass:receiverClass,supercall:supercall})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "methodContext",
protocol: "accessing",
args: [],
source: "methodContext\x0a\x09self isBlockContext ifFalse: [ ^ self ].\x0a\x09\x0a\x09^ self outerContext ifNotNil: [ :outer |\x0a\x09\x09outer methodContext ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "isBlockContext", "ifNotNil:", "outerContext", "methodContext"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if(!$core.assert($self._isBlockContext())){
return self;
}
$1=$self._outerContext();
if($1 == null || $1.a$nil){
return $1;
} else {
var outer;
outer=$1;
return $recv(outer)._methodContext();
}
}, function($ctx1) {$ctx1.fill(self,"methodContext",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "outerContext",
protocol: "accessing",
args: [],
source: "outerContext\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"outerContext",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream \x0a\x09\x09nextPutAll: '(';\x0a\x09\x09nextPutAll: self asString;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "asString"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_("(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aStream)._nextPutAll_($self._asString())
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ (self isBlockContext and: [ self outerContext notNil ])\x0a\x09\x09ifTrue: [ self outerContext receiver ]\x0a\x09\x09ifFalse: [ self basicReceiver ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "and:", "isBlockContext", "notNil", "outerContext", "receiver", "basicReceiver"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($self._isBlockContext())){
$1=$recv([$self._outerContext()
,$ctx1.sendIdx["outerContext"]=1
][0])._notNil();
} else {
$1=false;
}
if($core.assert($1)){
return $recv($self._outerContext())._receiver();
} else {
return $self._basicReceiver();
}
}, function($ctx1) {$ctx1.fill(self,"receiver",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"selector",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: "accessing",
args: [],
source: "sendIndexes\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"sendIndexes",{})});
}; }),
$globals.TMethodContext);

$core.addMethod(
$core.method({
selector: "supercall",
protocol: "accessing",
args: [],
source: "supercall\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"supercall",{})});
}; }),
$globals.TMethodContext);


$core.addClass("Timeout", $globals.Object, "Kernel-Methods");
$core.setSlots($globals.Timeout, ["rawTimeout"]);
$globals.Timeout.comment="I am wrapping the returns from `set{Timeout,Interval}`.\x0a\x0a## Motivation\x0a\x0aNumber suffices in browsers, but node.js returns an object.";
$core.addMethod(
$core.method({
selector: "clearInterval",
protocol: "timeout/interval",
args: [],
source: "clearInterval\x0a\x09<inlineJS: '\x0a\x09\x09var interval = $self.rawTimeout;\x0a\x09\x09clearInterval(interval);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var interval = $self.rawTimeout;\x0a\x09\x09clearInterval(interval);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var interval = $self.rawTimeout;
		clearInterval(interval);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"clearInterval",{})});
}; }),
$globals.Timeout);

$core.addMethod(
$core.method({
selector: "clearTimeout",
protocol: "timeout/interval",
args: [],
source: "clearTimeout\x0a\x09<inlineJS: '\x0a\x09\x09var timeout = $self.rawTimeout;\x0a\x09\x09clearTimeout(timeout);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var timeout = $self.rawTimeout;\x0a\x09\x09clearTimeout(timeout);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var timeout = $self.rawTimeout;
		clearTimeout(timeout);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"clearTimeout",{})});
}; }),
$globals.Timeout);

$core.addMethod(
$core.method({
selector: "rawTimeout:",
protocol: "accessing",
args: ["anObject"],
source: "rawTimeout: anObject\x0a\x09rawTimeout := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.rawTimeout=anObject;
return self;

}; }),
$globals.Timeout);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["anObject"],
source: "on: anObject\x0a\x09^ self new rawTimeout: anObject; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["rawTimeout:", "new", "yourself"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._rawTimeout_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{anObject:anObject})});
}; }),
$globals.Timeout.a$cls);

$core.setTraitComposition([{trait: $globals.TMethodContext}], $globals.MethodContext);

});

define('amber/core/Kernel-Dag',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Dag");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AbstractDagVisitor", $globals.Object, "Kernel-Dag");
$globals.AbstractDagVisitor.comment="I am base class of `DagNode` visitor.\x0a\x0aConcrete classes should implement `visitDagNode:`,\x0athey can reuse possible variants of implementation\x0aoffered directly: `visitDagNodeVariantSimple:`\x0aand `visitDagNodeVariantRedux:`.";
$core.addMethod(
$core.method({
selector: "value:",
protocol: "evaluating",
args: ["anObject"],
source: "value: anObject\x0a\x09^ self visit: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["visit:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visit_(anObject);
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject})});
}; }),
$globals.AbstractDagVisitor);

$core.addMethod(
$core.method({
selector: "visit:",
protocol: "visiting",
args: ["aNode"],
source: "visit: aNode\x0a\x09^ aNode acceptDagVisitor: self",
referencedClasses: [],
pragmas: [],
messageSends: ["acceptDagVisitor:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aNode)._acceptDagVisitor_(self);
}, function($ctx1) {$ctx1.fill(self,"visit:",{aNode:aNode})});
}; }),
$globals.AbstractDagVisitor);

$core.addMethod(
$core.method({
selector: "visitAll:",
protocol: "visiting",
args: ["aCollection"],
source: "visitAll: aCollection\x0a\x09^ aCollection collect: [ :each | self visit: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "visit:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aCollection)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $self._visit_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitAll:",{aCollection:aCollection})});
}; }),
$globals.AbstractDagVisitor);

$core.addMethod(
$core.method({
selector: "visitAllChildren:",
protocol: "visiting",
args: ["aDagNode"],
source: "visitAllChildren: aDagNode\x0a\x09^ self visitAll: aDagNode dagChildren",
referencedClasses: [],
pragmas: [],
messageSends: ["visitAll:", "dagChildren"]
}, function ($methodClass){ return function (aDagNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitAll_($recv(aDagNode)._dagChildren());
}, function($ctx1) {$ctx1.fill(self,"visitAllChildren:",{aDagNode:aDagNode})});
}; }),
$globals.AbstractDagVisitor);

$core.addMethod(
$core.method({
selector: "visitDagNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNode: aNode\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"visitDagNode:",{aNode:aNode})});
}; }),
$globals.AbstractDagVisitor);

$core.addMethod(
$core.method({
selector: "visitDagNodeVariantRedux:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNodeVariantRedux: aNode\x0a\x09\x22Immutable-guarded implementation of visitDagNode:.\x0a\x09Visits all children and checks if there were changes.\x0a\x09If not, returns aNode.\x0a\x09If yes, returns copy of aNode with new children.\x22\x0a\x0a\x09| newChildren oldChildren |\x0a\x09oldChildren := aNode dagChildren.\x0a\x09newChildren := self visitAllChildren: aNode.\x0a\x09oldChildren = newChildren\x0a\x09\x09ifTrue: [ ^ aNode ]\x0a\x09\x09ifFalse: [ ^ aNode copy dagChildren: newChildren; yourself ]",
referencedClasses: [],
pragmas: [],
messageSends: ["dagChildren", "visitAllChildren:", "ifTrue:ifFalse:", "=", "dagChildren:", "copy", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var newChildren,oldChildren;
return $core.withContext(function($ctx1) {
var $1;
oldChildren=$recv(aNode)._dagChildren();
newChildren=$self._visitAllChildren_(aNode);
if($core.assert($recv(oldChildren).__eq(newChildren))){
return aNode;
} else {
$1=$recv(aNode)._copy();
$recv($1)._dagChildren_(newChildren);
return $recv($1)._yourself();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"visitDagNodeVariantRedux:",{aNode:aNode,newChildren:newChildren,oldChildren:oldChildren})});
}; }),
$globals.AbstractDagVisitor);

$core.addMethod(
$core.method({
selector: "visitDagNodeVariantSimple:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNodeVariantSimple: aNode\x0a\x09\x22Simple implementation of visitDagNode:.\x0a\x09Visits children, then returns aNode\x22\x0a\x0a\x09self visitAllChildren: aNode.\x0a\x09^ aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitAllChildren:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._visitAllChildren_(aNode);
return aNode;
}, function($ctx1) {$ctx1.fill(self,"visitDagNodeVariantSimple:",{aNode:aNode})});
}; }),
$globals.AbstractDagVisitor);



$core.addClass("PathDagVisitor", $globals.AbstractDagVisitor, "Kernel-Dag");
$core.setSlots($globals.PathDagVisitor, ["path"]);
$globals.PathDagVisitor.comment="I am base class of `DagNode` visitor.\x0a\x0aI hold the path of ancestors up to actual node\x0ain `self path`.";
$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09path := #()",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.path=[];
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.PathDagVisitor);

$core.addMethod(
$core.method({
selector: "path",
protocol: "accessing",
args: [],
source: "path\x0a\x09^ path",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.path;

}; }),
$globals.PathDagVisitor);

$core.addMethod(
$core.method({
selector: "visit:",
protocol: "visiting",
args: ["aNode"],
source: "visit: aNode\x0a\x09| oldPath result |\x0a\x09result := aNode.\x0a\x09oldPath := path.\x0a\x09[\x0a\x09\x09path := path, {aNode}.\x0a\x09\x09result := super visit: aNode\x0a\x09] ensure: [ path := oldPath ].\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["ensure:", ",", "visit:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var oldPath,result;
return $core.withContext(function($ctx1) {
result=aNode;
oldPath=$self.path;
$recv((function(){
return $core.withContext(function($ctx2) {
$self.path=$recv($self.path).__comma([aNode]);
result=[(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visit_.call($self,aNode))
,$ctx2.supercall = false
][0];
return result;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
$self.path=oldPath;
return $self.path;

}));
return result;
}, function($ctx1) {$ctx1.fill(self,"visit:",{aNode:aNode,oldPath:oldPath,result:result})});
}; }),
$globals.PathDagVisitor);

$core.addMethod(
$core.method({
selector: "visitDagNodeVariantRedux:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNodeVariantRedux: aNode\x0a\x09| newNode |\x0a\x09newNode := super visitDagNodeVariantRedux: aNode.\x0a\x09aNode == newNode ifFalse: [ path at: path size put: newNode ].\x0a\x09^ newNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNodeVariantRedux:", "ifFalse:", "==", "at:put:", "size"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var newNode;
return $core.withContext(function($ctx1) {
newNode=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitDagNodeVariantRedux_.call($self,aNode))
,$ctx1.supercall = false
][0];
if(!$core.assert($recv(aNode).__eq_eq(newNode))){
$recv($self.path)._at_put_($recv($self.path)._size(),newNode);
}
return newNode;
}, function($ctx1) {$ctx1.fill(self,"visitDagNodeVariantRedux:",{aNode:aNode,newNode:newNode})});
}; }),
$globals.PathDagVisitor);



$core.addClass("DagNode", $globals.Object, "Kernel-Dag");
$globals.DagNode.comment="I am the abstract root class of any directed acyclic graph.\x0a\x0aConcrete classes should implement `dagChildren` and `dagChildren:`\x0ato get / set direct successor nodes (aka child nodes / subnodes).";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitDagNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitDagNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.DagNode);

$core.addMethod(
$core.method({
selector: "allDagChildren",
protocol: "accessing",
args: [],
source: "allDagChildren\x0a\x09| allNodes |\x0a\x09\x0a\x09allNodes := self dagChildren asSet.\x0a\x09self dagChildren do: [ :each | \x0a\x09\x09allNodes addAll: each allDagChildren ].\x0a\x09\x0a\x09^ allNodes",
referencedClasses: [],
pragmas: [],
messageSends: ["asSet", "dagChildren", "do:", "addAll:", "allDagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var allNodes;
return $core.withContext(function($ctx1) {
allNodes=$recv([$self._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._asSet();
$recv($self._dagChildren())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(allNodes)._addAll_($recv(each)._allDagChildren());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return allNodes;
}, function($ctx1) {$ctx1.fill(self,"allDagChildren",{allNodes:allNodes})});
}; }),
$globals.DagNode);

$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"dagChildren",{})});
}; }),
$globals.DagNode);

$core.addMethod(
$core.method({
selector: "dagChildren:",
protocol: "accessing",
args: ["aCollection"],
source: "dagChildren: aCollection\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"dagChildren:",{aCollection:aCollection})});
}; }),
$globals.DagNode);

$core.addMethod(
$core.method({
selector: "isDagNode",
protocol: "testing",
args: [],
source: "isDagNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.DagNode);



$core.addClass("DagParentNode", $globals.DagNode, "Kernel-Dag");
$core.setSlots($globals.DagParentNode, ["nodes"]);
$globals.DagParentNode.comment="I am `DagNode` that stores a collection of its children,\x0alazy initialized to empty array.\x0a\x0aI can `addDagChild:` to add a child.";
$core.addMethod(
$core.method({
selector: "addDagChild:",
protocol: "accessing",
args: ["aDagNode"],
source: "addDagChild: aDagNode\x0a\x09self dagChildren add: aDagNode",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "dagChildren"]
}, function ($methodClass){ return function (aDagNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._dagChildren())._add_(aDagNode);
return self;
}, function($ctx1) {$ctx1.fill(self,"addDagChild:",{aDagNode:aDagNode})});
}; }),
$globals.DagParentNode);

$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09^ nodes ifNil: [ nodes := Array new ]",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.nodes;
if($1 == null || $1.a$nil){
$self.nodes=$recv($globals.Array)._new();
return $self.nodes;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"dagChildren",{})});
}; }),
$globals.DagParentNode);

$core.addMethod(
$core.method({
selector: "dagChildren:",
protocol: "accessing",
args: ["aCollection"],
source: "dagChildren: aCollection\x0a\x09nodes := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.nodes=aCollection;
return self;

}; }),
$globals.DagParentNode);



$core.addClass("DagSink", $globals.DagNode, "Kernel-Dag");
$globals.DagSink.comment="I am `DagNode` with no direct successors.\x0a\x0aSending `dagChildren:` with empty collection is legal.";


$core.addTrait("TDagSink", "Kernel-Dag");
$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09^ #()",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [];

}; }),
$globals.TDagSink);

$core.addMethod(
$core.method({
selector: "dagChildren:",
protocol: "accessing",
args: ["aCollection"],
source: "dagChildren: aCollection\x0a\x09aCollection ifNotEmpty: [ self error: 'A DagSink cannot have children.' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "error:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $self._error_("A DagSink cannot have children.");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"dagChildren:",{aCollection:aCollection})});
}; }),
$globals.TDagSink);


$core.addTrait("TDerivedDagChildren", "Kernel-Dag");
$core.addMethod(
$core.method({
selector: "addDagChild:",
protocol: "accessing",
args: ["aDagNode"],
source: "addDagChild: aDagNode\x0a\x09self error: 'Cannot add child for a TDerivedChildren.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aDagNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Cannot add child for a TDerivedChildren.");
return self;
}, function($ctx1) {$ctx1.fill(self,"addDagChild:",{aDagNode:aDagNode})});
}; }),
$globals.TDerivedDagChildren);

$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"dagChildren",{})});
}; }),
$globals.TDerivedDagChildren);

$core.addMethod(
$core.method({
selector: "dagChildren:",
protocol: "accessing",
args: ["aCollection"],
source: "dagChildren: aCollection\x0a\x09self error: 'Cannot set children of a TDerivedChildren.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Cannot set children of a TDerivedChildren.");
return self;
}, function($ctx1) {$ctx1.fill(self,"dagChildren:",{aCollection:aCollection})});
}; }),
$globals.TDerivedDagChildren);


$core.addTrait("TSingleDagChild", "Kernel-Dag");
$core.addMethod(
$core.method({
selector: "dagChild",
protocol: "accessing",
args: [],
source: "dagChild\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"dagChild",{})});
}; }),
$globals.TSingleDagChild);

$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09^ { self dagChild }",
referencedClasses: [],
pragmas: [],
messageSends: ["dagChild"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$self._dagChild()];
}, function($ctx1) {$ctx1.fill(self,"dagChildren",{})});
}; }),
$globals.TSingleDagChild);

$core.setTraitComposition([{trait: $globals.TDerivedDagChildren}], $globals.TDagSink);
$core.setTraitComposition([{trait: $globals.TDerivedDagChildren}], $globals.TSingleDagChild);
$core.setTraitComposition([{trait: $globals.TDagSink}], $globals.DagSink);

$core.addMethod(
$core.method({
selector: "isDagNode",
protocol: "*Kernel-Dag",
args: [],
source: "isDagNode\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.Object);

});

define('amber/core/Kernel-Promises',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Promises");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("Promise", $globals.Object, "Kernel-Promises");

$core.addMethod(
$core.method({
selector: "all:",
protocol: "composites",
args: ["aCollection"],
source: "all: aCollection\x0a\x22Returns a Promise resolved with results of sub-promises.\x22\x0a<inlineJS: 'return Promise.all($recv(aCollection)._asArray())'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Promise.all($recv(aCollection)._asArray())"]]],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Promise.all($recv(aCollection)._asArray());
return self;
}, function($ctx1) {$ctx1.fill(self,"all:",{aCollection:aCollection})});
}; }),
$globals.Promise.a$cls);

$core.addMethod(
$core.method({
selector: "any:",
protocol: "composites",
args: ["aCollection"],
source: "any: aCollection\x0a\x22Returns a Promise resolved with first result of sub-promises.\x22\x0a<inlineJS: 'return Promise.race($recv(aCollection)._asArray())'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Promise.race($recv(aCollection)._asArray())"]]],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Promise.race($recv(aCollection)._asArray());
return self;
}, function($ctx1) {$ctx1.fill(self,"any:",{aCollection:aCollection})});
}; }),
$globals.Promise.a$cls);

$core.addMethod(
$core.method({
selector: "forBlock:",
protocol: "instance creation",
args: ["aBlock"],
source: "forBlock: aBlock\x0a\x22Returns a Promise that is resolved with the value of aBlock,\x0aand rejected if error happens while evaluating aBlock.\x22\x0a\x09^ self new then: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["then:", "new"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._then_(aBlock);
}, function($ctx1) {$ctx1.fill(self,"forBlock:",{aBlock:aBlock})});
}; }),
$globals.Promise.a$cls);

$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x22Returns a dumb Promise resolved with nil.\x22\x0a<inlineJS: 'return Promise.resolve()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Promise.resolve()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Promise.resolve();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.Promise.a$cls);

$core.addMethod(
$core.method({
selector: "new:",
protocol: "instance creation",
args: ["aBlock"],
source: "new: aBlock\x0a\x22Returns a Promise that is eventually resolved or rejected.\x0aPass a block that is called with one argument, model.\x0aYou should call model value: ... to resolve the promise\x0aand model signal: ... to reject the promise.\x0aIf error happens during run of the block,\x0apromise is rejected with that error as well.\x22\x0a<inlineJS: 'return new Promise(function (resolve, reject) {\x0a    var model = {value: resolve, signal: reject};\x0a    aBlock._value_(model);\x0a})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new Promise(function (resolve, reject) {\x0a    var model = {value: resolve, signal: reject};\x0a    aBlock._value_(model);\x0a})"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new Promise(function (resolve, reject) {
    var model = {value: resolve, signal: reject};
    aBlock._value_(model);
});
return self;
}, function($ctx1) {$ctx1.fill(self,"new:",{aBlock:aBlock})});
}; }),
$globals.Promise.a$cls);

$core.addMethod(
$core.method({
selector: "signal:",
protocol: "instance creation",
args: ["anObject"],
source: "signal: anObject\x0a\x22Returns a Promise rejected with anObject.\x22\x0a<inlineJS: 'return $recv(anObject)._in_(function (x) {return Promise.reject(x)})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $recv(anObject)._in_(function (x) {return Promise.reject(x)})"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._in_(function (x) {return Promise.reject(x)});
return self;
}, function($ctx1) {$ctx1.fill(self,"signal:",{anObject:anObject})});
}; }),
$globals.Promise.a$cls);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "instance creation",
args: ["anObject"],
source: "value: anObject\x0a\x22Returns a Promise resolved with anObject.\x22\x0a<inlineJS: 'return $recv(anObject)._in_(function (x) {return Promise.resolve(x)})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $recv(anObject)._in_(function (x) {return Promise.resolve(x)})"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._in_(function (x) {return Promise.resolve(x)});
return self;
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject})});
}; }),
$globals.Promise.a$cls);


$core.addTrait("TThenable", "Kernel-Promises");
$core.addMethod(
$core.method({
selector: "catch:",
protocol: "promises",
args: ["aBlock"],
source: "catch: aBlock\x0a<inlineJS: 'return self.then(null, function (err) { return aBlock._value_(err); })'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.then(null, function (err) { return aBlock._value_(err); })"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.then(null, function (err) { return aBlock._value_(err); });
return self;
}, function($ctx1) {$ctx1.fill(self,"catch:",{aBlock:aBlock})});
}; }),
$globals.TThenable);

$core.addMethod(
$core.method({
selector: "on:do:",
protocol: "promises",
args: ["aClass", "aBlock"],
source: "on: aClass do: aBlock\x0a<inlineJS: 'return self.then(null, function (err) {\x0a    if (err._isKindOf_(aClass)) return aBlock._value_(err);\x0a    else throw err;\x0a})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return self.then(null, function (err) {\x0a    if (err._isKindOf_(aClass)) return aBlock._value_(err);\x0a    else throw err;\x0a})"]]],
messageSends: []
}, function ($methodClass){ return function (aClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return self.then(null, function (err) {
    if (err._isKindOf_(aClass)) return aBlock._value_(err);
    else throw err;
});
return self;
}, function($ctx1) {$ctx1.fill(self,"on:do:",{aClass:aClass,aBlock:aBlock})});
}; }),
$globals.TThenable);

$core.addMethod(
$core.method({
selector: "on:do:catch:",
protocol: "promises",
args: ["aClass", "aBlock", "anotherBlock"],
source: "on: aClass do: aBlock catch: anotherBlock\x0a\x09^ (self on: aClass do: aBlock) catch: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["catch:", "on:do:"]
}, function ($methodClass){ return function (aClass,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._on_do_(aClass,aBlock))._catch_(anotherBlock);
}, function($ctx1) {$ctx1.fill(self,"on:do:catch:",{aClass:aClass,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.TThenable);

$core.addMethod(
$core.method({
selector: "then:",
protocol: "promises",
args: ["aBlockOrArray"],
source: "then: aBlockOrArray\x0a\x22Accepts a block or array of blocks.\x0aEach of blocks in the array or the singleton one is\x0aused in .then call to a promise, to accept a result\x0aand transform it to the result for the next one.\x0aIn case a block has more than one argument\x0aand result is an array, first n-1 elements of the array\x0aare put into additional arguments beyond the first.\x0aThe first argument always contains the result as-is.\x22\x0a<inlineJS: '\x0avar array = Array.isArray(aBlockOrArray) ? aBlockOrArray : [aBlockOrArray];\x0areturn array.reduce(function (soFar, aBlock) {\x0a    return soFar.then(typeof aBlock === \x22function\x22 && aBlock.length > 1 ?\x0a       function (result) {\x0a            if (Array.isArray(result)) {\x0a                return aBlock._valueWithPossibleArguments_([result].concat(result.slice(0, aBlock.length-1)));\x0a            } else {\x0a                return aBlock._value_(result);\x0a            }\x0a        } :\x0a        function (result) {\x0a            return aBlock._value_(result);\x0a        }\x0a    );\x0a}, self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0avar array = Array.isArray(aBlockOrArray) ? aBlockOrArray : [aBlockOrArray];\x0areturn array.reduce(function (soFar, aBlock) {\x0a    return soFar.then(typeof aBlock === \x22function\x22 && aBlock.length > 1 ?\x0a       function (result) {\x0a            if (Array.isArray(result)) {\x0a                return aBlock._valueWithPossibleArguments_([result].concat(result.slice(0, aBlock.length-1)));\x0a            } else {\x0a                return aBlock._value_(result);\x0a            }\x0a        } :\x0a        function (result) {\x0a            return aBlock._value_(result);\x0a        }\x0a    );\x0a}, self)"]]],
messageSends: []
}, function ($methodClass){ return function (aBlockOrArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

var array = Array.isArray(aBlockOrArray) ? aBlockOrArray : [aBlockOrArray];
return array.reduce(function (soFar, aBlock) {
    return soFar.then(typeof aBlock === "function" && aBlock.length > 1 ?
       function (result) {
            if (Array.isArray(result)) {
                return aBlock._valueWithPossibleArguments_([result].concat(result.slice(0, aBlock.length-1)));
            } else {
                return aBlock._value_(result);
            }
        } :
        function (result) {
            return aBlock._value_(result);
        }
    );
}, self);
return self;
}, function($ctx1) {$ctx1.fill(self,"then:",{aBlockOrArray:aBlockOrArray})});
}; }),
$globals.TThenable);

$core.addMethod(
$core.method({
selector: "then:catch:",
protocol: "promises",
args: ["aBlockOrArray", "anotherBlock"],
source: "then: aBlockOrArray catch: anotherBlock\x0a\x09^ (self then: aBlockOrArray) catch: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["catch:", "then:"]
}, function ($methodClass){ return function (aBlockOrArray,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._then_(aBlockOrArray))._catch_(anotherBlock);
}, function($ctx1) {$ctx1.fill(self,"then:catch:",{aBlockOrArray:aBlockOrArray,anotherBlock:anotherBlock})});
}; }),
$globals.TThenable);

$core.addMethod(
$core.method({
selector: "then:on:do:",
protocol: "promises",
args: ["aBlockOrArray", "aClass", "aBlock"],
source: "then: aBlockOrArray on: aClass do: aBlock\x0a\x09^ (self then: aBlockOrArray) on: aClass do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["on:do:", "then:"]
}, function ($methodClass){ return function (aBlockOrArray,aClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._then_(aBlockOrArray))._on_do_(aClass,aBlock);
}, function($ctx1) {$ctx1.fill(self,"then:on:do:",{aBlockOrArray:aBlockOrArray,aClass:aClass,aBlock:aBlock})});
}; }),
$globals.TThenable);

$core.addMethod(
$core.method({
selector: "then:on:do:catch:",
protocol: "promises",
args: ["aBlockOrArray", "aClass", "aBlock", "anotherBlock"],
source: "then: aBlockOrArray on: aClass do: aBlock catch: anotherBlock\x0a\x09^ ((self then: aBlockOrArray) on: aClass do: aBlock) catch: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["catch:", "on:do:", "then:"]
}, function ($methodClass){ return function (aBlockOrArray,aClass,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._then_(aBlockOrArray))._on_do_(aClass,aBlock))._catch_(anotherBlock);
}, function($ctx1) {$ctx1.fill(self,"then:on:do:catch:",{aBlockOrArray:aBlockOrArray,aClass:aClass,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.TThenable);

$core.setTraitComposition([{trait: $globals.TThenable}], $globals.Promise);

});

define('amber/core/Kernel-Infrastructure',["amber/boot", "require", "amber/core/Kernel-Collections", "amber/core/Kernel-Helpers", "amber/core/Kernel-Objects", "amber/core/Kernel-Promises"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Infrastructure");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AmberBootstrapInitialization", $globals.Object, "Kernel-Infrastructure");

$core.addMethod(
$core.method({
selector: "organizeClasses",
protocol: "organization",
args: [],
source: "organizeClasses\x0a\x09Smalltalk classes do: [ :each | each enterOrganization ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["do:", "classes", "enterOrganization"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._classes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._enterOrganization();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"organizeClasses",{})});
}; }),
$globals.AmberBootstrapInitialization.a$cls);

$core.addMethod(
$core.method({
selector: "organizeMethods",
protocol: "organization",
args: [],
source: "organizeMethods\x0a\x09Smalltalk classes do: [ :eachClass |\x0a\x09\x09eachClass definedMethods do: [ :eachMethod |\x0a\x09\x09\x09eachMethod methodClass methodOrganizationEnter: eachMethod andLeave: nil ] ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["do:", "classes", "definedMethods", "methodOrganizationEnter:andLeave:", "methodClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv($recv($globals.Smalltalk)._classes())._do_((function(eachClass){
return $core.withContext(function($ctx2) {
return $recv($recv(eachClass)._definedMethods())._do_((function(eachMethod){
return $core.withContext(function($ctx3) {
return $recv($recv(eachMethod)._methodClass())._methodOrganizationEnter_andLeave_(eachMethod,nil);
}, function($ctx3) {$ctx3.fillBlock({eachMethod:eachMethod},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({eachClass:eachClass},$ctx1,1)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"organizeMethods",{})});
}; }),
$globals.AmberBootstrapInitialization.a$cls);

$core.addMethod(
$core.method({
selector: "run",
protocol: "public api",
args: [],
source: "run\x0a\x09SmalltalkImage initialize.\x0a\x09self\x0a\x09\x09organizeClasses;\x0a\x09\x09organizeMethods.\x0a\x09^ Smalltalk postLoad",
referencedClasses: ["SmalltalkImage", "Smalltalk"],
pragmas: [],
messageSends: ["initialize", "organizeClasses", "organizeMethods", "postLoad"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.SmalltalkImage)._initialize();
$self._organizeClasses();
$self._organizeMethods();
return $recv($globals.Smalltalk)._postLoad();
}, function($ctx1) {$ctx1.fill(self,"run",{})});
}; }),
$globals.AmberBootstrapInitialization.a$cls);


$core.addClass("JSObjectProxy", $globals.ProtoObject, "Kernel-Infrastructure");
$core.setSlots($globals.JSObjectProxy, ["jsObject"]);
$globals.JSObjectProxy.comment="I handle sending messages to JavaScript objects, making  JavaScript object accessing from Amber fully transparent.\x0aMy instances make intensive use of `#doesNotUnderstand:`.\x0a\x0aMy instances are automatically created by Amber whenever a message is sent to a JavaScript object.\x0a\x0a## Usage examples\x0a\x0aJSObjectProxy objects are instanciated by Amber when a Smalltalk message is sent to a JavaScript object.\x0a\x0a\x09window alert: 'hello world'.\x0a\x09window inspect.\x0a\x09(window jQuery: 'body') append: 'hello world'\x0a\x0aAmber messages sends are converted to JavaScript function calls or object property access _(in this order)_. If n one of them match, a `MessageNotUnderstood` error will be thrown.\x0a\x0a## Message conversion rules\x0a\x0a- `someUser name` becomes `someUser.name`\x0a- `someUser name: 'John'` becomes `someUser name = \x22John\x22`\x0a- `console log: 'hello world'` becomes `console.log('hello world')`\x0a- `(window jQuery: 'foo') css: 'background' color: 'red'` becomes `window.jQuery('foo').css('background', 'red')`\x0a\x0a__Note:__ For keyword-based messages, only the first keyword is kept: `window foo: 1 bar: 2` is equivalent to `window foo: 1 baz: 2`.";
$core.addMethod(
$core.method({
selector: "=",
protocol: "comparing",
args: ["anObject"],
source: "= anObject\x0a\x09^ anObject class == self class and: [\x0a\x09\x09JSObjectProxy compareJSObjectOfProxy: self withProxy: anObject ]",
referencedClasses: ["JSObjectProxy"],
pragmas: [],
messageSends: ["and:", "==", "class", "compareJSObjectOfProxy:withProxy:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$recv(anObject)._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq_eq($self._class()))){
return $recv($globals.JSObjectProxy)._compareJSObjectOfProxy_withProxy_(self,anObject);
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"=",{anObject:anObject})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09\x22Answers the receiver in a stringify-friendly fashion\x22\x0a\x0a\x09^ jsObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.jsObject;

}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:",
protocol: "accessing",
args: ["aString"],
source: "at: aString\x0a\x09<inlineJS: 'return $self.jsObject[aString]'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self.jsObject[aString]"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.jsObject[aString];
return self;
}, function($ctx1) {$ctx1.fill(self,"at:",{aString:aString})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "accessing",
args: ["aString", "aBlock"],
source: "at: aString ifAbsent: aBlock\x0a\x09\x22return the aString property or evaluate aBlock if the property is not defined on the object\x22\x0a\x09<inlineJS: '\x0a\x09\x09var obj = $self.jsObject;\x0a\x09\x09return aString in obj ? obj[aString] : aBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var obj = $self.jsObject;\x0a\x09\x09return aString in obj ? obj[aString] : aBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var obj = $self.jsObject;
		return aString in obj ? obj[aString] : aBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aString:aString,aBlock:aBlock})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:ifPresent:",
protocol: "accessing",
args: ["aString", "aBlock"],
source: "at: aString ifPresent: aBlock\x0a\x09\x22return the evaluation of aBlock with the value if the property is defined or return nil\x22\x0a\x09<inlineJS: '\x0a\x09\x09var obj = $self.jsObject;\x0a\x09\x09return aString in obj ? aBlock._value_(obj[aString]) : nil;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var obj = $self.jsObject;\x0a\x09\x09return aString in obj ? aBlock._value_(obj[aString]) : nil;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var obj = $self.jsObject;
		return aString in obj ? aBlock._value_(obj[aString]) : nil;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:",{aString:aString,aBlock:aBlock})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:ifPresent:ifAbsent:",
protocol: "accessing",
args: ["aString", "aBlock", "anotherBlock"],
source: "at: aString ifPresent: aBlock ifAbsent: anotherBlock\x0a\x09\x22return the evaluation of aBlock with the value if the property is defined\x0a\x09or return value of anotherBlock\x22\x0a\x09<inlineJS: '\x0a\x09\x09var obj = $self.jsObject;\x0a\x09\x09return aString in obj ? aBlock._value_(obj[aString]) : anotherBlock._value();\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var obj = $self.jsObject;\x0a\x09\x09return aString in obj ? aBlock._value_(obj[aString]) : anotherBlock._value();\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var obj = $self.jsObject;
		return aString in obj ? aBlock._value_(obj[aString]) : anotherBlock._value();
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:ifPresent:ifAbsent:",{aString:aString,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "at:put:",
protocol: "accessing",
args: ["aString", "anObject"],
source: "at: aString put: anObject\x0a\x09<inlineJS: 'return $self.jsObject[aString] = anObject'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $self.jsObject[aString] = anObject"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.jsObject[aString] = anObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"at:put:",{aString:aString,anObject:anObject})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "catch:",
protocol: "promises",
args: ["aBlock"],
source: "catch: aBlock\x0a(NativeFunction isNativeFunction: (self at: #then))\x0a\x09ifTrue: [ ^ (TThenable >> #catch:) sendTo: jsObject arguments: {aBlock} ]\x0a\x09ifFalse: [ ^ super catch: aBlock ]",
referencedClasses: ["NativeFunction", "TThenable"],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isNativeFunction:", "at:", "sendTo:arguments:", ">>", "catch:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($globals.NativeFunction)._isNativeFunction_($self._at_("then")))){
return $recv($recv($globals.TThenable).__gt_gt("catch:"))._sendTo_arguments_($self.jsObject,[aBlock]);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._catch_.call($self,aBlock))
,$ctx1.supercall = false
][0];
}
return self;
}, function($ctx1) {$ctx1.fill(self,"catch:",{aBlock:aBlock})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "doesNotUnderstand:",
protocol: "proxy",
args: ["aMessage"],
source: "doesNotUnderstand: aMessage\x0a\x09^ (JSObjectProxy lookupProperty: aMessage selector asJavaScriptPropertyName ofProxy: self)\x0a\x09\x09ifNil: [ super doesNotUnderstand: aMessage ]\x0a\x09\x09ifNotNil: [ :jsSelector | \x0a\x09\x09\x09JSObjectProxy \x0a\x09\x09\x09\x09forwardMessage: jsSelector \x0a\x09\x09\x09\x09withArguments: aMessage arguments\x0a\x09\x09\x09\x09ofProxy: self ]",
referencedClasses: ["JSObjectProxy"],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "lookupProperty:ofProxy:", "asJavaScriptPropertyName", "selector", "doesNotUnderstand:", "forwardMessage:withArguments:ofProxy:", "arguments"]
}, function ($methodClass){ return function (aMessage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.JSObjectProxy)._lookupProperty_ofProxy_($recv($recv(aMessage)._selector())._asJavaScriptPropertyName(),self);
if($1 == null || $1.a$nil){
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._doesNotUnderstand_.call($self,aMessage))
,$ctx1.supercall = false
][0];
} else {
var jsSelector;
jsSelector=$1;
return $recv($globals.JSObjectProxy)._forwardMessage_withArguments_ofProxy_(jsSelector,$recv(aMessage)._arguments(),self);
}
}, function($ctx1) {$ctx1.fill(self,"doesNotUnderstand:",{aMessage:aMessage})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "in:",
protocol: "accessing",
args: ["aValuable"],
source: "in: aValuable\x0a\x09^ aValuable value: jsObject",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aValuable){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aValuable)._value_($self.jsObject);
}, function($ctx1) {$ctx1.fill(self,"in:",{aValuable:aValuable})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "jsObject",
protocol: "accessing",
args: [],
source: "jsObject\x0a\x09^ jsObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.jsObject;

}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "keysAndValuesDo:",
protocol: "enumerating",
args: ["aBlock"],
source: "keysAndValuesDo: aBlock\x0a\x09<inlineJS: '\x0a\x09\x09var o = $self.jsObject;\x0a\x09\x09for(var i in o) {\x0a\x09\x09\x09aBlock._value_value_(i, o[i]);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var o = $self.jsObject;\x0a\x09\x09for(var i in o) {\x0a\x09\x09\x09aBlock._value_value_(i, o[i]);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var o = $self.jsObject;
		for(var i in o) {
			aBlock._value_value_(i, o[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"keysAndValuesDo:",{aBlock:aBlock})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "on:do:",
protocol: "promises",
args: ["aClass", "aBlock"],
source: "on: aClass do: aBlock\x0a(NativeFunction isNativeFunction: (self at: #then))\x0a\x09ifTrue: [ ^ (TThenable >> #on:do:) sendTo: jsObject arguments: {aClass. aBlock} ]\x0a\x09ifFalse: [ ^ super on: aClass do: aBlock ]",
referencedClasses: ["NativeFunction", "TThenable"],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isNativeFunction:", "at:", "sendTo:arguments:", ">>", "on:do:"]
}, function ($methodClass){ return function (aClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($globals.NativeFunction)._isNativeFunction_($self._at_("then")))){
return $recv($recv($globals.TThenable).__gt_gt("on:do:"))._sendTo_arguments_($self.jsObject,[aClass,aBlock]);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._on_do_.call($self,aClass,aBlock))
,$ctx1.supercall = false
][0];
}
return self;
}, function($ctx1) {$ctx1.fill(self,"on:do:",{aClass:aClass,aBlock:aBlock})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09aStream nextPutAll: self printString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "printString"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutAll_($self._printString());
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "printString",
protocol: "printing",
args: [],
source: "printString\x0a\x09<inlineJS: '\x0a\x09\x09var js = $self.jsObject;\x0a\x09\x09return !js ? \x22<<malformed JS object proxy>>\x22 : js.toString\x0a\x09\x09\x09? js.toString()\x0a\x09\x09\x09: Object.prototype.toString.call(js)\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var js = $self.jsObject;\x0a\x09\x09return !js ? \x22<<malformed JS object proxy>>\x22 : js.toString\x0a\x09\x09\x09? js.toString()\x0a\x09\x09\x09: Object.prototype.toString.call(js)\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var js = $self.jsObject;
		return !js ? "<<malformed JS object proxy>>" : js.toString
			? js.toString()
			: Object.prototype.toString.call(js)
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"printString",{})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "putOn:",
protocol: "streaming",
args: ["aStream"],
source: "putOn: aStream\x0a\x09aStream nextPutJSObject: jsObject",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutJSObject:"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._nextPutJSObject_($self.jsObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"putOn:",{aStream:aStream})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "removeKey:",
protocol: "accessing",
args: ["aString"],
source: "removeKey: aString\x0a\x09<inlineJS: 'delete $self.jsObject[aString]; return aString'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["delete $self.jsObject[aString]; return aString"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
delete $self.jsObject[aString]; return aString;
return self;
}, function($ctx1) {$ctx1.fill(self,"removeKey:",{aString:aString})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "then:",
protocol: "promises",
args: ["aBlockOrArray"],
source: "then: aBlockOrArray\x0a(NativeFunction isNativeFunction: (self at: #then))\x0a\x09ifTrue: [ ^ (TThenable >> #then:) sendTo: jsObject arguments: {aBlockOrArray} ]\x0a\x09ifFalse: [ ^ super then: aBlockOrArray ]",
referencedClasses: ["NativeFunction", "TThenable"],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isNativeFunction:", "at:", "sendTo:arguments:", ">>", "then:"]
}, function ($methodClass){ return function (aBlockOrArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($globals.NativeFunction)._isNativeFunction_($self._at_("then")))){
return $recv($recv($globals.TThenable).__gt_gt("then:"))._sendTo_arguments_($self.jsObject,[aBlockOrArray]);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._then_.call($self,aBlockOrArray))
,$ctx1.supercall = false
][0];
}
return self;
}, function($ctx1) {$ctx1.fill(self,"then:",{aBlockOrArray:aBlockOrArray})});
}; }),
$globals.JSObjectProxy);


$core.addMethod(
$core.method({
selector: "addObjectVariablesTo:ofProxy:",
protocol: "proxy",
args: ["aDictionary", "aProxy"],
source: "addObjectVariablesTo: aDictionary ofProxy: aProxy\x0a\x09<inlineJS: '\x0a\x09\x09var jsObject = aProxy.jsObject;\x0a\x09\x09for(var i in jsObject) {\x0a\x09\x09\x09aDictionary._at_put_(i, jsObject[i]);\x0a\x09\x09}\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var jsObject = aProxy.jsObject;\x0a\x09\x09for(var i in jsObject) {\x0a\x09\x09\x09aDictionary._at_put_(i, jsObject[i]);\x0a\x09\x09}\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aDictionary,aProxy){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var jsObject = aProxy.jsObject;
		for(var i in jsObject) {
			aDictionary._at_put_(i, jsObject[i]);
		}
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"addObjectVariablesTo:ofProxy:",{aDictionary:aDictionary,aProxy:aProxy})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "associationsOfProxy:",
protocol: "proxy",
args: ["aProxy"],
source: "associationsOfProxy: aProxy\x0a\x09<inlineJS: '\x0a\x09\x09var jsObject = aProxy.jsObject, result = [];\x0a\x09\x09for(var i in jsObject) {\x0a\x09\x09\x09result.push(i.__minus_gt(jsObject[i]));\x0a\x09\x09}\x0a\x09\x09return result;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var jsObject = aProxy.jsObject, result = [];\x0a\x09\x09for(var i in jsObject) {\x0a\x09\x09\x09result.push(i.__minus_gt(jsObject[i]));\x0a\x09\x09}\x0a\x09\x09return result;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aProxy){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var jsObject = aProxy.jsObject, result = [];
		for(var i in jsObject) {
			result.push(i.__minus_gt(jsObject[i]));
		}
		return result;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"associationsOfProxy:",{aProxy:aProxy})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "compareJSObjectOfProxy:withProxy:",
protocol: "proxy",
args: ["aProxy", "anotherProxy"],
source: "compareJSObjectOfProxy: aProxy withProxy: anotherProxy\x0a<inlineJS: '\x0a\x09var anotherJSObject = anotherProxy.a$cls ? anotherProxy.jsObject : anotherProxy;\x0a\x09return aProxy.jsObject === anotherJSObject\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09var anotherJSObject = anotherProxy.a$cls ? anotherProxy.jsObject : anotherProxy;\x0a\x09return aProxy.jsObject === anotherJSObject"]]],
messageSends: []
}, function ($methodClass){ return function (aProxy,anotherProxy){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	var anotherJSObject = anotherProxy.a$cls ? anotherProxy.jsObject : anotherProxy;
	return aProxy.jsObject === anotherJSObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"compareJSObjectOfProxy:withProxy:",{aProxy:aProxy,anotherProxy:anotherProxy})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "forwardMessage:withArguments:ofProxy:",
protocol: "proxy",
args: ["aString", "anArray", "aProxy"],
source: "forwardMessage: aString withArguments: anArray ofProxy: aProxy\x0a\x09<inlineJS: '\x0a\x09\x09return $core.accessJavaScript(aProxy._jsObject(), aString, anArray);\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09return $core.accessJavaScript(aProxy._jsObject(), aString, anArray);\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anArray,aProxy){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		return $core.accessJavaScript(aProxy._jsObject(), aString, anArray);
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"forwardMessage:withArguments:ofProxy:",{aString:aString,anArray:anArray,aProxy:aProxy})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "jsObject:ofProxy:",
protocol: "proxy",
args: ["aJSObject", "aProxy"],
source: "jsObject: aJSObject ofProxy: aProxy\x0a\x09<inlineJS: 'aProxy.jsObject = aJSObject'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["aProxy.jsObject = aJSObject"]]],
messageSends: []
}, function ($methodClass){ return function (aJSObject,aProxy){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
aProxy.jsObject = aJSObject;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsObject:ofProxy:",{aJSObject:aJSObject,aProxy:aProxy})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "lookupProperty:ofProxy:",
protocol: "proxy",
args: ["aString", "aProxy"],
source: "lookupProperty: aString ofProxy: aProxy\x0a\x09\x22Looks up a property in JS object.\x0a\x09Answer the property if it is present, or nil if it is not present.\x22\x0a\x09\x0a\x09<inlineJS: 'return aString in aProxy._jsObject() ? aString : nil'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return aString in aProxy._jsObject() ? aString : nil"]]],
messageSends: []
}, function ($methodClass){ return function (aString,aProxy){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return aString in aProxy._jsObject() ? aString : nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"lookupProperty:ofProxy:",{aString:aString,aProxy:aProxy})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "null",
protocol: "accessing",
args: [],
source: "null\x0a\x09<inlineJS: 'return null'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return null"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return null;
return self;
}, function($ctx1) {$ctx1.fill(self,"null",{})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aJSObject"],
source: "on: aJSObject\x0a\x09| instance |\x0a\x09instance := self new.\x0a\x09self jsObject: aJSObject ofProxy: instance.\x0a\x09^ instance",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "jsObject:ofProxy:"]
}, function ($methodClass){ return function (aJSObject){
var self=this,$self=this;
var instance;
return $core.withContext(function($ctx1) {
instance=$self._new();
$self._jsObject_ofProxy_(aJSObject,instance);
return instance;
}, function($ctx1) {$ctx1.fill(self,"on:",{aJSObject:aJSObject,instance:instance})});
}; }),
$globals.JSObjectProxy.a$cls);

$core.addMethod(
$core.method({
selector: "undefined",
protocol: "accessing",
args: [],
source: "undefined\x0a\x09<inlineJS: 'return undefined'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return undefined"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return undefined;
return self;
}, function($ctx1) {$ctx1.fill(self,"undefined",{})});
}; }),
$globals.JSObjectProxy.a$cls);


$core.addClass("Organizer", $globals.Object, "Kernel-Infrastructure");
$core.setSlots($globals.Organizer, ["elements"]);
$globals.Organizer.comment="I represent categorization information. \x0a\x0a## API\x0a\x0aUse `#addElement:` and `#removeElement:` to manipulate instances.";
$core.addMethod(
$core.method({
selector: "addElement:",
protocol: "accessing",
args: ["anObject"],
source: "addElement: anObject\x0a\x09self elements add: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "elements"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._elements())._add_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"addElement:",{anObject:anObject})});
}; }),
$globals.Organizer);

$core.addMethod(
$core.method({
selector: "elements",
protocol: "accessing",
args: [],
source: "elements\x0a\x09^ elements",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.elements;

}; }),
$globals.Organizer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09elements := Set new",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.elements=$recv($globals.Set)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Organizer);

$core.addMethod(
$core.method({
selector: "removeElement:",
protocol: "accessing",
args: ["anObject"],
source: "removeElement: anObject\x0a\x09self elements remove: anObject ifAbsent: []",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:ifAbsent:", "elements"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._elements())._remove_ifAbsent_(anObject,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeElement:",{anObject:anObject})});
}; }),
$globals.Organizer);



$core.addClass("ClassOrganizer", $globals.Organizer, "Kernel-Infrastructure");
$core.setSlots($globals.ClassOrganizer, ["traitOrBehavior"]);
$globals.ClassOrganizer.comment="I am an organizer specific to classes. I hold method categorization information for classes.";
$core.addMethod(
$core.method({
selector: "addElement:",
protocol: "accessing",
args: ["aString"],
source: "addElement: aString\x0a\x09super addElement: aString.\x0a\x0a\x09SystemAnnouncer current announce: (ProtocolAdded new\x0a\x09\x09protocol: aString;\x0a\x09\x09theClass: self theClass;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ProtocolAdded"],
pragmas: [],
messageSends: ["addElement:", "announce:", "current", "protocol:", "new", "theClass:", "theClass", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._addElement_.call($self,aString))
,$ctx1.supercall = false
][0];
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ProtocolAdded)._new();
$recv($2)._protocol_(aString);
$recv($2)._theClass_($self._theClass());
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"addElement:",{aString:aString})});
}; }),
$globals.ClassOrganizer);

$core.addMethod(
$core.method({
selector: "removeElement:",
protocol: "accessing",
args: ["aString"],
source: "removeElement: aString\x0a\x09super removeElement: aString.\x0a\x0a\x09SystemAnnouncer current announce: (ProtocolRemoved new\x0a\x09\x09protocol: aString;\x0a\x09\x09theClass: self theClass;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ProtocolRemoved"],
pragmas: [],
messageSends: ["removeElement:", "announce:", "current", "protocol:", "new", "theClass:", "theClass", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._removeElement_.call($self,aString))
,$ctx1.supercall = false
][0];
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ProtocolRemoved)._new();
$recv($2)._protocol_(aString);
$recv($2)._theClass_($self._theClass());
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"removeElement:",{aString:aString})});
}; }),
$globals.ClassOrganizer);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ traitOrBehavior",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.traitOrBehavior;

}; }),
$globals.ClassOrganizer);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09traitOrBehavior := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.traitOrBehavior=aClass;
return self;

}; }),
$globals.ClassOrganizer);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aClass"],
source: "on: aClass\x0a\x09^ self new\x0a\x09\x09theClass: aClass;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._theClass_(aClass);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aClass:aClass})});
}; }),
$globals.ClassOrganizer.a$cls);


$core.addClass("PackageOrganizer", $globals.Organizer, "Kernel-Infrastructure");
$globals.PackageOrganizer.comment="I am an organizer specific to packages. I hold classes categorization information.";


$core.addClass("Package", $globals.Object, "Kernel-Infrastructure");
$core.setSlots($globals.Package, ["contextBlock", "basicTransport", "name", "transport", "imports", "dirty", "organization", "isReady"]);
$globals.Package.comment="I am similar to a \x22class category\x22 typically found in other Smalltalks like Pharo or Squeak. Amber does not have class categories anymore, it had in the beginning but now each class in the system knows which package it belongs to.\x0a\x0aEach package has a name and can be queried for its classes, but it will then resort to a reverse scan of all classes to find them.\x0a\x0a## API\x0a\x0aPackages are manipulated through \x22Smalltalk current\x22, like for example finding one based on a name or with `Package class >> #name` directly:\x0a\x0a    Smalltalk current packageAt: 'Kernel'\x0a    Package named: 'Kernel'\x0a\x0aA package differs slightly from a Monticello package which can span multiple class categories using a naming convention based on hyphenation. But just as in Monticello a package supports \x22class extensions\x22 so a package can define behaviors in foreign classes using a naming convention for method categories where the category starts with an asterisk and then the name of the owning package follows.\x0a\x0aYou can fetch a package from the server:\x0a\x0a\x09Package load: 'Additional-Examples'";
$core.addMethod(
$core.method({
selector: "basicTransport",
protocol: "private",
args: [],
source: "basicTransport\x0a\x09\x22Answer the transport literal JavaScript object as setup in the JavaScript file, if any\x22\x0a\x09\x0a\x09^ basicTransport",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.basicTransport;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "beClean",
protocol: "accessing",
args: [],
source: "beClean\x0a\x09dirty := false.\x0a\x09\x0a\x09SystemAnnouncer current announce: (PackageClean new\x0a\x09\x09package: self;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "PackageClean"],
pragmas: [],
messageSends: ["announce:", "current", "package:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self.dirty=false;
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.PackageClean)._new();
$recv($2)._package_(self);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"beClean",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "beDirty",
protocol: "accessing",
args: [],
source: "beDirty\x0a\x09dirty := true.\x0a\x09\x0a\x09SystemAnnouncer current announce: (PackageDirty new\x0a\x09\x09package: self;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "PackageDirty"],
pragmas: [],
messageSends: ["announce:", "current", "package:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self.dirty=true;
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.PackageDirty)._new();
$recv($2)._package_(self);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"beDirty",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "classTemplate",
protocol: "accessing",
args: [],
source: "classTemplate\x0a\x09^ String streamContents: [ :stream | stream\x0a\x09\x09write: 'Object subclass: #NameOfSubclass'; lf;\x0a\x09\x09tab; write: 'instanceVariableNames: '''''; lf;\x0a\x09\x09tab; write: 'package: '; print: self name ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "lf", "tab", "print:", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._write_("Object subclass: #NameOfSubclass")
,$ctx2.sendIdx["write:"]=1
][0];
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=1
][0];
[$recv(stream)._tab()
,$ctx2.sendIdx["tab"]=1
][0];
[$recv(stream)._write_("instanceVariableNames: ''")
,$ctx2.sendIdx["write:"]=2
][0];
$recv(stream)._lf();
$recv(stream)._tab();
$recv(stream)._write_("package: ");
return $recv(stream)._print_($self._name());
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"classTemplate",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "classes",
protocol: "classes",
args: [],
source: "classes\x0a\x09^ self organization elements copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy", "elements", "organization"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._organization())._elements())._copy();
}, function($ctx1) {$ctx1.fill(self,"classes",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "context",
protocol: "accessing",
args: [],
source: "context\x0a\x09^ self contextBlock\x0a\x09\x09ifNil: [ #{} ]\x0a\x09\x09ifNotNil: [ :block |\x0a\x09\x09\x09| result |\x0a\x09\x09\x09result := Dictionary new.\x0a\x09\x09\x09block value keysAndValuesDo: [ :key :value | result at: key put: value ].\x0a\x09\x09\x09result ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "contextBlock", "new", "keysAndValuesDo:", "value", "at:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._contextBlock();
if($1 == null || $1.a$nil){
return $globals.HashedCollection._newFromPairs_([]);
} else {
var result,block;
block=$1;
result=$recv($globals.Dictionary)._new();
$recv($recv(block)._value())._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(result)._at_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,3)});
}));
return result;
}
}, function($ctx1) {$ctx1.fill(self,"context",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "contextBlock",
protocol: "accessing",
args: [],
source: "contextBlock\x0a\x09^ contextBlock",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.contextBlock;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "contextBlock:",
protocol: "accessing",
args: ["aBlock"],
source: "contextBlock: aBlock\x0a\x09contextBlock := aBlock",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
$self.contextBlock=aBlock;
return self;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "contextFunctionSource",
protocol: "accessing",
args: [],
source: "contextFunctionSource\x0a\x09^ (self imports reject: #isString)\x0a\x09\x09ifEmpty: [ nil ]\x0a\x09\x09ifNotEmpty: [ :namedImports |\x0a\x09\x09\x09'function () { return {',\x0a\x09\x09\x09(',' join: (namedImports collect: [ :each | each key, ':', each key ])),\x0a\x09\x09\x09'}; }' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifEmpty:ifNotEmpty:", "reject:", "imports", ",", "join:", "collect:", "key"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._imports())._reject_("isString"))._ifEmpty_ifNotEmpty_((function(){
return nil;

}),(function(namedImports){
return $core.withContext(function($ctx2) {
return [$recv(["function () { return {".__comma(","._join_($recv(namedImports)._collect_((function(each){
return $core.withContext(function($ctx3) {
return [$recv($recv([$recv(each)._key()
,$ctx3.sendIdx["key"]=1
][0]).__comma(":")).__comma($recv(each)._key())
,$ctx3.sendIdx[","]=3
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,3)});
}))))
,$ctx2.sendIdx[","]=2
][0]).__comma("}; }")
,$ctx2.sendIdx[","]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({namedImports:namedImports},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"contextFunctionSource",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream | stream\x0a\x09\x09write: self class name; lf;\x0a\x09\x09tab; write: 'named: '; print: self name; lf;\x0a\x09\x09tab; write: { 'imports: '. self importsDefinition }; lf;\x0a\x09\x09tab; write: { 'transport: ('. self transport definition. ')' } ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "name", "class", "lf", "tab", "print:", "importsDefinition", "definition", "transport"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._write_([$recv($self._class())._name()
,$ctx2.sendIdx["name"]=1
][0])
,$ctx2.sendIdx["write:"]=1
][0];
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=1
][0];
[$recv(stream)._tab()
,$ctx2.sendIdx["tab"]=1
][0];
[$recv(stream)._write_("named: ")
,$ctx2.sendIdx["write:"]=2
][0];
$recv(stream)._print_($self._name());
[$recv(stream)._lf()
,$ctx2.sendIdx["lf"]=2
][0];
[$recv(stream)._tab()
,$ctx2.sendIdx["tab"]=2
][0];
[$recv(stream)._write_(["imports: ",$self._importsDefinition()])
,$ctx2.sendIdx["write:"]=3
][0];
$recv(stream)._lf();
$recv(stream)._tab();
return $recv(stream)._write_(["transport: (",$recv($self._transport())._definition(),")"]);
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "imports",
protocol: "accessing",
args: [],
source: "imports\x0a\x09^ imports ifNil: [\x0a\x09\x09self imports: #().\x0a\x09\x09imports ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "imports:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.imports;
if($1 == null || $1.a$nil){
$self._imports_([]);
return $self.imports;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"imports",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "imports:",
protocol: "accessing",
args: ["anArray"],
source: "imports: anArray\x0a\x09self validateImports: anArray.\x0a\x09imports := anArray asSet",
referencedClasses: [],
pragmas: [],
messageSends: ["validateImports:", "asSet"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._validateImports_(anArray);
$self.imports=$recv(anArray)._asSet();
return self;
}, function($ctx1) {$ctx1.fill(self,"imports:",{anArray:anArray})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "importsAsJson",
protocol: "converting",
args: [],
source: "importsAsJson\x0a\x0a\x09^ self sortedImportsAsArray collect: [ :each |\x0a\x09\x09each isString\x0a\x09\x09\x09ifTrue: [ each ]\x0a\x09\x09\x09ifFalse: [ each key, '=', each value ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "sortedImportsAsArray", "ifTrue:ifFalse:", "isString", ",", "key", "value"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._sortedImportsAsArray())._collect_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(each)._isString())){
return each;
} else {
return [$recv($recv($recv(each)._key()).__comma("=")).__comma($recv(each)._value())
,$ctx2.sendIdx[","]=1
][0];
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"importsAsJson",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "importsDefinition",
protocol: "accessing",
args: [],
source: "importsDefinition\x0a\x09^ String streamContents: [ :stream |\x0a\x09\x09stream write: '{'.\x0a\x09\x09self sortedImportsAsArray\x0a\x09\x09\x09do: [ :each | stream print: each ]\x0a\x09\x09\x09separatedBy: [ stream write: '. ' ].\x0a\x09\x09stream write: '}' ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "do:separatedBy:", "sortedImportsAsArray", "print:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._write_("{")
,$ctx2.sendIdx["write:"]=1
][0];
$recv($self._sortedImportsAsArray())._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._print_(each);
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return [$recv(stream)._write_(". ")
,$ctx3.sendIdx["write:"]=2
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
return $recv(stream)._write_("}");
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"importsDefinition",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "importsFromJson:",
protocol: "converting",
args: ["anArray"],
source: "importsFromJson: anArray\x0a\x09\x22Parses array of string, eg. #('asdf' 'qwer=tyuo')\x0a\x09into array of Strings and Associations,\x0a\x09eg. {'asdf'. 'qwer'->'tyuo'}\x22\x0a\x0a\x09^ anArray collect: [ :each |\x0a\x09\x09| split |\x0a\x09\x09split := each tokenize: '='.\x0a\x09\x09split size = 1\x0a\x09\x09\x09ifTrue: [ split first ]\x0a\x09\x09\x09ifFalse: [ split first -> split second ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "tokenize:", "ifTrue:ifFalse:", "=", "size", "first", "->", "second"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anArray)._collect_((function(each){
var split;
return $core.withContext(function($ctx2) {
split=$recv(each)._tokenize_("=");
if($core.assert($recv($recv(split)._size()).__eq((1)))){
return [$recv(split)._first()
,$ctx2.sendIdx["first"]=1
][0];
} else {
return $recv($recv(split)._first()).__minus_gt($recv(split)._second());
}
}, function($ctx2) {$ctx2.fillBlock({each:each,split:split},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"importsFromJson:",{anArray:anArray})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09organization := PackageOrganizer new.\x0a\x09contextBlock := nil.\x0a\x09dirty := nil.\x0a\x09imports := nil.\x0a\x09isReady := Promise new.\x0a\x09transport := nil",
referencedClasses: ["PackageOrganizer", "Promise"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.organization=[$recv($globals.PackageOrganizer)._new()
,$ctx1.sendIdx["new"]=1
][0];
$self.contextBlock=nil;
$self.dirty=nil;
$self.imports=nil;
$self.isReady=$recv($globals.Promise)._new();
$self.transport=nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isDirty",
protocol: "testing",
args: [],
source: "isDirty\x0a\x09^ dirty ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.dirty;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"isDirty",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isPackage",
protocol: "testing",
args: [],
source: "isPackage\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isReady",
protocol: "accessing",
args: [],
source: "isReady\x0a\x09^ isReady",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.isReady;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isReady:",
protocol: "accessing",
args: ["aPromise"],
source: "isReady: aPromise\x0a\x09isReady := aPromise",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPromise){
var self=this,$self=this;
$self.isReady=aPromise;
return self;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "javaScriptDescriptor:",
protocol: "accessing",
args: ["anObject"],
source: "javaScriptDescriptor: anObject\x0a\x09| basicEval basicContext basicImports |\x0a\x0a\x09basicImports := anObject at: 'imports' ifAbsent: [ #() ].\x0a\x09self imports: (self importsFromJson: basicImports).\x0a\x0a\x09basicTransport := anObject at: 'transport' ifAbsent: [].\x0a\x09anObject at: 'isReady' ifPresent: [ :aPromise | self isReady: aPromise ].\x0a\x0a\x09\x22TODO remove, backward compatibility\x22\x0a\x09anObject at: 'innerEval' ifPresent: [ :evalBlock |\x0a\x09\x09self contextFunctionSource ifNotNil: [ :source |\x0a\x09\x09\x09anObject at: 'context' put: (evalBlock value: '(', source, ')') ] ].\x0a\x0a\x09basicContext := anObject at: 'context' ifAbsent: [ nil asJavaScriptObject ].\x0a\x09self contextBlock: basicContext",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "imports:", "importsFromJson:", "at:ifPresent:", "isReady:", "ifNotNil:", "contextFunctionSource", "at:put:", "value:", ",", "asJavaScriptObject", "contextBlock:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
var basicEval,basicContext,basicImports;
return $core.withContext(function($ctx1) {
var $1;
basicImports=[$recv(anObject)._at_ifAbsent_("imports",(function(){
return [];

}))
,$ctx1.sendIdx["at:ifAbsent:"]=1
][0];
$self._imports_($self._importsFromJson_(basicImports));
$self.basicTransport=[$recv(anObject)._at_ifAbsent_("transport",(function(){

}))
,$ctx1.sendIdx["at:ifAbsent:"]=2
][0];
[$recv(anObject)._at_ifPresent_("isReady",(function(aPromise){
return $core.withContext(function($ctx2) {
return $self._isReady_(aPromise);
}, function($ctx2) {$ctx2.fillBlock({aPromise:aPromise},$ctx1,3)});
}))
,$ctx1.sendIdx["at:ifPresent:"]=1
][0];
$recv(anObject)._at_ifPresent_("innerEval",(function(evalBlock){
return $core.withContext(function($ctx2) {
$1=$self._contextFunctionSource();
if($1 == null || $1.a$nil){
return $1;
} else {
var source;
source=$1;
return $recv(anObject)._at_put_("context",$recv(evalBlock)._value_([$recv("(".__comma(source)).__comma(")")
,$ctx2.sendIdx[","]=1
][0]));
}
}, function($ctx2) {$ctx2.fillBlock({evalBlock:evalBlock},$ctx1,4)});
}));
basicContext=$recv(anObject)._at_ifAbsent_("context",(function(){
return $core.withContext(function($ctx2) {
return $nil._asJavaScriptObject();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}));
$self._contextBlock_(basicContext);
return self;
}, function($ctx1) {$ctx1.fill(self,"javaScriptDescriptor:",{anObject:anObject,basicEval:basicEval,basicContext:basicContext,basicImports:basicImports})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "loadDependencies",
protocol: "dependencies",
args: [],
source: "loadDependencies\x0a\x09\x22Returns list of packages that need to be loaded\x0a\x09before loading this package.\x22\x0a\x09\x0a\x09| classes packages |\x0a\x09classes := self loadDependencyClasses.\x0a\x09^ (classes collect: [ :each | each package ]) asSet\x0a\x09\x09remove: self ifAbsent: [];\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["loadDependencyClasses", "remove:ifAbsent:", "asSet", "collect:", "package", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var classes,packages;
return $core.withContext(function($ctx1) {
var $1;
classes=$self._loadDependencyClasses();
$1=$recv($recv(classes)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._package();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._asSet();
$recv($1)._remove_ifAbsent_(self,(function(){

}));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"loadDependencies",{classes:classes,packages:packages})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "loadDependencyClasses",
protocol: "dependencies",
args: [],
source: "loadDependencyClasses\x0a\x09\x22Returns classes needed at the time of loading a package.\x0a\x09These are all that are used to subclass\x0a\x09and to define an extension method\x0a\x09as well as all traits used\x22\x0a\x09\x0a\x09| starCategoryName |\x0a\x09starCategoryName := '*', self name.\x0a\x09^ (self classes collect: [ :each | each superclass ]) asSet\x0a\x09\x09addAll: (Smalltalk classes select: [ :each |\x0a\x09\x09\x09({each. each theMetaClass} copyWithout: nil) anySatisfy: [ :any |\x0a\x09\x09\x09\x09(any protocols includes: starCategoryName) and: [\x0a\x09\x09\x09\x09\x09(any ownMethodsInProtocol: starCategoryName) notEmpty ]]]);\x0a\x09\x09addAll: (Array streamContents: [ :as | self traitCompositions valuesDo: [ :each | as write: (each collect: [ :eachTT | eachTT trait ])]]);\x0a\x09\x09remove: nil ifAbsent: [];\x0a\x09\x09yourself",
referencedClasses: ["Smalltalk", "Array"],
pragmas: [],
messageSends: [",", "name", "addAll:", "asSet", "collect:", "classes", "superclass", "select:", "anySatisfy:", "copyWithout:", "theMetaClass", "and:", "includes:", "protocols", "notEmpty", "ownMethodsInProtocol:", "streamContents:", "valuesDo:", "traitCompositions", "write:", "trait", "remove:ifAbsent:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var starCategoryName;
return $core.withContext(function($ctx1) {
var $1;
starCategoryName="*".__comma($self._name());
$1=$recv([$recv([$self._classes()
,$ctx1.sendIdx["classes"]=1
][0])._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._superclass();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["collect:"]=1
][0])._asSet();
[$recv($1)._addAll_($recv($recv($globals.Smalltalk)._classes())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv([each,$recv(each)._theMetaClass()])._copyWithout_(nil))._anySatisfy_((function(any){
return $core.withContext(function($ctx3) {
if($core.assert($recv($recv(any)._protocols())._includes_(starCategoryName))){
return $recv($recv(any)._ownMethodsInProtocol_(starCategoryName))._notEmpty();
} else {
return false;
}
}, function($ctx3) {$ctx3.fillBlock({any:any},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})))
,$ctx1.sendIdx["addAll:"]=1
][0];
$recv($1)._addAll_($recv($globals.Array)._streamContents_((function(as){
return $core.withContext(function($ctx2) {
return $recv($self._traitCompositions())._valuesDo_((function(each){
return $core.withContext(function($ctx3) {
return $recv(as)._write_($recv(each)._collect_((function(eachTT){
return $core.withContext(function($ctx4) {
return $recv(eachTT)._trait();
}, function($ctx4) {$ctx4.fillBlock({eachTT:eachTT},$ctx3,7)});
})));
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,6)});
}));
}, function($ctx2) {$ctx2.fillBlock({as:as},$ctx1,5)});
})));
$recv($1)._remove_ifAbsent_(nil,(function(){

}));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"loadDependencyClasses",{starCategoryName:starCategoryName})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.name;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "name:",
protocol: "accessing",
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.name=aString;
return self;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "organization",
protocol: "accessing",
args: [],
source: "organization\x0a\x09^ organization",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.organization;

}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream \x0a\x09\x09nextPutAll: ' (';\x0a\x09\x09nextPutAll: self name;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "name"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_(" (")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aStream)._nextPutAll_($self._name())
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "setupClasses",
protocol: "classes",
args: [],
source: "setupClasses\x0a\x09self classes do: [ :each | each initialize ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "classes", "initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._classes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._initialize();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"setupClasses",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "sortedClasses",
protocol: "classes",
args: [],
source: "sortedClasses\x0a\x09\x22Answer all classes in the receiver, sorted by superclass/subclasses and by class name for common subclasses (Issue #143).\x22\x0a\x0a\x09^ self class sortedClasses: self classes",
referencedClasses: [],
pragmas: [],
messageSends: ["sortedClasses:", "class", "classes"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._sortedClasses_($self._classes());
}, function($ctx1) {$ctx1.fill(self,"sortedClasses",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "sortedImportsAsArray",
protocol: "private",
args: [],
source: "sortedImportsAsArray\x0a\x09\x22Answer imports sorted first by type (associations first),\x0a\x09then by value\x22\x0a\x0a\x09^ self imports asArray\x0a\x09\x09sorted: [ :a :b |\x0a\x09\x09\x09a isString not & b isString or: [\x0a\x09\x09\x09\x09a isString = b isString and: [\x0a\x09\x09\x09\x09\x09a value <= b value ]]]",
referencedClasses: [],
pragmas: [],
messageSends: ["sorted:", "asArray", "imports", "or:", "&", "not", "isString", "and:", "=", "<=", "value"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._imports())._asArray())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
if($core.assert($recv($recv([$recv(a)._isString()
,$ctx2.sendIdx["isString"]=1
][0])._not()).__and([$recv(b)._isString()
,$ctx2.sendIdx["isString"]=2
][0]))){
return true;
} else {
if($core.assert($recv([$recv(a)._isString()
,$ctx2.sendIdx["isString"]=3
][0]).__eq($recv(b)._isString()))){
return $recv([$recv(a)._value()
,$ctx2.sendIdx["value"]=1
][0]).__lt_eq($recv(b)._value());
} else {
return false;
}
}
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"sortedImportsAsArray",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "traitCompositions",
protocol: "dependencies",
args: [],
source: "traitCompositions\x0a\x09| traitCompositions |\x0a\x09traitCompositions := Dictionary new.\x0a\x09self classes do: [ :eachClass | eachClass includingPossibleMetaDo: [ :each |\x0a\x09\x09traitCompositions at: each put: each traitComposition ] ].\x0a\x09^ traitCompositions reject: [ :each | each isEmpty ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["new", "do:", "classes", "includingPossibleMetaDo:", "at:put:", "traitComposition", "reject:", "isEmpty"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var traitCompositions;
return $core.withContext(function($ctx1) {
traitCompositions=$recv($globals.Dictionary)._new();
$recv($self._classes())._do_((function(eachClass){
return $core.withContext(function($ctx2) {
return $recv(eachClass)._includingPossibleMetaDo_((function(each){
return $core.withContext(function($ctx3) {
return $recv(traitCompositions)._at_put_(each,$recv(each)._traitComposition());
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({eachClass:eachClass},$ctx1,1)});
}));
return $recv(traitCompositions)._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isEmpty();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
}, function($ctx1) {$ctx1.fill(self,"traitCompositions",{traitCompositions:traitCompositions})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "transport",
protocol: "accessing",
args: [],
source: "transport\x0a\x09^ transport ifNil: [ \x0a\x09\x09self transport: (PackageTransport fromJson: self basicTransport).\x0a\x09\x09transport ]",
referencedClasses: ["PackageTransport"],
pragmas: [],
messageSends: ["ifNil:", "transport:", "fromJson:", "basicTransport"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.transport;
if($1 == null || $1.a$nil){
$self._transport_($recv($globals.PackageTransport)._fromJson_($self._basicTransport()));
return $self.transport;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"transport",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "transport:",
protocol: "accessing",
args: ["aPackageTransport"],
source: "transport: aPackageTransport\x0a\x09transport := aPackageTransport.\x0a\x09aPackageTransport package: self",
referencedClasses: [],
pragmas: [],
messageSends: ["package:"]
}, function ($methodClass){ return function (aPackageTransport){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.transport=aPackageTransport;
$recv(aPackageTransport)._package_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"transport:",{aPackageTransport:aPackageTransport})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "validateImports:",
protocol: "validation",
args: ["aCollection"],
source: "validateImports: aCollection\x0a\x0a\x09aCollection do: [ :import |\x0a\x09\x09import isString ifFalse: [\x0a\x09\x09\x09(import respondsTo: #key) ifFalse: [\x0a\x09\x09\x09\x09self error: 'Imports must be Strings or Associations' ].\x0a\x09\x09\x09import key isString & import value isString ifFalse: [\x0a\x09\x09\x09\x09self error: 'Key and value must be Strings' ].\x0a\x09\x09\x09(import key match: '^[a-zA-Z][a-zA-Z0-9]*$') ifFalse: [\x0a\x09\x09\x09\x09self error: 'Keys must be identifiers' ]]]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "ifFalse:", "isString", "respondsTo:", "error:", "&", "key", "value", "match:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(import_){
return $core.withContext(function($ctx2) {
if(!$core.assert([$recv(import_)._isString()
,$ctx2.sendIdx["isString"]=1
][0])){
if(!$core.assert($recv(import_)._respondsTo_("key"))){
[$self._error_("Imports must be Strings or Associations")
,$ctx2.sendIdx["error:"]=1
][0];
}
if(!$core.assert($recv([$recv([$recv(import_)._key()
,$ctx2.sendIdx["key"]=1
][0])._isString()
,$ctx2.sendIdx["isString"]=2
][0]).__and($recv($recv(import_)._value())._isString()))){
[$self._error_("Key and value must be Strings")
,$ctx2.sendIdx["error:"]=2
][0];
}
if(!$core.assert($recv($recv(import_)._key())._match_("^[a-zA-Z][a-zA-Z0-9]*$"))){
return $self._error_("Keys must be identifiers");
}
}
}, function($ctx2) {$ctx2.fillBlock({import_:import_},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"validateImports:",{aCollection:aCollection})});
}; }),
$globals.Package);


$core.setSlots($globals.Package.a$cls, ["defaultCommitPathJs", "defaultCommitPathSt"]);
$core.addMethod(
$core.method({
selector: "named:",
protocol: "accessing",
args: ["aPackageName"],
source: "named: aPackageName\x0a\x09^ Smalltalk \x0a\x09\x09packageAt: aPackageName\x0a\x09\x09ifAbsent: [ \x0a\x09\x09\x09Smalltalk createPackage: aPackageName ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["packageAt:ifAbsent:", "createPackage:"]
}, function ($methodClass){ return function (aPackageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._packageAt_ifAbsent_(aPackageName,(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Smalltalk)._createPackage_(aPackageName);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"named:",{aPackageName:aPackageName})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "named:ifAbsent:",
protocol: "accessing",
args: ["aPackageName", "aBlock"],
source: "named: aPackageName ifAbsent: aBlock\x0a\x09^ Smalltalk packageAt: aPackageName ifAbsent: aBlock",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["packageAt:ifAbsent:"]
}, function ($methodClass){ return function (aPackageName,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._packageAt_ifAbsent_(aPackageName,aBlock);
}, function($ctx1) {$ctx1.fill(self,"named:ifAbsent:",{aPackageName:aPackageName,aBlock:aBlock})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "named:imports:transport:",
protocol: "accessing",
args: ["aPackageName", "anArray", "aTransport"],
source: "named: aPackageName imports: anArray transport: aTransport\x0a\x09| pkg |\x0a\x09\x0a\x09pkg := self named: aPackageName.\x0a\x09pkg\x0a\x09\x09imports: anArray;\x0a\x09\x09transport: aTransport;\x0a\x09\x09beDirty.\x0a\x09\x0a\x09^ pkg",
referencedClasses: [],
pragmas: [],
messageSends: ["named:", "imports:", "transport:", "beDirty"]
}, function ($methodClass){ return function (aPackageName,anArray,aTransport){
var self=this,$self=this;
var pkg;
return $core.withContext(function($ctx1) {
var $1;
pkg=$self._named_(aPackageName);
$1=pkg;
$recv($1)._imports_(anArray);
$recv($1)._transport_(aTransport);
$recv($1)._beDirty();
return pkg;
}, function($ctx1) {$ctx1.fill(self,"named:imports:transport:",{aPackageName:aPackageName,anArray:anArray,aTransport:aTransport,pkg:pkg})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "named:javaScriptDescriptor:",
protocol: "instance creation",
args: ["aString", "anObject"],
source: "named: aString javaScriptDescriptor: anObject\x0a\x09| pkg |\x0a\x09\x0a\x09pkg := Smalltalk createPackage: aString.\x0a\x09pkg javaScriptDescriptor: anObject.\x0a\x09^ pkg",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["createPackage:", "javaScriptDescriptor:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
var pkg;
return $core.withContext(function($ctx1) {
pkg=$recv($globals.Smalltalk)._createPackage_(aString);
$recv(pkg)._javaScriptDescriptor_(anObject);
return pkg;
}, function($ctx1) {$ctx1.fill(self,"named:javaScriptDescriptor:",{aString:aString,anObject:anObject,pkg:pkg})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "named:transport:",
protocol: "accessing",
args: ["aPackageName", "aTransport"],
source: "named: aPackageName transport: aTransport\x0a\x09| pkg |\x0a\x09\x0a\x09pkg := self named: aPackageName.\x0a\x09pkg transport: aTransport; beDirty.\x0a\x09\x0a\x09^ pkg",
referencedClasses: [],
pragmas: [],
messageSends: ["named:", "transport:", "beDirty"]
}, function ($methodClass){ return function (aPackageName,aTransport){
var self=this,$self=this;
var pkg;
return $core.withContext(function($ctx1) {
var $1;
pkg=$self._named_(aPackageName);
$1=pkg;
$recv($1)._transport_(aTransport);
$recv($1)._beDirty();
return pkg;
}, function($ctx1) {$ctx1.fill(self,"named:transport:",{aPackageName:aPackageName,aTransport:aTransport,pkg:pkg})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "new:",
protocol: "instance creation",
args: ["aString"],
source: "new: aString\x0a\x09^ Package new\x0a\x09\x09name: aString;\x0a\x09\x09yourself",
referencedClasses: ["Package"],
pragmas: [],
messageSends: ["name:", "new", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Package)._new();
$recv($1)._name_(aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"new:",{aString:aString})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "sortedClasses:",
protocol: "sorting",
args: ["classes"],
source: "sortedClasses: classes\x0a\x09^ Array streamContents: [ :stream | stream << (ClassBuilder sortClasses: classes) ]",
referencedClasses: ["Array", "ClassBuilder"],
pragmas: [],
messageSends: ["streamContents:", "<<", "sortClasses:"]
}, function ($methodClass){ return function (classes){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
return $recv(stream).__lt_lt($recv($globals.ClassBuilder)._sortClasses_(classes));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"sortedClasses:",{classes:classes})});
}; }),
$globals.Package.a$cls);


$core.addClass("PackageStateObserver", $globals.Object, "Kernel-Infrastructure");
$globals.PackageStateObserver.comment="My current instance listens for any changes in the system that might affect the state of a package (being dirty).";
$core.addMethod(
$core.method({
selector: "announcer",
protocol: "accessing",
args: [],
source: "announcer\x0a\x09^ SystemAnnouncer current",
referencedClasses: ["SystemAnnouncer"],
pragmas: [],
messageSends: ["current"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.SystemAnnouncer)._current();
}, function($ctx1) {$ctx1.fill(self,"announcer",{})});
}; }),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "observeSystem",
protocol: "actions",
args: [],
source: "observeSystem\x0a\x09self announcer\x0a\x09\x09on: PackageAdded\x0a\x09\x09send: #onPackageAdded:\x0a\x09\x09to: self;\x0a\x09\x09\x0a\x09\x09on: ClassAnnouncement\x0a\x09\x09send: #onClassModification:\x0a\x09\x09to: self;\x0a\x09\x09\x0a\x09\x09on: MethodAnnouncement\x0a\x09\x09send: #onMethodModification:\x0a\x09\x09to: self",
referencedClasses: ["PackageAdded", "ClassAnnouncement", "MethodAnnouncement"],
pragmas: [],
messageSends: ["on:send:to:", "announcer"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._announcer();
[$recv($1)._on_send_to_($globals.PackageAdded,"onPackageAdded:",self)
,$ctx1.sendIdx["on:send:to:"]=1
][0];
[$recv($1)._on_send_to_($globals.ClassAnnouncement,"onClassModification:",self)
,$ctx1.sendIdx["on:send:to:"]=2
][0];
$recv($1)._on_send_to_($globals.MethodAnnouncement,"onMethodModification:",self);
return self;
}, function($ctx1) {$ctx1.fill(self,"observeSystem",{})});
}; }),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onClassModification:",
protocol: "reactions",
args: ["anAnnouncement"],
source: "onClassModification: anAnnouncement\x0a\x09anAnnouncement theClass ifNotNil: [ :theClass | theClass package beDirty ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "theClass", "beDirty", "package"]
}, function ($methodClass){ return function (anAnnouncement){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(anAnnouncement)._theClass();
if($1 == null || $1.a$nil){
$1;
} else {
var theClass;
theClass=$1;
$recv($recv(theClass)._package())._beDirty();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"onClassModification:",{anAnnouncement:anAnnouncement})});
}; }),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onMethodModification:",
protocol: "reactions",
args: ["anAnnouncement"],
source: "onMethodModification: anAnnouncement\x0a\x09anAnnouncement method package ifNotNil: [ :package | package beDirty ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "package", "method", "beDirty"]
}, function ($methodClass){ return function (anAnnouncement){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv(anAnnouncement)._method())._package();
if($1 == null || $1.a$nil){
$1;
} else {
var package_;
package_=$1;
$recv(package_)._beDirty();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"onMethodModification:",{anAnnouncement:anAnnouncement})});
}; }),
$globals.PackageStateObserver);

$core.addMethod(
$core.method({
selector: "onPackageAdded:",
protocol: "reactions",
args: ["anAnnouncement"],
source: "onPackageAdded: anAnnouncement\x0a\x09anAnnouncement package beDirty",
referencedClasses: [],
pragmas: [],
messageSends: ["beDirty", "package"]
}, function ($methodClass){ return function (anAnnouncement){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(anAnnouncement)._package())._beDirty();
return self;
}, function($ctx1) {$ctx1.fill(self,"onPackageAdded:",{anAnnouncement:anAnnouncement})});
}; }),
$globals.PackageStateObserver);


$core.setSlots($globals.PackageStateObserver.a$cls, ["current"]);
$core.addMethod(
$core.method({
selector: "current",
protocol: "accessing",
args: [],
source: "current\x0a\x09^ current ifNil: [ current := self new ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.current;
if($1 == null || $1.a$nil){
$self.current=$self._new();
return $self.current;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"current",{})});
}; }),
$globals.PackageStateObserver.a$cls);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09self current observeSystem",
referencedClasses: [],
pragmas: [],
messageSends: ["observeSystem", "current"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._current())._observeSystem();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.PackageStateObserver.a$cls);


$core.addClass("Setting", $globals.Object, "Kernel-Infrastructure");
$core.setSlots($globals.Setting, ["key", "defaultValue"]);
$globals.Setting.comment="I represent a setting **stored** at `Smalltalk settings`. \x0aIn the current implementation, `Smalltalk settings` is an object persisted in the localStorage.\x0a\x0a## API\x0a\x0aA `Setting` value can be read using `value` and set using `value:`.\x0a\x0aSettings are accessed with `'key' asSetting` or `'key' asSettingIfAbsent: aDefaultValue`.\x0a\x0aTo read the value of a setting you can also use the convenience:\x0a\x0a`theValueSet :=  'any.characteristic' settingValue` \x0a\x0aor with a default using:\x0a\x0a `theEnsuredValueSet := 'any.characteristic' settingValueIfAbsent: true`";
$core.addMethod(
$core.method({
selector: "defaultValue",
protocol: "accessing",
args: [],
source: "defaultValue\x0a\x09^ defaultValue",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.defaultValue;

}; }),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "defaultValue:",
protocol: "accessing",
args: ["aStringifiableObject"],
source: "defaultValue: aStringifiableObject\x0a\x09defaultValue := aStringifiableObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aStringifiableObject){
var self=this,$self=this;
$self.defaultValue=aStringifiableObject;
return self;

}; }),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "key",
protocol: "accessing",
args: [],
source: "key\x0a\x09^ key",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.key;

}; }),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "key:",
protocol: "accessing",
args: ["aString"],
source: "key: aString\x0a\x09key := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.key=aString;
return self;

}; }),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "value",
protocol: "accessing",
args: [],
source: "value\x0a\x09^ Smalltalk settings at: self key ifAbsent: [ self defaultValue ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["at:ifAbsent:", "settings", "key", "defaultValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._settings())._at_ifAbsent_($self._key(),(function(){
return $core.withContext(function($ctx2) {
return $self._defaultValue();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.Setting);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "accessing",
args: ["aStringifiableObject"],
source: "value: aStringifiableObject\x0a\x09^ Smalltalk settings at: self key put: aStringifiableObject",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["at:put:", "settings", "key"]
}, function ($methodClass){ return function (aStringifiableObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._settings())._at_put_($self._key(),aStringifiableObject);
}, function($ctx1) {$ctx1.fill(self,"value:",{aStringifiableObject:aStringifiableObject})});
}; }),
$globals.Setting);


$core.addMethod(
$core.method({
selector: "at:ifAbsent:",
protocol: "instance creation",
args: ["aString", "aDefaultValue"],
source: "at: aString ifAbsent: aDefaultValue\x0a\x09\x0a\x09^ super new\x0a\x09\x09key: aString;\x0a\x09\x09defaultValue: aDefaultValue;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["key:", "new", "defaultValue:", "yourself"]
}, function ($methodClass){ return function (aString,aDefaultValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._new.call($self))
,$ctx1.supercall = false
][0];
$recv($1)._key_(aString);
$recv($1)._defaultValue_(aDefaultValue);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"at:ifAbsent:",{aString:aString,aDefaultValue:aDefaultValue})});
}; }),
$globals.Setting.a$cls);

$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldNotImplement"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.Setting.a$cls);


$core.addClass("SmalltalkImage", $globals.Object, "Kernel-Infrastructure");
$core.setSlots($globals.SmalltalkImage, ["globalJsVariables", "packageDictionary"]);
$globals.SmalltalkImage.comment="I represent the Smalltalk system, wrapping\x0aoperations of variable `$core` declared in `base/boot.js`.\x0a\x0a## API\x0a\x0aI have only one instance, accessed with global variable `Smalltalk`.\x0a\x0a## Classes\x0a\x0aClasses can be accessed using the following methods:\x0a\x0a- `#classes` answers the full list of Smalltalk classes in the system\x0a- `#globals #at:` answers a specific global (usually, a class) or `nil`\x0a\x0a## Packages\x0a\x0aPackages can be accessed using the following methods:\x0a\x0a- `#packages` answers the full list of packages\x0a- `#packageAt:` answers a specific package or `nil`\x0a\x0a## Parsing\x0a\x0aThe `#parse:` method is used to parse Amber source code.\x0aIt requires the `Compiler` package and the `base/parser.js` parser file in order to work.";
$core.addMethod(
$core.method({
selector: "addGlobalJsVariable:",
protocol: "globals",
args: ["aString"],
source: "addGlobalJsVariable: aString\x0a\x09self globalJsVariables add: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "globalJsVariables"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._globalJsVariables())._add_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"addGlobalJsVariable:",{aString:aString})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "adoptPackageDescriptors",
protocol: "private",
args: [],
source: "adoptPackageDescriptors\x0a\x09^ self tryAdoptPackageDescriptorsBeyond: Set new",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["tryAdoptPackageDescriptorsBeyond:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._tryAdoptPackageDescriptorsBeyond_($recv($globals.Set)._new());
}, function($ctx1) {$ctx1.fill(self,"adoptPackageDescriptors",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "amdRequire",
protocol: "accessing amd",
args: [],
source: "amdRequire\x0a\x09^ self core at: 'amdRequire'",
referencedClasses: [],
pragmas: [],
messageSends: ["at:", "core"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._core())._at_("amdRequire");
}, function($ctx1) {$ctx1.fill(self,"amdRequire",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "asSmalltalkException:",
protocol: "error handling",
args: ["anObject"],
source: "asSmalltalkException: anObject\x0a\x09\x22A JavaScript exception may be thrown.\x0a\x09We then need to convert it back to a Smalltalk object\x22\x0a\x09\x0a\x09^ anObject\x0a\x09\x09ifNil: [ [ self error: 'Error: nil' ] on: Error do: [ :e | e ] ]\x0a\x09\x09ifNotNil: [\x0a\x09\x09\x09(self isError: anObject)\x0a\x09\x09\x09\x09ifTrue: [ anObject ]\x0a\x09\x09\x09\x09ifFalse: [ JavaScriptException on: anObject ] ]",
referencedClasses: ["Error", "JavaScriptException"],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "on:do:", "error:", "ifTrue:ifFalse:", "isError:", "on:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(anObject == null || anObject.a$nil){
return $recv((function(){
return $core.withContext(function($ctx2) {
return $self._error_("Error: nil");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))._on_do_($globals.Error,(function(e){
return e;

}));
} else {
if($core.assert($self._isError_(anObject))){
return anObject;
} else {
return $recv($globals.JavaScriptException)._on_(anObject);
}
}
}, function($ctx1) {$ctx1.fill(self,"asSmalltalkException:",{anObject:anObject})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "basicCreatePackage:",
protocol: "private",
args: ["packageName"],
source: "basicCreatePackage: packageName\x0a\x09\x22Create and bind a new bare package with given name and return it.\x22\x0a\x09^ self packageDictionary at: packageName ifAbsentPut: [ Package new: packageName ]",
referencedClasses: ["Package"],
pragmas: [],
messageSends: ["at:ifAbsentPut:", "packageDictionary", "new:"]
}, function ($methodClass){ return function (packageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._packageDictionary())._at_ifAbsentPut_(packageName,(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Package)._new_(packageName);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"basicCreatePackage:",{packageName:packageName})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "beClean",
protocol: "packages",
args: [],
source: "beClean\x0a\x09\x22Marks all packages clean.\x22\x0a\x0a\x09self packages do: #beClean",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "packages"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._packages())._do_("beClean");
return self;
}, function($ctx1) {$ctx1.fill(self,"beClean",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "cancelOptOut:",
protocol: "accessing",
args: ["anObject"],
source: "cancelOptOut: anObject\x0a\x09\x22A Smalltalk object has a 'a$cls' property.\x0a\x09If this property is shadowed for anObject by optOut:,\x0a\x09the object is treated as plain JS object.\x0a\x09This removes the shadow and anObject is Smalltalk object\x0a\x09again if it was before.\x22\x0a\x09\x0a\x09<inlineJS: 'delete anObject.a$cls;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["delete anObject.a$cls;"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
delete anObject.a$cls;;
return self;
}, function($ctx1) {$ctx1.fill(self,"cancelOptOut:",{anObject:anObject})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "classes",
protocol: "classes",
args: [],
source: "classes\x0a\x09^ self core traitsOrClasses copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy", "traitsOrClasses", "core"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._core())._traitsOrClasses())._copy();
}, function($ctx1) {$ctx1.fill(self,"classes",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "core",
protocol: "accessing",
args: [],
source: "core\x0a\x09<inlineJS: 'return $core'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core;
return self;
}, function($ctx1) {$ctx1.fill(self,"core",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "createPackage:",
protocol: "packages",
args: ["packageName"],
source: "createPackage: packageName\x0a\x09| package announcement |\x0a\x09\x0a\x09package := self basicCreatePackage: packageName.\x0a\x09\x0a\x09announcement := PackageAdded new\x0a\x09\x09package: package;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09SystemAnnouncer current announce: announcement.\x0a\x09\x0a\x09^ package",
referencedClasses: ["PackageAdded", "SystemAnnouncer"],
pragmas: [],
messageSends: ["basicCreatePackage:", "package:", "new", "yourself", "announce:", "current"]
}, function ($methodClass){ return function (packageName){
var self=this,$self=this;
var package_,announcement;
return $core.withContext(function($ctx1) {
var $1;
package_=$self._basicCreatePackage_(packageName);
$1=$recv($globals.PackageAdded)._new();
$recv($1)._package_(package_);
announcement=$recv($1)._yourself();
$recv($recv($globals.SystemAnnouncer)._current())._announce_(announcement);
return package_;
}, function($ctx1) {$ctx1.fill(self,"createPackage:",{packageName:packageName,package_:package_,announcement:announcement})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "defaultAmdNamespace",
protocol: "accessing amd",
args: [],
source: "defaultAmdNamespace\x0a\x09^ 'transport.defaultAmdNamespace' settingValue",
referencedClasses: [],
pragmas: [],
messageSends: ["settingValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "transport.defaultAmdNamespace"._settingValue();
}, function($ctx1) {$ctx1.fill(self,"defaultAmdNamespace",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "defaultAmdNamespace:",
protocol: "accessing amd",
args: ["aString"],
source: "defaultAmdNamespace: aString\x0a\x09'transport.defaultAmdNamespace' settingValue: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["settingValue:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
"transport.defaultAmdNamespace"._settingValue_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"defaultAmdNamespace:",{aString:aString})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "deleteClass:",
protocol: "private",
args: ["aClass"],
source: "deleteClass: aClass\x0a\x09\x22Deletes a class by deleting its binding only. Use #removeClass instead\x22\x0a\x09\x0a\x09<inlineJS: '$core.removeClass(aClass)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["$core.removeClass(aClass)"]]],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$core.removeClass(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"deleteClass:",{aClass:aClass})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "deleteGlobalJsVariable:",
protocol: "globals",
args: ["aString"],
source: "deleteGlobalJsVariable: aString\x0a\x09self globalJsVariables remove: aString ifAbsent:[]",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:ifAbsent:", "globalJsVariables"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._globalJsVariables())._remove_ifAbsent_(aString,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"deleteGlobalJsVariable:",{aString:aString})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "existsJsGlobal:",
protocol: "testing",
args: ["aString"],
source: "existsJsGlobal: aString\x0a\x09self deprecatedAPI: 'Use Platform >> includesGlobal: instead'.\x0a\x09^ Platform includesGlobal: aString",
referencedClasses: ["Platform"],
pragmas: [],
messageSends: ["deprecatedAPI:", "includesGlobal:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use Platform >> includesGlobal: instead");
return $recv($globals.Platform)._includesGlobal_(aString);
}, function($ctx1) {$ctx1.fill(self,"existsJsGlobal:",{aString:aString})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "globalJsVariables",
protocol: "globals",
args: [],
source: "globalJsVariables\x0a\x09^ globalJsVariables ifNil: [\x0a\x09\x09globalJsVariables := #(window document process global) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.globalJsVariables;
if($1 == null || $1.a$nil){
$self.globalJsVariables=["window", "document", "process", "global"];
return $self.globalJsVariables;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"globalJsVariables",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "globals",
protocol: "accessing",
args: [],
source: "globals\x0a\x09<inlineJS: 'return $globals'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $globals"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $globals;
return self;
}, function($ctx1) {$ctx1.fill(self,"globals",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "isError:",
protocol: "testing",
args: ["anObject"],
source: "isError: anObject\x0a\x09^ (self isSmalltalkObject: anObject) and: [ anObject isError ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "isSmalltalkObject:", "isError"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isSmalltalkObject_(anObject))){
return $recv(anObject)._isError();
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"isError:",{anObject:anObject})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "isSmalltalkObject:",
protocol: "testing",
args: ["anObject"],
source: "isSmalltalkObject: anObject\x0a\x09\x22Consider anObject a Smalltalk object if it has a 'a$cls' property.\x0a\x09Note that this may be unaccurate\x22\x0a\x09\x0a\x09<inlineJS: 'return anObject.a$cls != null'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return anObject.a$cls != null"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return anObject.a$cls != null;
return self;
}, function($ctx1) {$ctx1.fill(self,"isSmalltalkObject:",{anObject:anObject})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "optOut:",
protocol: "accessing",
args: ["anObject"],
source: "optOut: anObject\x0a\x09\x22A Smalltalk object has a 'a$cls' property.\x0a\x09This shadows the property for anObject.\x0a\x09The object is treated as plain JS object following this.\x22\x0a\x09\x0a\x09<inlineJS: 'anObject.a$cls = null'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["anObject.a$cls = null"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
anObject.a$cls = null;
return self;
}, function($ctx1) {$ctx1.fill(self,"optOut:",{anObject:anObject})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packageAt:ifAbsent:",
protocol: "packages",
args: ["packageName", "aBlock"],
source: "packageAt: packageName ifAbsent: aBlock\x0a\x09^ self packageDictionary at: packageName ifAbsent: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "packageDictionary"]
}, function ($methodClass){ return function (packageName,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._packageDictionary())._at_ifAbsent_(packageName,aBlock);
}, function($ctx1) {$ctx1.fill(self,"packageAt:ifAbsent:",{packageName:packageName,aBlock:aBlock})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packageAt:ifPresent:",
protocol: "packages",
args: ["packageName", "aBlock"],
source: "packageAt: packageName ifPresent: aBlock\x0a\x09^ self packageDictionary at: packageName ifPresent: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifPresent:", "packageDictionary"]
}, function ($methodClass){ return function (packageName,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._packageDictionary())._at_ifPresent_(packageName,aBlock);
}, function($ctx1) {$ctx1.fill(self,"packageAt:ifPresent:",{packageName:packageName,aBlock:aBlock})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packageDictionary",
protocol: "packages",
args: [],
source: "packageDictionary\x0a\x09^ packageDictionary ifNil: [ packageDictionary := Dictionary new ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.packageDictionary;
if($1 == null || $1.a$nil){
$self.packageDictionary=$recv($globals.Dictionary)._new();
return $self.packageDictionary;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"packageDictionary",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "packages",
protocol: "packages",
args: [],
source: "packages\x0a\x09\x22Return all Package instances in the system.\x22\x0a\x0a\x09^ self packageDictionary values copy",
referencedClasses: [],
pragmas: [],
messageSends: ["copy", "values", "packageDictionary"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._packageDictionary())._values())._copy();
}, function($ctx1) {$ctx1.fill(self,"packages",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: "accessing",
args: ["aString"],
source: "parse: aString\x0a\x09^ Compiler new parse: aString",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["parse:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Compiler)._new())._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "postFailedLoad:",
protocol: "image",
args: ["aPackage"],
source: "postFailedLoad: aPackage\x0a\x09| keys descriptors |\x0a\x09Smalltalk removePackage: aPackage name.\x0a\x09keys := Set new.\x0a\x09descriptors := self core packageDescriptors.\x0a\x09descriptors keysAndValuesDo: [ :key :value | keys add: key ].\x0a\x09keys do: [ :each |\x0a\x09\x09Smalltalk removePackage: each.\x0a\x09\x09descriptors removeKey: each ]",
referencedClasses: ["Smalltalk", "Set"],
pragmas: [],
messageSends: ["removePackage:", "name", "new", "packageDescriptors", "core", "keysAndValuesDo:", "add:", "do:", "removeKey:"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var keys,descriptors;
return $core.withContext(function($ctx1) {
[$recv($globals.Smalltalk)._removePackage_($recv(aPackage)._name())
,$ctx1.sendIdx["removePackage:"]=1
][0];
keys=$recv($globals.Set)._new();
descriptors=$recv($self._core())._packageDescriptors();
$recv(descriptors)._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(keys)._add_(key);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
$recv(keys)._do_((function(each){
return $core.withContext(function($ctx2) {
$recv($globals.Smalltalk)._removePackage_(each);
return $recv(descriptors)._removeKey_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"postFailedLoad:",{aPackage:aPackage,keys:keys,descriptors:descriptors})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "postLoad",
protocol: "image",
args: [],
source: "postLoad\x0a\x09^ self adoptPackageDescriptors then: [ :pkgs |\x0a\x09\x09| classes |\x0a\x09\x09pkgs do: #beClean.\x0a\x09\x09classes := Smalltalk classes select:\x0a\x09\x09\x09[ :each | pkgs includes: each package ].\x0a\x09\x09classes do: [ :each |\x0a\x09\x09\x09each = self class ifFalse: [ each initialize ] ].\x0a\x09\x09self sweepPackageDescriptors: pkgs ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["then:", "adoptPackageDescriptors", "do:", "select:", "classes", "includes:", "package", "ifFalse:", "=", "class", "initialize", "sweepPackageDescriptors:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._adoptPackageDescriptors())._then_((function(pkgs){
var classes;
return $core.withContext(function($ctx2) {
[$recv(pkgs)._do_("beClean")
,$ctx2.sendIdx["do:"]=1
][0];
classes=$recv($recv($globals.Smalltalk)._classes())._select_((function(each){
return $core.withContext(function($ctx3) {
return $recv(pkgs)._includes_($recv(each)._package());
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
$recv(classes)._do_((function(each){
return $core.withContext(function($ctx3) {
if(!$core.assert($recv(each).__eq($self._class()))){
return $recv(each)._initialize();
}
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,3)});
}));
return $self._sweepPackageDescriptors_(pkgs);
}, function($ctx2) {$ctx2.fillBlock({pkgs:pkgs,classes:classes},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"postLoad",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "pseudoVariableNames",
protocol: "accessing",
args: [],
source: "pseudoVariableNames\x0a\x09^ Compiler pseudoVariableNames",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["pseudoVariableNames"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Compiler)._pseudoVariableNames();
}, function($ctx1) {$ctx1.fill(self,"pseudoVariableNames",{})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "readJSObject:",
protocol: "accessing",
args: ["anObject"],
source: "readJSObject: anObject\x0a\x09<inlineJS: 'return $core.readJSObject(anObject)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.readJSObject(anObject)"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.readJSObject(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"readJSObject:",{anObject:anObject})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "removeClass:",
protocol: "classes",
args: ["aClass"],
source: "removeClass: aClass\x0a\x09aClass isMetaclass ifTrue: [ self error: aClass asString, ' is a Metaclass and cannot be removed!' ].\x0a\x09aClass allSubclassesDo: [ :subclass | self error: aClass name, ' has a subclass: ', subclass name ].\x0a\x09aClass traitUsers ifNotEmpty: [ self error: aClass name, ' has trait users.' ].\x0a\x09\x0a\x09self deleteClass: aClass.\x0a\x09aClass includingPossibleMetaDo: [ :each | each setTraitComposition: #() ].\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09\x09announce: (ClassRemoved new\x0a\x09\x09\x09theClass: aClass;\x0a\x09\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "ClassRemoved"],
pragmas: [],
messageSends: ["ifTrue:", "isMetaclass", "error:", ",", "asString", "allSubclassesDo:", "name", "ifNotEmpty:", "traitUsers", "deleteClass:", "includingPossibleMetaDo:", "setTraitComposition:", "announce:", "current", "theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
if($core.assert($recv(aClass)._isMetaclass())){
[$self._error_([$recv($recv(aClass)._asString()).__comma(" is a Metaclass and cannot be removed!")
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["error:"]=1
][0];
}
$recv(aClass)._allSubclassesDo_((function(subclass){
return $core.withContext(function($ctx2) {
return [$self._error_([$recv([$recv([$recv(aClass)._name()
,$ctx2.sendIdx["name"]=1
][0]).__comma(" has a subclass: ")
,$ctx2.sendIdx[","]=3
][0]).__comma([$recv(subclass)._name()
,$ctx2.sendIdx["name"]=2
][0])
,$ctx2.sendIdx[","]=2
][0])
,$ctx2.sendIdx["error:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({subclass:subclass},$ctx1,2)});
}));
$recv($recv(aClass)._traitUsers())._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $self._error_($recv($recv(aClass)._name()).__comma(" has trait users."));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$self._deleteClass_(aClass);
$recv(aClass)._includingPossibleMetaDo_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._setTraitComposition_([]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.ClassRemoved)._new();
$recv($2)._theClass_(aClass);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"removeClass:",{aClass:aClass})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "removePackage:",
protocol: "packages",
args: ["packageName"],
source: "removePackage: packageName\x0a\x09\x22Removes a package and all its classes.\x22\x0a\x0a\x09| pkg |\x0a\x09pkg := self packageAt: packageName ifAbsent: [ self error: 'Missing package: ', packageName ].\x0a\x09pkg classes do: [ :each |\x0a\x09\x09\x09self removeClass: each ].\x0a\x09self packageDictionary removeKey: packageName.\x0a\x09\x0a\x09SystemAnnouncer current\x0a\x09announce: (PackageRemoved new\x0a\x09\x09package: pkg;\x0a\x09\x09yourself)",
referencedClasses: ["SystemAnnouncer", "PackageRemoved"],
pragmas: [],
messageSends: ["packageAt:ifAbsent:", "error:", ",", "do:", "classes", "removeClass:", "removeKey:", "packageDictionary", "announce:", "current", "package:", "new", "yourself"]
}, function ($methodClass){ return function (packageName){
var self=this,$self=this;
var pkg;
return $core.withContext(function($ctx1) {
var $1,$2;
pkg=$self._packageAt_ifAbsent_(packageName,(function(){
return $core.withContext(function($ctx2) {
return $self._error_("Missing package: ".__comma(packageName));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv($recv(pkg)._classes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._removeClass_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$recv($self._packageDictionary())._removeKey_(packageName);
$1=$recv($globals.SystemAnnouncer)._current();
$2=$recv($globals.PackageRemoved)._new();
$recv($2)._package_(pkg);
$recv($1)._announce_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"removePackage:",{packageName:packageName,pkg:pkg})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "renamePackage:to:",
protocol: "packages",
args: ["packageName", "newName"],
source: "renamePackage: packageName to: newName\x0a\x09\x22Rename a package.\x22\x0a\x0a\x09| pkg |\x0a\x09pkg := self packageAt: packageName ifAbsent: [ self error: 'Missing package: ', packageName ].\x0a\x09self packageAt: newName ifPresent: [ self error: 'Already exists a package called: ', newName ].\x0a\x09pkg name: newName; beDirty.\x0a\x09self packageDictionary\x0a\x09\x09at: newName put: pkg;\x0a\x09\x09removeKey: packageName",
referencedClasses: [],
pragmas: [],
messageSends: ["packageAt:ifAbsent:", "error:", ",", "packageAt:ifPresent:", "name:", "beDirty", "at:put:", "packageDictionary", "removeKey:"]
}, function ($methodClass){ return function (packageName,newName){
var self=this,$self=this;
var pkg;
return $core.withContext(function($ctx1) {
var $1,$2;
pkg=$self._packageAt_ifAbsent_(packageName,(function(){
return $core.withContext(function($ctx2) {
return [$self._error_(["Missing package: ".__comma(packageName)
,$ctx2.sendIdx[","]=1
][0])
,$ctx2.sendIdx["error:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$self._packageAt_ifPresent_(newName,(function(){
return $core.withContext(function($ctx2) {
return $self._error_("Already exists a package called: ".__comma(newName));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$1=pkg;
$recv($1)._name_(newName);
$recv($1)._beDirty();
$2=$self._packageDictionary();
$recv($2)._at_put_(newName,pkg);
$recv($2)._removeKey_(packageName);
return self;
}, function($ctx1) {$ctx1.fill(self,"renamePackage:to:",{packageName:packageName,newName:newName,pkg:pkg})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "reservedWords",
protocol: "accessing",
args: [],
source: "reservedWords\x0a\x09^ #(\x0a\x09\x09\x22http://www.ecma-international.org/ecma-262/6.0/#sec-keywords\x22\x0a\x09\x09break case catch class const continue debugger\x0a\x09\x09default delete do else export extends finally\x0a\x09\x09for function if import in instanceof new\x0a\x09\x09return super switch this throw try typeof\x0a\x09\x09var void while with yield\x0a\x09\x09\x22in strict mode\x22\x0a\x09\x09let static\x0a\x09\x09\x22Amber protected words: these should not be compiled as-is when in code\x22\x0a\x09\x09arguments\x0a\x09\x09\x22http://www.ecma-international.org/ecma-262/6.0/#sec-future-reserved-words\x22\x0a\x09\x09await enum\x0a\x09\x09\x22in strict mode\x22\x0a\x09\x09implements interface package private protected public\x0a\x09)",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return ["break", "case", "catch", "class", "const", "continue", "debugger", "default", "delete", "do", "else", "export", "extends", "finally", "for", "function", "if", "import", "in", "instanceof", "new", "return", "super", "switch", "this", "throw", "try", "typeof", "var", "void", "while", "with", "yield", "let", "static", "arguments", "await", "enum", "implements", "interface", "package", "private", "protected", "public"];

}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "settings",
protocol: "accessing",
args: [],
source: "settings\x0a\x09^ SmalltalkSettings",
referencedClasses: ["SmalltalkSettings"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.SmalltalkSettings;

}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "sweepPackageDescriptors:",
protocol: "private",
args: ["pkgs"],
source: "sweepPackageDescriptors: pkgs\x0a\x09| pd |\x09\x0a\x09pd := self core packageDescriptors.\x0a\x09pkgs do: [ :each | pd removeKey: each name ]",
referencedClasses: [],
pragmas: [],
messageSends: ["packageDescriptors", "core", "do:", "removeKey:", "name"]
}, function ($methodClass){ return function (pkgs){
var self=this,$self=this;
var pd;
return $core.withContext(function($ctx1) {
pd=$recv($self._core())._packageDescriptors();
$recv(pkgs)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(pd)._removeKey_($recv(each)._name());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"sweepPackageDescriptors:",{pkgs:pkgs,pd:pd})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "try:ifTrue:catch:",
protocol: "error handling",
args: ["actionBlock", "aBlock", "anotherBlock"],
source: "try: actionBlock ifTrue: aBlock catch: anotherBlock\x0a\x09\x22Similar to BlockClosure >> tryifTrue:catch:, but\x0a\x09converts all JS exceptions to JavaScriptException instances.\x22\x0a\x09\x0a\x09| smalltalkError |\x0a\x09^ actionBlock\x0a\x09\x09tryIfTrue: [ :error |\x0a\x09\x09\x09smalltalkError := self asSmalltalkException: error.\x0a\x09\x09\x09aBlock value: smalltalkError ]\x0a\x09\x09catch: [ anotherBlock value: smalltalkError ]",
referencedClasses: [],
pragmas: [],
messageSends: ["tryIfTrue:catch:", "asSmalltalkException:", "value:"]
}, function ($methodClass){ return function (actionBlock,aBlock,anotherBlock){
var self=this,$self=this;
var smalltalkError;
return $core.withContext(function($ctx1) {
return $recv(actionBlock)._tryIfTrue_catch_((function(error){
return $core.withContext(function($ctx2) {
smalltalkError=$self._asSmalltalkException_(error);
return [$recv(aBlock)._value_(smalltalkError)
,$ctx2.sendIdx["value:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv(anotherBlock)._value_(smalltalkError);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"try:ifTrue:catch:",{actionBlock:actionBlock,aBlock:aBlock,anotherBlock:anotherBlock,smalltalkError:smalltalkError})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "tryAdoptPackageDescriptorsBeyond:",
protocol: "private",
args: ["aSet"],
source: "tryAdoptPackageDescriptorsBeyond: aSet\x0a\x09| original |\x0a\x09original := aSet copy.\x0a\x09self core packageDescriptors keysAndValuesDo: [ :key :value |\x0a\x09\x09aSet add: (Package named: key javaScriptDescriptor: value) ].\x0a\x09^ (aSet allSatisfy: [ :each | original includes: each ])\x0a\x09\x09ifFalse: [ (Promise all: (aSet collect: #isReady)) then: [ self tryAdoptPackageDescriptorsBeyond: aSet ] ]\x0a\x09\x09ifTrue: [ Promise value: aSet ]",
referencedClasses: ["Package", "Promise"],
pragmas: [],
messageSends: ["copy", "keysAndValuesDo:", "packageDescriptors", "core", "add:", "named:javaScriptDescriptor:", "ifFalse:ifTrue:", "allSatisfy:", "includes:", "then:", "all:", "collect:", "tryAdoptPackageDescriptorsBeyond:", "value:"]
}, function ($methodClass){ return function (aSet){
var self=this,$self=this;
var original;
return $core.withContext(function($ctx1) {
original=$recv(aSet)._copy();
$recv($recv($self._core())._packageDescriptors())._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv(aSet)._add_($recv($globals.Package)._named_javaScriptDescriptor_(key,value));
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,1)});
}));
if($core.assert($recv(aSet)._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(original)._includes_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})))){
return $recv($globals.Promise)._value_(aSet);
} else {
return $recv($recv($globals.Promise)._all_($recv(aSet)._collect_("isReady")))._then_((function(){
return $core.withContext(function($ctx2) {
return $self._tryAdoptPackageDescriptorsBeyond_(aSet);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}));
}
}, function($ctx1) {$ctx1.fill(self,"tryAdoptPackageDescriptorsBeyond:",{aSet:aSet,original:original})});
}; }),
$globals.SmalltalkImage);

$core.addMethod(
$core.method({
selector: "version",
protocol: "accessing",
args: [],
source: "version\x0a\x09\x22Answer the version string of Amber\x22\x0a\x09\x0a\x09^ '0.29.2'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "0.29.2";

}; }),
$globals.SmalltalkImage);


$core.setSlots($globals.SmalltalkImage.a$cls, ["current"]);
$core.addMethod(
$core.method({
selector: "current",
protocol: "instance creation",
args: [],
source: "current\x0a\x09^ current ifNil: [ current := super new ] ifNotNil: [ self deprecatedAPI. current ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "new", "deprecatedAPI"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.current;
if($1 == null || $1.a$nil){
$self.current=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._new.call($self))
,$ctx1.supercall = false
][0];
return $self.current;
} else {
$self._deprecatedAPI();
return $self.current;
}
}, function($ctx1) {$ctx1.fill(self,"current",{})});
}; }),
$globals.SmalltalkImage.a$cls);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09| st |\x0a\x09st := self current.\x0a\x09st globals at: 'Smalltalk' put: st",
referencedClasses: [],
pragmas: [],
messageSends: ["current", "at:put:", "globals"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var st;
return $core.withContext(function($ctx1) {
st=$self._current();
$recv($recv(st)._globals())._at_put_("Smalltalk",st);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{st:st})});
}; }),
$globals.SmalltalkImage.a$cls);

$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldNotImplement"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.SmalltalkImage.a$cls);

$core.setTraitComposition([{trait: $globals.TIsInGroup}, {trait: $globals.TThenable}], $globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "nextPutJSObject:",
protocol: "*Kernel-Infrastructure",
args: ["aJSObject"],
source: "nextPutJSObject: aJSObject\x0a\x09self nextPut: aJSObject",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPut:"]
}, function ($methodClass){ return function (aJSObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nextPut_(aJSObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutJSObject:",{aJSObject:aJSObject})});
}; }),
$globals.ProtoStream);

$core.addMethod(
$core.method({
selector: "asJavaScriptPropertyName",
protocol: "*Kernel-Infrastructure",
args: [],
source: "asJavaScriptPropertyName\x0a<inlineJS: 'return $core.st2prop(self)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return $core.st2prop(self)"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $core.st2prop(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptPropertyName",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSetting",
protocol: "*Kernel-Infrastructure",
args: [],
source: "asSetting\x0a\x09\x22Answer aSetting dedicated to locally store a value using this string as key.\x0a\x09Nil will be the default value.\x22\x0a\x09^ Setting at: self ifAbsent: nil",
referencedClasses: ["Setting"],
pragmas: [],
messageSends: ["at:ifAbsent:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Setting)._at_ifAbsent_(self,nil);
}, function($ctx1) {$ctx1.fill(self,"asSetting",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "asSettingIfAbsent:",
protocol: "*Kernel-Infrastructure",
args: ["aDefaultValue"],
source: "asSettingIfAbsent: aDefaultValue\x0a\x09\x22Answer aSetting dedicated to locally store a value using this string as key.\x0a\x09Make this setting to have aDefaultValue.\x22\x0a\x09^ Setting at: self ifAbsent: aDefaultValue",
referencedClasses: ["Setting"],
pragmas: [],
messageSends: ["at:ifAbsent:"]
}, function ($methodClass){ return function (aDefaultValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Setting)._at_ifAbsent_(self,aDefaultValue);
}, function($ctx1) {$ctx1.fill(self,"asSettingIfAbsent:",{aDefaultValue:aDefaultValue})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "settingValue",
protocol: "*Kernel-Infrastructure",
args: [],
source: "settingValue\x0a\x09^ self asSetting value",
referencedClasses: [],
pragmas: [],
messageSends: ["value", "asSetting"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asSetting())._value();
}, function($ctx1) {$ctx1.fill(self,"settingValue",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "settingValue:",
protocol: "*Kernel-Infrastructure",
args: ["aValue"],
source: "settingValue: aValue\x0a\x09\x22Sets the value of the setting that will be locally stored using this string as key.\x0a\x09Note that aValue can be any object that can be stringifyed\x22\x0a\x09^ self asSetting value: aValue",
referencedClasses: [],
pragmas: [],
messageSends: ["value:", "asSetting"]
}, function ($methodClass){ return function (aValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asSetting())._value_(aValue);
}, function($ctx1) {$ctx1.fill(self,"settingValue:",{aValue:aValue})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "settingValueIfAbsent:",
protocol: "*Kernel-Infrastructure",
args: ["aDefaultValue"],
source: "settingValueIfAbsent: aDefaultValue\x0a\x09\x22Answer the value of the locally stored setting using this string as key.\x0a\x09Use aDefaultValue in case no setting is found\x22\x0a\x09^ (self asSettingIfAbsent: aDefaultValue) value",
referencedClasses: [],
pragmas: [],
messageSends: ["value", "asSettingIfAbsent:"]
}, function ($methodClass){ return function (aDefaultValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._asSettingIfAbsent_(aDefaultValue))._value();
}, function($ctx1) {$ctx1.fill(self,"settingValueIfAbsent:",{aDefaultValue:aDefaultValue})});
}; }),
$globals.String);

});

define('amber/core/Kernel-Exceptions',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Exceptions");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("Error", $globals.Object, "Kernel-Exceptions");
$core.setSlots($globals.Error, ["message", "stack", "amberHandled", "context", "smalltalkError"]);
$globals.Error.comment="From the ANSI standard:\x0a\x0aThis protocol describes the behavior of instances of class `Error`.\x0aThese are used to represent error conditions that prevent the normal continuation of processing.\x0aActual error exceptions used by an application may be subclasses of this class.\x0aAs `Error` is explicitly specified to be subclassable, conforming implementations must implement its behavior in a non-fragile manner.";
$core.addMethod(
$core.method({
selector: "basicSignal",
protocol: "private",
args: [],
source: "basicSignal\x0a\x09<inlineJS: 'throw self;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["throw self;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
throw self;;
return self;
}, function($ctx1) {$ctx1.fill(self,"basicSignal",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "beHandled",
protocol: "accessing",
args: [],
source: "beHandled\x0a\x09amberHandled := true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
$self.amberHandled=true;
return self;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "beUnhandled",
protocol: "accessing",
args: [],
source: "beUnhandled\x0a\x09amberHandled := false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
$self.amberHandled=false;
return self;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "context",
protocol: "accessing",
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.context;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "context:",
protocol: "accessing",
args: ["aMethodContext"],
source: "context: aMethodContext\x0a\x09context := aMethodContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aMethodContext){
var self=this,$self=this;
$self.context=aMethodContext;
return self;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09self messageText: 'Errorclass: ', (self class name).",
referencedClasses: [],
pragmas: [],
messageSends: ["messageText:", ",", "name", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._messageText_("Errorclass: ".__comma($recv($self._class())._name()));
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "isError",
protocol: "testing",
args: [],
source: "isError\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "jsStack",
protocol: "accessing",
args: [],
source: "jsStack\x0a\x09^ stack",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.stack;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09^ message",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.message;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "messageText:",
protocol: "accessing",
args: ["aString"],
source: "messageText: aString\x0a\x09message := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.message=aString;
return self;

}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "outer",
protocol: "signaling",
args: [],
source: "outer\x0a\x09\x22Pharo compatibility. Just sends #pass.\x22\x0a\x09\x0a\x09^ self pass",
referencedClasses: [],
pragmas: [],
messageSends: ["pass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._pass();
}, function($ctx1) {$ctx1.fill(self,"outer",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "pass",
protocol: "signaling",
args: [],
source: "pass\x0a\x09\x22Let outer handler take care of this.\x22\x0a\x0a\x09self beUnhandled; basicSignal",
referencedClasses: [],
pragmas: [],
messageSends: ["beUnhandled", "basicSignal"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._beUnhandled();
$self._basicSignal();
return self;
}, function($ctx1) {$ctx1.fill(self,"pass",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "resignal",
protocol: "signaling",
args: [],
source: "resignal\x0a\x09self deprecatedAPI: 'Use #pass.'.\x0a\x09^ self pass",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "pass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #pass.");
return $self._pass();
}, function($ctx1) {$ctx1.fill(self,"resignal",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signal",
protocol: "signaling",
args: [],
source: "signal\x0a\x09self beUnhandled; context: thisContext; basicSignal",
referencedClasses: [],
pragmas: [],
messageSends: ["beUnhandled", "context:", "basicSignal"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._beUnhandled();
$self._context_($core.getThisContext());
$self._basicSignal();
return self;
}, function($ctx1) {$ctx1.fill(self,"signal",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signal:",
protocol: "signaling",
args: ["aString"],
source: "signal: aString\x0a\x09self messageText: aString; signal",
referencedClasses: [],
pragmas: [],
messageSends: ["messageText:", "signal"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._messageText_(aString);
$self._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"signal:",{aString:aString})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signalerContext",
protocol: "accessing",
args: [],
source: "signalerContext\x0a\x09^ self signalerContextFrom: self context",
referencedClasses: [],
pragmas: [],
messageSends: ["signalerContextFrom:", "context"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._signalerContextFrom_($self._context());
}, function($ctx1) {$ctx1.fill(self,"signalerContext",{})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "signalerContextFrom:",
protocol: "accessing",
args: ["aContext"],
source: "signalerContextFrom: aContext\x0a\x09\x22Find the first sender of signal(:), the first context which is neither \x0a\x09for an instance method nor for a class side method of Exception (or subclass).\x0a\x09This will make sure that the same context is found for both, `Error signal` \x0a\x09and `Error new signal`\x22\x0a\x0a\x09^ aContext findContextSuchThat: [ :one |\x0a\x09\x09(one receiver == self \x0a\x09\x09or: [ one receiver == self class ]) not ]",
referencedClasses: [],
pragmas: [],
messageSends: ["findContextSuchThat:", "not", "or:", "==", "receiver", "class"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv(aContext)._findContextSuchThat_((function(one){
return $core.withContext(function($ctx2) {
if($core.assert([$recv([$recv(one)._receiver()
,$ctx2.sendIdx["receiver"]=1
][0]).__eq_eq(self)
,$ctx2.sendIdx["=="]=1
][0])){
$1=true;
} else {
$1=$recv($recv(one)._receiver()).__eq_eq($self._class());
}
return $recv($1)._not();
}, function($ctx2) {$ctx2.fillBlock({one:one},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"signalerContextFrom:",{aContext:aContext})});
}; }),
$globals.Error);

$core.addMethod(
$core.method({
selector: "wasHandled",
protocol: "testing",
args: [],
source: "wasHandled\x0a\x09^ amberHandled == true",
referencedClasses: [],
pragmas: [],
messageSends: ["=="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.amberHandled).__eq_eq(true);
}, function($ctx1) {$ctx1.fill(self,"wasHandled",{})});
}; }),
$globals.Error);


$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'exception'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "exception";

}; }),
$globals.Error.a$cls);

$core.addMethod(
$core.method({
selector: "signal",
protocol: "instance creation",
args: [],
source: "signal\x0a\x09^ self new signal",
referencedClasses: [],
pragmas: [],
messageSends: ["signal", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._signal();
}, function($ctx1) {$ctx1.fill(self,"signal",{})});
}; }),
$globals.Error.a$cls);

$core.addMethod(
$core.method({
selector: "signal:",
protocol: "instance creation",
args: ["aString"],
source: "signal: aString\x0a\x09^ self new\x0a\x09\x09signal: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["signal:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._signal_(aString);
}, function($ctx1) {$ctx1.fill(self,"signal:",{aString:aString})});
}; }),
$globals.Error.a$cls);


$core.addClass("Halt", $globals.Error, "Kernel-Exceptions");
$globals.Halt.comment="I am provided to support `Object>>#halt`.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09^ 'Halt encountered'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "Halt encountered";

}; }),
$globals.Halt);

$core.addMethod(
$core.method({
selector: "signalerContextFrom:",
protocol: "accessing",
args: ["aContext"],
source: "signalerContextFrom: aContext\x0a\x09\x22specialized version to find the proper context to open the debugger on.\x0a\x09This will find the first context whose method is no longer on `Halt` or \x0a\x09`Halt class` nor is `#halt` method itself.\x22\x0a\x09\x0a\x09^ aContext findContextSuchThat: [ :one |\x0a\x09\x09(one receiver == self \x0a\x09\x09or: [ (one receiver == self class) \x0a\x09\x09or: [ one method selector = #halt ]]) not ]",
referencedClasses: [],
pragmas: [],
messageSends: ["findContextSuchThat:", "not", "or:", "==", "receiver", "class", "=", "selector", "method"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv(aContext)._findContextSuchThat_((function(one){
return $core.withContext(function($ctx2) {
if($core.assert([$recv([$recv(one)._receiver()
,$ctx2.sendIdx["receiver"]=1
][0]).__eq_eq(self)
,$ctx2.sendIdx["=="]=1
][0])){
$1=true;
} else {
if($core.assert($recv($recv(one)._receiver()).__eq_eq($self._class()))){
$1=true;
} else {
$1=$recv($recv($recv(one)._method())._selector()).__eq("halt");
}
}
return $recv($1)._not();
}, function($ctx2) {$ctx2.fillBlock({one:one},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"signalerContextFrom:",{aContext:aContext})});
}; }),
$globals.Halt);



$core.addClass("JavaScriptException", $globals.Error, "Kernel-Exceptions");
$core.setSlots($globals.JavaScriptException, ["exception"]);
$globals.JavaScriptException.comment="A JavaScriptException is thrown when a non-Smalltalk exception occurs while in the Smalltalk stack.\x0aSee `boot.js` `inContext()` and `BlockClosure >> on:do:`";
$core.addMethod(
$core.method({
selector: "exception",
protocol: "accessing",
args: [],
source: "exception\x0a\x09^ exception",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.exception;

}; }),
$globals.JavaScriptException);

$core.addMethod(
$core.method({
selector: "exception:",
protocol: "accessing",
args: ["anException"],
source: "exception: anException\x0a\x09exception := anException",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anException){
var self=this,$self=this;
$self.exception=anException;
return self;

}; }),
$globals.JavaScriptException);

$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09<inlineJS: 'return \x22JavaScript exception: \x22 + $self.exception.toString()'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return \x22JavaScript exception: \x22 + $self.exception.toString()"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "JavaScript exception: " + $self.exception.toString();
return self;
}, function($ctx1) {$ctx1.fill(self,"messageText",{})});
}; }),
$globals.JavaScriptException);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["anException"],
source: "on: anException\x0a\x09^ self new\x0a\x09\x09exception: anException;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["exception:", "new", "yourself"]
}, function ($methodClass){ return function (anException){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._exception_(anException);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{anException:anException})});
}; }),
$globals.JavaScriptException.a$cls);

$core.addMethod(
$core.method({
selector: "on:context:",
protocol: "instance creation",
args: ["anException", "aMethodContext"],
source: "on: anException context: aMethodContext\x0a\x09^ self new\x0a\x09\x09exception: anException;\x0a\x09\x09context: aMethodContext;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["exception:", "new", "context:", "yourself"]
}, function ($methodClass){ return function (anException,aMethodContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._exception_(anException);
$recv($1)._context_(aMethodContext);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:context:",{anException:anException,aMethodContext:aMethodContext})});
}; }),
$globals.JavaScriptException.a$cls);


$core.addClass("MessageNotUnderstood", $globals.Error, "Kernel-Exceptions");
$core.setSlots($globals.MessageNotUnderstood, ["smalltalkMessage", "receiver"]);
$globals.MessageNotUnderstood.comment="This exception is provided to support `Object>>doesNotUnderstand:`.";
$core.addMethod(
$core.method({
selector: "message",
protocol: "accessing",
args: [],
source: "message\x0a\x09^ smalltalkMessage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.smalltalkMessage;

}; }),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "message:",
protocol: "accessing",
args: ["aMessage"],
source: "message: aMessage\x0a\x09smalltalkMessage := aMessage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aMessage){
var self=this,$self=this;
$self.smalltalkMessage=aMessage;
return self;

}; }),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09^ self receiver asString, ' does not understand #', self message selector",
referencedClasses: [],
pragmas: [],
messageSends: [",", "asString", "receiver", "selector", "message"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv($recv($recv($self._receiver())._asString()).__comma(" does not understand #")).__comma($recv($self._message())._selector())
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"messageText",{})});
}; }),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.MessageNotUnderstood);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: "accessing",
args: ["anObject"],
source: "receiver: anObject\x0a\x09receiver := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.receiver=anObject;
return self;

}; }),
$globals.MessageNotUnderstood);



$core.addClass("NonBooleanReceiver", $globals.Error, "Kernel-Exceptions");
$core.setSlots($globals.NonBooleanReceiver, ["object"]);
$globals.NonBooleanReceiver.comment="NonBooleanReceiver exceptions may be thrown when executing inlined methods such as `#ifTrue:` with a non boolean receiver.";
$core.addMethod(
$core.method({
selector: "object",
protocol: "accessing",
args: [],
source: "object\x0a\x09^ object",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.object;

}; }),
$globals.NonBooleanReceiver);

$core.addMethod(
$core.method({
selector: "object:",
protocol: "accessing",
args: ["anObject"],
source: "object: anObject\x0a\x09object := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.object=anObject;
return self;

}; }),
$globals.NonBooleanReceiver);


$core.addMethod(
$core.method({
selector: "signalOn:",
protocol: "instance creation",
args: ["anObject"],
source: "signalOn: anObject\x0a\x09^ self new\x0a\x09\x09object: anObject;\x0a\x09\x09signal",
referencedClasses: [],
pragmas: [],
messageSends: ["object:", "new", "signal"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._object_(anObject);
return $recv($1)._signal();
}, function($ctx1) {$ctx1.fill(self,"signalOn:",{anObject:anObject})});
}; }),
$globals.NonBooleanReceiver.a$cls);

});

define('amber/core/Kernel-Announcements',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Announcements");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AnnouncementSubscription", $globals.Object, "Kernel-Announcements");
$core.setSlots($globals.AnnouncementSubscription, ["valuable", "announcementClass"]);
$globals.AnnouncementSubscription.comment="I am a single entry in a subscription registry of an `Announcer`.\x0aSeveral subscriptions by the same object is possible.";
$core.addMethod(
$core.method({
selector: "announcementClass",
protocol: "accessing",
args: [],
source: "announcementClass\x0a\x09^ announcementClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.announcementClass;

}; }),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "announcementClass:",
protocol: "accessing",
args: ["aClass"],
source: "announcementClass: aClass\x0a\x09announcementClass := Smalltalk globals at: aClass name",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["at:", "globals", "name"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.announcementClass=$recv($recv($globals.Smalltalk)._globals())._at_($recv(aClass)._name());
return self;
}, function($ctx1) {$ctx1.fill(self,"announcementClass:",{aClass:aClass})});
}; }),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "deliver:",
protocol: "announcing",
args: ["anAnnouncement"],
source: "deliver: anAnnouncement\x0a\x09(self handlesAnnouncement: anAnnouncement)\x0a\x09\x09ifTrue: [ self valuable value: anAnnouncement ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "handlesAnnouncement:", "value:", "valuable"]
}, function ($methodClass){ return function (anAnnouncement){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._handlesAnnouncement_(anAnnouncement))){
$recv($self._valuable())._value_(anAnnouncement);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"deliver:",{anAnnouncement:anAnnouncement})});
}; }),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "handlesAnnouncement:",
protocol: "announcing",
args: ["anAnnouncement"],
source: "handlesAnnouncement: anAnnouncement\x0a\x09\x22anAnnouncement might be announced from within another Amber environment\x22\x0a\x09\x0a\x09^ (Smalltalk globals at: anAnnouncement class name) includesBehavior: self announcementClass",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["includesBehavior:", "at:", "globals", "name", "class", "announcementClass"]
}, function ($methodClass){ return function (anAnnouncement){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($globals.Smalltalk)._globals())._at_($recv($recv(anAnnouncement)._class())._name()))._includesBehavior_($self._announcementClass());
}, function($ctx1) {$ctx1.fill(self,"handlesAnnouncement:",{anAnnouncement:anAnnouncement})});
}; }),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ self valuable receiver",
referencedClasses: [],
pragmas: [],
messageSends: ["receiver", "valuable"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._valuable())._receiver();
}, function($ctx1) {$ctx1.fill(self,"receiver",{})});
}; }),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "valuable",
protocol: "accessing",
args: [],
source: "valuable\x0a\x09^ valuable",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.valuable;

}; }),
$globals.AnnouncementSubscription);

$core.addMethod(
$core.method({
selector: "valuable:",
protocol: "accessing",
args: ["aValuable"],
source: "valuable: aValuable\x0a\x09valuable := aValuable",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aValuable){
var self=this,$self=this;
$self.valuable=aValuable;
return self;

}; }),
$globals.AnnouncementSubscription);



$core.addClass("AnnouncementValuable", $globals.Object, "Kernel-Announcements");
$core.setSlots($globals.AnnouncementValuable, ["valuable", "receiver"]);
$globals.AnnouncementValuable.comment="I wrap `valuable` objects (typically instances of `BlockClosure`) with a `receiver` to be able to unregister subscriptions based on a `receiver`.";
$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: "accessing",
args: ["anObject"],
source: "receiver: anObject\x0a\x09receiver := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.receiver=anObject;
return self;

}; }),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "valuable",
protocol: "accessing",
args: [],
source: "valuable\x0a\x09^ valuable",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.valuable;

}; }),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "valuable:",
protocol: "accessing",
args: ["anObject"],
source: "valuable: anObject\x0a\x09valuable := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.valuable=anObject;
return self;

}; }),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "value",
protocol: "evaluating",
args: [],
source: "value\x0a\x09^ self valuable value",
referencedClasses: [],
pragmas: [],
messageSends: ["value", "valuable"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._valuable())._value();
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.AnnouncementValuable);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "evaluating",
args: ["anObject"],
source: "value: anObject\x0a\x09^ self valuable value: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["value:", "valuable"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._valuable())._value_(anObject);
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject})});
}; }),
$globals.AnnouncementValuable);



$core.addClass("Announcer", $globals.Object, "Kernel-Announcements");
$core.setSlots($globals.Announcer, ["registry", "subscriptions"]);
$globals.Announcer.comment="I hold annoncement subscriptions (instances of `AnnouncementSubscription`) in a private registry.\x0aI announce (trigger) announces, which are then dispatched to all subscriptions.\x0a\x0aThe code is based on the announcements as [described by Vassili Bykov](http://www.cincomsmalltalk.com/userblogs/vbykov/blogView?searchCategory=Announcements%20Framework).\x0a\x0a## API\x0a\x0aUse `#announce:` to trigger an announcement.\x0a\x0aUse `#on:do:` or `#on:send:to:` to register subscriptions.\x0a\x0aWhen using `#on:send:to:`, unregistration can be done with `#unregister:`.\x0a\x0a## Usage example:\x0a\x0a    SystemAnnouncer current\x0a        on: ClassAdded\x0a        do: [ :ann | window alert: ann theClass name, ' added' ].";
$core.addMethod(
$core.method({
selector: "announce:",
protocol: "announcing",
args: ["anAnnouncement"],
source: "announce: anAnnouncement\x0a\x09subscriptions do: [ :each |\x0a\x09\x09each deliver: anAnnouncement ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "deliver:"]
}, function ($methodClass){ return function (anAnnouncement){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.subscriptions)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._deliver_(anAnnouncement);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"announce:",{anAnnouncement:anAnnouncement})});
}; }),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09subscriptions := OrderedCollection new",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.subscriptions=$recv($globals.OrderedCollection)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:do:",
protocol: "subscribing",
args: ["aClass", "aBlock"],
source: "on: aClass do: aBlock\x0a\x09self on: aClass do: aBlock for: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["on:do:for:"]
}, function ($methodClass){ return function (aClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._on_do_for_(aClass,aBlock,nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"on:do:",{aClass:aClass,aBlock:aBlock})});
}; }),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:do:for:",
protocol: "subscribing",
args: ["aClass", "aBlock", "aReceiver"],
source: "on: aClass do: aBlock for: aReceiver\x0a\x09subscriptions add: (AnnouncementSubscription new\x0a\x09\x09valuable: (AnnouncementValuable new\x0a\x09\x09\x09valuable: aBlock;\x0a\x09\x09\x09receiver: aReceiver;\x0a\x09\x09\x09yourself);\x0a\x09\x09announcementClass: aClass;\x0a\x09\x09yourself)",
referencedClasses: ["AnnouncementSubscription", "AnnouncementValuable"],
pragmas: [],
messageSends: ["add:", "valuable:", "new", "receiver:", "yourself", "announcementClass:"]
}, function ($methodClass){ return function (aClass,aBlock,aReceiver){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=$self.subscriptions;
$2=[$recv($globals.AnnouncementSubscription)._new()
,$ctx1.sendIdx["new"]=1
][0];
$3=$recv($globals.AnnouncementValuable)._new();
$recv($3)._valuable_(aBlock);
$recv($3)._receiver_(aReceiver);
[$recv($2)._valuable_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0])
,$ctx1.sendIdx["valuable:"]=1
][0];
$recv($2)._announcementClass_(aClass);
$recv($1)._add_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"on:do:for:",{aClass:aClass,aBlock:aBlock,aReceiver:aReceiver})});
}; }),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:doOnce:",
protocol: "subscribing",
args: ["aClass", "aBlock"],
source: "on: aClass doOnce: aBlock\x0a\x09| subscription |\x0a\x09\x0a\x09subscription := AnnouncementSubscription new\x0a\x09\x09announcementClass: aClass;\x0a\x09\x09yourself.\x0a\x09subscription valuable: [ :ann |\x0a\x09\x09subscriptions remove: subscription.\x0a\x09\x09aBlock value: ann ].\x0a\x0a\x09subscriptions add: subscription",
referencedClasses: ["AnnouncementSubscription"],
pragmas: [],
messageSends: ["announcementClass:", "new", "yourself", "valuable:", "remove:", "value:", "add:"]
}, function ($methodClass){ return function (aClass,aBlock){
var self=this,$self=this;
var subscription;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.AnnouncementSubscription)._new();
$recv($1)._announcementClass_(aClass);
subscription=$recv($1)._yourself();
$recv(subscription)._valuable_((function(ann){
return $core.withContext(function($ctx2) {
$recv($self.subscriptions)._remove_(subscription);
return $recv(aBlock)._value_(ann);
}, function($ctx2) {$ctx2.fillBlock({ann:ann},$ctx1,1)});
}));
$recv($self.subscriptions)._add_(subscription);
return self;
}, function($ctx1) {$ctx1.fill(self,"on:doOnce:",{aClass:aClass,aBlock:aBlock,subscription:subscription})});
}; }),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "on:send:to:",
protocol: "subscribing",
args: ["aClass", "aSelector", "anObject"],
source: "on: aClass send: aSelector to: anObject\x0a\x09subscriptions add: (AnnouncementSubscription new\x0a\x09\x09valuable: (MessageSend new\x0a\x09\x09\x09receiver: anObject;\x0a\x09\x09\x09selector: aSelector;\x0a\x09\x09\x09yourself);\x0a\x09\x09announcementClass: aClass;\x0a\x09\x09yourself)",
referencedClasses: ["AnnouncementSubscription", "MessageSend"],
pragmas: [],
messageSends: ["add:", "valuable:", "new", "receiver:", "selector:", "yourself", "announcementClass:"]
}, function ($methodClass){ return function (aClass,aSelector,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=$self.subscriptions;
$2=[$recv($globals.AnnouncementSubscription)._new()
,$ctx1.sendIdx["new"]=1
][0];
$3=$recv($globals.MessageSend)._new();
$recv($3)._receiver_(anObject);
$recv($3)._selector_(aSelector);
$recv($2)._valuable_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]);
$recv($2)._announcementClass_(aClass);
$recv($1)._add_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"on:send:to:",{aClass:aClass,aSelector:aSelector,anObject:anObject})});
}; }),
$globals.Announcer);

$core.addMethod(
$core.method({
selector: "unsubscribe:",
protocol: "subscribing",
args: ["anObject"],
source: "unsubscribe: anObject\x0a\x09subscriptions := subscriptions reject: [ :each |\x0a\x09\x09each receiver = anObject ]",
referencedClasses: [],
pragmas: [],
messageSends: ["reject:", "=", "receiver"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.subscriptions=$recv($self.subscriptions)._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._receiver()).__eq(anObject);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"unsubscribe:",{anObject:anObject})});
}; }),
$globals.Announcer);



$core.addClass("SystemAnnouncer", $globals.Announcer, "Kernel-Announcements");
$globals.SystemAnnouncer.comment="My unique instance is the global announcer handling all Amber system-related announces.\x0a\x0a## API\x0a\x0aAccess to the unique instance is done via `#current`";

$core.setSlots($globals.SystemAnnouncer.a$cls, ["current"]);
$core.addMethod(
$core.method({
selector: "current",
protocol: "accessing",
args: [],
source: "current\x0a\x09^ current ifNil: [ current := super new ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.current;
if($1 == null || $1.a$nil){
$self.current=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._new.call($self))
,$ctx1.supercall = false
][0];
return $self.current;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"current",{})});
}; }),
$globals.SystemAnnouncer.a$cls);

$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldNotImplement"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.SystemAnnouncer.a$cls);


$core.addClass("SystemAnnouncement", $globals.Object, "Kernel-Announcements");
$globals.SystemAnnouncement.comment="I am the superclass of all system announcements";

$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'announcement'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "announcement";

}; }),
$globals.SystemAnnouncement.a$cls);


$core.addClass("ClassAnnouncement", $globals.SystemAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.ClassAnnouncement, ["theClass"]);
$globals.ClassAnnouncement.comment="I am the abstract superclass of class-related announcements.";
$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.ClassAnnouncement);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.theClass=aClass;
return self;

}; }),
$globals.ClassAnnouncement);



$core.addClass("ClassAdded", $globals.ClassAnnouncement, "Kernel-Announcements");
$globals.ClassAdded.comment="I am emitted when a class is added to the system.\x0aSee ClassBuilder >> #addSubclassOf:... methods";


$core.addClass("ClassCommentChanged", $globals.ClassAnnouncement, "Kernel-Announcements");
$globals.ClassCommentChanged.comment="I am emitted when the comment of a class changes. (Behavior >> #comment)";


$core.addClass("ClassDefinitionChanged", $globals.ClassAnnouncement, "Kernel-Announcements");
$globals.ClassDefinitionChanged.comment="I am emitted when the definition of a class changes.\x0aSee ClassBuilder >> #class:instanceVariableNames:";


$core.addClass("ClassMigrated", $globals.ClassAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.ClassMigrated, ["oldClass"]);
$globals.ClassMigrated.comment="I am emitted when a class is migrated.";
$core.addMethod(
$core.method({
selector: "oldClass",
protocol: "accessing",
args: [],
source: "oldClass\x0a\x09^ oldClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.oldClass;

}; }),
$globals.ClassMigrated);

$core.addMethod(
$core.method({
selector: "oldClass:",
protocol: "accessing",
args: ["aClass"],
source: "oldClass: aClass\x0a\x09oldClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.oldClass=aClass;
return self;

}; }),
$globals.ClassMigrated);



$core.addClass("ClassMoved", $globals.ClassAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.ClassMoved, ["oldPackage"]);
$globals.ClassMoved.comment="I am emitted when a class is moved from one package to another.";
$core.addMethod(
$core.method({
selector: "oldPackage",
protocol: "accessing",
args: [],
source: "oldPackage\x0a\x09^ oldPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.oldPackage;

}; }),
$globals.ClassMoved);

$core.addMethod(
$core.method({
selector: "oldPackage:",
protocol: "accessing",
args: ["aPackage"],
source: "oldPackage: aPackage\x0a\x09oldPackage := aPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
$self.oldPackage=aPackage;
return self;

}; }),
$globals.ClassMoved);



$core.addClass("ClassRemoved", $globals.ClassAnnouncement, "Kernel-Announcements");
$globals.ClassRemoved.comment="I am emitted when a class is removed.\x0aSee Smalltalk >> #removeClass:";


$core.addClass("ClassRenamed", $globals.ClassAnnouncement, "Kernel-Announcements");
$globals.ClassRenamed.comment="I am emitted when a class is renamed.\x0aSee ClassBuilder >> #renameClass:to:";


$core.addClass("MethodAnnouncement", $globals.SystemAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.MethodAnnouncement, ["method"]);
$globals.MethodAnnouncement.comment="I am the abstract superclass of method-related announcements.";
$core.addMethod(
$core.method({
selector: "method",
protocol: "accessing",
args: [],
source: "method\x0a\x09^ method",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.method;

}; }),
$globals.MethodAnnouncement);

$core.addMethod(
$core.method({
selector: "method:",
protocol: "accessing",
args: ["aCompiledMethod"],
source: "method: aCompiledMethod\x0a\x09method := aCompiledMethod",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCompiledMethod){
var self=this,$self=this;
$self.method=aCompiledMethod;
return self;

}; }),
$globals.MethodAnnouncement);



$core.addClass("MethodAdded", $globals.MethodAnnouncement, "Kernel-Announcements");
$globals.MethodAdded.comment="I am emitted when a `CompiledMethod` is added to a class.";


$core.addClass("MethodModified", $globals.MethodAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.MethodModified, ["oldMethod"]);
$globals.MethodModified.comment="I am emitted when a `CompiledMethod` is modified (a new method is installed). I hold a reference to the old method being replaced.";
$core.addMethod(
$core.method({
selector: "oldMethod",
protocol: "accessing",
args: [],
source: "oldMethod\x0a\x09^ oldMethod",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.oldMethod;

}; }),
$globals.MethodModified);

$core.addMethod(
$core.method({
selector: "oldMethod:",
protocol: "accessing",
args: ["aMethod"],
source: "oldMethod: aMethod\x0a\x09oldMethod := aMethod",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aMethod){
var self=this,$self=this;
$self.oldMethod=aMethod;
return self;

}; }),
$globals.MethodModified);



$core.addClass("MethodMoved", $globals.MethodAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.MethodMoved, ["oldProtocol"]);
$globals.MethodMoved.comment="I am emitted when a `CompiledMethod` is moved to another protocol. I hold a refernce to the old protocol of the method.";
$core.addMethod(
$core.method({
selector: "oldProtocol",
protocol: "accessing",
args: [],
source: "oldProtocol\x0a\x09^ oldProtocol",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.oldProtocol;

}; }),
$globals.MethodMoved);

$core.addMethod(
$core.method({
selector: "oldProtocol:",
protocol: "accessing",
args: ["aString"],
source: "oldProtocol: aString\x0a\x09oldProtocol := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.oldProtocol=aString;
return self;

}; }),
$globals.MethodMoved);



$core.addClass("MethodRemoved", $globals.MethodAnnouncement, "Kernel-Announcements");
$globals.MethodRemoved.comment="I am emitted when a `CompiledMethod` is removed from a class.";


$core.addClass("PackageAnnouncement", $globals.SystemAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.PackageAnnouncement, ["package"]);
$globals.PackageAnnouncement.comment="I am the abstract superclass of package-related announcements.";
$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09^ package",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.package;

}; }),
$globals.PackageAnnouncement);

$core.addMethod(
$core.method({
selector: "package:",
protocol: "accessing",
args: ["aPackage"],
source: "package: aPackage\x0a\x09package := aPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
$self.package=aPackage;
return self;

}; }),
$globals.PackageAnnouncement);



$core.addClass("PackageAdded", $globals.PackageAnnouncement, "Kernel-Announcements");
$globals.PackageAdded.comment="I am emitted when a `Package` is added to the system.";


$core.addClass("PackageClean", $globals.PackageAnnouncement, "Kernel-Announcements");
$globals.PackageClean.comment="I am emitted when a package is committed and becomes clean.";


$core.addClass("PackageDirty", $globals.PackageAnnouncement, "Kernel-Announcements");
$globals.PackageDirty.comment="I am emitted when a package becomes dirty.";


$core.addClass("PackageRemoved", $globals.PackageAnnouncement, "Kernel-Announcements");
$globals.PackageRemoved.comment="I am emitted when a `Package` is removed from the system.";


$core.addClass("ProtocolAnnouncement", $globals.SystemAnnouncement, "Kernel-Announcements");
$core.setSlots($globals.ProtocolAnnouncement, ["theClass", "protocol"]);
$globals.ProtocolAnnouncement.comment="I am the abstract superclass of protocol-related announcements.";
$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09\x0a\x09^ self theClass ifNotNil: [ :class | class packageOfProtocol: self protocol ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "theClass", "packageOfProtocol:", "protocol"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._theClass();
if($1 == null || $1.a$nil){
return $1;
} else {
var class_;
class_=$1;
return $recv(class_)._packageOfProtocol_($self._protocol());
}
}, function($ctx1) {$ctx1.fill(self,"package",{})});
}; }),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "protocol",
protocol: "accessing",
args: [],
source: "protocol\x0a\x09^ protocol",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.protocol;

}; }),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "protocol:",
protocol: "accessing",
args: ["aString"],
source: "protocol: aString\x0a\x09protocol := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.protocol=aString;
return self;

}; }),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.ProtocolAnnouncement);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.theClass=aClass;
return self;

}; }),
$globals.ProtocolAnnouncement);



$core.addClass("ProtocolAdded", $globals.ProtocolAnnouncement, "Kernel-Announcements");
$globals.ProtocolAdded.comment="I am emitted when a protocol is added to a class.";


$core.addClass("ProtocolRemoved", $globals.ProtocolAnnouncement, "Kernel-Announcements");
$globals.ProtocolRemoved.comment="I am emitted when a protocol is removed from a class.";

});

define('amber/core/Platform-Services',["amber/boot", "require", "amber/core/Kernel-Collections", "amber/core/Kernel-Infrastructure", "amber/core/Kernel-Methods", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Platform-Services");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ConsoleErrorHandler", $globals.Object, "Platform-Services");
$globals.ConsoleErrorHandler.comment="I am manage Smalltalk errors, displaying the stack in the console.";
$core.addMethod(
$core.method({
selector: "handleError:",
protocol: "error handling",
args: ["anError"],
source: "handleError: anError\x0a\x09anError context ifNotNil: [ self logErrorContext: anError context ].\x0a\x09self logError: anError",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "context", "logErrorContext:", "logError:"]
}, function ($methodClass){ return function (anError){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$recv(anError)._context()
,$ctx1.sendIdx["context"]=1
][0];
if($1 == null || $1.a$nil){
$1;
} else {
$self._logErrorContext_($recv(anError)._context());
}
$self._logError_(anError);
return self;
}, function($ctx1) {$ctx1.fill(self,"handleError:",{anError:anError})});
}; }),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "log:",
protocol: "private",
args: ["aString"],
source: "log: aString\x0a\x09console log: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["log:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"log:",{aString:aString})});
}; }),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "logContext:",
protocol: "private",
args: ["aContext"],
source: "logContext: aContext\x0a\x09aContext home ifNotNil: [\x0a\x09\x09self logContext: aContext home ].\x0a\x09self log: aContext asString",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "home", "logContext:", "log:", "asString"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$recv(aContext)._home()
,$ctx1.sendIdx["home"]=1
][0];
if($1 == null || $1.a$nil){
$1;
} else {
$self._logContext_($recv(aContext)._home());
}
$self._log_($recv(aContext)._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"logContext:",{aContext:aContext})});
}; }),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "logError:",
protocol: "private",
args: ["anError"],
source: "logError: anError\x0a\x09self log: anError messageText",
referencedClasses: [],
pragmas: [],
messageSends: ["log:", "messageText"]
}, function ($methodClass){ return function (anError){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._log_($recv(anError)._messageText());
return self;
}, function($ctx1) {$ctx1.fill(self,"logError:",{anError:anError})});
}; }),
$globals.ConsoleErrorHandler);

$core.addMethod(
$core.method({
selector: "logErrorContext:",
protocol: "private",
args: ["aContext"],
source: "logErrorContext: aContext\x0a\x09aContext ifNotNil: [\x0a\x09\x09aContext home ifNotNil: [\x0a\x09\x09\x09self logContext: aContext home ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "home", "logContext:"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if(aContext == null || aContext.a$nil){
aContext;
} else {
$1=[$recv(aContext)._home()
,$ctx1.sendIdx["home"]=1
][0];
if($1 == null || $1.a$nil){
$1;
} else {
$self._logContext_($recv(aContext)._home());
}
}
return self;
}, function($ctx1) {$ctx1.fill(self,"logErrorContext:",{aContext:aContext})});
}; }),
$globals.ConsoleErrorHandler);


$core.setSlots($globals.ConsoleErrorHandler.a$cls, ["current"]);
$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09ErrorHandler registerIfNone: self new",
referencedClasses: ["ErrorHandler"],
pragmas: [],
messageSends: ["registerIfNone:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ErrorHandler)._registerIfNone_($self._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.ConsoleErrorHandler.a$cls);


$core.addClass("ConsoleTranscript", $globals.Object, "Platform-Services");
$core.setSlots($globals.ConsoleTranscript, ["textarea"]);
$globals.ConsoleTranscript.comment="I am a specific transcript emitting to the JavaScript console.\x0a\x0aIf no other transcript is registered, I am the default.";
$core.addMethod(
$core.method({
selector: "clear",
protocol: "printing",
args: [],
source: "clear\x0a\x09\x22no op\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.ConsoleTranscript);

$core.addMethod(
$core.method({
selector: "cr",
protocol: "printing",
args: [],
source: "cr\x0a\x09\x22no op\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.ConsoleTranscript);

$core.addMethod(
$core.method({
selector: "open",
protocol: "actions",
args: [],
source: "open",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.ConsoleTranscript);

$core.addMethod(
$core.method({
selector: "show:",
protocol: "printing",
args: ["anObject"],
source: "show: anObject\x0a\x22Smalltalk objects should have no trouble displaying themselves on the Transcript; Javascript objects don't know how, so must be wrapped in a JSObectProxy.\x22\x0a<inlineJS: 'console.log(String($recv(anObject)._asString()))'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["console.log(String($recv(anObject)._asString()))"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
console.log(String($recv(anObject)._asString()));
return self;
}, function($ctx1) {$ctx1.fill(self,"show:",{anObject:anObject})});
}; }),
$globals.ConsoleTranscript);


$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09Transcript registerIfNone: self new",
referencedClasses: ["Transcript"],
pragmas: [],
messageSends: ["registerIfNone:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._registerIfNone_($self._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.ConsoleTranscript.a$cls);


$core.addClass("Environment", $globals.Object, "Platform-Services");
$globals.Environment.comment="I provide an unified entry point to manipulate Amber packages, classes and methods.\x0a\x0aTypical use cases include IDEs, remote access and restricting browsing.";
$core.addMethod(
$core.method({
selector: "addInstVarNamed:to:",
protocol: "compiling",
args: ["aString", "aClass"],
source: "addInstVarNamed: aString to: aClass\x0a\x09| newSlots |\x0a\x09newSlots := aClass slots copyWith: aString.\x0a\x0a\x09aClass isMetaclass\x0a\x09\x09ifTrue: [ self classBuilder\x0a\x09\x09\x09class: aClass slots: newSlots ]\x0a\x09\x09ifFalse: [ self classBuilder\x0a\x09\x09\x09addSubclassOf: aClass superclass \x0a\x09\x09\x09named: aClass name \x0a\x09\x09\x09slots: newSlots\x0a\x09\x09\x09package: aClass package name ]",
referencedClasses: [],
pragmas: [],
messageSends: ["copyWith:", "slots", "ifTrue:ifFalse:", "isMetaclass", "class:slots:", "classBuilder", "addSubclassOf:named:slots:package:", "superclass", "name", "package"]
}, function ($methodClass){ return function (aString,aClass){
var self=this,$self=this;
var newSlots;
return $core.withContext(function($ctx1) {
newSlots=$recv($recv(aClass)._slots())._copyWith_(aString);
if($core.assert($recv(aClass)._isMetaclass())){
$recv([$self._classBuilder()
,$ctx1.sendIdx["classBuilder"]=1
][0])._class_slots_(aClass,newSlots);
} else {
$recv($self._classBuilder())._addSubclassOf_named_slots_package_($recv(aClass)._superclass(),[$recv(aClass)._name()
,$ctx1.sendIdx["name"]=1
][0],newSlots,$recv($recv(aClass)._package())._name());
}
return self;
}, function($ctx1) {$ctx1.fill(self,"addInstVarNamed:to:",{aString:aString,aClass:aClass,newSlots:newSlots})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "allSelectors",
protocol: "accessing",
args: [],
source: "allSelectors\x0a\x09^ Smalltalk core allSelectors",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["allSelectors", "core"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._core())._allSelectors();
}, function($ctx1) {$ctx1.fill(self,"allSelectors",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "availableClassNames",
protocol: "accessing",
args: [],
source: "availableClassNames\x0a\x09^ Smalltalk classes \x0a\x09\x09collect: [ :each | each name ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["collect:", "classes", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._classes())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._name();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"availableClassNames",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "availablePackageNames",
protocol: "accessing",
args: [],
source: "availablePackageNames\x0a\x09^ Smalltalk packages \x0a\x09\x09collect: [ :each | each name ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["collect:", "packages", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Smalltalk)._packages())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._name();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"availablePackageNames",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "availableProtocolsFor:",
protocol: "accessing",
args: ["aClass"],
source: "availableProtocolsFor: aClass\x0a\x09| protocols |\x0a\x09\x0a\x09protocols := aClass protocols.\x0a\x09aClass superclass ifNotNil: [ protocols addAll: (self availableProtocolsFor: aClass superclass) ].\x0a\x09^ protocols asSet asArray sort",
referencedClasses: [],
pragmas: [],
messageSends: ["protocols", "ifNotNil:", "superclass", "addAll:", "availableProtocolsFor:", "sort", "asArray", "asSet"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
var protocols;
return $core.withContext(function($ctx1) {
var $1;
protocols=$recv(aClass)._protocols();
$1=[$recv(aClass)._superclass()
,$ctx1.sendIdx["superclass"]=1
][0];
if($1 == null || $1.a$nil){
$1;
} else {
$recv(protocols)._addAll_($self._availableProtocolsFor_($recv(aClass)._superclass()));
}
return $recv($recv($recv(protocols)._asSet())._asArray())._sort();
}, function($ctx1) {$ctx1.fill(self,"availableProtocolsFor:",{aClass:aClass,protocols:protocols})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "classBuilder",
protocol: "accessing",
args: [],
source: "classBuilder\x0a\x09^ ClassBuilder new",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.ClassBuilder)._new();
}, function($ctx1) {$ctx1.fill(self,"classBuilder",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "classNamed:",
protocol: "accessing",
args: ["aString"],
source: "classNamed: aString\x0a\x09^ (Smalltalk globals at: aString asSymbol)\x0a\x09\x09ifNil: [ self error: 'Invalid class name' ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["ifNil:", "at:", "globals", "asSymbol", "error:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv($globals.Smalltalk)._globals())._at_($recv(aString)._asSymbol());
if($1 == null || $1.a$nil){
return $self._error_("Invalid class name");
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"classNamed:",{aString:aString})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "classes",
protocol: "accessing",
args: [],
source: "classes\x0a\x09^ Smalltalk classes",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["classes"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._classes();
}, function($ctx1) {$ctx1.fill(self,"classes",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "commitPackage:onSuccess:onError:",
protocol: "actions",
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commitPackage: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09aPackage transport\x0a\x09\x09commitOnSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["commitOnSuccess:onError:", "transport"]
}, function ($methodClass){ return function (aPackage,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._transport())._commitOnSuccess_onError_(aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitPackage:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "compileClassComment:for:",
protocol: "compiling",
args: ["aString", "aClass"],
source: "compileClassComment: aString for: aClass\x0a\x09aClass comment: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["comment:"]
}, function ($methodClass){ return function (aString,aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aClass)._comment_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"compileClassComment:for:",{aString:aString,aClass:aClass})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "compileClassDefinition:",
protocol: "compiling",
args: ["aString"],
source: "compileClassDefinition: aString\x0a\x09[ self evaluate: aString for: DoIt new ]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :error | Terminal alert: error messageText ]",
referencedClasses: ["DoIt", "Error", "Terminal"],
pragmas: [],
messageSends: ["on:do:", "evaluate:for:", "new", "alert:", "messageText"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._evaluate_for_(aString,$recv($globals.DoIt)._new());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(error){
return $core.withContext(function($ctx2) {
return $recv($globals.Terminal)._alert_($recv(error)._messageText());
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"compileClassDefinition:",{aString:aString})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "compileMethod:for:protocol:",
protocol: "compiling",
args: ["sourceCode", "class", "protocol"],
source: "compileMethod: sourceCode for: class protocol: protocol\x0a\x09^ class\x0a\x09\x09compile: sourceCode\x0a\x09\x09protocol: protocol",
referencedClasses: [],
pragmas: [],
messageSends: ["compile:protocol:"]
}, function ($methodClass){ return function (sourceCode,class_,protocol){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(class_)._compile_protocol_(sourceCode,protocol);
}, function($ctx1) {$ctx1.fill(self,"compileMethod:for:protocol:",{sourceCode:sourceCode,class_:class_,protocol:protocol})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "copyClass:to:",
protocol: "actions",
args: ["aClass", "aClassName"],
source: "copyClass: aClass to: aClassName\x0a\x09(Smalltalk globals at: aClassName)\x0a\x09\x09ifNotNil: [ self error: 'A class named ', aClassName, ' already exists' ].\x0a\x09\x09\x0a\x09ClassBuilder new copyClass: aClass named: aClassName",
referencedClasses: ["Smalltalk", "ClassBuilder"],
pragmas: [],
messageSends: ["ifNotNil:", "at:", "globals", "error:", ",", "copyClass:named:", "new"]
}, function ($methodClass){ return function (aClass,aClassName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv($globals.Smalltalk)._globals())._at_(aClassName);
if($1 == null || $1.a$nil){
$1;
} else {
$self._error_([$recv("A class named ".__comma(aClassName)).__comma(" already exists")
,$ctx1.sendIdx[","]=1
][0]);
}
$recv($recv($globals.ClassBuilder)._new())._copyClass_named_(aClass,aClassName);
return self;
}, function($ctx1) {$ctx1.fill(self,"copyClass:to:",{aClass:aClass,aClassName:aClassName})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "doItReceiver",
protocol: "accessing",
args: [],
source: "doItReceiver\x0a\x09^ DoIt new",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.DoIt)._new();
}, function($ctx1) {$ctx1.fill(self,"doItReceiver",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "evaluate:for:",
protocol: "evaluating",
args: ["aString", "anObject"],
source: "evaluate: aString for: anObject\x0a\x09^ Evaluator evaluate: aString for: anObject",
referencedClasses: ["Evaluator"],
pragmas: [],
messageSends: ["evaluate:for:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Evaluator)._evaluate_for_(aString,anObject);
}, function($ctx1) {$ctx1.fill(self,"evaluate:for:",{aString:aString,anObject:anObject})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "evaluate:on:do:",
protocol: "error handling",
args: ["aBlock", "anErrorClass", "exceptionBlock"],
source: "evaluate: aBlock on: anErrorClass do: exceptionBlock\x0a\x09\x22Evaluate a block and catch exceptions happening on the environment stack\x22\x0a\x09\x0a\x09^ aBlock on: (self classNamed: anErrorClass name) do: exceptionBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["on:do:", "classNamed:", "name"]
}, function ($methodClass){ return function (aBlock,anErrorClass,exceptionBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aBlock)._on_do_($self._classNamed_($recv(anErrorClass)._name()),exceptionBlock);
}, function($ctx1) {$ctx1.fill(self,"evaluate:on:do:",{aBlock:aBlock,anErrorClass:anErrorClass,exceptionBlock:exceptionBlock})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "inspect:",
protocol: "actions",
args: ["anObject"],
source: "inspect: anObject\x0a\x09Inspector inspect: anObject",
referencedClasses: ["Inspector"],
pragmas: [],
messageSends: ["inspect:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Inspector)._inspect_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspect:",{anObject:anObject})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "moveClass:toPackage:",
protocol: "actions",
args: ["aClass", "aPackageName"],
source: "moveClass: aClass toPackage: aPackageName\x0a\x09| package |\x0a\x09\x0a\x09package := Package named: aPackageName.\x0a\x09package ifNil: [ self error: 'Invalid package name' ].\x0a\x09package == aClass package ifTrue: [ ^ self ].\x0a\x09\x0a\x09aClass package: package.\x0a\x09aClass recompile",
referencedClasses: ["Package"],
pragmas: [],
messageSends: ["named:", "ifNil:", "error:", "ifTrue:", "==", "package", "package:", "recompile"]
}, function ($methodClass){ return function (aClass,aPackageName){
var self=this,$self=this;
var package_;
return $core.withContext(function($ctx1) {
var $1;
package_=$recv($globals.Package)._named_(aPackageName);
$1=package_;
if($1 == null || $1.a$nil){
$self._error_("Invalid package name");
} else {
$1;
}
if($core.assert($recv(package_).__eq_eq($recv(aClass)._package()))){
return self;
}
$recv(aClass)._package_(package_);
$recv(aClass)._recompile();
return self;
}, function($ctx1) {$ctx1.fill(self,"moveClass:toPackage:",{aClass:aClass,aPackageName:aPackageName,package_:package_})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "moveMethod:toClass:",
protocol: "actions",
args: ["aMethod", "aClassName"],
source: "moveMethod: aMethod toClass: aClassName\x0a\x09| destinationClass |\x0a\x09\x0a\x09destinationClass := self classNamed: aClassName.\x0a\x09destinationClass == aMethod origin ifTrue: [ ^ self ].\x0a\x09\x0a\x09aMethod origin isMetaclass ifTrue: [ \x0a\x09\x09destinationClass := destinationClass theMetaClass ].\x0a\x09\x0a\x09destinationClass \x0a\x09\x09compile: aMethod source\x0a\x09\x09protocol: aMethod protocol.\x0a\x09aMethod origin \x0a\x09\x09removeCompiledMethod: aMethod",
referencedClasses: [],
pragmas: [],
messageSends: ["classNamed:", "ifTrue:", "==", "origin", "isMetaclass", "theMetaClass", "compile:protocol:", "source", "protocol", "removeCompiledMethod:"]
}, function ($methodClass){ return function (aMethod,aClassName){
var self=this,$self=this;
var destinationClass;
return $core.withContext(function($ctx1) {
destinationClass=$self._classNamed_(aClassName);
if($core.assert($recv(destinationClass).__eq_eq([$recv(aMethod)._origin()
,$ctx1.sendIdx["origin"]=1
][0]))){
return self;
}
if($core.assert($recv([$recv(aMethod)._origin()
,$ctx1.sendIdx["origin"]=2
][0])._isMetaclass())){
destinationClass=$recv(destinationClass)._theMetaClass();
destinationClass;
}
$recv(destinationClass)._compile_protocol_($recv(aMethod)._source(),$recv(aMethod)._protocol());
$recv($recv(aMethod)._origin())._removeCompiledMethod_(aMethod);
return self;
}, function($ctx1) {$ctx1.fill(self,"moveMethod:toClass:",{aMethod:aMethod,aClassName:aClassName,destinationClass:destinationClass})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "moveMethod:toProtocol:",
protocol: "actions",
args: ["aMethod", "aProtocol"],
source: "moveMethod: aMethod toProtocol: aProtocol\x0a\x09aMethod protocol: aProtocol.\x0a\x0a\x09aMethod origin\x0a\x09\x09compile: aMethod source\x0a\x09\x09protocol: aMethod protocol",
referencedClasses: [],
pragmas: [],
messageSends: ["protocol:", "compile:protocol:", "origin", "source", "protocol"]
}, function ($methodClass){ return function (aMethod,aProtocol){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aMethod)._protocol_(aProtocol);
$recv($recv(aMethod)._origin())._compile_protocol_($recv(aMethod)._source(),$recv(aMethod)._protocol());
return self;
}, function($ctx1) {$ctx1.fill(self,"moveMethod:toProtocol:",{aMethod:aMethod,aProtocol:aProtocol})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "packages",
protocol: "accessing",
args: [],
source: "packages\x0a\x09^ Smalltalk packages",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["packages"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._packages();
}, function($ctx1) {$ctx1.fill(self,"packages",{})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerErrorHandler:",
protocol: "services",
args: ["anErrorHandler"],
source: "registerErrorHandler: anErrorHandler\x0a\x09ErrorHandler register: anErrorHandler",
referencedClasses: ["ErrorHandler"],
pragmas: [],
messageSends: ["register:"]
}, function ($methodClass){ return function (anErrorHandler){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ErrorHandler)._register_(anErrorHandler);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerErrorHandler:",{anErrorHandler:anErrorHandler})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerFinder:",
protocol: "services",
args: ["aFinder"],
source: "registerFinder: aFinder\x0a\x09Finder register: aFinder",
referencedClasses: ["Finder"],
pragmas: [],
messageSends: ["register:"]
}, function ($methodClass){ return function (aFinder){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Finder)._register_(aFinder);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerFinder:",{aFinder:aFinder})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerInspector:",
protocol: "services",
args: ["anInspector"],
source: "registerInspector: anInspector\x0a\x09Inspector register: anInspector",
referencedClasses: ["Inspector"],
pragmas: [],
messageSends: ["register:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Inspector)._register_(anInspector);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerInspector:",{anInspector:anInspector})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerProgressHandler:",
protocol: "services",
args: ["aProgressHandler"],
source: "registerProgressHandler: aProgressHandler\x0a\x09ProgressHandler register: aProgressHandler",
referencedClasses: ["ProgressHandler"],
pragmas: [],
messageSends: ["register:"]
}, function ($methodClass){ return function (aProgressHandler){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ProgressHandler)._register_(aProgressHandler);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerProgressHandler:",{aProgressHandler:aProgressHandler})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "registerTranscript:",
protocol: "services",
args: ["aTranscript"],
source: "registerTranscript: aTranscript\x0a\x09Transcript register: aTranscript",
referencedClasses: ["Transcript"],
pragmas: [],
messageSends: ["register:"]
}, function ($methodClass){ return function (aTranscript){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._register_(aTranscript);
return self;
}, function($ctx1) {$ctx1.fill(self,"registerTranscript:",{aTranscript:aTranscript})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "removeClass:",
protocol: "actions",
args: ["aClass"],
source: "removeClass: aClass\x0a\x09Smalltalk removeClass: aClass",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["removeClass:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Smalltalk)._removeClass_(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeClass:",{aClass:aClass})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "removeMethod:",
protocol: "actions",
args: ["aMethod"],
source: "removeMethod: aMethod\x0a\x09aMethod origin removeCompiledMethod: aMethod",
referencedClasses: [],
pragmas: [],
messageSends: ["removeCompiledMethod:", "origin"]
}, function ($methodClass){ return function (aMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aMethod)._origin())._removeCompiledMethod_(aMethod);
return self;
}, function($ctx1) {$ctx1.fill(self,"removeMethod:",{aMethod:aMethod})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "removeProtocol:from:",
protocol: "actions",
args: ["aString", "aClass"],
source: "removeProtocol: aString from: aClass\x0a\x09(aClass methodsInProtocol: aString)\x0a\x09\x09do: [ :each | aClass removeCompiledMethod: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "methodsInProtocol:", "removeCompiledMethod:"]
}, function ($methodClass){ return function (aString,aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aClass)._methodsInProtocol_(aString))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(aClass)._removeCompiledMethod_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeProtocol:from:",{aString:aString,aClass:aClass})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "renameClass:to:",
protocol: "actions",
args: ["aClass", "aClassName"],
source: "renameClass: aClass to: aClassName\x0a\x09(Smalltalk globals at: aClassName)\x0a\x09\x09ifNotNil: [ self error: 'A class named ', aClassName, ' already exists' ].\x0a\x09\x09\x0a\x09ClassBuilder new renameClass: aClass to: aClassName",
referencedClasses: ["Smalltalk", "ClassBuilder"],
pragmas: [],
messageSends: ["ifNotNil:", "at:", "globals", "error:", ",", "renameClass:to:", "new"]
}, function ($methodClass){ return function (aClass,aClassName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($recv($globals.Smalltalk)._globals())._at_(aClassName);
if($1 == null || $1.a$nil){
$1;
} else {
$self._error_([$recv("A class named ".__comma(aClassName)).__comma(" already exists")
,$ctx1.sendIdx[","]=1
][0]);
}
$recv($recv($globals.ClassBuilder)._new())._renameClass_to_(aClass,aClassName);
return self;
}, function($ctx1) {$ctx1.fill(self,"renameClass:to:",{aClass:aClass,aClassName:aClassName})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "renamePackage:to:",
protocol: "actions",
args: ["aPackageName", "aNewPackageName"],
source: "renamePackage: aPackageName to: aNewPackageName\x0a        Smalltalk renamePackage: aPackageName to: aNewPackageName",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["renamePackage:to:"]
}, function ($methodClass){ return function (aPackageName,aNewPackageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Smalltalk)._renamePackage_to_(aPackageName,aNewPackageName);
return self;
}, function($ctx1) {$ctx1.fill(self,"renamePackage:to:",{aPackageName:aPackageName,aNewPackageName:aNewPackageName})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "renameProtocol:to:in:",
protocol: "actions",
args: ["aString", "anotherString", "aClass"],
source: "renameProtocol: aString to: anotherString in: aClass\x0a\x09(aClass methodsInProtocol: aString)\x0a\x09\x09do: [ :each | each protocol: anotherString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "methodsInProtocol:", "protocol:"]
}, function ($methodClass){ return function (aString,anotherString,aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aClass)._methodsInProtocol_(aString))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._protocol_(anotherString);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"renameProtocol:to:in:",{aString:aString,anotherString:anotherString,aClass:aClass})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "setClassCommentOf:to:",
protocol: "actions",
args: ["aClass", "aString"],
source: "setClassCommentOf: aClass to: aString\x0a\x09aClass comment: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["comment:"]
}, function ($methodClass){ return function (aClass,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aClass)._comment_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"setClassCommentOf:to:",{aClass:aClass,aString:aString})});
}; }),
$globals.Environment);

$core.addMethod(
$core.method({
selector: "systemAnnouncer",
protocol: "accessing",
args: [],
source: "systemAnnouncer\x0a\x09^ (Smalltalk globals at: #SystemAnnouncer) current",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["current", "at:", "globals"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($globals.Smalltalk)._globals())._at_("SystemAnnouncer"))._current();
}, function($ctx1) {$ctx1.fill(self,"systemAnnouncer",{})});
}; }),
$globals.Environment);



$core.addClass("NullProgressHandler", $globals.Object, "Platform-Services");
$globals.NullProgressHandler.comment="I am the default progress handler. I do not display any progress, and simply iterate over the collection.";
$core.addMethod(
$core.method({
selector: "do:on:displaying:",
protocol: "progress handling",
args: ["aBlock", "aCollection", "aString"],
source: "do: aBlock on: aCollection displaying: aString\x0a\x09aCollection do: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["do:"]
}, function ($methodClass){ return function (aBlock,aCollection,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_(aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:on:displaying:",{aBlock:aBlock,aCollection:aCollection,aString:aString})});
}; }),
$globals.NullProgressHandler);


$core.setSlots($globals.NullProgressHandler.a$cls, ["current"]);
$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09ProgressHandler registerIfNone: self new",
referencedClasses: ["ProgressHandler"],
pragmas: [],
messageSends: ["registerIfNone:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ProgressHandler)._registerIfNone_($self._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.NullProgressHandler.a$cls);


$core.addClass("Service", $globals.Object, "Platform-Services");
$globals.Service.comment="I implement the basic behavior for class registration to a service.\x0a\x0aSee the `Transcript` class for a concrete service.\x0a\x0a## API\x0a\x0aUse class-side methods `#register:` and `#registerIfNone:` to register classes to a specific service.";

$core.setSlots($globals.Service.a$cls, ["current"]);
$core.addMethod(
$core.method({
selector: "current",
protocol: "accessing",
args: [],
source: "current\x0a\x09^ current",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.current;

}; }),
$globals.Service.a$cls);

$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldNotImplement"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.Service.a$cls);

$core.addMethod(
$core.method({
selector: "register:",
protocol: "registration",
args: ["anObject"],
source: "register: anObject\x0a\x09current := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.current=anObject;
return self;

}; }),
$globals.Service.a$cls);

$core.addMethod(
$core.method({
selector: "registerIfNone:",
protocol: "registration",
args: ["anObject"],
source: "registerIfNone: anObject\x0a\x09self current ifNil: [ self register: anObject ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "current", "register:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._current();
if($1 == null || $1.a$nil){
$self._register_(anObject);
} else {
$1;
}
return self;
}, function($ctx1) {$ctx1.fill(self,"registerIfNone:",{anObject:anObject})});
}; }),
$globals.Service.a$cls);


$core.addClass("ErrorHandler", $globals.Service, "Platform-Services");
$globals.ErrorHandler.comment="I am the service used to handle Smalltalk errors.\x0aSee `boot.js` `handleError()` function.\x0a\x0aRegistered service instances must implement `#handleError:` to perform an action on the thrown exception.";

$core.addMethod(
$core.method({
selector: "handleError:",
protocol: "error handling",
args: ["anError"],
source: "handleError: anError\x0a\x09| smalltalkError |\x0a\x09smalltalkError := Smalltalk asSmalltalkException: anError.\x0a\x09smalltalkError context ifNil: [ smalltalkError context: thisContext ].\x0a\x09self handleUnhandledError: smalltalkError",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["asSmalltalkException:", "ifNil:", "context", "context:", "handleUnhandledError:"]
}, function ($methodClass){ return function (anError){
var self=this,$self=this;
var smalltalkError;
return $core.withContext(function($ctx1) {
var $1;
smalltalkError=$recv($globals.Smalltalk)._asSmalltalkException_(anError);
$1=$recv(smalltalkError)._context();
if($1 == null || $1.a$nil){
$recv(smalltalkError)._context_($core.getThisContext());
} else {
$1;
}
$self._handleUnhandledError_(smalltalkError);
return self;
}, function($ctx1) {$ctx1.fill(self,"handleError:",{anError:anError,smalltalkError:smalltalkError})});
}; }),
$globals.ErrorHandler.a$cls);

$core.addMethod(
$core.method({
selector: "handleUnhandledError:",
protocol: "error handling",
args: ["anError"],
source: "handleUnhandledError: anError\x0a\x09anError wasHandled ifFalse: [\x0a\x09\x09self current handleError: anError.\x0a\x09\x09anError beHandled ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "wasHandled", "handleError:", "current", "beHandled"]
}, function ($methodClass){ return function (anError){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(anError)._wasHandled())){
$recv($self._current())._handleError_(anError);
$recv(anError)._beHandled();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"handleUnhandledError:",{anError:anError})});
}; }),
$globals.ErrorHandler.a$cls);


$core.addClass("Finder", $globals.Service, "Platform-Services");
$globals.Finder.comment="I am the service responsible for finding classes/methods.\x0a__There is no default finder.__\x0a\x0a## API\x0a\x0aUse `#browse` on an object to find it.";

$core.addMethod(
$core.method({
selector: "findClass:",
protocol: "finding",
args: ["aClass"],
source: "findClass: aClass\x0a\x09^ self current findClass: aClass",
referencedClasses: [],
pragmas: [],
messageSends: ["findClass:", "current"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._findClass_(aClass);
}, function($ctx1) {$ctx1.fill(self,"findClass:",{aClass:aClass})});
}; }),
$globals.Finder.a$cls);

$core.addMethod(
$core.method({
selector: "findMethod:",
protocol: "finding",
args: ["aCompiledMethod"],
source: "findMethod: aCompiledMethod\x0a\x09^ self current findMethod: aCompiledMethod",
referencedClasses: [],
pragmas: [],
messageSends: ["findMethod:", "current"]
}, function ($methodClass){ return function (aCompiledMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._findMethod_(aCompiledMethod);
}, function($ctx1) {$ctx1.fill(self,"findMethod:",{aCompiledMethod:aCompiledMethod})});
}; }),
$globals.Finder.a$cls);

$core.addMethod(
$core.method({
selector: "findString:",
protocol: "finding",
args: ["aString"],
source: "findString: aString\x0a\x09^ self current findString: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["findString:", "current"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._findString_(aString);
}, function($ctx1) {$ctx1.fill(self,"findString:",{aString:aString})});
}; }),
$globals.Finder.a$cls);


$core.addClass("Inspector", $globals.Service, "Platform-Services");
$globals.Inspector.comment="I am the service responsible for inspecting objects.\x0a\x0aThe default inspector object is the transcript.";

$core.addMethod(
$core.method({
selector: "inspect:",
protocol: "inspecting",
args: ["anObject"],
source: "inspect: anObject\x0a\x09^ self current inspect: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["inspect:", "current"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._inspect_(anObject);
}, function($ctx1) {$ctx1.fill(self,"inspect:",{anObject:anObject})});
}; }),
$globals.Inspector.a$cls);


$core.addClass("Platform", $globals.Service, "Platform-Services");
$globals.Platform.comment="I am bridge to JS environment.\x0a\x0a## API\x0a\x0a    Platform globals. \x22JS global object\x22\x0a    Platform newXHR \x22new XMLHttpRequest() or its shim\x22";

$core.addMethod(
$core.method({
selector: "fetch:",
protocol: "accessing",
args: ["aStringOrObject"],
source: "fetch: aStringOrObject\x0a\x09^ self current fetch: aStringOrObject",
referencedClasses: [],
pragmas: [],
messageSends: ["fetch:", "current"]
}, function ($methodClass){ return function (aStringOrObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._fetch_(aStringOrObject);
}, function($ctx1) {$ctx1.fill(self,"fetch:",{aStringOrObject:aStringOrObject})});
}; }),
$globals.Platform.a$cls);

$core.addMethod(
$core.method({
selector: "fetchUrl:options:",
protocol: "accessing",
args: ["aString", "anObject"],
source: "fetchUrl: aString options: anObject\x0a\x09^ self current fetchUrl: aString options: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["fetchUrl:options:", "current"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._fetchUrl_options_(aString,anObject);
}, function($ctx1) {$ctx1.fill(self,"fetchUrl:options:",{aString:aString,anObject:anObject})});
}; }),
$globals.Platform.a$cls);

$core.addMethod(
$core.method({
selector: "globals",
protocol: "accessing",
args: [],
source: "globals\x0a\x09^ self current globals",
referencedClasses: [],
pragmas: [],
messageSends: ["globals", "current"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._globals();
}, function($ctx1) {$ctx1.fill(self,"globals",{})});
}; }),
$globals.Platform.a$cls);

$core.addMethod(
$core.method({
selector: "includesGlobal:",
protocol: "testing",
args: ["aString"],
source: "includesGlobal: aString\x0a\x09^ self globals \x0a\x09\x09at: aString \x0a\x09\x09ifPresent: [ true ] \x0a\x09\x09ifAbsent: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:", "globals"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._globals())._at_ifPresent_ifAbsent_(aString,(function(){
return true;

}),(function(){
return false;

}));
}, function($ctx1) {$ctx1.fill(self,"includesGlobal:",{aString:aString})});
}; }),
$globals.Platform.a$cls);

$core.addMethod(
$core.method({
selector: "newXhr",
protocol: "accessing",
args: [],
source: "newXhr\x0a\x09^ self current newXhr",
referencedClasses: [],
pragmas: [],
messageSends: ["newXhr", "current"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._newXhr();
}, function($ctx1) {$ctx1.fill(self,"newXhr",{})});
}; }),
$globals.Platform.a$cls);


$core.addClass("ProgressHandler", $globals.Service, "Platform-Services");
$globals.ProgressHandler.comment="I am used to manage progress in collection iterations, see `SequenceableCollection >> #do:displayingProgress:`.\x0a\x0aRegistered instances must implement `#do:on:displaying:`.\x0a\x0aThe default behavior is to simply iterate over the collection, using `NullProgressHandler`.";

$core.addMethod(
$core.method({
selector: "do:on:displaying:",
protocol: "progress handling",
args: ["aBlock", "aCollection", "aString"],
source: "do: aBlock on: aCollection displaying: aString\x0a\x09self current do: aBlock on: aCollection displaying: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["do:on:displaying:", "current"]
}, function ($methodClass){ return function (aBlock,aCollection,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._current())._do_on_displaying_(aBlock,aCollection,aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:on:displaying:",{aBlock:aBlock,aCollection:aCollection,aString:aString})});
}; }),
$globals.ProgressHandler.a$cls);


$core.addClass("Terminal", $globals.Service, "Platform-Services");
$globals.Terminal.comment="I am UI interface service.\x0a\x0a## API\x0a\x0a    Terminal alert: 'Hey, there is a problem'.\x0a    Terminal confirm: 'Affirmative?'.\x0a    Terminal prompt: 'Your name:'.";

$core.addMethod(
$core.method({
selector: "alert:",
protocol: "dialogs",
args: ["aString"],
source: "alert: aString\x0a\x09^ self current alert: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["alert:", "current"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._alert_(aString);
}, function($ctx1) {$ctx1.fill(self,"alert:",{aString:aString})});
}; }),
$globals.Terminal.a$cls);

$core.addMethod(
$core.method({
selector: "confirm:",
protocol: "dialogs",
args: ["aString"],
source: "confirm: aString\x0a\x09^ self current confirm: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["confirm:", "current"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._confirm_(aString);
}, function($ctx1) {$ctx1.fill(self,"confirm:",{aString:aString})});
}; }),
$globals.Terminal.a$cls);

$core.addMethod(
$core.method({
selector: "prompt:",
protocol: "dialogs",
args: ["aString"],
source: "prompt: aString\x0a\x09^ self current prompt: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["prompt:", "current"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._prompt_(aString);
}, function($ctx1) {$ctx1.fill(self,"prompt:",{aString:aString})});
}; }),
$globals.Terminal.a$cls);

$core.addMethod(
$core.method({
selector: "prompt:default:",
protocol: "dialogs",
args: ["aString", "defaultString"],
source: "prompt: aString default: defaultString\x0a\x09^ self current prompt: aString default: defaultString",
referencedClasses: [],
pragmas: [],
messageSends: ["prompt:default:", "current"]
}, function ($methodClass){ return function (aString,defaultString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._current())._prompt_default_(aString,defaultString);
}, function($ctx1) {$ctx1.fill(self,"prompt:default:",{aString:aString,defaultString:defaultString})});
}; }),
$globals.Terminal.a$cls);


$core.addClass("Transcript", $globals.Service, "Platform-Services");
$globals.Transcript.comment="I am a facade for Transcript actions.\x0a\x0aI delegate actions to the currently registered transcript.\x0a\x0a## API\x0a\x0a    Transcript \x0a        show: 'hello world';\x0a        cr;\x0a        show: anObject.";

$core.addMethod(
$core.method({
selector: "clear",
protocol: "printing",
args: [],
source: "clear\x0a\x09self current clear",
referencedClasses: [],
pragmas: [],
messageSends: ["clear", "current"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._current())._clear();
return self;
}, function($ctx1) {$ctx1.fill(self,"clear",{})});
}; }),
$globals.Transcript.a$cls);

$core.addMethod(
$core.method({
selector: "cr",
protocol: "printing",
args: [],
source: "cr\x0a\x09self current show: String cr",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["show:", "current", "cr"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._current())._show_($recv($globals.String)._cr());
return self;
}, function($ctx1) {$ctx1.fill(self,"cr",{})});
}; }),
$globals.Transcript.a$cls);

$core.addMethod(
$core.method({
selector: "inspect:",
protocol: "printing",
args: ["anObject"],
source: "inspect: anObject\x0a\x09self show: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["show:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._show_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspect:",{anObject:anObject})});
}; }),
$globals.Transcript.a$cls);

$core.addMethod(
$core.method({
selector: "open",
protocol: "instance creation",
args: [],
source: "open\x0a\x09self current open",
referencedClasses: [],
pragmas: [],
messageSends: ["open", "current"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._current())._open();
return self;
}, function($ctx1) {$ctx1.fill(self,"open",{})});
}; }),
$globals.Transcript.a$cls);

$core.addMethod(
$core.method({
selector: "show:",
protocol: "printing",
args: ["anObject"],
source: "show: anObject\x0a\x09self current show: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["show:", "current"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._current())._show_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"show:",{anObject:anObject})});
}; }),
$globals.Transcript.a$cls);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPut: '#self' -> self;\x0a\x09\x09\x09nextPut: '#keys' -> self keys;\x0a\x09\x09\x09nextPutAll: self associations ].\x0a\x09anInspector\x0a\x09\x09setLabel: self shortenedPrintString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "keys", "nextPutAll:", "associations", "setLabel:", "shortenedPrintString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._nextPut_(["#self".__minus_gt(self)
,$ctx2.sendIdx["->"]=1
][0])
,$ctx2.sendIdx["nextPut:"]=1
][0];
$recv(stream)._nextPut_("#keys".__minus_gt($self._keys()));
return $recv(stream)._nextPutAll_($self._associations());
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._shortenedPrintString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.AssociativeCollection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09| i |\x0a\x09\x09stream nextPut: '#self' -> self.\x0a\x09\x09i := 1.\x0a\x09\x09self do: [ :each |\x0a\x09\x09\x09stream nextPut: i -> each.\x0a\x09\x09\x09i := i + 1 ] ].\x0a\x09anInspector\x0a\x09\x09setLabel: self shortenedPrintString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "do:", "+", "setLabel:", "shortenedPrintString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
var i;
return $core.withContext(function($ctx2) {
[$recv(stream)._nextPut_(["#self".__minus_gt(self)
,$ctx2.sendIdx["->"]=1
][0])
,$ctx2.sendIdx["nextPut:"]=1
][0];
i=(1);
return $self._do_((function(each){
return $core.withContext(function($ctx3) {
$recv(stream)._nextPut_($recv(i).__minus_gt(each));
i=$recv(i).__plus((1));
return i;
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({stream:stream,i:i},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._shortenedPrintString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPut: '#self' -> self;\x0a\x09\x09\x09nextPut: '#year' -> self year;\x0a\x09\x09\x09nextPut: '#month' -> self month;\x0a\x09\x09\x09nextPut: '#day' -> self day;\x0a\x09\x09\x09nextPut: '#hours' -> self hours;\x0a\x09\x09\x09nextPut: '#minutes' -> self minutes;\x0a\x09\x09\x09nextPut: '#seconds' -> self seconds;\x0a\x09\x09\x09nextPut: '#milliseconds' -> self milliseconds ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "setLabel:", "printString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._nextPut_(["#self".__minus_gt(self)
,$ctx2.sendIdx["->"]=1
][0])
,$ctx2.sendIdx["nextPut:"]=1
][0];
[$recv(stream)._nextPut_(["#year".__minus_gt($self._year())
,$ctx2.sendIdx["->"]=2
][0])
,$ctx2.sendIdx["nextPut:"]=2
][0];
[$recv(stream)._nextPut_(["#month".__minus_gt($self._month())
,$ctx2.sendIdx["->"]=3
][0])
,$ctx2.sendIdx["nextPut:"]=3
][0];
[$recv(stream)._nextPut_(["#day".__minus_gt($self._day())
,$ctx2.sendIdx["->"]=4
][0])
,$ctx2.sendIdx["nextPut:"]=4
][0];
[$recv(stream)._nextPut_(["#hours".__minus_gt($self._hours())
,$ctx2.sendIdx["->"]=5
][0])
,$ctx2.sendIdx["nextPut:"]=5
][0];
[$recv(stream)._nextPut_(["#minutes".__minus_gt($self._minutes())
,$ctx2.sendIdx["->"]=6
][0])
,$ctx2.sendIdx["nextPut:"]=6
][0];
[$recv(stream)._nextPut_(["#seconds".__minus_gt($self._seconds())
,$ctx2.sendIdx["->"]=7
][0])
,$ctx2.sendIdx["nextPut:"]=7
][0];
return $recv(stream)._nextPut_("#milliseconds".__minus_gt($self._milliseconds()));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.Date);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPut: '#self' -> self jsObject;\x0a\x09\x09\x09nextPutAll: (JSObjectProxy associationsOfProxy: self) ].\x0a\x09anInspector setLabel: self printString.\x0a\x09anInspector setVariables: variables",
referencedClasses: ["Array", "JSObjectProxy"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "jsObject", "nextPutAll:", "associationsOfProxy:", "setLabel:", "printString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._nextPut_("#self".__minus_gt($self._jsObject()));
return $recv(stream)._nextPutAll_($recv($globals.JSObjectProxy)._associationsOfProxy_(self));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09stream nextPut: '#self' -> self.\x0a\x09\x09self class allInstanceVariableNames do: [ :each |\x0a\x09\x09\x09stream nextPut: each -> (self instVarNamed: each) ] ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "do:", "allInstanceVariableNames", "class", "instVarNamed:", "setLabel:", "printString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._nextPut_(["#self".__minus_gt(self)
,$ctx2.sendIdx["->"]=1
][0])
,$ctx2.sendIdx["nextPut:"]=1
][0];
return $recv($recv($self._class())._allInstanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPut_($recv(each).__minus_gt($self._instVarNamed_(each)));
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.Object);

$core.addMethod(
$core.method({
selector: "do:displayingProgress:",
protocol: "*Platform-Services",
args: ["aBlock", "aString"],
source: "do: aBlock displayingProgress: aString\x0a\x09ProgressHandler \x0a\x09\x09do: aBlock \x0a\x09\x09on: self \x0a\x09\x09displaying: aString",
referencedClasses: ["ProgressHandler"],
pragmas: [],
messageSends: ["do:on:displaying:"]
}, function ($methodClass){ return function (aBlock,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ProgressHandler)._do_on_displaying_(aBlock,self,aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"do:displayingProgress:",{aBlock:aBlock,aString:aString})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09stream nextPut: '#self' -> self.\x0a\x09\x09self withIndexDo: [ :each :i |\x0a\x09\x09\x09stream nextPut: i -> each ] ].\x0a\x09anInspector\x0a\x09\x09setLabel: self shortenedPrintString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "withIndexDo:", "setLabel:", "shortenedPrintString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._nextPut_(["#self".__minus_gt(self)
,$ctx2.sendIdx["->"]=1
][0])
,$ctx2.sendIdx["nextPut:"]=1
][0];
return $self._withIndexDo_((function(each,i){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPut_($recv(i).__minus_gt(each));
}, function($ctx3) {$ctx3.fillBlock({each:each,i:i},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._shortenedPrintString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.SequenceableCollection);

$core.addMethod(
$core.method({
selector: "inspectOn:",
protocol: "*Platform-Services",
args: ["anInspector"],
source: "inspectOn: anInspector\x0a\x09| variables |\x0a\x09variables := Array streamContents: [ :stream |\x0a\x09\x09stream\x0a\x09\x09\x09nextPut: '#self' -> self;\x0a\x09\x09\x09nextPut: '#home' -> self home;\x0a\x09\x09\x09nextPut: '#receiver' -> self receiver;\x0a\x09\x09\x09nextPut: '#selector' -> self selector;\x0a\x09\x09\x09nextPut: '#locals' -> self locals.\x0a\x09self class instanceVariableNames do: [ :each |\x0a\x09\x09stream nextPut: each -> (self instVarNamed: each) ] ].\x0a\x09anInspector\x0a\x09\x09setLabel: self printString;\x0a\x09\x09setVariables: variables",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["streamContents:", "nextPut:", "->", "home", "receiver", "selector", "locals", "do:", "instanceVariableNames", "class", "instVarNamed:", "setLabel:", "printString", "setVariables:"]
}, function ($methodClass){ return function (anInspector){
var self=this,$self=this;
var variables;
return $core.withContext(function($ctx1) {
variables=$recv($globals.Array)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
[$recv(stream)._nextPut_(["#self".__minus_gt(self)
,$ctx2.sendIdx["->"]=1
][0])
,$ctx2.sendIdx["nextPut:"]=1
][0];
[$recv(stream)._nextPut_(["#home".__minus_gt($self._home())
,$ctx2.sendIdx["->"]=2
][0])
,$ctx2.sendIdx["nextPut:"]=2
][0];
[$recv(stream)._nextPut_(["#receiver".__minus_gt($self._receiver())
,$ctx2.sendIdx["->"]=3
][0])
,$ctx2.sendIdx["nextPut:"]=3
][0];
[$recv(stream)._nextPut_(["#selector".__minus_gt($self._selector())
,$ctx2.sendIdx["->"]=4
][0])
,$ctx2.sendIdx["nextPut:"]=4
][0];
[$recv(stream)._nextPut_(["#locals".__minus_gt($self._locals())
,$ctx2.sendIdx["->"]=5
][0])
,$ctx2.sendIdx["nextPut:"]=5
][0];
return $recv($recv($self._class())._instanceVariableNames())._do_((function(each){
return $core.withContext(function($ctx3) {
return $recv(stream)._nextPut_($recv(each).__minus_gt($self._instVarNamed_(each)));
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
$recv(anInspector)._setLabel_($self._printString());
$recv(anInspector)._setVariables_(variables);
return self;
}, function($ctx1) {$ctx1.fill(self,"inspectOn:",{anInspector:anInspector,variables:variables})});
}; }),
$globals.TMethodContext);

});

define('amber/deploy',[
    './helpers',
    './boot', // pre-fetch, dep of ./helpers
    // --- packages of the core Amber begin here ---
    'amber/core/Kernel-Helpers',
    'amber/core/Kernel-Objects',
    'amber/core/Kernel-Classes',
    'amber/core/Kernel-Methods',
    'amber/core/Kernel-Collections',
    'amber/core/Kernel-Dag',
    'amber/core/Kernel-Infrastructure',
    'amber/core/Kernel-Promises',
    'amber/core/Kernel-Exceptions',
    'amber/core/Kernel-Announcements',
    'amber/core/Platform-Services',
    // --- packages of the core Amber end here ---
], function (amber) {
    return amber;
});

/*
 * Generated by PEG.js 0.10.0.
 *
 * http://pegjs.org/
 */
define('amber/parser',["./boot"], function(__boot) {
  "use strict";

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function peg$SyntaxError(message, expected, found, location) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.location = location;
    this.name     = "SyntaxError";

    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(this, peg$SyntaxError);
    }
  }

  peg$subclass(peg$SyntaxError, Error);

  peg$SyntaxError.buildMessage = function(expected, found) {
    var DESCRIBE_EXPECTATION_FNS = {
          literal: function(expectation) {
            return "\"" + literalEscape(expectation.text) + "\"";
          },

          "class": function(expectation) {
            var escapedParts = "",
                i;

            for (i = 0; i < expectation.parts.length; i++) {
              escapedParts += expectation.parts[i] instanceof Array
                ? classEscape(expectation.parts[i][0]) + "-" + classEscape(expectation.parts[i][1])
                : classEscape(expectation.parts[i]);
            }

            return "[" + (expectation.inverted ? "^" : "") + escapedParts + "]";
          },

          any: function(expectation) {
            return "any character";
          },

          end: function(expectation) {
            return "end of input";
          },

          other: function(expectation) {
            return expectation.description;
          }
        };

    function hex(ch) {
      return ch.charCodeAt(0).toString(16).toUpperCase();
    }

    function literalEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/"/g,  '\\"')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function classEscape(s) {
      return s
        .replace(/\\/g, '\\\\')
        .replace(/\]/g, '\\]')
        .replace(/\^/g, '\\^')
        .replace(/-/g,  '\\-')
        .replace(/\0/g, '\\0')
        .replace(/\t/g, '\\t')
        .replace(/\n/g, '\\n')
        .replace(/\r/g, '\\r')
        .replace(/[\x00-\x0F]/g,          function(ch) { return '\\x0' + hex(ch); })
        .replace(/[\x10-\x1F\x7F-\x9F]/g, function(ch) { return '\\x'  + hex(ch); });
    }

    function describeExpectation(expectation) {
      return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);
    }

    function describeExpected(expected) {
      var descriptions = new Array(expected.length),
          i, j;

      for (i = 0; i < expected.length; i++) {
        descriptions[i] = describeExpectation(expected[i]);
      }

      descriptions.sort();

      if (descriptions.length > 0) {
        for (i = 1, j = 1; i < descriptions.length; i++) {
          if (descriptions[i - 1] !== descriptions[i]) {
            descriptions[j] = descriptions[i];
            j++;
          }
        }
        descriptions.length = j;
      }

      switch (descriptions.length) {
        case 1:
          return descriptions[0];

        case 2:
          return descriptions[0] + " or " + descriptions[1];

        default:
          return descriptions.slice(0, -1).join(", ")
            + ", or "
            + descriptions[descriptions.length - 1];
      }
    }

    function describeFound(found) {
      return found ? "\"" + literalEscape(found) + "\"" : "end of input";
    }

    return "Expected " + describeExpected(expected) + " but " + describeFound(found) + " found.";
  };

  function peg$parse(input, options) {
    options = options !== void 0 ? options : {};

    var peg$FAILED = {},

        peg$startRuleFunctions = { start: peg$parsestart },
        peg$startRuleFunction  = peg$parsestart,

        peg$c0 = /^[ \t\x0B\f\xA0\u1680\u2000-\u200A\u202F\u205F\u3000\uFEFF\n\r\u2028\u2029]/,
        peg$c1 = peg$classExpectation([" ", "\t", "\x0B", "\f", "\xA0", "\u1680", ["\u2000", "\u200A"], "\u202F", "\u205F", "\u3000", "\uFEFF", "\n", "\r", "\u2028", "\u2029"], false, false),
        peg$c2 = "\"",
        peg$c3 = peg$literalExpectation("\"", false),
        peg$c4 = /^[^"]/,
        peg$c5 = peg$classExpectation(["\""], true, false),
        peg$c6 = ".",
        peg$c7 = peg$literalExpectation(".", false),
        peg$c8 = /^[a-zA-Z]/,
        peg$c9 = peg$classExpectation([["a", "z"], ["A", "Z"]], false, false),
        peg$c10 = /^[a-zA-Z0-9]/,
        peg$c11 = peg$classExpectation([["a", "z"], ["A", "Z"], ["0", "9"]], false, false),
        peg$c12 = ":",
        peg$c13 = peg$literalExpectation(":", false),
        peg$c14 = /^[A-Z]/,
        peg$c15 = peg$classExpectation([["A", "Z"]], false, false),
        peg$c16 = function(val) {
        	return newNode($globals.ValueNode)._value_(val);
        },
        peg$c17 = "'",
        peg$c18 = peg$literalExpectation("'", false),
        peg$c19 = "''",
        peg$c20 = peg$literalExpectation("''", false),
        peg$c21 = function() {return '\'';},
        peg$c22 = /^[^']/,
        peg$c23 = peg$classExpectation(["'"], true, false),
        peg$c24 = function(val) {return val.join('');},
        peg$c25 = "$",
        peg$c26 = peg$literalExpectation("$", false),
        peg$c27 = peg$anyExpectation(),
        peg$c28 = function(char) {
        	return newNode($globals.ValueNode)._value_(char);
        },
        peg$c29 = "#",
        peg$c30 = peg$literalExpectation("#", false),
        peg$c31 = function(rest) {return rest;},
        peg$c32 = "e",
        peg$c33 = peg$literalExpectation("e", false),
        peg$c34 = function(n) {return parseFloat(n);},
        peg$c35 = "-",
        peg$c36 = peg$literalExpectation("-", false),
        peg$c37 = "16r",
        peg$c38 = peg$literalExpectation("16r", false),
        peg$c39 = /^[0-9a-fA-F]/,
        peg$c40 = peg$classExpectation([["0", "9"], ["a", "f"], ["A", "F"]], false, false),
        peg$c41 = function(neg, num) {
        	return parseInt(((neg || '') + num), 16);
        },
        peg$c42 = /^[0-9]/,
        peg$c43 = peg$classExpectation([["0", "9"]], false, false),
        peg$c44 = function(n) {return parseFloat(n, 10);},
        peg$c45 = function(n) {return parseInt(n, 10);},
        peg$c46 = "#(",
        peg$c47 = peg$literalExpectation("#(", false),
        peg$c48 = ")",
        peg$c49 = peg$literalExpectation(")", false),
        peg$c50 = function(rest) {
        	return newNode($globals.ValueNode)._value_(rest);
        },
        peg$c51 = "(",
        peg$c52 = peg$literalExpectation("(", false),
        peg$c53 = function(lit) {return lit._value();},
        peg$c54 = "{",
        peg$c55 = peg$literalExpectation("{", false),
        peg$c56 = "}",
        peg$c57 = peg$literalExpectation("}", false),
        peg$c58 = function(expressions) {
        	return newNode($globals.DynamicArrayNode)._dagChildren_(expressions || []);
        },
        peg$c59 = "#{",
        peg$c60 = peg$literalExpectation("#{", false),
        peg$c61 = function(expressions) {
        	return newNode($globals.DynamicDictionaryNode)._dagChildren_(expressions || []);
        },
        peg$c62 = "true",
        peg$c63 = peg$literalExpectation("true", false),
        peg$c64 = function() {return true;},
        peg$c65 = "false",
        peg$c66 = peg$literalExpectation("false", false),
        peg$c67 = function() {return false;},
        peg$c68 = "nil",
        peg$c69 = peg$literalExpectation("nil", false),
        peg$c70 = function() {return null;},
        peg$c71 = function(identifier) {
        	return newNode($globals.VariableNode)._identifier_(identifier);
        },
        peg$c72 = /^[\\+*\/=><,@%~|&\-]/,
        peg$c73 = peg$classExpectation(["\\", "+", "*", "/", "=", ">", "<", ",", "@", "%", "~", "|", "&", "-"], false, false),
        peg$c74 = function(key, arg) {return {key:key, arg:arg};},
        peg$c75 = function(pairs) {
        		var selector = '';
        		var params = [];
        		for(var i = 0; i < pairs.length; i++) {
        			selector += pairs[i].key;
        			params.push(pairs[i].arg);
        		}
        		return [selector, params];
        	},
        peg$c76 = function(selector, arg) {
        	return [selector, [arg]];
        },
        peg$c77 = function(selector) {return [selector, []];},
        peg$c78 = function(expression) {
        	return expression;
        },
        peg$c79 = function(first, others) {
        	return [first].concat(others);
        },
        peg$c80 = function(selector) {
        	return $globals.Message._selector_arguments_(selector, []);
        },
        peg$c81 = function(pairs) {
        		var selector = '';
        		var args = [];
        		for(var i = 0; i < pairs.length; i++) {
        			selector += pairs[i].key;
        			args.push(pairs[i].arg._value());
        		}
        		return $globals.Message._selector_arguments_(selector, args)
        	},
        peg$c82 = "<",
        peg$c83 = peg$literalExpectation("<", false),
        peg$c84 = ">",
        peg$c85 = peg$literalExpectation(">", false),
        peg$c86 = function(message) {return message;},
        peg$c87 = ":=",
        peg$c88 = peg$literalExpectation(":=", false),
        peg$c89 = function(variable, expression) {
        	return newNode($globals.AssignmentNode)._left_(variable)._right_(expression);
        },
        peg$c90 = "^",
        peg$c91 = peg$literalExpectation("^", false),
        peg$c92 = function(expression) {
        	return newNode($globals.ReturnNode)._expression_(expression);
        },
        peg$c93 = "|",
        peg$c94 = peg$literalExpectation("|", false),
        peg$c95 = function(variable) {return variable;},
        peg$c96 = function(vars) {
        	return vars;
        },
        peg$c97 = function(param) {return param;},
        peg$c98 = function(params) {
        		return params;
        	},
        peg$c99 = function(ret) {return [ret];},
        peg$c100 = function(exps, ret) {
        		var expressions = exps;
        		expressions.push(ret);
        		return expressions;
        	},
        peg$c101 = function(expressions) {return expressions || [];},
        peg$c102 = "[",
        peg$c103 = peg$literalExpectation("[", false),
        peg$c104 = "]",
        peg$c105 = peg$literalExpectation("]", false),
        peg$c106 = function(params, temps, statements) {
        	return newNode($globals.BlockNode)
        		._parameters_(params || [])
        		._sequenceNode_(newSequenceNode($globals.BlockSequenceNode, temps, statements));
        },
        peg$c107 = function(selector) {
        	return newNode($globals.SendNode)._selector_(selector);
        },
        peg$c108 = function(receiver, tail) {
        	return receiver._withTail_(tail);
        },
        peg$c109 = function(selector, arg) {
        	return newNode($globals.SendNode)._selector_(selector)._arguments_([arg]);
        },
        peg$c110 = function(unarys, binarys) { return unarys.concat(binarys); },
        peg$c111 = function(pairs) {
        		var selector = '';
        		var args = [];
        		for(var i = 0; i < pairs.length; i++) {
        			selector += pairs[i].key;
        			args.push(pairs[i].arg);
        		}
        		return newNode($globals.SendNode)._selector_(selector)._arguments_(args);
        	},
        peg$c112 = function(binarys, final) {
        	if (final) binarys.push(final);
        	return binarys;
        },
        peg$c113 = function(receiver, tail) {return tail.length > 0;},
        peg$c114 = ";",
        peg$c115 = peg$literalExpectation(";", false),
        peg$c116 = function(receiver, tail, mess) {return mess;},
        peg$c117 = function(receiver, tail, messages) {
        		messages.unshift(receiver._withTail_(tail));
        		return newNode($globals.CascadeNode)._dagChildren_(messages);
        	},
        peg$c118 = function(pattern, aPragmas, temps, zPragmas, statements) {
        		return newNode($globals.MethodNode)
        			._selector_(pattern[0])
        			._arguments_(pattern[1])
        			._pragmas_((aPragmas || []).concat(zPragmas || []))
        			._sequenceNode_(newSequenceNode($globals.SequenceNode, temps, statements));
        	},
        peg$c119 = function(receiver, tail) { return tail.length > 0 && tail[tail.length-1]._selector() === '->' },
        peg$c120 = function(receiver, tail) {
        	    var last = tail.pop();
        		return [receiver._withTail_(tail), last._arguments()[0]];
        	},
        peg$c121 = function(first, others) {
        	return first.concat.apply(first, others);
        },

        peg$currPos          = 0,
        peg$savedPos         = 0,
        peg$posDetailsCache  = [{ line: 1, column: 1 }],
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$resultsCache = {},

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$savedPos, peg$currPos);
    }

    function location() {
      return peg$computeLocation(peg$savedPos, peg$currPos);
    }

    function expected(description, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildStructuredError(
        [peg$otherExpectation(description)],
        input.substring(peg$savedPos, peg$currPos),
        location
      );
    }

    function error(message, location) {
      location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)

      throw peg$buildSimpleError(message, location);
    }

    function peg$literalExpectation(text, ignoreCase) {
      return { type: "literal", text: text, ignoreCase: ignoreCase };
    }

    function peg$classExpectation(parts, inverted, ignoreCase) {
      return { type: "class", parts: parts, inverted: inverted, ignoreCase: ignoreCase };
    }

    function peg$anyExpectation() {
      return { type: "any" };
    }

    function peg$endExpectation() {
      return { type: "end" };
    }

    function peg$otherExpectation(description) {
      return { type: "other", description: description };
    }

    function peg$computePosDetails(pos) {
      var details = peg$posDetailsCache[pos], p;

      if (details) {
        return details;
      } else {
        p = pos - 1;
        while (!peg$posDetailsCache[p]) {
          p--;
        }

        details = peg$posDetailsCache[p];
        details = {
          line:   details.line,
          column: details.column
        };

        while (p < pos) {
          if (input.charCodeAt(p) === 10) {
            details.line++;
            details.column = 1;
          } else {
            details.column++;
          }

          p++;
        }

        peg$posDetailsCache[pos] = details;
        return details;
      }
    }

    function peg$computeLocation(startPos, endPos) {
      var startPosDetails = peg$computePosDetails(startPos),
          endPosDetails   = peg$computePosDetails(endPos);

      return {
        start: {
          offset: startPos,
          line:   startPosDetails.line,
          column: startPosDetails.column
        },
        end: {
          offset: endPos,
          line:   endPosDetails.line,
          column: endPosDetails.column
        }
      };
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildSimpleError(message, location) {
      return new peg$SyntaxError(message, null, null, location);
    }

    function peg$buildStructuredError(expected, found, location) {
      return new peg$SyntaxError(
        peg$SyntaxError.buildMessage(expected, found),
        expected,
        found,
        location
      );
    }

    function peg$parsestart() {
      var s0;

      var key    = peg$currPos * 65 + 0,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsemethod();

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseseparator() {
      var s0, s1;

      var key    = peg$currPos * 65 + 1,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (peg$c0.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c1); }
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          if (peg$c0.test(input.charAt(peg$currPos))) {
            s1 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s1 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c1); }
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecomments() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 2,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c2;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c3); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c4.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c5); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c4.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c5); }
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s4 = peg$c2;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$currPos;
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c2;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c3); }
          }
          if (s2 !== peg$FAILED) {
            s3 = [];
            if (peg$c4.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c5); }
            }
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              if (peg$c4.test(input.charAt(peg$currPos))) {
                s4 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c5); }
              }
            }
            if (s3 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 34) {
                s4 = peg$c2;
                peg$currPos++;
              } else {
                s4 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c3); }
              }
              if (s4 !== peg$FAILED) {
                s2 = [s2, s3, s4];
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        }
      } else {
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsews() {
      var s0, s1;

      var key    = peg$currPos * 65 + 3,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$parseseparator();
      if (s1 === peg$FAILED) {
        s1 = peg$parsecomments();
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parseseparator();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomments();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemaybeDotsWs() {
      var s0, s1;

      var key    = peg$currPos * 65 + 4,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c6;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c7); }
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parseseparator();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomments();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (input.charCodeAt(peg$currPos) === 46) {
          s1 = peg$c6;
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s1 === peg$FAILED) {
          s1 = peg$parseseparator();
          if (s1 === peg$FAILED) {
            s1 = peg$parsecomments();
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesomeDotsWs() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 5,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 46) {
          s2 = peg$c6;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c7); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybeDotsWs();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 6,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c8.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c9); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c10.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsekeyword() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 7,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$parseidentifier();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s3 = peg$c12;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseclassName() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 8,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (peg$c14.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c15); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        if (peg$c10.test(input.charAt(peg$currPos))) {
          s4 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c11); }
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          if (peg$c10.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c11); }
          }
        }
        if (s3 !== peg$FAILED) {
          s2 = [s2, s3];
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsestring() {
      var s0, s1;

      var key    = peg$currPos * 65 + 9,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parserawString();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parserawString() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 10,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c17;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c18); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        if (input.substr(peg$currPos, 2) === peg$c19) {
          s4 = peg$c19;
          peg$currPos += 2;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c20); }
        }
        if (s4 !== peg$FAILED) {
          peg$savedPos = s3;
          s4 = peg$c21();
        }
        s3 = s4;
        if (s3 === peg$FAILED) {
          if (peg$c22.test(input.charAt(peg$currPos))) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c23); }
          }
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          if (input.substr(peg$currPos, 2) === peg$c19) {
            s4 = peg$c19;
            peg$currPos += 2;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c20); }
          }
          if (s4 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c21();
          }
          s3 = s4;
          if (s3 === peg$FAILED) {
            if (peg$c22.test(input.charAt(peg$currPos))) {
              s3 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c23); }
            }
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c17;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c18); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c24(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecharacter() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 11,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c25;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c27); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c28(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesymbol() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 12,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 35) {
        s1 = peg$c29;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c30); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebareSymbol();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c31(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebareSymbol() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 13,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = [];
      s3 = peg$parsekeyword();
      if (s3 !== peg$FAILED) {
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsekeyword();
        }
      } else {
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 === peg$FAILED) {
        s1 = peg$parsebinarySelector();
        if (s1 === peg$FAILED) {
          s1 = peg$parseidentifier();
          if (s1 === peg$FAILED) {
            s1 = peg$parserawString();
          }
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1;

      var key    = peg$currPos * 65 + 14,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parserawNumber();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parserawNumber() {
      var s0;

      var key    = peg$currPos * 65 + 15,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsenumberExp();
      if (s0 === peg$FAILED) {
        s0 = peg$parsehex();
        if (s0 === peg$FAILED) {
          s0 = peg$parsefloat();
          if (s0 === peg$FAILED) {
            s0 = peg$parseinteger();
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsenumberExp() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 65 + 16,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parsefloat();
      if (s3 === peg$FAILED) {
        s3 = peg$parseinteger();
      }
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 101) {
          s4 = peg$c32;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseinteger();
          if (s5 !== peg$FAILED) {
            s3 = [s3, s4, s5];
            s2 = s3;
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c34(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsehex() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 65 + 17,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s1 = peg$c35;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s1 === peg$FAILED) {
        s1 = null;
      }
      if (s1 !== peg$FAILED) {
        if (input.substr(peg$currPos, 3) === peg$c37) {
          s2 = peg$c37;
          peg$currPos += 3;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c38); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          s4 = [];
          if (peg$c39.test(input.charAt(peg$currPos))) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c40); }
          }
          if (s5 !== peg$FAILED) {
            while (s5 !== peg$FAILED) {
              s4.push(s5);
              if (peg$c39.test(input.charAt(peg$currPos))) {
                s5 = input.charAt(peg$currPos);
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c40); }
              }
            }
          } else {
            s4 = peg$FAILED;
          }
          if (s4 !== peg$FAILED) {
            s3 = input.substring(s3, peg$currPos);
          } else {
            s3 = s4;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c41(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsefloat() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 65 + 18,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s3 = peg$c35;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c42.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c42.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 46) {
            s5 = peg$c6;
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c7); }
          }
          if (s5 !== peg$FAILED) {
            s6 = [];
            if (peg$c42.test(input.charAt(peg$currPos))) {
              s7 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s7 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
            if (s7 !== peg$FAILED) {
              while (s7 !== peg$FAILED) {
                s6.push(s7);
                if (peg$c42.test(input.charAt(peg$currPos))) {
                  s7 = input.charAt(peg$currPos);
                  peg$currPos++;
                } else {
                  s7 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c43); }
                }
              }
            } else {
              s6 = peg$FAILED;
            }
            if (s6 !== peg$FAILED) {
              s3 = [s3, s4, s5, s6];
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c44(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseinteger() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 65 + 19,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 45) {
        s3 = peg$c35;
        peg$currPos++;
      } else {
        s3 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c36); }
      }
      if (s3 === peg$FAILED) {
        s3 = null;
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        if (peg$c42.test(input.charAt(peg$currPos))) {
          s5 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c43); }
        }
        if (s5 !== peg$FAILED) {
          while (s5 !== peg$FAILED) {
            s4.push(s5);
            if (peg$c42.test(input.charAt(peg$currPos))) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c43); }
            }
          }
        } else {
          s4 = peg$FAILED;
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        s1 = input.substring(s1, peg$currPos);
      } else {
        s1 = s2;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c45(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteralArray() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 20,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c46) {
        s1 = peg$c46;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsLiteralArrayContents();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c48;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c50(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebareLiteralArray() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 21,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c51;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsLiteralArrayContents();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 41) {
              s4 = peg$c48;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c49); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c50(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteralArrayElement() {
      var s0;

      var key    = peg$currPos * 65 + 22,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseparseTimeLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parsebareLiteralArray();
        if (s0 === peg$FAILED) {
          s0 = peg$parsebareSymbol();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsLiteralArrayContents() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 23,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$currPos;
      s2 = peg$parsews();
      if (s2 !== peg$FAILED) {
        s3 = peg$parseliteralArrayElement();
        if (s3 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c53(s3);
          s1 = s2;
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$currPos;
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseliteralArrayElement();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c53(s3);
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedynamicArray() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 24,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s1 = peg$c54;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsExpressions();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybeDotsWs();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s4 = peg$c56;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c57); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c58(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsedynamicDictionary() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 25,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c59) {
        s1 = peg$c59;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c60); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsAssociations();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsemaybeDotsWs();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 125) {
              s4 = peg$c56;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c57); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c61(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsepseudoVariable() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 26,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c62) {
        s2 = peg$c62;
        peg$currPos += 4;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c63); }
      }
      if (s2 !== peg$FAILED) {
        peg$savedPos = s1;
        s2 = peg$c64();
      }
      s1 = s2;
      if (s1 === peg$FAILED) {
        s1 = peg$currPos;
        if (input.substr(peg$currPos, 5) === peg$c65) {
          s2 = peg$c65;
          peg$currPos += 5;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c66); }
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s1;
          s2 = peg$c67();
        }
        s1 = s2;
        if (s1 === peg$FAILED) {
          s1 = peg$currPos;
          if (input.substr(peg$currPos, 3) === peg$c68) {
            s2 = peg$c68;
            peg$currPos += 3;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c69); }
          }
          if (s2 !== peg$FAILED) {
            peg$savedPos = s1;
            s2 = peg$c70();
          }
          s1 = s2;
        }
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c16(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseparseTimeLiteral() {
      var s0;

      var key    = peg$currPos * 65 + 27,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsepseudoVariable();
      if (s0 === peg$FAILED) {
        s0 = peg$parsenumber();
        if (s0 === peg$FAILED) {
          s0 = peg$parseliteralArray();
          if (s0 === peg$FAILED) {
            s0 = peg$parsestring();
            if (s0 === peg$FAILED) {
              s0 = peg$parsesymbol();
              if (s0 === peg$FAILED) {
                s0 = peg$parsecharacter();
              }
            }
          }
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseruntimeLiteral() {
      var s0;

      var key    = peg$currPos * 65 + 28,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsedynamicDictionary();
      if (s0 === peg$FAILED) {
        s0 = peg$parsedynamicArray();
        if (s0 === peg$FAILED) {
          s0 = peg$parseblock();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseliteral() {
      var s0;

      var key    = peg$currPos * 65 + 29,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseruntimeLiteral();
      if (s0 === peg$FAILED) {
        s0 = peg$parseparseTimeLiteral();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsevariable() {
      var s0, s1;

      var key    = peg$currPos * 65 + 30,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c71(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinarySelector() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 31,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      if (peg$c72.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          if (peg$c72.test(input.charAt(peg$currPos))) {
            s2 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c73); }
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s0 = input.substring(s0, peg$currPos);
      } else {
        s0 = s1;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsKeywordPattern() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 65 + 32,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekeyword();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseidentifier();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c74(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekeyword();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c74(s4, s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c75(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBinaryPattern() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 33,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebinarySelector();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseidentifier();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c76(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryPattern() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 34,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c77(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseexpression() {
      var s0;

      var key    = peg$currPos * 65 + 35,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parseassignment();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecascade();
        if (s0 === peg$FAILED) {
          s0 = peg$parsekeywordSend();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsExpressionsRest() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 36,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsesomeDotsWs();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpression();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c78(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsExpressions() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 37,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsemaybeDotsWs();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseexpression();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsewsExpressionsRest();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsewsExpressionsRest();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c79(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryPragmaMessage() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 38,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c12;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c80(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsKeywordPragmaMessage() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 65 + 39,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekeyword();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseparseTimeLiteral();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c74(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekeyword();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseparseTimeLiteral();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c74(s4, s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c81(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsPragmaMessage() {
      var s0;

      var key    = peg$currPos * 65 + 40,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsewsUnaryPragmaMessage();
      if (s0 === peg$FAILED) {
        s0 = peg$parsewsKeywordPragmaMessage();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsPragmas() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 65 + 41,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$currPos;
      s2 = peg$parsews();
      if (s2 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 60) {
          s3 = peg$c82;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c83); }
        }
        if (s3 !== peg$FAILED) {
          s4 = peg$parsewsPragmaMessage();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsews();
            if (s5 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 62) {
                s6 = peg$c84;
                peg$currPos++;
              } else {
                s6 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c85); }
              }
              if (s6 !== peg$FAILED) {
                peg$savedPos = s1;
                s2 = peg$c86(s4);
                s1 = s2;
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$FAILED;
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$currPos;
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 60) {
            s3 = peg$c82;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c83); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsewsPragmaMessage();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                if (input.charCodeAt(peg$currPos) === 62) {
                  s6 = peg$c84;
                  peg$currPos++;
                } else {
                  s6 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c85); }
                }
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s1;
                  s2 = peg$c86(s4);
                  s1 = s2;
                } else {
                  peg$currPos = s1;
                  s1 = peg$FAILED;
                }
              } else {
                peg$currPos = s1;
                s1 = peg$FAILED;
              }
            } else {
              peg$currPos = s1;
              s1 = peg$FAILED;
            }
          } else {
            peg$currPos = s1;
            s1 = peg$FAILED;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$FAILED;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassignment() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 65 + 42,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsevariable();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c87) {
            s3 = peg$c87;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c88); }
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsews();
            if (s4 !== peg$FAILED) {
              s5 = peg$parseexpression();
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c89(s1, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseret() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 43,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 94) {
        s1 = peg$c90;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c91); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpression();
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c92(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsetemps() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 65 + 44,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 124) {
        s1 = peg$c93;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c94); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parsews();
        if (s4 !== peg$FAILED) {
          s5 = peg$parseidentifier();
          if (s5 !== peg$FAILED) {
            peg$savedPos = s3;
            s4 = peg$c95(s5);
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$FAILED;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parsews();
          if (s4 !== peg$FAILED) {
            s5 = peg$parseidentifier();
            if (s5 !== peg$FAILED) {
              peg$savedPos = s3;
              s4 = peg$c95(s5);
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$FAILED;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 124) {
              s4 = peg$c93;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c94); }
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c96(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBlockParamList() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 65 + 45,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s4 = peg$c12;
          peg$currPos++;
        } else {
          s4 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c13); }
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parseidentifier();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c97(s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 58) {
              s4 = peg$c12;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c13); }
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parseidentifier();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c97(s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 124) {
            s3 = peg$c93;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c94); }
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c98(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsesubexpression() {
      var s0, s1, s2, s3, s4, s5;

      var key    = peg$currPos * 65 + 46,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c51;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsews();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseexpression();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsews();
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 41) {
                s5 = peg$c48;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c49); }
              }
              if (s5 !== peg$FAILED) {
                peg$savedPos = s0;
                s1 = peg$c78(s3);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsStatements() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 47,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsemaybeDotsWs();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseret();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c99(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsewsExpressions();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsesomeDotsWs();
          if (s2 !== peg$FAILED) {
            s3 = peg$parseret();
            if (s3 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c100(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parsewsExpressions();
          if (s1 === peg$FAILED) {
            s1 = null;
          }
          if (s1 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c101(s1);
          }
          s0 = s1;
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseblock() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 65 + 48,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c102;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c103); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsBlockParamList();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsetemps();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsewsStatements();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsemaybeDotsWs();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 93) {
                    s7 = peg$c104;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c105); }
                  }
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c106(s2, s4, s5);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseoperand() {
      var s0;

      var key    = peg$currPos * 65 + 49,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsevariable();
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral();
        if (s0 === peg$FAILED) {
          s0 = peg$parsesubexpression();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryMessage() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 50,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseidentifier();
        if (s2 !== peg$FAILED) {
          s3 = peg$currPos;
          peg$silentFails++;
          if (input.charCodeAt(peg$currPos) === 58) {
            s4 = peg$c12;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c13); }
          }
          peg$silentFails--;
          if (s4 === peg$FAILED) {
            s3 = void 0;
          } else {
            peg$currPos = s3;
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c107(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsUnaryTail() {
      var s0, s1;

      var key    = peg$currPos * 65 + 51,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = [];
      s1 = peg$parsewsUnaryMessage();
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsewsUnaryMessage();
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseunarySend() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 52,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsUnaryTail();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c108(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBinaryMessage() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 53,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebinarySelector();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parseunarySend();
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c109(s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsBinaryTail() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 54,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsewsUnaryTail();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsewsBinaryMessage();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsewsBinaryMessage();
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c110(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsebinarySend() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 55,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsBinaryTail();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c108(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsKeywordMessage() {
      var s0, s1, s2, s3, s4, s5, s6;

      var key    = peg$currPos * 65 + 56,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$currPos;
      s3 = peg$parsews();
      if (s3 !== peg$FAILED) {
        s4 = peg$parsekeyword();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsews();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsebinarySend();
            if (s6 !== peg$FAILED) {
              peg$savedPos = s2;
              s3 = peg$c74(s4, s6);
              s2 = s3;
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        } else {
          peg$currPos = s2;
          s2 = peg$FAILED;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$FAILED;
      }
      if (s2 !== peg$FAILED) {
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$currPos;
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsekeyword();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsews();
              if (s5 !== peg$FAILED) {
                s6 = peg$parsebinarySend();
                if (s6 !== peg$FAILED) {
                  peg$savedPos = s2;
                  s3 = peg$c74(s4, s6);
                  s2 = s3;
                } else {
                  peg$currPos = s2;
                  s2 = peg$FAILED;
                }
              } else {
                peg$currPos = s2;
                s2 = peg$FAILED;
              }
            } else {
              peg$currPos = s2;
              s2 = peg$FAILED;
            }
          } else {
            peg$currPos = s2;
            s2 = peg$FAILED;
          }
        }
      } else {
        s1 = peg$FAILED;
      }
      if (s1 !== peg$FAILED) {
        peg$savedPos = s0;
        s1 = peg$c111(s1);
      }
      s0 = s1;

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsKeywordTail() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 57,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsewsBinaryTail();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsKeywordMessage();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c112(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsekeywordSend() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 58,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsKeywordTail();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c108(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsMessage() {
      var s0;

      var key    = peg$currPos * 65 + 59,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$parsewsBinaryMessage();
      if (s0 === peg$FAILED) {
        s0 = peg$parsewsUnaryMessage();
        if (s0 === peg$FAILED) {
          s0 = peg$parsewsKeywordMessage();
        }
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsecascade() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8;

      var key    = peg$currPos * 65 + 60,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsKeywordTail();
        if (s2 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s3 = peg$c113(s1, s2);
          if (s3) {
            s3 = void 0;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            s4 = [];
            s5 = peg$currPos;
            s6 = peg$parsews();
            if (s6 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 59) {
                s7 = peg$c114;
                peg$currPos++;
              } else {
                s7 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c115); }
              }
              if (s7 !== peg$FAILED) {
                s8 = peg$parsewsMessage();
                if (s8 !== peg$FAILED) {
                  peg$savedPos = s5;
                  s6 = peg$c116(s1, s2, s8);
                  s5 = s6;
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              } else {
                peg$currPos = s5;
                s5 = peg$FAILED;
              }
            } else {
              peg$currPos = s5;
              s5 = peg$FAILED;
            }
            if (s5 !== peg$FAILED) {
              while (s5 !== peg$FAILED) {
                s4.push(s5);
                s5 = peg$currPos;
                s6 = peg$parsews();
                if (s6 !== peg$FAILED) {
                  if (input.charCodeAt(peg$currPos) === 59) {
                    s7 = peg$c114;
                    peg$currPos++;
                  } else {
                    s7 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c115); }
                  }
                  if (s7 !== peg$FAILED) {
                    s8 = peg$parsewsMessage();
                    if (s8 !== peg$FAILED) {
                      peg$savedPos = s5;
                      s6 = peg$c116(s1, s2, s8);
                      s5 = s6;
                    } else {
                      peg$currPos = s5;
                      s5 = peg$FAILED;
                    }
                  } else {
                    peg$currPos = s5;
                    s5 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s5;
                  s5 = peg$FAILED;
                }
              }
            } else {
              s4 = peg$FAILED;
            }
            if (s4 !== peg$FAILED) {
              peg$savedPos = s0;
              s1 = peg$c117(s1, s2, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsemethod() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      var key    = peg$currPos * 65 + 61,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsewsKeywordPattern();
      if (s1 === peg$FAILED) {
        s1 = peg$parsewsBinaryPattern();
        if (s1 === peg$FAILED) {
          s1 = peg$parsewsUnaryPattern();
        }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsPragmas();
        if (s2 === peg$FAILED) {
          s2 = null;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsetemps();
            if (s4 === peg$FAILED) {
              s4 = null;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsewsPragmas();
              if (s5 === peg$FAILED) {
                s5 = null;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parsewsStatements();
                if (s6 === peg$FAILED) {
                  s6 = null;
                }
                if (s6 !== peg$FAILED) {
                  s7 = peg$parsemaybeDotsWs();
                  if (s7 !== peg$FAILED) {
                    peg$savedPos = s0;
                    s1 = peg$c118(s1, s2, s4, s5, s6);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$FAILED;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$FAILED;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$FAILED;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$FAILED;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parseassociationSend() {
      var s0, s1, s2, s3;

      var key    = peg$currPos * 65 + 62,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsewsBinaryTail();
        if (s2 !== peg$FAILED) {
          peg$savedPos = peg$currPos;
          s3 = peg$c119(s1, s2);
          if (s3) {
            s3 = void 0;
          } else {
            s3 = peg$FAILED;
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c120(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsAssociationsRest() {
      var s0, s1, s2;

      var key    = peg$currPos * 65 + 63,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsesomeDotsWs();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseassociationSend();
        if (s2 !== peg$FAILED) {
          peg$savedPos = s0;
          s1 = peg$c78(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }

    function peg$parsewsAssociations() {
      var s0, s1, s2, s3, s4;

      var key    = peg$currPos * 65 + 64,
          cached = peg$resultsCache[key];

      if (cached) {
        peg$currPos = cached.nextPos;

        return cached.result;
      }

      s0 = peg$currPos;
      s1 = peg$parsemaybeDotsWs();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseassociationSend();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsewsAssociationsRest();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsewsAssociationsRest();
          }
          if (s3 !== peg$FAILED) {
            peg$savedPos = s0;
            s1 = peg$c121(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$FAILED;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$FAILED;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$FAILED;
      }

      peg$resultsCache[key] = { nextPos: peg$currPos, result: s0 };

      return s0;
    }


    	var $globals = __boot.globals;

    	function newNode(nodeClass) {
    		return nodeClass._new()._location_(location())._source_(text());
    	}

    	function newSequenceNode(nodeClass, temps, statements) {
    		return newNode(nodeClass)._temps_(temps || [])._dagChildren_(statements || []);
    	}


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail(peg$endExpectation());
      }

      throw peg$buildStructuredError(
        peg$maxFailExpected,
        peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,
        peg$maxFailPos < input.length
          ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)
          : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)
      );
    }
  }

  return {
    SyntaxError: peg$SyntaxError,
    parse:       peg$parse
  };
});

define('amber/core/Platform-ImportExport',["amber/boot", "require", "amber/core/Kernel-Classes", "amber/core/Kernel-Exceptions", "amber/core/Kernel-Infrastructure", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Platform-ImportExport");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AbstractExporter", $globals.Object, "Platform-ImportExport");
$globals.AbstractExporter.comment="I am an abstract exporter for Amber source code.\x0a\x0a## API\x0a\x0aUse `#exportPackage:on:` to export a given package on a Stream.";
$core.addMethod(
$core.method({
selector: "exportPackage:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackage: aPackage on: aStream\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackage:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.AbstractExporter);

$core.addMethod(
$core.method({
selector: "extensionMethodsOfPackage:",
protocol: "accessing",
args: ["aPackage"],
source: "extensionMethodsOfPackage: aPackage\x0a\x09| result |\x0a\x09\x0a\x09result := OrderedCollection new.\x0a\x09\x0a\x09(self extensionProtocolsOfPackage: aPackage) do: [ :each |\x0a\x09\x09result addAll: each ownMethods ].\x0a\x09\x09\x0a\x09^ result",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["new", "do:", "extensionProtocolsOfPackage:", "addAll:", "ownMethods"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
result=$recv($globals.OrderedCollection)._new();
$recv($self._extensionProtocolsOfPackage_(aPackage))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(result)._addAll_($recv(each)._ownMethods());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"extensionMethodsOfPackage:",{aPackage:aPackage,result:result})});
}; }),
$globals.AbstractExporter);

$core.addMethod(
$core.method({
selector: "extensionProtocolsOfPackage:",
protocol: "accessing",
args: ["aPackage"],
source: "extensionProtocolsOfPackage: aPackage\x0a\x09| extensionName result |\x0a\x09\x0a\x09extensionName := '*', aPackage name.\x0a\x09result := OrderedCollection new.\x0a\x09\x0a\x09\x22The classes must be loaded since it is extensions only.\x0a\x09Therefore topological sorting (dependency resolution) does not matter here.\x0a\x09Not sorting topologically improves the speed by a number of magnitude.\x0a\x09\x0a\x09Not to shuffle diffs, classes are sorted by their name.\x22\x0a\x09\x0a\x09(Smalltalk classes asArray sorted: [ :a :b | a name < b name ]) do: [ :each |\x0a\x09\x09each includingPossibleMetaDo: [ :behavior |\x0a\x09\x09\x09(behavior protocols includes: extensionName) ifTrue: [\x0a\x09\x09\x09\x09result add: (ExportMethodProtocol name: extensionName theClass: behavior) ] ] ].\x0a\x0a\x09^ result",
referencedClasses: ["OrderedCollection", "Smalltalk", "ExportMethodProtocol"],
pragmas: [],
messageSends: [",", "name", "new", "do:", "sorted:", "asArray", "classes", "<", "includingPossibleMetaDo:", "ifTrue:", "includes:", "protocols", "add:", "name:theClass:"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var extensionName,result;
return $core.withContext(function($ctx1) {
extensionName="*".__comma([$recv(aPackage)._name()
,$ctx1.sendIdx["name"]=1
][0]);
result=$recv($globals.OrderedCollection)._new();
$recv($recv($recv($recv($globals.Smalltalk)._classes())._asArray())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv(a)._name()
,$ctx2.sendIdx["name"]=2
][0]).__lt($recv(b)._name());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
})))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._includingPossibleMetaDo_((function(behavior){
return $core.withContext(function($ctx3) {
if($core.assert($recv($recv(behavior)._protocols())._includes_(extensionName))){
return $recv(result)._add_($recv($globals.ExportMethodProtocol)._name_theClass_(extensionName,behavior));
}
}, function($ctx3) {$ctx3.fillBlock({behavior:behavior},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"extensionProtocolsOfPackage:",{aPackage:aPackage,extensionName:extensionName,result:result})});
}; }),
$globals.AbstractExporter);



$core.addClass("ChunkExporter", $globals.AbstractExporter, "Platform-ImportExport");
$globals.ChunkExporter.comment="I am an exporter dedicated to outputting Amber source code in the classic Smalltalk chunk format.\x0a\x0aI do not output any compiled code.";
$core.addMethod(
$core.method({
selector: "chunkEscape:",
protocol: "convenience",
args: ["aString"],
source: "chunkEscape: aString\x0a\x09\x22Replace all occurrences of ! with !! and trim at both ends.\x22\x0a\x0a\x09^ (aString replace: '!' with: '!!') trimBoth",
referencedClasses: [],
pragmas: [],
messageSends: ["trimBoth", "replace:with:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aString)._replace_with_("!","!!"))._trimBoth();
}, function($ctx1) {$ctx1.fill(self,"chunkEscape:",{aString:aString})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportBehavior:on:",
protocol: "output",
args: ["aBehavior", "aStream"],
source: "exportBehavior: aBehavior on: aStream\x0a\x09aBehavior exportBehaviorDefinitionTo: aStream using: self.\x0a\x09self \x0a\x09\x09exportProtocols: (self ownMethodProtocolsOfClass: aBehavior)\x0a\x09\x09on: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["exportBehaviorDefinitionTo:using:", "exportProtocols:on:", "ownMethodProtocolsOfClass:"]
}, function ($methodClass){ return function (aBehavior,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aBehavior)._exportBehaviorDefinitionTo_using_(aStream,self);
$self._exportProtocols_on_($self._ownMethodProtocolsOfClass_(aBehavior),aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportBehavior:on:",{aBehavior:aBehavior,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportCategoryEpilogueOf:on:",
protocol: "output",
args: ["aCategory", "aStream"],
source: "exportCategoryEpilogueOf: aCategory on: aStream\x0a\x09aStream write: ' !'; lf; lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "lf"]
}, function ($methodClass){ return function (aCategory,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_(" !");
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportCategoryEpilogueOf:on:",{aCategory:aCategory,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportCategoryPrologueOf:on:",
protocol: "output",
args: ["aCategory", "aStream"],
source: "exportCategoryPrologueOf: aCategory on: aStream\x0a\x09aStream\x0a\x09\x09write: '!';\x0a\x09\x09print: aCategory theClass;\x0a\x09\x09write: ' methodsFor: ';\x0a\x09\x09print: aCategory;\x0a\x09\x09write: '!'",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "print:", "theClass"]
}, function ($methodClass){ return function (aCategory,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._write_("!")
,$ctx1.sendIdx["write:"]=1
][0];
[$recv(aStream)._print_($recv(aCategory)._theClass())
,$ctx1.sendIdx["print:"]=1
][0];
[$recv(aStream)._write_(" methodsFor: ")
,$ctx1.sendIdx["write:"]=2
][0];
$recv(aStream)._print_(aCategory);
$recv(aStream)._write_("!");
return self;
}, function($ctx1) {$ctx1.fill(self,"exportCategoryPrologueOf:on:",{aCategory:aCategory,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportDefinitionOf:on:",
protocol: "output",
args: ["aClass", "aStream"],
source: "exportDefinitionOf: aClass on: aStream\x0a\x09\x22Chunk format.\x22\x0a\x0a\x09aStream\x0a\x09\x09print: aClass superclass;\x0a\x09\x09write: ' subclass: ';\x0a\x09\x09printSymbol: aClass name;\x0a\x09\x09lf.\x0a\x09\x22aClass traitComposition\x0a\x09\x09ifNotEmpty: [ aStream tab; write: {'uses: '. aClass traitCompositionDefinition}; lf ].\x22\x0a\x09aStream\x0a\x09\x09tab;\x0a\x09\x09write: {'slots: {'. ('. ' join: (aClass instanceVariableNames collect: #symbolPrintString)). '}'};\x0a\x09\x09lf;\x0a\x09\x09tab;\x0a\x09\x09write: 'package: ';\x0a\x09\x09print: aClass category;\x0a\x09\x09write: '!';\x0a\x09\x09lf.\x0a\x09aClass comment ifNotEmpty: [ aStream\x0a\x09\x09write: '!'; print: aClass; write: ' commentStamp!'; lf;\x0a\x09\x09write: { self chunkEscape: aClass comment. '!' }; lf ].\x0a\x09aStream lf",
referencedClasses: [],
pragmas: [],
messageSends: ["print:", "superclass", "write:", "printSymbol:", "name", "lf", "tab", "join:", "collect:", "instanceVariableNames", "category", "ifNotEmpty:", "comment", "chunkEscape:"]
}, function ($methodClass){ return function (aClass,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._print_($recv(aClass)._superclass())
,$ctx1.sendIdx["print:"]=1
][0];
[$recv(aStream)._write_(" subclass: ")
,$ctx1.sendIdx["write:"]=1
][0];
$recv(aStream)._printSymbol_($recv(aClass)._name());
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$recv(aStream)._tab()
,$ctx1.sendIdx["tab"]=1
][0];
[$recv(aStream)._write_(["slots: {",". "._join_($recv($recv(aClass)._instanceVariableNames())._collect_("symbolPrintString")),"}"])
,$ctx1.sendIdx["write:"]=2
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
$recv(aStream)._tab();
[$recv(aStream)._write_("package: ")
,$ctx1.sendIdx["write:"]=3
][0];
[$recv(aStream)._print_($recv(aClass)._category())
,$ctx1.sendIdx["print:"]=2
][0];
[$recv(aStream)._write_("!")
,$ctx1.sendIdx["write:"]=4
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=3
][0];
$recv([$recv(aClass)._comment()
,$ctx1.sendIdx["comment"]=1
][0])._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
[$recv(aStream)._write_("!")
,$ctx2.sendIdx["write:"]=5
][0];
$recv(aStream)._print_(aClass);
[$recv(aStream)._write_(" commentStamp!")
,$ctx2.sendIdx["write:"]=6
][0];
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=4
][0];
$recv(aStream)._write_([$self._chunkEscape_($recv(aClass)._comment()),"!"]);
return [$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=5
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportDefinitionOf:on:",{aClass:aClass,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportMetaDefinitionOf:on:",
protocol: "output",
args: ["aClass", "aStream"],
source: "exportMetaDefinitionOf: aClass on: aStream\x0a\x0a\x09| classIvars classTraitComposition |\x0a\x09classIvars := aClass class instanceVariableNames.\x0a\x09classTraitComposition := aClass class traitComposition.\x0a\x0a\x09(classIvars notEmpty \x22or: [classTraitComposition notEmpty]\x22) ifTrue: [\x0a\x09\x09aStream\x0a\x09\x09\x09print: aClass theMetaClass.\x0a\x09\x09aStream space. \x22classTraitComposition\x0a\x09\x09\x09ifEmpty: [ aStream space ]\x0a\x09\x09\x09ifNotEmpty: [ aStream lf; tab; write: {'uses: '. aClass class traitCompositionDefinition}; lf; tab ].\x22\x0a\x09\x09aStream\x0a\x09\x09\x09write: {'slots: {'. ('. ' join: (classIvars collect: #symbolPrintString)). '}!'}; lf; lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["instanceVariableNames", "class", "traitComposition", "ifTrue:", "notEmpty", "print:", "theMetaClass", "space", "write:", "join:", "collect:", "lf"]
}, function ($methodClass){ return function (aClass,aStream){
var self=this,$self=this;
var classIvars,classTraitComposition;
return $core.withContext(function($ctx1) {
classIvars=$recv([$recv(aClass)._class()
,$ctx1.sendIdx["class"]=1
][0])._instanceVariableNames();
classTraitComposition=$recv($recv(aClass)._class())._traitComposition();
if($core.assert($recv(classIvars)._notEmpty())){
$recv(aStream)._print_($recv(aClass)._theMetaClass());
$recv(aStream)._space();
$recv(aStream)._write_(["slots: {",". "._join_($recv(classIvars)._collect_("symbolPrintString")),"}!"]);
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$recv(aStream)._lf();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMetaDefinitionOf:on:",{aClass:aClass,aStream:aStream,classIvars:classIvars,classTraitComposition:classTraitComposition})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportMethod:on:",
protocol: "output",
args: ["aMethod", "aStream"],
source: "exportMethod: aMethod on: aStream\x0a\x09aStream\x0a\x09\x09lf; lf; write: (self chunkEscape: aMethod source); lf;\x0a\x09\x09write: '!'",
referencedClasses: [],
pragmas: [],
messageSends: ["lf", "write:", "chunkEscape:", "source"]
}, function ($methodClass){ return function (aMethod,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
[$recv(aStream)._write_($self._chunkEscape_($recv(aMethod)._source()))
,$ctx1.sendIdx["write:"]=1
][0];
$recv(aStream)._lf();
$recv(aStream)._write_("!");
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMethod:on:",{aMethod:aMethod,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackage:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackage: aPackage on: aStream\x0a\x0a\x09self\x0a\x09\x09exportPackageDefinitionOf: aPackage on: aStream;\x0a\x09\x09exportPackageImportsOf: aPackage on: aStream.\x0a\x09\x0a\x09aPackage sortedClasses do: [ :eachClass | eachClass includingPossibleMetaDo: [ :each |\x0a\x09\x09self exportBehavior: each on: aStream ] ].\x0a\x09\x0a\x09self exportPackageTraitCompositionsOf: aPackage on: aStream.\x0a\x0a\x09self \x0a\x09\x09exportProtocols: (self extensionProtocolsOfPackage: aPackage)\x0a\x09\x09on: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["exportPackageDefinitionOf:on:", "exportPackageImportsOf:on:", "do:", "sortedClasses", "includingPossibleMetaDo:", "exportBehavior:on:", "exportPackageTraitCompositionsOf:on:", "exportProtocols:on:", "extensionProtocolsOfPackage:"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._exportPackageDefinitionOf_on_(aPackage,aStream);
$self._exportPackageImportsOf_on_(aPackage,aStream);
$recv($recv(aPackage)._sortedClasses())._do_((function(eachClass){
return $core.withContext(function($ctx2) {
return $recv(eachClass)._includingPossibleMetaDo_((function(each){
return $core.withContext(function($ctx3) {
return $self._exportBehavior_on_(each,aStream);
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({eachClass:eachClass},$ctx1,1)});
}));
$self._exportPackageTraitCompositionsOf_on_(aPackage,aStream);
$self._exportProtocols_on_($self._extensionProtocolsOfPackage_(aPackage),aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackage:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackageDefinitionOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageDefinitionOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09write: 'Smalltalk createPackage: ';\x0a\x09\x09print: aPackage name;\x0a\x09\x09write: '!';\x0a\x09\x09lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "print:", "name", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._write_("Smalltalk createPackage: ")
,$ctx1.sendIdx["write:"]=1
][0];
$recv(aStream)._print_($recv(aPackage)._name());
$recv(aStream)._write_("!");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageDefinitionOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackageImportsOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageImportsOf: aPackage on: aStream\x0a\x09aPackage imports ifNotEmpty: [ :imports | aStream\x0a\x09\x09write: '(Smalltalk packageAt: ';\x0a\x09\x09print: aPackage name;\x0a\x09\x09write: ' ifAbsent: [ self error: ';\x0a\x09\x09print: 'Package not created: ', aPackage name;\x0a\x09\x09write: { ' ]) imports: '. self chunkEscape: aPackage importsDefinition. '!' };\x0a\x09\x09lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "imports", "write:", "print:", "name", ",", "chunkEscape:", "importsDefinition", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._imports())._ifNotEmpty_((function(imports){
return $core.withContext(function($ctx2) {
[$recv(aStream)._write_("(Smalltalk packageAt: ")
,$ctx2.sendIdx["write:"]=1
][0];
[$recv(aStream)._print_([$recv(aPackage)._name()
,$ctx2.sendIdx["name"]=1
][0])
,$ctx2.sendIdx["print:"]=1
][0];
[$recv(aStream)._write_(" ifAbsent: [ self error: ")
,$ctx2.sendIdx["write:"]=2
][0];
$recv(aStream)._print_("Package not created: ".__comma($recv(aPackage)._name()));
$recv(aStream)._write_([" ]) imports: ",$self._chunkEscape_($recv(aPackage)._importsDefinition()),"!"]);
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({imports:imports},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageImportsOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportPackageTraitCompositionsOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageTraitCompositionsOf: aPackage on: aStream\x0a\x09aPackage traitCompositions ifNotEmpty: [ :traitCompositions |\x0a\x09\x09traitCompositions keysAndValuesDo: [ :key :value | self exportTraitComposition: value of: key on: aStream ].\x0a\x09\x09aStream write: '! !'; lf; lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "traitCompositions", "keysAndValuesDo:", "exportTraitComposition:of:on:", "write:", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._traitCompositions())._ifNotEmpty_((function(traitCompositions){
return $core.withContext(function($ctx2) {
$recv(traitCompositions)._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx3) {
return $self._exportTraitComposition_of_on_(value,key,aStream);
}, function($ctx3) {$ctx3.fillBlock({key:key,value:value},$ctx2,2)});
}));
$recv(aStream)._write_("! !");
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=1
][0];
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({traitCompositions:traitCompositions},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageTraitCompositionsOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocol:on:",
protocol: "output",
args: ["aProtocol", "aStream"],
source: "exportProtocol: aProtocol on: aStream\x0a\x09aProtocol ownMethods ifNotEmpty: [ :methods |\x0a\x09\x09self exportProtocolPrologueOf: aProtocol on: aStream.\x0a\x09\x09methods do: [ :method | \x0a\x09\x09\x09self exportMethod: method on: aStream ].\x0a\x09\x09self exportProtocolEpilogueOf: aProtocol on: aStream ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "ownMethods", "exportProtocolPrologueOf:on:", "do:", "exportMethod:on:", "exportProtocolEpilogueOf:on:"]
}, function ($methodClass){ return function (aProtocol,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aProtocol)._ownMethods())._ifNotEmpty_((function(methods){
return $core.withContext(function($ctx2) {
$self._exportProtocolPrologueOf_on_(aProtocol,aStream);
$recv(methods)._do_((function(method){
return $core.withContext(function($ctx3) {
return $self._exportMethod_on_(method,aStream);
}, function($ctx3) {$ctx3.fillBlock({method:method},$ctx2,2)});
}));
return $self._exportProtocolEpilogueOf_on_(aProtocol,aStream);
}, function($ctx2) {$ctx2.fillBlock({methods:methods},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocol:on:",{aProtocol:aProtocol,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocolEpilogueOf:on:",
protocol: "output",
args: ["aProtocol", "aStream"],
source: "exportProtocolEpilogueOf: aProtocol on: aStream\x0a\x09aStream write: ' !'; lf; lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "lf"]
}, function ($methodClass){ return function (aProtocol,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_(" !");
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocolEpilogueOf:on:",{aProtocol:aProtocol,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocolPrologueOf:on:",
protocol: "output",
args: ["aProtocol", "aStream"],
source: "exportProtocolPrologueOf: aProtocol on: aStream\x0a\x09aStream\x0a\x09\x09write: '!';\x0a\x09\x09print: aProtocol theClass;\x0a\x09\x09write: ' methodsFor: ';\x0a\x09\x09print: aProtocol name;\x0a\x09\x09write: '!'",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "print:", "theClass", "name"]
}, function ($methodClass){ return function (aProtocol,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._write_("!")
,$ctx1.sendIdx["write:"]=1
][0];
[$recv(aStream)._print_($recv(aProtocol)._theClass())
,$ctx1.sendIdx["print:"]=1
][0];
[$recv(aStream)._write_(" methodsFor: ")
,$ctx1.sendIdx["write:"]=2
][0];
$recv(aStream)._print_($recv(aProtocol)._name());
$recv(aStream)._write_("!");
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocolPrologueOf:on:",{aProtocol:aProtocol,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportProtocols:on:",
protocol: "output",
args: ["aCollection", "aStream"],
source: "exportProtocols: aCollection on: aStream\x0a\x09aCollection do: [ :each |\x0a\x09\x09self exportProtocol: each on: aStream ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "exportProtocol:on:"]
}, function ($methodClass){ return function (aCollection,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._exportProtocol_on_(each,aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportProtocols:on:",{aCollection:aCollection,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportTraitComposition:of:on:",
protocol: "output",
args: ["aTraitComposition", "aBehavior", "aStream"],
source: "exportTraitComposition: aTraitComposition of: aBehavior on: aStream\x0a\x09aStream \x0a\x09\x09print: aBehavior;\x0a\x09\x09write: ' setTraitComposition: ';\x0a\x09\x09write: aBehavior traitCompositionDefinition;\x0a\x09\x09write: ' asTraitComposition!';\x0a\x09\x09lf",
referencedClasses: [],
pragmas: [],
messageSends: ["print:", "write:", "traitCompositionDefinition", "lf"]
}, function ($methodClass){ return function (aTraitComposition,aBehavior,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._print_(aBehavior);
[$recv(aStream)._write_(" setTraitComposition: ")
,$ctx1.sendIdx["write:"]=1
][0];
[$recv(aStream)._write_($recv(aBehavior)._traitCompositionDefinition())
,$ctx1.sendIdx["write:"]=2
][0];
$recv(aStream)._write_(" asTraitComposition!");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportTraitComposition:of:on:",{aTraitComposition:aTraitComposition,aBehavior:aBehavior,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "exportTraitDefinitionOf:on:",
protocol: "output",
args: ["aClass", "aStream"],
source: "exportTraitDefinitionOf: aClass on: aStream\x0a\x09\x22Chunk format.\x22\x0a\x0a\x09aStream\x0a\x09\x09write: 'Trait named: '; printSymbol: aClass name; lf.\x0a\x09\x22aClass traitComposition\x0a\x09\x09ifNotEmpty: [ aStream tab; write: {'uses: '. aClass traitCompositionDefinition}; lf ].\x22\x0a\x09aStream\x0a\x09\x09tab; write: 'package: '; print:\x09aClass category; write: '!'; lf.\x0a\x09aClass comment ifNotEmpty: [\x0a\x09\x09aStream\x0a\x09\x09write: '!'; print: aClass; write: ' commentStamp!'; lf;\x0a\x09\x09write: { self chunkEscape: aClass comment. '!' }; lf ].\x0a\x09aStream lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "printSymbol:", "name", "lf", "tab", "print:", "category", "ifNotEmpty:", "comment", "chunkEscape:"]
}, function ($methodClass){ return function (aClass,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._write_("Trait named: ")
,$ctx1.sendIdx["write:"]=1
][0];
$recv(aStream)._printSymbol_($recv(aClass)._name());
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$recv(aStream)._tab();
[$recv(aStream)._write_("package: ")
,$ctx1.sendIdx["write:"]=2
][0];
[$recv(aStream)._print_($recv(aClass)._category())
,$ctx1.sendIdx["print:"]=1
][0];
[$recv(aStream)._write_("!")
,$ctx1.sendIdx["write:"]=3
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
$recv([$recv(aClass)._comment()
,$ctx1.sendIdx["comment"]=1
][0])._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
[$recv(aStream)._write_("!")
,$ctx2.sendIdx["write:"]=4
][0];
$recv(aStream)._print_(aClass);
[$recv(aStream)._write_(" commentStamp!")
,$ctx2.sendIdx["write:"]=5
][0];
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=3
][0];
$recv(aStream)._write_([$self._chunkEscape_($recv(aClass)._comment()),"!"]);
return [$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=4
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportTraitDefinitionOf:on:",{aClass:aClass,aStream:aStream})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "extensionCategoriesOfPackage:",
protocol: "accessing",
args: ["aPackage"],
source: "extensionCategoriesOfPackage: aPackage\x0a\x09\x22Issue #143: sort protocol alphabetically\x22\x0a\x0a\x09| name map result |\x0a\x09name := aPackage name.\x0a\x09result := OrderedCollection new.\x0a\x09(Package sortedClasses: Smalltalk classes) do: [ :each |\x0a\x09\x09each includingPossibleMetaDo: [ :aClass |\x0a\x09\x09\x09map := Dictionary new.\x0a\x09\x09\x09aClass protocolsDo: [ :category :methods |\x0a\x09\x09\x09\x09category = ('*', name) ifTrue: [ map at: category put: methods ] ].\x0a\x09\x09\x09result addAll: ((map keys sorted: [ :a :b | a <= b ]) collect: [ :category |\x0a\x09\x09\x09\x09MethodCategory name: category theClass: aClass methods: (map at: category) ]) ] ].\x0a\x09^ result",
referencedClasses: ["OrderedCollection", "Package", "Smalltalk", "Dictionary", "MethodCategory"],
pragmas: [],
messageSends: ["name", "new", "do:", "sortedClasses:", "classes", "includingPossibleMetaDo:", "protocolsDo:", "ifTrue:", "=", ",", "at:put:", "addAll:", "collect:", "sorted:", "keys", "<=", "name:theClass:methods:", "at:"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var name,map,result;
return $core.withContext(function($ctx1) {
name=$recv(aPackage)._name();
result=[$recv($globals.OrderedCollection)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($recv($globals.Package)._sortedClasses_($recv($globals.Smalltalk)._classes()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._includingPossibleMetaDo_((function(aClass){
return $core.withContext(function($ctx3) {
map=$recv($globals.Dictionary)._new();
$recv(aClass)._protocolsDo_((function(category,methods){
return $core.withContext(function($ctx4) {
if($core.assert($recv(category).__eq("*".__comma(name)))){
return $recv(map)._at_put_(category,methods);
}
}, function($ctx4) {$ctx4.fillBlock({category:category,methods:methods},$ctx3,3)});
}));
return $recv(result)._addAll_($recv($recv($recv(map)._keys())._sorted_((function(a,b){
return $core.withContext(function($ctx4) {
return $recv(a).__lt_eq(b);
}, function($ctx4) {$ctx4.fillBlock({a:a,b:b},$ctx3,5)});
})))._collect_((function(category){
return $core.withContext(function($ctx4) {
return $recv($globals.MethodCategory)._name_theClass_methods_(category,aClass,$recv(map)._at_(category));
}, function($ctx4) {$ctx4.fillBlock({category:category},$ctx3,6)});
})));
}, function($ctx3) {$ctx3.fillBlock({aClass:aClass},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"extensionCategoriesOfPackage:",{aPackage:aPackage,name:name,map:map,result:result})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "ownCategoriesOfClass:",
protocol: "accessing",
args: ["aClass"],
source: "ownCategoriesOfClass: aClass\x0a\x09\x22Answer the protocols of aClass that are not package extensions\x22\x0a\x09\x0a\x09\x22Issue #143: sort protocol alphabetically\x22\x0a\x0a\x09| map |\x0a\x09map := Dictionary new.\x0a\x09aClass protocolsDo: [ :each :methods |\x0a\x09\x09(each match: '^\x5c*') ifFalse: [ map at: each put: methods ] ].\x0a\x09^ (map keys sorted: [ :a :b | a <= b ]) collect: [ :each |\x0a\x09\x09MethodCategory name: each theClass: aClass methods: (map at: each) ]",
referencedClasses: ["Dictionary", "MethodCategory"],
pragmas: [],
messageSends: ["new", "protocolsDo:", "ifFalse:", "match:", "at:put:", "collect:", "sorted:", "keys", "<=", "name:theClass:methods:", "at:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
var map;
return $core.withContext(function($ctx1) {
map=$recv($globals.Dictionary)._new();
$recv(aClass)._protocolsDo_((function(each,methods){
return $core.withContext(function($ctx2) {
if(!$core.assert($recv(each)._match_("^\x5c*"))){
return $recv(map)._at_put_(each,methods);
}
}, function($ctx2) {$ctx2.fillBlock({each:each,methods:methods},$ctx1,1)});
}));
return $recv($recv($recv(map)._keys())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv(a).__lt_eq(b);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,3)});
})))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.MethodCategory)._name_theClass_methods_(each,aClass,$recv(map)._at_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownCategoriesOfClass:",{aClass:aClass,map:map})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "ownCategoriesOfMetaClass:",
protocol: "accessing",
args: ["aClass"],
source: "ownCategoriesOfMetaClass: aClass\x0a\x09\x22Issue #143: sort protocol alphabetically\x22\x0a\x0a\x09^ self ownCategoriesOfClass: aClass theMetaClass",
referencedClasses: [],
pragmas: [],
messageSends: ["ownCategoriesOfClass:", "theMetaClass"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ownCategoriesOfClass_($recv(aClass)._theMetaClass());
}, function($ctx1) {$ctx1.fill(self,"ownCategoriesOfMetaClass:",{aClass:aClass})});
}; }),
$globals.ChunkExporter);

$core.addMethod(
$core.method({
selector: "ownMethodProtocolsOfClass:",
protocol: "accessing",
args: ["aClass"],
source: "ownMethodProtocolsOfClass: aClass\x0a\x09\x22Answer a collection of ExportMethodProtocol object of aClass that are not package extensions\x22\x0a\x09\x0a\x09^ aClass ownProtocols collect: [ :each |\x0a\x09\x09ExportMethodProtocol name: each theClass: aClass ]",
referencedClasses: ["ExportMethodProtocol"],
pragmas: [],
messageSends: ["collect:", "ownProtocols", "name:theClass:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aClass)._ownProtocols())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.ExportMethodProtocol)._name_theClass_(each,aClass);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethodProtocolsOfClass:",{aClass:aClass})});
}; }),
$globals.ChunkExporter);



$core.addClass("Exporter", $globals.AbstractExporter, "Platform-ImportExport");
$globals.Exporter.comment="I am responsible for outputting Amber code into a JavaScript string.\x0a\x0aThe generated output is enough to reconstruct the exported data, including Smalltalk source code and other metadata.\x0a\x0a## Use case\x0a\x0aI am typically used to save code outside of the Amber runtime (committing to disk, etc.).";
$core.addMethod(
$core.method({
selector: "exportBehavior:on:",
protocol: "output",
args: ["aBehavior", "aStream"],
source: "exportBehavior: aBehavior on: aStream\x0a\x09aBehavior exportBehaviorDefinitionTo: aStream using: self.\x0a\x09aBehavior ownMethods do: [ :method |\x0a\x09\x09self exportMethod: method on: aStream ]",
referencedClasses: [],
pragmas: [],
messageSends: ["exportBehaviorDefinitionTo:using:", "do:", "ownMethods", "exportMethod:on:"]
}, function ($methodClass){ return function (aBehavior,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aBehavior)._exportBehaviorDefinitionTo_using_(aStream,self);
$recv($recv(aBehavior)._ownMethods())._do_((function(method){
return $core.withContext(function($ctx2) {
return $self._exportMethod_on_(method,aStream);
}, function($ctx2) {$ctx2.fillBlock({method:method},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportBehavior:on:",{aBehavior:aBehavior,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportDefinitionOf:on:",
protocol: "output",
args: ["aClass", "aStream"],
source: "exportDefinitionOf: aClass on: aStream\x0a\x09aStream\x0a\x09\x09lf;\x0a\x09\x09write: {\x0a\x09\x09\x09'$core.addClass('.\x0a\x09\x09\x09aClass name asJavaScriptSource. ', '.\x0a\x09\x09\x09aClass superclass ifNil: [ 'null' ] ifNotNil: [ :superclass | superclass asJavaScriptSource ]. ', '.\x0a\x09\x09\x09aClass category asJavaScriptSource.\x0a\x09\x09\x09');' };\x0a\x09\x09lf.\x0a\x09aClass instanceVariableNames ifNotEmpty: [ :ivars | aStream\x0a\x09\x09write: { '$core.setSlots('. aClass asJavaScriptSource. ', '. ivars asJavaScriptSource. ');' };\x0a\x09\x09lf ].\x0a\x09aClass comment ifNotEmpty: [\x0a\x09\x09aStream\x0a\x09\x09\x09write: '//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);'; lf;\x0a\x09\x09\x09write: { aClass asJavaScriptSource. '.comment='. aClass comment crlfSanitized asJavaScriptSource. ';' }; lf;\x0a\x09\x09\x09write: '//>>excludeEnd(\x22ide\x22);';\x0a\x09\x09\x09lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["lf", "write:", "asJavaScriptSource", "name", "ifNil:ifNotNil:", "superclass", "category", "ifNotEmpty:", "instanceVariableNames", "comment", "crlfSanitized"]
}, function ($methodClass){ return function (aClass,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$1=[$recv($recv(aClass)._name())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=1
][0];
$2=$recv(aClass)._superclass();
if($2 == null || $2.a$nil){
$3="null";
} else {
var superclass;
superclass=$2;
$3=[$recv(superclass)._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=2
][0];
}
[$recv(aStream)._write_(["$core.addClass(",$1,", ",$3,", ",[$recv($recv(aClass)._category())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=3
][0],");"])
,$ctx1.sendIdx["write:"]=1
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
[$recv($recv(aClass)._instanceVariableNames())._ifNotEmpty_((function(ivars){
return $core.withContext(function($ctx2) {
[$recv(aStream)._write_(["$core.setSlots(",[$recv(aClass)._asJavaScriptSource()
,$ctx2.sendIdx["asJavaScriptSource"]=4
][0],", ",[$recv(ivars)._asJavaScriptSource()
,$ctx2.sendIdx["asJavaScriptSource"]=5
][0],");"])
,$ctx2.sendIdx["write:"]=2
][0];
return [$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=3
][0];
}, function($ctx2) {$ctx2.fillBlock({ivars:ivars},$ctx1,3)});
}))
,$ctx1.sendIdx["ifNotEmpty:"]=1
][0];
$recv([$recv(aClass)._comment()
,$ctx1.sendIdx["comment"]=1
][0])._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
[$recv(aStream)._write_("//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);")
,$ctx2.sendIdx["write:"]=3
][0];
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=4
][0];
[$recv(aStream)._write_([[$recv(aClass)._asJavaScriptSource()
,$ctx2.sendIdx["asJavaScriptSource"]=6
][0],".comment=",$recv($recv($recv(aClass)._comment())._crlfSanitized())._asJavaScriptSource(),";"])
,$ctx2.sendIdx["write:"]=4
][0];
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=5
][0];
$recv(aStream)._write_("//>>excludeEnd(\x22ide\x22);");
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportDefinitionOf:on:",{aClass:aClass,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportMetaDefinitionOf:on:",
protocol: "output",
args: ["aClass", "aStream"],
source: "exportMetaDefinitionOf: aClass on: aStream\x0a\x09aStream lf.\x0a\x09aClass theMetaClass instanceVariableNames ifNotEmpty: [ :classIvars | aStream\x0a\x09\x09write: { '$core.setSlots('. aClass theMetaClass asJavaScriptSource. ', '. classIvars asJavaScriptSource. ');' };\x0a\x09\x09lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["lf", "ifNotEmpty:", "instanceVariableNames", "theMetaClass", "write:", "asJavaScriptSource"]
}, function ($methodClass){ return function (aClass,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$recv($recv([$recv(aClass)._theMetaClass()
,$ctx1.sendIdx["theMetaClass"]=1
][0])._instanceVariableNames())._ifNotEmpty_((function(classIvars){
return $core.withContext(function($ctx2) {
$recv(aStream)._write_(["$core.setSlots(",[$recv($recv(aClass)._theMetaClass())._asJavaScriptSource()
,$ctx2.sendIdx["asJavaScriptSource"]=1
][0],", ",$recv(classIvars)._asJavaScriptSource(),");"]);
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({classIvars:classIvars},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMetaDefinitionOf:on:",{aClass:aClass,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportMethod:on:",
protocol: "output",
args: ["aMethod", "aStream"],
source: "exportMethod: aMethod on: aStream\x0a\x09aStream\x0a\x09\x09write: '$core.addMethod('; lf;\x0a\x09\x09write: '$core.method({'; lf;\x0a\x09\x09write: { 'selector: '. aMethod selector asJavaScriptSource. ',' }; lf;\x0a\x09\x09write: { 'protocol: '. aMethod protocol asJavaScriptSource. ',' }; lf.\x0a\x09aMethod instantiateFn ifNil: [ aStream write: { 'fn: '. aMethod fn compiledSource. ',' }; lf ].\x0a\x09aStream\x0a\x09\x09write: '//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);'; lf;\x0a\x09\x09write: { 'args: '. aMethod arguments asJavaScriptSource. ',' }; lf;\x0a\x09\x09write: { 'source: '. aMethod source asJavaScriptSource. ',' }; lf;\x0a\x09\x09write: { 'referencedClasses: '. aMethod referencedClasses asJavaScriptSource. ',' }; lf;\x0a\x09\x09write: '//>>excludeEnd(\x22ide\x22);'; lf;\x0a\x09\x09write: { 'pragmas: '. aMethod basicPragmas asJavaScriptSource. ',' }; lf;\x0a\x09\x09write: { 'messageSends: '. aMethod messageSends asJavaScriptSource }; lf;\x0a\x09\x09write: '}'.\x0a\x09aMethod instantiateFn ifNotNil: [ :ifn | aStream write: { ', '. ifn compiledSource } ].\x0a\x09aStream\x0a\x09\x09write: '),'; lf;\x0a\x09\x09write: { aMethod origin asJavaScriptSource. ');' }; lf; lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "lf", "asJavaScriptSource", "selector", "protocol", "ifNil:", "instantiateFn", "compiledSource", "fn", "arguments", "source", "referencedClasses", "basicPragmas", "messageSends", "ifNotNil:", "origin"]
}, function ($methodClass){ return function (aMethod,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
[$recv(aStream)._write_("$core.addMethod(")
,$ctx1.sendIdx["write:"]=1
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$recv(aStream)._write_("$core.method({")
,$ctx1.sendIdx["write:"]=2
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
[$recv(aStream)._write_(["selector: ",[$recv($recv(aMethod)._selector())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=1
][0],","])
,$ctx1.sendIdx["write:"]=3
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=3
][0];
[$recv(aStream)._write_(["protocol: ",[$recv($recv(aMethod)._protocol())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=2
][0],","])
,$ctx1.sendIdx["write:"]=4
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=4
][0];
$1=[$recv(aMethod)._instantiateFn()
,$ctx1.sendIdx["instantiateFn"]=1
][0];
if($1 == null || $1.a$nil){
[$recv(aStream)._write_(["fn: ",[$recv($recv(aMethod)._fn())._compiledSource()
,$ctx1.sendIdx["compiledSource"]=1
][0],","])
,$ctx1.sendIdx["write:"]=5
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=5
][0];
} else {
$1;
}
[$recv(aStream)._write_("//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);")
,$ctx1.sendIdx["write:"]=6
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=6
][0];
[$recv(aStream)._write_(["args: ",[$recv($recv(aMethod)._arguments())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=3
][0],","])
,$ctx1.sendIdx["write:"]=7
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=7
][0];
[$recv(aStream)._write_(["source: ",[$recv($recv(aMethod)._source())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=4
][0],","])
,$ctx1.sendIdx["write:"]=8
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=8
][0];
[$recv(aStream)._write_(["referencedClasses: ",[$recv($recv(aMethod)._referencedClasses())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=5
][0],","])
,$ctx1.sendIdx["write:"]=9
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=9
][0];
[$recv(aStream)._write_("//>>excludeEnd(\x22ide\x22);")
,$ctx1.sendIdx["write:"]=10
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=10
][0];
[$recv(aStream)._write_(["pragmas: ",[$recv($recv(aMethod)._basicPragmas())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=6
][0],","])
,$ctx1.sendIdx["write:"]=11
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=11
][0];
[$recv(aStream)._write_(["messageSends: ",[$recv($recv(aMethod)._messageSends())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=7
][0]])
,$ctx1.sendIdx["write:"]=12
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=12
][0];
[$recv(aStream)._write_("}")
,$ctx1.sendIdx["write:"]=13
][0];
$2=$recv(aMethod)._instantiateFn();
if($2 == null || $2.a$nil){
$2;
} else {
var ifn;
ifn=$2;
[$recv(aStream)._write_([", ",$recv(ifn)._compiledSource()])
,$ctx1.sendIdx["write:"]=14
][0];
}
[$recv(aStream)._write_("),")
,$ctx1.sendIdx["write:"]=15
][0];
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=13
][0];
$recv(aStream)._write_([$recv($recv(aMethod)._origin())._asJavaScriptSource(),");"]);
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=14
][0];
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportMethod:on:",{aMethod:aMethod,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackage:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackage: aPackage on: aStream\x0a\x09\x0a\x09self \x0a\x09\x09exportPackagePrologueOf: aPackage on: aStream;\x0a\x09\x09exportPackageDefinitionOf: aPackage on: aStream;\x0a\x09\x09exportPackageContextOf: aPackage on: aStream;\x0a\x09\x09exportPackageImportsOf: aPackage on: aStream;\x0a\x09\x09exportPackageTransportOf: aPackage on: aStream.\x0a\x09\x0a\x09aPackage sortedClasses do: [ :eachClass | eachClass includingPossibleMetaDo: [ :each |\x0a\x09\x09self exportBehavior: each on: aStream ] ].\x0a\x09\x09\x09\x0a\x09self exportPackageTraitCompositionsOf: aPackage on: aStream.\x0a\x0a\x09(self extensionMethodsOfPackage: aPackage) do: [ :each |\x0a\x09\x09self exportMethod: each on: aStream ].\x0a\x09\x09\x0a\x09self exportPackageEpilogueOf: aPackage on: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["exportPackagePrologueOf:on:", "exportPackageDefinitionOf:on:", "exportPackageContextOf:on:", "exportPackageImportsOf:on:", "exportPackageTransportOf:on:", "do:", "sortedClasses", "includingPossibleMetaDo:", "exportBehavior:on:", "exportPackageTraitCompositionsOf:on:", "extensionMethodsOfPackage:", "exportMethod:on:", "exportPackageEpilogueOf:on:"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._exportPackagePrologueOf_on_(aPackage,aStream);
$self._exportPackageDefinitionOf_on_(aPackage,aStream);
$self._exportPackageContextOf_on_(aPackage,aStream);
$self._exportPackageImportsOf_on_(aPackage,aStream);
$self._exportPackageTransportOf_on_(aPackage,aStream);
[$recv($recv(aPackage)._sortedClasses())._do_((function(eachClass){
return $core.withContext(function($ctx2) {
return $recv(eachClass)._includingPossibleMetaDo_((function(each){
return $core.withContext(function($ctx3) {
return $self._exportBehavior_on_(each,aStream);
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({eachClass:eachClass},$ctx1,1)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
$self._exportPackageTraitCompositionsOf_on_(aPackage,aStream);
$recv($self._extensionMethodsOfPackage_(aPackage))._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._exportMethod_on_(each,aStream);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$self._exportPackageEpilogueOf_on_(aPackage,aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackage:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageBodyBlockPrologueOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageBodyBlockPrologueOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09write: 'var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;'; lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_("var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageBodyBlockPrologueOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageContextOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageContextOf: aPackage on: aStream\x0a\x09aPackage contextFunctionSource ifNotNil: [ :source |\x0a\x09\x09aStream\x0a\x09\x09\x09write: { '$pkg.context = '. source. ';' };\x0a\x09\x09\x09lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "contextFunctionSource", "write:", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aPackage)._contextFunctionSource();
if($1 == null || $1.a$nil){
$1;
} else {
var source;
source=$1;
$recv(aStream)._write_(["$pkg.context = ",source,";"]);
$recv(aStream)._lf();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageContextOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageDefinitionOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageDefinitionOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09write: { 'var $pkg = $core.addPackage('. aPackage name asJavaScriptSource. ');' };\x0a\x09\x09lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "asJavaScriptSource", "name", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_(["var $pkg = $core.addPackage(",$recv($recv(aPackage)._name())._asJavaScriptSource(),");"]);
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageDefinitionOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageEpilogueOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageEpilogueOf: aPackage on: aStream\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageEpilogueOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageImportsOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageImportsOf: aPackage on: aStream\x0a\x09aPackage importsAsJson ifNotEmpty: [ :imports |\x0a\x09\x09aStream\x0a\x09\x09\x09write: { '$pkg.imports = '. imports asJavaScriptSource. ';' };\x0a\x09\x09\x09lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "importsAsJson", "write:", "asJavaScriptSource", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._importsAsJson())._ifNotEmpty_((function(imports){
return $core.withContext(function($ctx2) {
$recv(aStream)._write_(["$pkg.imports = ",$recv(imports)._asJavaScriptSource(),";"]);
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({imports:imports},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageImportsOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackagePrologueOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackagePrologueOf: aPackage on: aStream\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackagePrologueOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageTraitCompositionsOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageTraitCompositionsOf: aPackage on: aStream\x0a\x09aPackage traitCompositions ifNotEmpty: [ :traitCompositions |\x0a\x09\x09traitCompositions keysAndValuesDo: [ :key :value | self exportTraitComposition: value of: key on: aStream ].\x0a\x09\x09aStream lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "traitCompositions", "keysAndValuesDo:", "exportTraitComposition:of:on:", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aPackage)._traitCompositions())._ifNotEmpty_((function(traitCompositions){
return $core.withContext(function($ctx2) {
$recv(traitCompositions)._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx3) {
return $self._exportTraitComposition_of_on_(value,key,aStream);
}, function($ctx3) {$ctx3.fillBlock({key:key,value:value},$ctx2,2)});
}));
return $recv(aStream)._lf();
}, function($ctx2) {$ctx2.fillBlock({traitCompositions:traitCompositions},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageTraitCompositionsOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportPackageTransportOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageTransportOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09write: { '$pkg.transport = '. aPackage transport asJSONString. ';' };\x0a\x09\x09lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "asJSONString", "transport", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_(["$pkg.transport = ",$recv($recv(aPackage)._transport())._asJSONString(),";"]);
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageTransportOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportTraitComposition:of:on:",
protocol: "output",
args: ["aTraitComposition", "aBehavior", "aStream"],
source: "exportTraitComposition: aTraitComposition of: aBehavior on: aStream\x0a\x09aStream write: {\x0a\x09\x09'$core.setTraitComposition('.\x0a\x09\x09aTraitComposition asJavaScriptSource.\x0a\x09\x09', '.\x0a\x09\x09aBehavior asJavaScriptSource.\x0a\x09\x09');' };\x0a\x09lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "asJavaScriptSource", "lf"]
}, function ($methodClass){ return function (aTraitComposition,aBehavior,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_(["$core.setTraitComposition(",[$recv(aTraitComposition)._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=1
][0],", ",$recv(aBehavior)._asJavaScriptSource(),");"]);
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportTraitComposition:of:on:",{aTraitComposition:aTraitComposition,aBehavior:aBehavior,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "exportTraitDefinitionOf:on:",
protocol: "output",
args: ["aClass", "aStream"],
source: "exportTraitDefinitionOf: aClass on: aStream\x0a\x09aStream\x0a\x09\x09lf;\x0a\x09\x09write: {\x0a\x09\x09\x09'$core.addTrait('.\x0a\x09\x09\x09aClass name asJavaScriptSource. ', '.\x0a\x09\x09\x09aClass category asJavaScriptSource.\x0a\x09\x09\x09');' }.\x0a\x09aClass comment ifNotEmpty: [\x0a\x09\x09aStream\x0a\x09\x09\x09lf;\x0a\x09\x09\x09write: '//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);'; lf;\x0a\x09\x09\x09write: { aClass asJavaScriptSource. '.comment='. aClass comment crlfSanitized asJavaScriptSource. ';' }; lf;\x0a\x09\x09\x09write: '//>>excludeEnd(\x22ide\x22);' ].\x0a\x09aStream lf",
referencedClasses: [],
pragmas: [],
messageSends: ["lf", "write:", "asJavaScriptSource", "name", "category", "ifNotEmpty:", "comment", "crlfSanitized"]
}, function ($methodClass){ return function (aClass,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aStream)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$recv(aStream)._write_(["$core.addTrait(",[$recv($recv(aClass)._name())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=1
][0],", ",[$recv($recv(aClass)._category())._asJavaScriptSource()
,$ctx1.sendIdx["asJavaScriptSource"]=2
][0],");"])
,$ctx1.sendIdx["write:"]=1
][0];
$recv([$recv(aClass)._comment()
,$ctx1.sendIdx["comment"]=1
][0])._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=2
][0];
[$recv(aStream)._write_("//>>excludeStart(\x22ide\x22, pragmas.excludeIdeData);")
,$ctx2.sendIdx["write:"]=2
][0];
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=3
][0];
[$recv(aStream)._write_([[$recv(aClass)._asJavaScriptSource()
,$ctx2.sendIdx["asJavaScriptSource"]=3
][0],".comment=",$recv($recv($recv(aClass)._comment())._crlfSanitized())._asJavaScriptSource(),";"])
,$ctx2.sendIdx["write:"]=3
][0];
[$recv(aStream)._lf()
,$ctx2.sendIdx["lf"]=4
][0];
return $recv(aStream)._write_("//>>excludeEnd(\x22ide\x22);");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportTraitDefinitionOf:on:",{aClass:aClass,aStream:aStream})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "ownMethodsOfClass:",
protocol: "accessing",
args: ["aClass"],
source: "ownMethodsOfClass: aClass\x0a\x09\x22Issue #143: sort methods alphabetically\x22\x0a\x0a\x09^ ((aClass methodDictionary values) sorted: [ :a :b | a selector <= b selector ])\x0a\x09\x09reject: [ :each | (each protocol match: '^\x5c*') ]",
referencedClasses: [],
pragmas: [],
messageSends: ["reject:", "sorted:", "values", "methodDictionary", "<=", "selector", "match:", "protocol"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($recv(aClass)._methodDictionary())._values())._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv(a)._selector()
,$ctx2.sendIdx["selector"]=1
][0]).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
})))._reject_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._protocol())._match_("^\x5c*");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethodsOfClass:",{aClass:aClass})});
}; }),
$globals.Exporter);

$core.addMethod(
$core.method({
selector: "ownMethodsOfMetaClass:",
protocol: "accessing",
args: ["aClass"],
source: "ownMethodsOfMetaClass: aClass\x0a\x09\x22Issue #143: sort methods alphabetically\x22\x0a\x0a\x09^ self ownMethodsOfClass: aClass theMetaClass",
referencedClasses: [],
pragmas: [],
messageSends: ["ownMethodsOfClass:", "theMetaClass"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._ownMethodsOfClass_($recv(aClass)._theMetaClass());
}, function($ctx1) {$ctx1.fill(self,"ownMethodsOfMetaClass:",{aClass:aClass})});
}; }),
$globals.Exporter);



$core.addClass("AmdExporter", $globals.Exporter, "Platform-ImportExport");
$core.setSlots($globals.AmdExporter, ["namespace"]);
$globals.AmdExporter.comment="I am used to export Packages in an AMD (Asynchronous Module Definition) JavaScript format.";
$core.addMethod(
$core.method({
selector: "amdNamesOfPackages:",
protocol: "private",
args: ["anArray"],
source: "amdNamesOfPackages: anArray\x0a\x09^ (anArray\x0a\x09\x09select: [ :each | (self amdNamespaceOfPackage: each) notNil ])\x0a\x09\x09collect: [ :each | (self amdNamespaceOfPackage: each), '/', each name ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "select:", "notNil", "amdNamespaceOfPackage:", ",", "name"]
}, function ($methodClass){ return function (anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(anArray)._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv([$self._amdNamespaceOfPackage_(each)
,$ctx2.sendIdx["amdNamespaceOfPackage:"]=1
][0])._notNil();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._collect_((function(each){
return $core.withContext(function($ctx2) {
return [$recv($recv($self._amdNamespaceOfPackage_(each)).__comma("/")).__comma($recv(each)._name())
,$ctx2.sendIdx[","]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"amdNamesOfPackages:",{anArray:anArray})});
}; }),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "amdNamespaceOfPackage:",
protocol: "private",
args: ["aPackage"],
source: "amdNamespaceOfPackage: aPackage\x0a\x09^ (aPackage transport type = 'amd')\x0a\x09\x09ifTrue: [ aPackage transport namespace ]\x0a\x09\x09ifFalse: [ nil ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "=", "type", "transport", "namespace"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv([$recv(aPackage)._transport()
,$ctx1.sendIdx["transport"]=1
][0])._type()).__eq("amd"))){
return $recv($recv(aPackage)._transport())._namespace();
} else {
return nil;
}
}, function($ctx1) {$ctx1.fill(self,"amdNamespaceOfPackage:",{aPackage:aPackage})});
}; }),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "exportPackageEpilogueOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageEpilogueOf: aPackage on: aStream\x0a\x09aStream\x0a\x09\x09write: '});';\x0a\x09\x09lf",
referencedClasses: [],
pragmas: [],
messageSends: ["write:", "lf"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aStream)._write_("});");
$recv(aStream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageEpilogueOf:on:",{aPackage:aPackage,aStream:aStream})});
}; }),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "exportPackageImportsOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackageImportsOf: aPackage on: aStream\x0a\x09| importsForOutput pragmaStart pragmaEnd |\x0a\x09pragmaStart := '//>>excludeStart(\x22imports\x22, pragmas.excludeImports);', String lf.\x0a\x09pragmaEnd := '//>>excludeEnd(\x22imports\x22);', String lf.\x0a\x09super exportPackageImportsOf: aPackage on: aStream.\x0a\x09importsForOutput := self importsForOutput: aPackage.\x0a\x09importsForOutput value ifNotEmpty: [ :imports |\x0a\x09\x09| vars |\x0a\x09\x09aStream write: pragmaStart.\x0a\x09\x09vars := importsForOutput key.\x0a\x09\x09vars ifNotEmpty: [ aStream write: { 'var '. ',' join: vars. ';' }; lf ]. \x0a\x09\x09aStream\x0a\x09\x09\x09write: {\x0a\x09\x09\x09\x09'$pkg.isReady = new Promise(function (resolve, reject) { requirejs('.\x0a\x09\x09\x09\x09imports asJavaScriptSource.\x0a\x09\x09\x09\x09', function ('.\x0a\x09\x09\x09\x09',' join: ((1 to: vars size) collect: [ :each | '$', each asString ]).\x0a\x09\x09\x09\x09') {'.\x0a\x09\x09\x09\x09(1 to: vars size) collect: [ :each | (vars at: each), '=$', each asString, '; ' ].\x0a\x09\x09\x09\x09'resolve();}, reject); });' };\x0a\x09\x09\x09lf;\x0a\x09\x09\x09write: pragmaEnd ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: [",", "lf", "exportPackageImportsOf:on:", "importsForOutput:", "ifNotEmpty:", "value", "write:", "key", "join:", "asJavaScriptSource", "collect:", "to:", "size", "asString", "at:"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
var importsForOutput,pragmaStart,pragmaEnd;
return $core.withContext(function($ctx1) {
pragmaStart=["//>>excludeStart(\x22imports\x22, pragmas.excludeImports);".__comma([$recv($globals.String)._lf()
,$ctx1.sendIdx["lf"]=1
][0])
,$ctx1.sendIdx[","]=1
][0];
pragmaEnd=["//>>excludeEnd(\x22imports\x22);".__comma([$recv($globals.String)._lf()
,$ctx1.sendIdx["lf"]=2
][0])
,$ctx1.sendIdx[","]=2
][0];
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._exportPackageImportsOf_on_.call($self,aPackage,aStream))
,$ctx1.supercall = false
][0];
importsForOutput=$self._importsForOutput_(aPackage);
[$recv($recv(importsForOutput)._value())._ifNotEmpty_((function(imports){
var vars;
return $core.withContext(function($ctx2) {
[$recv(aStream)._write_(pragmaStart)
,$ctx2.sendIdx["write:"]=1
][0];
vars=$recv(importsForOutput)._key();
$recv(vars)._ifNotEmpty_((function(){
return $core.withContext(function($ctx3) {
[$recv(aStream)._write_(["var ",[","._join_(vars)
,$ctx3.sendIdx["join:"]=1
][0],";"])
,$ctx3.sendIdx["write:"]=2
][0];
return [$recv(aStream)._lf()
,$ctx3.sendIdx["lf"]=3
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
[$recv(aStream)._write_(["$pkg.isReady = new Promise(function (resolve, reject) { requirejs(",$recv(imports)._asJavaScriptSource(),", function (",","._join_([$recv([(1)._to_([$recv(vars)._size()
,$ctx2.sendIdx["size"]=1
][0])
,$ctx2.sendIdx["to:"]=1
][0])._collect_((function(each){
return $core.withContext(function($ctx3) {
return ["$".__comma([$recv(each)._asString()
,$ctx3.sendIdx["asString"]=1
][0])
,$ctx3.sendIdx[","]=3
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,3)});
}))
,$ctx2.sendIdx["collect:"]=1
][0]),") {",$recv((1)._to_($recv(vars)._size()))._collect_((function(each){
return $core.withContext(function($ctx3) {
return [$recv([$recv($recv($recv(vars)._at_(each)).__comma("=$")).__comma($recv(each)._asString())
,$ctx3.sendIdx[","]=5
][0]).__comma("; ")
,$ctx3.sendIdx[","]=4
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,4)});
})),"resolve();}, reject); });"])
,$ctx2.sendIdx["write:"]=3
][0];
$recv(aStream)._lf();
return $recv(aStream)._write_(pragmaEnd);
}, function($ctx2) {$ctx2.fillBlock({imports:imports,vars:vars},$ctx1,1)});
}))
,$ctx1.sendIdx["ifNotEmpty:"]=1
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackageImportsOf:on:",{aPackage:aPackage,aStream:aStream,importsForOutput:importsForOutput,pragmaStart:pragmaStart,pragmaEnd:pragmaEnd})});
}; }),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "exportPackagePrologueOf:on:",
protocol: "output",
args: ["aPackage", "aStream"],
source: "exportPackagePrologueOf: aPackage on: aStream\x0a\x09| loadDependencies pragmaStart pragmaEnd |\x0a\x09pragmaStart := '//>>excludeStart(\x22imports\x22, pragmas.excludeImports);', String lf.\x0a\x09pragmaEnd := '//>>excludeEnd(\x22imports\x22);', String lf.\x0a\x09loadDependencies := self amdNamesOfPackages: aPackage loadDependencies.\x0a\x09aStream\x0a\x09\x09write: {\x0a\x09\x09\x09'define('.\x0a\x09\x09\x09(#('amber/boot' 'require'), loadDependencies asArray sorted) asJavaScriptSource.\x0a\x09\x09\x09', function($boot,requirejs){\x22use strict\x22;' };\x0a\x09\x09lf.\x0a\x09self exportPackageBodyBlockPrologueOf: aPackage on: aStream",
referencedClasses: ["String"],
pragmas: [],
messageSends: [",", "lf", "amdNamesOfPackages:", "loadDependencies", "write:", "asJavaScriptSource", "sorted", "asArray", "exportPackageBodyBlockPrologueOf:on:"]
}, function ($methodClass){ return function (aPackage,aStream){
var self=this,$self=this;
var loadDependencies,pragmaStart,pragmaEnd;
return $core.withContext(function($ctx1) {
pragmaStart=["//>>excludeStart(\x22imports\x22, pragmas.excludeImports);".__comma([$recv($globals.String)._lf()
,$ctx1.sendIdx["lf"]=1
][0])
,$ctx1.sendIdx[","]=1
][0];
pragmaEnd=["//>>excludeEnd(\x22imports\x22);".__comma([$recv($globals.String)._lf()
,$ctx1.sendIdx["lf"]=2
][0])
,$ctx1.sendIdx[","]=2
][0];
loadDependencies=$self._amdNamesOfPackages_($recv(aPackage)._loadDependencies());
$recv(aStream)._write_(["define(",$recv(["amber/boot", "require"].__comma($recv($recv(loadDependencies)._asArray())._sorted()))._asJavaScriptSource(),", function($boot,requirejs){\x22use strict\x22;"]);
$recv(aStream)._lf();
$self._exportPackageBodyBlockPrologueOf_on_(aPackage,aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportPackagePrologueOf:on:",{aPackage:aPackage,aStream:aStream,loadDependencies:loadDependencies,pragmaStart:pragmaStart,pragmaEnd:pragmaEnd})});
}; }),
$globals.AmdExporter);

$core.addMethod(
$core.method({
selector: "importsForOutput:",
protocol: "private",
args: ["aPackage"],
source: "importsForOutput: aPackage\x0a\x09\x22Returns an association where key is list of import variables\x0a\x09and value is list of external dependencies, with ones imported as variables\x0a\x09put at the beginning with same order as is in key.\x0a\x09\x0a\x09For example imports:{'jQuery'->'jquery'. 'bootstrap'} would yield\x0a\x09#('jQuery') -> #('jquery' 'bootstrap')\x22\x0a\x09| namedImports anonImports importVarNames |\x0a\x09namedImports := #().\x0a\x09anonImports := #().\x0a\x09importVarNames := #().\x0a\x09aPackage imports do: [ :each | each isString\x0a\x09\x09ifTrue: [ anonImports add: each ]\x0a\x09\x09ifFalse: [ namedImports add: each value.\x0a\x09\x09\x09importVarNames add: each key ]].\x0a\x09^ importVarNames -> (namedImports, anonImports)",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "imports", "ifTrue:ifFalse:", "isString", "add:", "value", "key", "->", ","]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var namedImports,anonImports,importVarNames;
return $core.withContext(function($ctx1) {
namedImports=[];
anonImports=[];
importVarNames=[];
$recv($recv(aPackage)._imports())._do_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(each)._isString())){
return [$recv(anonImports)._add_(each)
,$ctx2.sendIdx["add:"]=1
][0];
} else {
[$recv(namedImports)._add_($recv(each)._value())
,$ctx2.sendIdx["add:"]=2
][0];
return $recv(importVarNames)._add_($recv(each)._key());
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return $recv(importVarNames).__minus_gt($recv(namedImports).__comma(anonImports));
}, function($ctx1) {$ctx1.fill(self,"importsForOutput:",{aPackage:aPackage,namedImports:namedImports,anonImports:anonImports,importVarNames:importVarNames})});
}; }),
$globals.AmdExporter);



$core.addClass("ChunkParser", $globals.Object, "Platform-ImportExport");
$core.setSlots($globals.ChunkParser, ["stream", "last"]);
$globals.ChunkParser.comment="I am responsible for parsing aStream contents in the chunk format.\x0a\x0a## API\x0a\x0a    ChunkParser new\x0a        stream: aStream;\x0a        nextChunk";
$core.addMethod(
$core.method({
selector: "last",
protocol: "accessing",
args: [],
source: "last\x0a\x09^ last",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.last;

}; }),
$globals.ChunkParser);

$core.addMethod(
$core.method({
selector: "nextChunk",
protocol: "reading",
args: [],
source: "nextChunk\x0a\x09\x22The chunk format (Smalltalk Interchange Format or Fileout format)\x0a\x09is a trivial format but can be a bit tricky to understand:\x0a\x09\x09- Uses the exclamation mark as delimiter of chunks.\x0a\x09\x09- Inside a chunk a normal exclamation mark must be doubled.\x0a\x09\x09- A non empty chunk must be a valid Smalltalk expression.\x0a\x09\x09- A chunk on top level with a preceding empty chunk is an instruction chunk:\x0a\x09\x09\x09- The object created by the expression then takes over reading chunks.\x0a\x0a\x09This method returns next chunk as a String (trimmed), empty String (all whitespace) or nil.\x22\x0a\x0a\x09| char result chunk |\x0a\x09result := '' writeStream.\x0a\x09\x09[ char := stream next.\x0a\x09\x09char notNil ] whileTrue: [\x0a\x09\x09\x09\x09char = '!' ifTrue: [\x0a\x09\x09\x09\x09\x09\x09stream peek = '!'\x0a\x09\x09\x09\x09\x09\x09\x09\x09ifTrue: [ stream next \x22skipping the escape double\x22 ]\x0a\x09\x09\x09\x09\x09\x09\x09\x09ifFalse: [ ^ last := result contents trimBoth \x22chunk end marker found\x22 ]].\x0a\x09\x09\x09\x09result nextPut: char ].\x0a\x09^ last := nil \x22a chunk needs to end with !\x22",
referencedClasses: [],
pragmas: [],
messageSends: ["writeStream", "whileTrue:", "next", "notNil", "ifTrue:", "=", "ifTrue:ifFalse:", "peek", "trimBoth", "contents", "nextPut:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var char,result,chunk;
return $core.withContext(function($ctx1) {
var $early={};
try {
result=""._writeStream();
$recv((function(){
return $core.withContext(function($ctx2) {
char=[$recv($self.stream)._next()
,$ctx2.sendIdx["next"]=1
][0];
return $recv(char)._notNil();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
if($core.assert([$recv(char).__eq("!")
,$ctx2.sendIdx["="]=1
][0])){
if($core.assert($recv($recv($self.stream)._peek()).__eq("!"))){
$recv($self.stream)._next();
} else {
$self.last=$recv($recv(result)._contents())._trimBoth();
throw $early=[$self.last];
}
}
return $recv(result)._nextPut_(char);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$self.last=nil;
return $self.last;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"nextChunk",{char:char,result:result,chunk:chunk})});
}; }),
$globals.ChunkParser);

$core.addMethod(
$core.method({
selector: "stream:",
protocol: "accessing",
args: ["aStream"],
source: "stream: aStream\x0a\x09stream := aStream",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
$self.stream=aStream;
return self;

}; }),
$globals.ChunkParser);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aStream"],
source: "on: aStream\x0a\x09^ self new stream: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["stream:", "new"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._stream_(aStream);
}, function($ctx1) {$ctx1.fill(self,"on:",{aStream:aStream})});
}; }),
$globals.ChunkParser.a$cls);


$core.addClass("ClassCommentReader", $globals.Object, "Platform-ImportExport");
$core.setSlots($globals.ClassCommentReader, ["class"]);
$globals.ClassCommentReader.comment="I provide a mechanism for retrieving class comments stored on a file.\x0a\x0aSee also `ClassCategoryReader`.";
$core.addMethod(
$core.method({
selector: "class:",
protocol: "accessing",
args: ["aClass"],
source: "class: aClass\x0a\x09class := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.class=aClass;
return self;

}; }),
$globals.ClassCommentReader);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.ClassCommentReader);

$core.addMethod(
$core.method({
selector: "scanFrom:",
protocol: "fileIn",
args: ["aChunkParser"],
source: "scanFrom: aChunkParser\x0a\x09| chunk |\x0a\x09chunk := aChunkParser nextChunk.\x0a\x09chunk ifNotEmpty: [\x0a\x09\x09self setComment: chunk ].",
referencedClasses: [],
pragmas: [],
messageSends: ["nextChunk", "ifNotEmpty:", "setComment:"]
}, function ($methodClass){ return function (aChunkParser){
var self=this,$self=this;
var chunk;
return $core.withContext(function($ctx1) {
chunk=$recv(aChunkParser)._nextChunk();
$recv(chunk)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $self._setComment_(chunk);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"scanFrom:",{aChunkParser:aChunkParser,chunk:chunk})});
}; }),
$globals.ClassCommentReader);

$core.addMethod(
$core.method({
selector: "setComment:",
protocol: "private",
args: ["aString"],
source: "setComment: aString\x0a\x09class comment: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["comment:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.class)._comment_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"setComment:",{aString:aString})});
}; }),
$globals.ClassCommentReader);



$core.addClass("ClassProtocolReader", $globals.Object, "Platform-ImportExport");
$core.setSlots($globals.ClassProtocolReader, ["class", "category"]);
$globals.ClassProtocolReader.comment="I provide a mechanism for retrieving class descriptions stored on a file in the Smalltalk chunk format.";
$core.addMethod(
$core.method({
selector: "class:category:",
protocol: "accessing",
args: ["aClass", "aString"],
source: "class: aClass category: aString\x0a\x09class := aClass.\x0a\x09category := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass,aString){
var self=this,$self=this;
$self.class=aClass;
$self.category=aString;
return self;

}; }),
$globals.ClassProtocolReader);

$core.addMethod(
$core.method({
selector: "compileMethod:",
protocol: "private",
args: ["aString"],
source: "compileMethod: aString\x0a\x09Compiler new install: aString forClass: class protocol: category",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["install:forClass:protocol:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Compiler)._new())._install_forClass_protocol_(aString,$self.class,$self.category);
return self;
}, function($ctx1) {$ctx1.fill(self,"compileMethod:",{aString:aString})});
}; }),
$globals.ClassProtocolReader);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.ClassProtocolReader);

$core.addMethod(
$core.method({
selector: "scanFrom:",
protocol: "fileIn",
args: ["aChunkParser"],
source: "scanFrom: aChunkParser\x0a\x09| chunk |\x0a\x09[ chunk := aChunkParser nextChunk.\x0a\x09chunk isEmpty ] whileFalse: [\x0a\x09\x09self compileMethod: chunk ]",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", "nextChunk", "isEmpty", "compileMethod:"]
}, function ($methodClass){ return function (aChunkParser){
var self=this,$self=this;
var chunk;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
chunk=$recv(aChunkParser)._nextChunk();
return $recv(chunk)._isEmpty();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return $self._compileMethod_(chunk);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"scanFrom:",{aChunkParser:aChunkParser,chunk:chunk})});
}; }),
$globals.ClassProtocolReader);



$core.addClass("ExportMethodProtocol", $globals.Object, "Platform-ImportExport");
$core.setSlots($globals.ExportMethodProtocol, ["name", "theClass"]);
$globals.ExportMethodProtocol.comment="I am an abstraction for a method protocol in a class / metaclass.\x0a\x0aI know of my class, name and methods.\x0aI am used when exporting a package.";
$core.addMethod(
$core.method({
selector: "methods",
protocol: "accessing",
args: [],
source: "methods\x0a\x09^ (self theClass methodsInProtocol: self name)\x0a\x09\x09sorted: [ :a :b | a selector <= b selector ]",
referencedClasses: [],
pragmas: [],
messageSends: ["sorted:", "methodsInProtocol:", "theClass", "name", "<=", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._theClass())._methodsInProtocol_($self._name()))._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv(a)._selector()
,$ctx2.sendIdx["selector"]=1
][0]).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"methods",{})});
}; }),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.name;

}; }),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "name:",
protocol: "accessing",
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.name=aString;
return self;

}; }),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "ownMethods",
protocol: "accessing",
args: [],
source: "ownMethods\x0a\x09^ (self theClass ownMethodsInProtocol: self name)\x0a\x09\x09sorted: [ :a :b | a selector <= b selector ]",
referencedClasses: [],
pragmas: [],
messageSends: ["sorted:", "ownMethodsInProtocol:", "theClass", "name", "<=", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._theClass())._ownMethodsInProtocol_($self._name()))._sorted_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv(a)._selector()
,$ctx2.sendIdx["selector"]=1
][0]).__lt_eq($recv(b)._selector());
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"ownMethods",{})});
}; }),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.ExportMethodProtocol);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.theClass=aClass;
return self;

}; }),
$globals.ExportMethodProtocol);


$core.addMethod(
$core.method({
selector: "name:theClass:",
protocol: "instance creation",
args: ["aString", "aClass"],
source: "name: aString theClass: aClass\x0a\x09^ self new\x0a\x09\x09name: aString;\x0a\x09\x09theClass: aClass;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["name:", "new", "theClass:", "yourself"]
}, function ($methodClass){ return function (aString,aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._name_(aString);
$recv($1)._theClass_(aClass);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"name:theClass:",{aString:aString,aClass:aClass})});
}; }),
$globals.ExportMethodProtocol.a$cls);


$core.addClass("Importer", $globals.Object, "Platform-ImportExport");
$core.setSlots($globals.Importer, ["lastSection", "lastChunk"]);
$globals.Importer.comment="I can import Amber code from a string in the chunk format.\x0a\x0a## API\x0a\x0a    Importer new import: aString";
$core.addMethod(
$core.method({
selector: "import:",
protocol: "fileIn",
args: ["aStream"],
source: "import: aStream\x0a\x09| chunk result parser lastEmpty |\x0a\x09parser := ChunkParser on: aStream.\x0a\x09lastEmpty := false.\x0a\x09lastSection := 'n/a, not started'.\x0a\x09lastChunk := nil.\x0a\x09[\x0a\x09[ chunk := parser nextChunk.\x0a\x09chunk isNil ] whileFalse: [\x0a\x09\x09chunk\x0a\x09\x09\x09ifEmpty: [ lastEmpty := true ]\x0a\x09\x09\x09ifNotEmpty: [\x0a\x09\x09\x09\x09lastSection := chunk.\x0a\x09\x09\x09\x09result := Compiler new evaluateExpression: chunk.\x0a\x09\x09\x09\x09lastEmpty\x0a\x09\x09\x09\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09lastEmpty := false.\x0a\x09\x09\x09\x09\x09\x09\x09\x09\x09result scanFrom: parser ]] ].\x0a\x09lastSection := 'n/a, finished'\x0a\x09] on: Error do: [:e | lastChunk := parser last. e pass ].",
referencedClasses: ["ChunkParser", "Compiler", "Error"],
pragmas: [],
messageSends: ["on:", "on:do:", "whileFalse:", "nextChunk", "isNil", "ifEmpty:ifNotEmpty:", "evaluateExpression:", "new", "ifTrue:", "scanFrom:", "last", "pass"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
var chunk,result,parser,lastEmpty;
return $core.withContext(function($ctx1) {
parser=$recv($globals.ChunkParser)._on_(aStream);
lastEmpty=false;
$self.lastSection="n/a, not started";
$self.lastChunk=nil;
$recv((function(){
return $core.withContext(function($ctx2) {
$recv((function(){
return $core.withContext(function($ctx3) {
chunk=$recv(parser)._nextChunk();
return $recv(chunk)._isNil();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx3) {
return $recv(chunk)._ifEmpty_ifNotEmpty_((function(){
lastEmpty=true;
return lastEmpty;

}),(function(){
return $core.withContext(function($ctx4) {
$self.lastSection=chunk;
result=$recv($recv($globals.Compiler)._new())._evaluateExpression_(chunk);
if($core.assert(lastEmpty)){
lastEmpty=false;
return $recv(result)._scanFrom_(parser);
}
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,5)});
}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$self.lastSection="n/a, finished";
return $self.lastSection;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(e){
return $core.withContext(function($ctx2) {
$self.lastChunk=$recv(parser)._last();
return $recv(e)._pass();
}, function($ctx2) {$ctx2.fillBlock({e:e},$ctx1,7)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"import:",{aStream:aStream,chunk:chunk,result:result,parser:parser,lastEmpty:lastEmpty})});
}; }),
$globals.Importer);

$core.addMethod(
$core.method({
selector: "lastChunk",
protocol: "accessing",
args: [],
source: "lastChunk\x0a\x09^ lastChunk",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.lastChunk;

}; }),
$globals.Importer);

$core.addMethod(
$core.method({
selector: "lastSection",
protocol: "accessing",
args: [],
source: "lastSection\x0a\x09^ lastSection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.lastSection;

}; }),
$globals.Importer);



$core.addClass("PackageCommitError", $globals.Error, "Platform-ImportExport");
$globals.PackageCommitError.comment="I get signaled when an attempt to commit a package has failed.";


$core.addClass("PackageHandler", $globals.Object, "Platform-ImportExport");
$globals.PackageHandler.comment="I am responsible for handling package loading and committing.\x0a\x0aI should not be used directly. Instead, use the corresponding `Package` methods.";
$core.addMethod(
$core.method({
selector: "ajaxPutAt:data:onSuccess:onError:",
protocol: "private",
args: ["aURL", "aString", "aBlock", "anotherBlock"],
source: "ajaxPutAt: aURL data: aString onSuccess: aBlock onError: anotherBlock\x0a\x09| xhr |\x0a\x09xhr := Platform newXhr.\x0a\x09xhr open: 'PUT' url: aURL async: true.\x0a\x09xhr onreadystatechange: [\x0a\x09\x09xhr readyState = 4 ifTrue: [\x0a\x09\x09\x09(xhr status >= 200 and: [ xhr status < 300 ])\x0a\x09\x09\x09\x09ifTrue: aBlock\x0a\x09\x09\x09\x09ifFalse: anotherBlock ]].\x0a\x09xhr send: aString",
referencedClasses: ["Platform"],
pragmas: [],
messageSends: ["newXhr", "open:url:async:", "onreadystatechange:", "ifTrue:", "=", "readyState", "ifTrue:ifFalse:", "and:", ">=", "status", "<", "send:"]
}, function ($methodClass){ return function (aURL,aString,aBlock,anotherBlock){
var self=this,$self=this;
var xhr;
return $core.withContext(function($ctx1) {
var $1;
xhr=$recv($globals.Platform)._newXhr();
$recv(xhr)._open_url_async_("PUT",aURL,true);
$recv(xhr)._onreadystatechange_((function(){
return $core.withContext(function($ctx2) {
if($core.assert($recv($recv(xhr)._readyState()).__eq((4)))){
if($core.assert($recv([$recv(xhr)._status()
,$ctx2.sendIdx["status"]=1
][0]).__gt_eq((200)))){
$1=$recv($recv(xhr)._status()).__lt((300));
} else {
$1=false;
}
return $recv($1)._ifTrue_ifFalse_(aBlock,anotherBlock);
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(xhr)._send_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"ajaxPutAt:data:onSuccess:onError:",{aURL:aURL,aString:aString,aBlock:aBlock,anotherBlock:anotherBlock,xhr:xhr})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "chunkContentsFor:",
protocol: "accessing",
args: ["aPackage"],
source: "chunkContentsFor: aPackage\x0a\x09^ String streamContents: [ :str |\x0a\x09\x09self chunkExporter exportPackage: aPackage on: str ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "exportPackage:on:", "chunkExporter"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $recv($self._chunkExporter())._exportPackage_on_(aPackage,str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"chunkContentsFor:",{aPackage:aPackage})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "chunkExporter",
protocol: "factory",
args: [],
source: "chunkExporter\x0a\x09^ self chunkExporterClass new",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "chunkExporterClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._chunkExporterClass())._new();
}, function($ctx1) {$ctx1.fill(self,"chunkExporter",{})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "chunkExporterClass",
protocol: "accessing",
args: [],
source: "chunkExporterClass\x0a\x09^ ChunkExporter",
referencedClasses: ["ChunkExporter"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.ChunkExporter;

}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commit:",
protocol: "committing",
args: ["aPackage"],
source: "commit: aPackage\x0a\x09self \x0a\x09\x09commit: aPackage\x0a\x09\x09onSuccess: []\x0a\x09\x09onError: [ :error |\x0a\x09\x09\x09PackageCommitError new\x0a\x09\x09\x09\x09messageText: 'Commiting failed with reason: \x22' , (error responseText) , '\x22';\x0a\x09\x09\x09\x09signal ]",
referencedClasses: ["PackageCommitError"],
pragmas: [],
messageSends: ["commit:onSuccess:onError:", "messageText:", "new", ",", "responseText", "signal"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self._commit_onSuccess_onError_(aPackage,(function(){

}),(function(error){
return $core.withContext(function($ctx2) {
$1=$recv($globals.PackageCommitError)._new();
$recv($1)._messageText_([$recv("Commiting failed with reason: \x22".__comma($recv(error)._responseText())).__comma("\x22")
,$ctx2.sendIdx[","]=1
][0]);
return $recv($1)._signal();
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"commit:",{aPackage:aPackage})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commit:onSuccess:onError:",
protocol: "committing",
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commit: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09self \x0a\x09\x09commitJsFileFor: aPackage \x0a\x09\x09onSuccess: [\x0a\x09\x09\x09self \x0a\x09\x09\x09\x09commitStFileFor: aPackage \x0a\x09\x09\x09\x09onSuccess: [ aPackage beClean. aBlock value ]\x0a\x09\x09\x09\x09onError: anotherBlock ] \x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["commitJsFileFor:onSuccess:onError:", "commitStFileFor:onSuccess:onError:", "beClean", "value"]
}, function ($methodClass){ return function (aPackage,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._commitJsFileFor_onSuccess_onError_(aPackage,(function(){
return $core.withContext(function($ctx2) {
return $self._commitStFileFor_onSuccess_onError_(aPackage,(function(){
return $core.withContext(function($ctx3) {
$recv(aPackage)._beClean();
return $recv(aBlock)._value();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),anotherBlock);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commit:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitJsFileFor:onSuccess:onError:",
protocol: "committing",
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commitJsFileFor: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09self \x0a\x09\x09ajaxPutAt: (self commitPathJsFor: aPackage), '/', aPackage name, '.js'\x0a\x09\x09data: (self contentsFor: aPackage)\x0a\x09\x09onSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["ajaxPutAt:data:onSuccess:onError:", ",", "commitPathJsFor:", "name", "contentsFor:"]
}, function ($methodClass){ return function (aPackage,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._ajaxPutAt_data_onSuccess_onError_([$recv([$recv($recv($self._commitPathJsFor_(aPackage)).__comma("/")).__comma($recv(aPackage)._name())
,$ctx1.sendIdx[","]=2
][0]).__comma(".js")
,$ctx1.sendIdx[","]=1
][0],$self._contentsFor_(aPackage),aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitJsFileFor:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitPathJsFor:",
protocol: "accessing",
args: ["aPackage"],
source: "commitPathJsFor: aPackage\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"commitPathJsFor:",{aPackage:aPackage})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitPathStFor:",
protocol: "accessing",
args: ["aPackage"],
source: "commitPathStFor: aPackage\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"commitPathStFor:",{aPackage:aPackage})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "commitStFileFor:onSuccess:onError:",
protocol: "committing",
args: ["aPackage", "aBlock", "anotherBlock"],
source: "commitStFileFor: aPackage onSuccess: aBlock onError: anotherBlock\x0a\x09self \x0a\x09\x09ajaxPutAt: (self commitPathStFor: aPackage), '/', aPackage name, '.st'\x0a\x09\x09data: (self chunkContentsFor: aPackage)\x0a\x09\x09onSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["ajaxPutAt:data:onSuccess:onError:", ",", "commitPathStFor:", "name", "chunkContentsFor:"]
}, function ($methodClass){ return function (aPackage,aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._ajaxPutAt_data_onSuccess_onError_([$recv([$recv($recv($self._commitPathStFor_(aPackage)).__comma("/")).__comma($recv(aPackage)._name())
,$ctx1.sendIdx[","]=2
][0]).__comma(".st")
,$ctx1.sendIdx[","]=1
][0],$self._chunkContentsFor_(aPackage),aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitStFileFor:onSuccess:onError:",{aPackage:aPackage,aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "contentsFor:",
protocol: "accessing",
args: ["aPackage"],
source: "contentsFor: aPackage\x0a\x09^ String streamContents: [ :str |\x0a\x09\x09self exporter exportPackage: aPackage on: str ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "exportPackage:on:", "exporter"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
return $recv($self._exporter())._exportPackage_on_(aPackage,str);
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"contentsFor:",{aPackage:aPackage})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "exporter",
protocol: "factory",
args: [],
source: "exporter\x0a\x09^ self exporterClass new",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "exporterClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._exporterClass())._new();
}, function($ctx1) {$ctx1.fill(self,"exporter",{})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "exporterClass",
protocol: "accessing",
args: [],
source: "exporterClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"exporterClass",{})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "load:",
protocol: "loading",
args: ["aPackage"],
source: "load: aPackage\x0a\x09\x22Should return a TThenable\x22\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"load:",{aPackage:aPackage})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "onCommitError:",
protocol: "error handling",
args: ["anError"],
source: "onCommitError: anError\x0a\x09PackageCommitError new\x0a\x09\x09messageText: 'Commiting failed with reason: \x22' , (anError responseText) , '\x22';\x0a\x09\x09signal",
referencedClasses: ["PackageCommitError"],
pragmas: [],
messageSends: ["messageText:", "new", ",", "responseText", "signal"]
}, function ($methodClass){ return function (anError){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.PackageCommitError)._new();
$recv($1)._messageText_([$recv("Commiting failed with reason: \x22".__comma($recv(anError)._responseText())).__comma("\x22")
,$ctx1.sendIdx[","]=1
][0]);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"onCommitError:",{anError:anError})});
}; }),
$globals.PackageHandler);

$core.addMethod(
$core.method({
selector: "setPath:forPackage:",
protocol: "accessing",
args: ["aString", "aPackage"],
source: "setPath: aString forPackage: aPackage\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aString,aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"setPath:forPackage:",{aString:aString,aPackage:aPackage})});
}; }),
$globals.PackageHandler);



$core.addClass("AmdPackageHandler", $globals.PackageHandler, "Platform-ImportExport");
$globals.AmdPackageHandler.comment="I am responsible for handling package loading and committing.\x0a\x0aI should not be used directly. Instead, use the corresponding `Package` methods.";
$core.addMethod(
$core.method({
selector: "commitPathJsFor:",
protocol: "accessing",
args: ["aPackage"],
source: "commitPathJsFor: aPackage\x0a\x09^ self toUrl: (self namespaceFor: aPackage)",
referencedClasses: [],
pragmas: [],
messageSends: ["toUrl:", "namespaceFor:"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._toUrl_($self._namespaceFor_(aPackage));
}, function($ctx1) {$ctx1.fill(self,"commitPathJsFor:",{aPackage:aPackage})});
}; }),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "commitPathStFor:",
protocol: "accessing",
args: ["aPackage"],
source: "commitPathStFor: aPackage\x0a\x09\x22If _source is not mapped, .st will be committed to .js path.\x0a\x09It is recommended not to use _source as it can be deprecated.\x22\x0a\x09\x0a\x09| path pathWithout |\x0a\x09path := self toUrl: (self namespaceFor: aPackage), '/_source'.\x0a\x09pathWithout := self commitPathJsFor: aPackage.\x0a\x09^ path = (pathWithout, '/_source') ifTrue: [ pathWithout ] ifFalse: [ path ]",
referencedClasses: [],
pragmas: [],
messageSends: ["toUrl:", ",", "namespaceFor:", "commitPathJsFor:", "ifTrue:ifFalse:", "="]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
var path,pathWithout;
return $core.withContext(function($ctx1) {
path=$self._toUrl_([$recv($self._namespaceFor_(aPackage)).__comma("/_source")
,$ctx1.sendIdx[","]=1
][0]);
pathWithout=$self._commitPathJsFor_(aPackage);
if($core.assert($recv(path).__eq($recv(pathWithout).__comma("/_source")))){
return pathWithout;
} else {
return path;
}
}, function($ctx1) {$ctx1.fill(self,"commitPathStFor:",{aPackage:aPackage,path:path,pathWithout:pathWithout})});
}; }),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "exporterClass",
protocol: "accessing",
args: [],
source: "exporterClass\x0a\x09^ AmdExporter",
referencedClasses: ["AmdExporter"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.AmdExporter;

}; }),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "load:",
protocol: "loading",
args: ["aPackage"],
source: "load: aPackage\x0a\x09^ Promise new: [ :model |\x0a\x09\x09Smalltalk amdRequire\x0a\x09\x09\x09ifNil: [ self error: 'AMD loader not present' ]\x0a\x09\x09\x09ifNotNil: [ :require |\x0a\x09\x09\x09\x09require\x0a\x09\x09\x09\x09\x09value: { (self namespaceFor: aPackage), '/', aPackage name }\x0a\x09\x09\x09\x09\x09value: [ :result | model value: result ]\x0a\x09\x09\x09\x09\x09value: [ :error | model signal: error ] ] ]",
referencedClasses: ["Promise", "Smalltalk"],
pragmas: [],
messageSends: ["new:", "ifNil:ifNotNil:", "amdRequire", "error:", "value:value:value:", ",", "namespaceFor:", "name", "value:", "signal:"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($globals.Promise)._new_((function(model){
return $core.withContext(function($ctx2) {
$1=$recv($globals.Smalltalk)._amdRequire();
if($1 == null || $1.a$nil){
return $self._error_("AMD loader not present");
} else {
var require;
require=$1;
return $recv(require)._value_value_value_([[$recv($recv($self._namespaceFor_(aPackage)).__comma("/")).__comma($recv(aPackage)._name())
,$ctx2.sendIdx[","]=1
][0]],(function(result){
return $core.withContext(function($ctx3) {
return $recv(model)._value_(result);
}, function($ctx3) {$ctx3.fillBlock({result:result},$ctx2,4)});
}),(function(error){
return $core.withContext(function($ctx3) {
return $recv(model)._signal_(error);
}, function($ctx3) {$ctx3.fillBlock({error:error},$ctx2,5)});
}));
}
}, function($ctx2) {$ctx2.fillBlock({model:model},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"load:",{aPackage:aPackage})});
}; }),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "namespaceFor:",
protocol: "committing",
args: ["aPackage"],
source: "namespaceFor: aPackage\x0a\x09^ aPackage transport namespace",
referencedClasses: [],
pragmas: [],
messageSends: ["namespace", "transport"]
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aPackage)._transport())._namespace();
}, function($ctx1) {$ctx1.fill(self,"namespaceFor:",{aPackage:aPackage})});
}; }),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "setPath:forPackage:",
protocol: "accessing",
args: ["aString", "aPackage"],
source: "setPath: aString forPackage: aPackage\x0a\x09\x22Set the path the the package's `namespace`\x22\x0a\x09\x0a\x09\x22Smalltalk amdRequire\x0a\x09\x09ifNil: [ self error: 'AMD loader not present' ]\x0a\x09\x09ifNotNil: [ :require |\x22\x0a\x09\x09\x09require provided config: #{\x0a\x09\x09\x09\x09'paths' -> #{\x0a\x09\x09\x09\x09\x09(self namespaceFor: aPackage) -> aString\x0a\x09\x09\x09\x09}\x0a\x09\x09\x09}\x0a\x09\x09\x22]\x22",
referencedClasses: [],
pragmas: [],
messageSends: ["config:", "provided", "namespaceFor:"]
}, function ($methodClass){ return function (aString,aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(require)._provided())._config_($globals.HashedCollection._newFromPairs_(["paths",$globals.HashedCollection._newFromPairs_([$self._namespaceFor_(aPackage),aString])]));
return self;
}, function($ctx1) {$ctx1.fill(self,"setPath:forPackage:",{aString:aString,aPackage:aPackage})});
}; }),
$globals.AmdPackageHandler);

$core.addMethod(
$core.method({
selector: "toUrl:",
protocol: "private",
args: ["aString"],
source: "toUrl: aString\x0a\x09^ Smalltalk amdRequire\x0a\x09\x09ifNil: [ self error: 'AMD loader not present' ]\x0a\x09\x09ifNotNil: [ :require | require provided toUrl: aString ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "amdRequire", "error:", "toUrl:", "provided"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Smalltalk)._amdRequire();
if($1 == null || $1.a$nil){
return $self._error_("AMD loader not present");
} else {
var require;
require=$1;
return $recv($recv(require)._provided())._toUrl_(aString);
}
}, function($ctx1) {$ctx1.fill(self,"toUrl:",{aString:aString})});
}; }),
$globals.AmdPackageHandler);


$core.addMethod(
$core.method({
selector: "defaultNamespace",
protocol: "commit paths",
args: [],
source: "defaultNamespace\x0a\x09^ Smalltalk defaultAmdNamespace",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["defaultAmdNamespace"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._defaultAmdNamespace();
}, function($ctx1) {$ctx1.fill(self,"defaultNamespace",{})});
}; }),
$globals.AmdPackageHandler.a$cls);

$core.addMethod(
$core.method({
selector: "defaultNamespace:",
protocol: "commit paths",
args: ["aString"],
source: "defaultNamespace: aString\x0a\x09Smalltalk defaultAmdNamespace: aString",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["defaultAmdNamespace:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Smalltalk)._defaultAmdNamespace_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"defaultNamespace:",{aString:aString})});
}; }),
$globals.AmdPackageHandler.a$cls);


$core.addClass("PackageTransport", $globals.Object, "Platform-ImportExport");
$core.setSlots($globals.PackageTransport, ["package"]);
$globals.PackageTransport.comment="I represent the transport mechanism used to commit a package.\x0a\x0aMy concrete subclasses have a `#handler` to which committing is delegated.";
$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ #{ 'type' -> self type }",
referencedClasses: [],
pragmas: [],
messageSends: ["type"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $globals.HashedCollection._newFromPairs_(["type",$self._type()]);
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptObject",{})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commit",
protocol: "committing",
args: [],
source: "commit\x0a\x09self commitHandler commit: self package",
referencedClasses: [],
pragmas: [],
messageSends: ["commit:", "commitHandler", "package"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._commitHandler())._commit_($self._package());
return self;
}, function($ctx1) {$ctx1.fill(self,"commit",{})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commitHandler",
protocol: "factory",
args: [],
source: "commitHandler\x0a\x09^ self commitHandlerClass new",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "commitHandlerClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._commitHandlerClass())._new();
}, function($ctx1) {$ctx1.fill(self,"commitHandler",{})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commitHandlerClass",
protocol: "accessing",
args: [],
source: "commitHandlerClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"commitHandlerClass",{})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "commitOnSuccess:onError:",
protocol: "committing",
args: ["aBlock", "anotherBlock"],
source: "commitOnSuccess: aBlock onError: anotherBlock\x0a\x09self commitHandler \x0a\x09\x09commit: self package\x0a\x09\x09onSuccess: aBlock\x0a\x09\x09onError: anotherBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["commit:onSuccess:onError:", "commitHandler", "package"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._commitHandler())._commit_onSuccess_onError_($self._package(),aBlock,anotherBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"commitOnSuccess:onError:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ ''",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "";

}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "load",
protocol: "loading",
args: [],
source: "load\x0a\x09^ ((self commitHandler load: self package)\x0a\x09\x09then: [ Smalltalk postLoad ])\x0a\x09\x09catch: [ :e | Smalltalk postFailedLoad: self package. e pass ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["catch:", "then:", "load:", "commitHandler", "package", "postLoad", "postFailedLoad:", "pass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($self._commitHandler())._load_([$self._package()
,$ctx1.sendIdx["package"]=1
][0]))._then_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Smalltalk)._postLoad();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._catch_((function(e){
return $core.withContext(function($ctx2) {
$recv($globals.Smalltalk)._postFailedLoad_($self._package());
return $recv(e)._pass();
}, function($ctx2) {$ctx2.fillBlock({e:e},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"load",{})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "package",
protocol: "accessing",
args: [],
source: "package\x0a\x09^ package",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.package;

}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "package:",
protocol: "accessing",
args: ["aPackage"],
source: "package: aPackage\x0a\x09package := aPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
$self.package=aPackage;
return self;

}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "setPath:",
protocol: "actions",
args: ["aString"],
source: "setPath: aString\x0a\x09\x22Set the commit path for the package\x22\x0a\x0a\x09self commitHandler setPath: aString forPackage: package",
referencedClasses: [],
pragmas: [],
messageSends: ["setPath:forPackage:", "commitHandler"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._commitHandler())._setPath_forPackage_(aString,$self.package);
return self;
}, function($ctx1) {$ctx1.fill(self,"setPath:",{aString:aString})});
}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "setupFromJson:",
protocol: "initialization",
args: ["anObject"],
source: "setupFromJson: anObject\x0a\x09\x22no op. override if needed in subclasses\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return self;

}; }),
$globals.PackageTransport);

$core.addMethod(
$core.method({
selector: "type",
protocol: "accessing",
args: [],
source: "type\x0a\x09^ self class type",
referencedClasses: [],
pragmas: [],
messageSends: ["type", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._type();
}, function($ctx1) {$ctx1.fill(self,"type",{})});
}; }),
$globals.PackageTransport);


$core.setSlots($globals.PackageTransport.a$cls, ["registry"]);
$core.addMethod(
$core.method({
selector: "classRegisteredFor:",
protocol: "accessing",
args: ["aString"],
source: "classRegisteredFor: aString\x0a\x09^ registry at: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["at:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.registry)._at_(aString);
}, function($ctx1) {$ctx1.fill(self,"classRegisteredFor:",{aString:aString})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "defaultType",
protocol: "accessing",
args: [],
source: "defaultType\x0a\x09^ AmdPackageTransport type",
referencedClasses: ["AmdPackageTransport"],
pragmas: [],
messageSends: ["type"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.AmdPackageTransport)._type();
}, function($ctx1) {$ctx1.fill(self,"defaultType",{})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "for:",
protocol: "instance creation",
args: ["aString"],
source: "for: aString\x0a\x09^ (self classRegisteredFor: aString) new",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "classRegisteredFor:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._classRegisteredFor_(aString))._new();
}, function($ctx1) {$ctx1.fill(self,"for:",{aString:aString})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "fromJson:",
protocol: "instance creation",
args: ["anObject"],
source: "fromJson: anObject\x0a\x09anObject ifNil: [ ^ self for: self defaultType ].\x0a\x09\x0a\x09^ (self for: anObject type)\x0a\x09\x09setupFromJson: anObject;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "for:", "defaultType", "setupFromJson:", "type", "yourself"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if(anObject == null || anObject.a$nil){
return [$self._for_($self._defaultType())
,$ctx1.sendIdx["for:"]=1
][0];
} else {
anObject;
}
$1=$self._for_($recv(anObject)._type());
$recv($1)._setupFromJson_(anObject);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"fromJson:",{anObject:anObject})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09self == PackageTransport\x0a\x09\x09ifTrue: [ registry := #{} ]\x0a\x09\x09ifFalse: [ self register ]",
referencedClasses: ["PackageTransport"],
pragmas: [],
messageSends: ["initialize", "ifTrue:ifFalse:", "==", "register"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
if($core.assert($self.__eq_eq($globals.PackageTransport))){
$self.registry=$globals.HashedCollection._newFromPairs_([]);
$self.registry;
} else {
$self._register();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "register",
protocol: "registration",
args: [],
source: "register\x0a\x09PackageTransport register: self",
referencedClasses: ["PackageTransport"],
pragmas: [],
messageSends: ["register:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.PackageTransport)._register_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"register",{})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "register:",
protocol: "registration",
args: ["aClass"],
source: "register: aClass\x0a\x09aClass type ifNotNil: [\x0a\x09\x09registry at: aClass type put: aClass ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "type", "at:put:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$recv(aClass)._type()
,$ctx1.sendIdx["type"]=1
][0];
if($1 == null || $1.a$nil){
$1;
} else {
$recv($self.registry)._at_put_($recv(aClass)._type(),aClass);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"register:",{aClass:aClass})});
}; }),
$globals.PackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "type",
protocol: "accessing",
args: [],
source: "type\x0a\x09\x22Override in subclasses\x22\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.PackageTransport.a$cls);


$core.addClass("AmdPackageTransport", $globals.PackageTransport, "Platform-ImportExport");
$core.setSlots($globals.AmdPackageTransport, ["namespace"]);
$globals.AmdPackageTransport.comment="I am the default transport for committing packages.\x0a\x0aSee `AmdExporter` and `AmdPackageHandler`.";
$core.addMethod(
$core.method({
selector: "asJavaScriptObject",
protocol: "converting",
args: [],
source: "asJavaScriptObject\x0a\x09^ super asJavaScriptObject\x0a\x09\x09at: 'amdNamespace' put: self namespace;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "asJavaScriptObject", "namespace", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._asJavaScriptObject.call($self))
,$ctx1.supercall = false
][0];
$recv($1)._at_put_("amdNamespace",$self._namespace());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"asJavaScriptObject",{})});
}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "commitHandlerClass",
protocol: "accessing",
args: [],
source: "commitHandlerClass\x0a\x09^ AmdPackageHandler",
referencedClasses: ["AmdPackageHandler"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.AmdPackageHandler;

}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "defaultNamespace",
protocol: "defaults",
args: [],
source: "defaultNamespace\x0a\x09^ Smalltalk defaultAmdNamespace",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["defaultAmdNamespace"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._defaultAmdNamespace();
}, function($ctx1) {$ctx1.fill(self,"defaultNamespace",{})});
}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "definition",
protocol: "accessing",
args: [],
source: "definition\x0a\x09^ String streamContents: [ :stream | stream \x0a\x09\x09write: { self class name. ' namespace: ' }; print: self namespace ]",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["streamContents:", "write:", "name", "class", "print:", "namespace"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.String)._streamContents_((function(stream){
return $core.withContext(function($ctx2) {
$recv(stream)._write_([$recv($self._class())._name()," namespace: "]);
return $recv(stream)._print_($self._namespace());
}, function($ctx2) {$ctx2.fillBlock({stream:stream},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"definition",{})});
}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "namespace",
protocol: "accessing",
args: [],
source: "namespace\x0a\x09^ namespace ifNil: [ self defaultNamespace ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "defaultNamespace"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.namespace;
if($1 == null || $1.a$nil){
return $self._defaultNamespace();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"namespace",{})});
}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "namespace:",
protocol: "accessing",
args: ["aString"],
source: "namespace: aString\x0a\x09namespace := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.namespace=aString;
return self;

}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "printOn:",
protocol: "printing",
args: ["aStream"],
source: "printOn: aStream\x0a\x09super printOn: aStream.\x0a\x09aStream\x0a\x09\x09nextPutAll: ' (AMD Namespace: ';\x0a\x09\x09nextPutAll: self namespace;\x0a\x09\x09nextPutAll: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["printOn:", "nextPutAll:", "namespace"]
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._printOn_.call($self,aStream))
,$ctx1.supercall = false
][0];
[$recv(aStream)._nextPutAll_(" (AMD Namespace: ")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aStream)._nextPutAll_($self._namespace())
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv(aStream)._nextPutAll_(")");
return self;
}, function($ctx1) {$ctx1.fill(self,"printOn:",{aStream:aStream})});
}; }),
$globals.AmdPackageTransport);

$core.addMethod(
$core.method({
selector: "setupFromJson:",
protocol: "initialization",
args: ["anObject"],
source: "setupFromJson: anObject\x0a\x09self namespace: (anObject at: 'amdNamespace')",
referencedClasses: [],
pragmas: [],
messageSends: ["namespace:", "at:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._namespace_($recv(anObject)._at_("amdNamespace"));
return self;
}, function($ctx1) {$ctx1.fill(self,"setupFromJson:",{anObject:anObject})});
}; }),
$globals.AmdPackageTransport);


$core.addMethod(
$core.method({
selector: "namespace:",
protocol: "instance creation",
args: ["aString"],
source: "namespace: aString\x0a\x09^ self new\x0a\x09\x09namespace: aString;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["namespace:", "new", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._namespace_(aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"namespace:",{aString:aString})});
}; }),
$globals.AmdPackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "type",
protocol: "accessing",
args: [],
source: "type\x0a\x09^ 'amd'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "amd";

}; }),
$globals.AmdPackageTransport.a$cls);

$core.addMethod(
$core.method({
selector: "exportBehaviorDefinitionTo:using:",
protocol: "*Platform-ImportExport",
args: ["aStream", "anExporter"],
source: "exportBehaviorDefinitionTo: aStream using: anExporter\x0a\x09anExporter exportDefinitionOf: self on: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["exportDefinitionOf:on:"]
}, function ($methodClass){ return function (aStream,anExporter){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anExporter)._exportDefinitionOf_on_(self,aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportBehaviorDefinitionTo:using:",{aStream:aStream,anExporter:anExporter})});
}; }),
$globals.Class);

$core.addMethod(
$core.method({
selector: "exportBehaviorDefinitionTo:using:",
protocol: "*Platform-ImportExport",
args: ["aStream", "anExporter"],
source: "exportBehaviorDefinitionTo: aStream using: anExporter\x0a\x09anExporter exportMetaDefinitionOf: self instanceClass on: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["exportMetaDefinitionOf:on:", "instanceClass"]
}, function ($methodClass){ return function (aStream,anExporter){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anExporter)._exportMetaDefinitionOf_on_($self._instanceClass(),aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportBehaviorDefinitionTo:using:",{aStream:aStream,anExporter:anExporter})});
}; }),
$globals.Metaclass);

$core.addMethod(
$core.method({
selector: "commit",
protocol: "*Platform-ImportExport",
args: [],
source: "commit\x0a\x09^ self transport commit",
referencedClasses: [],
pragmas: [],
messageSends: ["commit", "transport"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._transport())._commit();
}, function($ctx1) {$ctx1.fill(self,"commit",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "load",
protocol: "*Platform-ImportExport",
args: [],
source: "load\x0a\x09^ self transport load",
referencedClasses: [],
pragmas: [],
messageSends: ["load", "transport"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._transport())._load();
}, function($ctx1) {$ctx1.fill(self,"load",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "loadFromNamespace:",
protocol: "*Platform-ImportExport",
args: ["aString"],
source: "loadFromNamespace: aString\x0a\x09^ self transport\x0a\x09\x09namespace: aString;\x0a\x09\x09load",
referencedClasses: [],
pragmas: [],
messageSends: ["namespace:", "transport", "load"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._transport();
$recv($1)._namespace_(aString);
return $recv($1)._load();
}, function($ctx1) {$ctx1.fill(self,"loadFromNamespace:",{aString:aString})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "load:",
protocol: "*Platform-ImportExport",
args: ["aPackageName"],
source: "load: aPackageName\x0a\x09^ (self named: aPackageName) load",
referencedClasses: [],
pragmas: [],
messageSends: ["load", "named:"]
}, function ($methodClass){ return function (aPackageName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._named_(aPackageName))._load();
}, function($ctx1) {$ctx1.fill(self,"load:",{aPackageName:aPackageName})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "load:fromNamespace:",
protocol: "*Platform-ImportExport",
args: ["aPackageName", "aString"],
source: "load: aPackageName fromNamespace: aString\x0a\x09^ (self named: aPackageName) loadFromNamespace: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["loadFromNamespace:", "named:"]
}, function ($methodClass){ return function (aPackageName,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._named_(aPackageName))._loadFromNamespace_(aString);
}, function($ctx1) {$ctx1.fill(self,"load:fromNamespace:",{aPackageName:aPackageName,aString:aString})});
}; }),
$globals.Package.a$cls);

$core.addMethod(
$core.method({
selector: "methodsFor:",
protocol: "*Platform-ImportExport",
args: ["aString"],
source: "methodsFor: aString\x0a\x09^ ClassProtocolReader new\x0a\x09\x09class: self category: aString;\x0a\x09\x09yourself",
referencedClasses: ["ClassProtocolReader"],
pragmas: [],
messageSends: ["class:category:", "new", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ClassProtocolReader)._new();
$recv($1)._class_category_(self,aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"methodsFor:",{aString:aString})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "methodsFor:stamp:",
protocol: "*Platform-ImportExport",
args: ["aString", "aStamp"],
source: "methodsFor: aString stamp: aStamp\x0a\x09\x22Added for file-in compatibility, ignores stamp.\x22\x0a\x09^ self methodsFor: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["methodsFor:"]
}, function ($methodClass){ return function (aString,aStamp){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._methodsFor_(aString);
}, function($ctx1) {$ctx1.fill(self,"methodsFor:stamp:",{aString:aString,aStamp:aStamp})});
}; }),
$globals.TBehaviorProvider);

$core.addMethod(
$core.method({
selector: "commentStamp",
protocol: "*Platform-ImportExport",
args: [],
source: "commentStamp\x0a\x09^ ClassCommentReader new\x0a\x09class: self;\x0a\x09yourself",
referencedClasses: ["ClassCommentReader"],
pragmas: [],
messageSends: ["class:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ClassCommentReader)._new();
$recv($1)._class_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"commentStamp",{})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "commentStamp:prior:",
protocol: "*Platform-ImportExport",
args: ["aStamp", "prior"],
source: "commentStamp: aStamp prior: prior\x0a\x09\x09^ self commentStamp",
referencedClasses: [],
pragmas: [],
messageSends: ["commentStamp"]
}, function ($methodClass){ return function (aStamp,prior){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._commentStamp();
}, function($ctx1) {$ctx1.fill(self,"commentStamp:prior:",{aStamp:aStamp,prior:prior})});
}; }),
$globals.TMasterBehavior);

$core.addMethod(
$core.method({
selector: "exportBehaviorDefinitionTo:using:",
protocol: "*Platform-ImportExport",
args: ["aStream", "anExporter"],
source: "exportBehaviorDefinitionTo: aStream using: anExporter\x0a\x09anExporter exportTraitDefinitionOf: self on: aStream",
referencedClasses: [],
pragmas: [],
messageSends: ["exportTraitDefinitionOf:on:"]
}, function ($methodClass){ return function (aStream,anExporter){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anExporter)._exportTraitDefinitionOf_on_(self,aStream);
return self;
}, function($ctx1) {$ctx1.fill(self,"exportBehaviorDefinitionTo:using:",{aStream:aStream,anExporter:anExporter})});
}; }),
$globals.Trait);

});

define('amber/core/Compiler-Core',["amber/boot", "require", "amber/core/Kernel-Collections", "amber/core/Kernel-Exceptions", "amber/core/Kernel-Infrastructure", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-Core");
$pkg.context = function () { return {smalltalkParser:smalltalkParser}; };
$pkg.imports = ["smalltalkParser=amber/parser"];
var smalltalkParser;
$pkg.isReady = new Promise(function (resolve, reject) { requirejs(["amber/parser"], function ($1) {smalltalkParser=$1; resolve();}, reject); });
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AbstractCodeGenerator", $globals.Object, "Compiler-Core");
$core.setSlots($globals.AbstractCodeGenerator, ["currentClass", "currentPackage", "source"]);
$globals.AbstractCodeGenerator.comment="I am the abstract super class of all code generators and provide their common API.";
$core.addMethod(
$core.method({
selector: "compileNode:",
protocol: "compiling",
args: ["aNode"],
source: "compileNode: aNode\x0a\x09^ self transformers\x0a\x09\x09inject: aNode\x0a\x09\x09into: [ :input :transformer | transformer value: input ]",
referencedClasses: [],
pragmas: [],
messageSends: ["inject:into:", "transformers", "value:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._transformers())._inject_into_(aNode,(function(input,transformer){
return $core.withContext(function($ctx2) {
return $recv(transformer)._value_(input);
}, function($ctx2) {$ctx2.fillBlock({input:input,transformer:transformer},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"compileNode:",{aNode:aNode})});
}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentClass",
protocol: "accessing",
args: [],
source: "currentClass\x0a\x09^ currentClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.currentClass;

}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentClass:",
protocol: "accessing",
args: ["aClass"],
source: "currentClass: aClass\x0a\x09currentClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.currentClass=aClass;
return self;

}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentPackage",
protocol: "accessing",
args: [],
source: "currentPackage\x0a\x09^ currentPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.currentPackage;

}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "currentPackage:",
protocol: "accessing",
args: ["anObject"],
source: "currentPackage: anObject\x0a\x09currentPackage := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.currentPackage=anObject;
return self;

}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "pseudoVariables",
protocol: "accessing",
args: [],
source: "pseudoVariables\x0a\x09^ Smalltalk pseudoVariableNames",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["pseudoVariableNames"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Smalltalk)._pseudoVariableNames();
}, function($ctx1) {$ctx1.fill(self,"pseudoVariables",{})});
}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "source",
protocol: "accessing",
args: [],
source: "source\x0a\x09^ source ifNil: [ '' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.source;
if($1 == null || $1.a$nil){
return "";
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"source",{})});
}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "source:",
protocol: "accessing",
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.source=aString;
return self;

}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "transformers",
protocol: "compiling",
args: [],
source: "transformers\x0a\x09| dict |\x0a\x09dict := self transformersDictionary.\x0a\x09^ dict keys asArray sort collect: [ :each | dict at: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["transformersDictionary", "collect:", "sort", "asArray", "keys", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var dict;
return $core.withContext(function($ctx1) {
dict=$self._transformersDictionary();
return $recv($recv($recv($recv(dict)._keys())._asArray())._sort())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(dict)._at_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"transformers",{dict:dict})});
}; }),
$globals.AbstractCodeGenerator);

$core.addMethod(
$core.method({
selector: "transformersDictionary",
protocol: "compiling",
args: [],
source: "transformersDictionary\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"transformersDictionary",{})});
}; }),
$globals.AbstractCodeGenerator);



$core.addClass("AstGenerator", $globals.AbstractCodeGenerator, "Compiler-Core");
$core.setSlots($globals.AstGenerator, ["transformersDictionary"]);
$globals.AstGenerator.comment="I am a very basic code generator.\x0aI generate semantically augmented abstract syntax tree,\x0aSome initial pragmas (eg. #inlineJS:) are applied to transform the tree.";
$core.addMethod(
$core.method({
selector: "semanticAnalyzer",
protocol: "compiling",
args: [],
source: "semanticAnalyzer\x0a\x09^ (SemanticAnalyzer on: self currentClass)\x0a\x09\x09thePackage: self currentPackage;\x0a\x09\x09yourself",
referencedClasses: ["SemanticAnalyzer"],
pragmas: [],
messageSends: ["thePackage:", "on:", "currentClass", "currentPackage", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.SemanticAnalyzer)._on_($self._currentClass());
$recv($1)._thePackage_($self._currentPackage());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"semanticAnalyzer",{})});
}; }),
$globals.AstGenerator);

$core.addMethod(
$core.method({
selector: "semanticAstPragmator",
protocol: "compiling",
args: [],
source: "semanticAstPragmator\x0a\x09^ AstSemanticPragmator new",
referencedClasses: ["AstSemanticPragmator"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.AstSemanticPragmator)._new();
}, function($ctx1) {$ctx1.fill(self,"semanticAstPragmator",{})});
}; }),
$globals.AstGenerator);

$core.addMethod(
$core.method({
selector: "transformersDictionary",
protocol: "compiling",
args: [],
source: "transformersDictionary\x0a\x09^ transformersDictionary ifNil: [ transformersDictionary := Dictionary new\x0a\x09\x09at: '2000-semantic' put: self semanticAnalyzer;\x0a\x09\x09at: '2500-semanticPragmas' put: self semanticAstPragmator;\x0a\x09\x09yourself ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "at:put:", "new", "semanticAnalyzer", "semanticAstPragmator", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.transformersDictionary;
if($1 == null || $1.a$nil){
$2=$recv($globals.Dictionary)._new();
[$recv($2)._at_put_("2000-semantic",$self._semanticAnalyzer())
,$ctx1.sendIdx["at:put:"]=1
][0];
$recv($2)._at_put_("2500-semanticPragmas",$self._semanticAstPragmator());
$self.transformersDictionary=$recv($2)._yourself();
return $self.transformersDictionary;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"transformersDictionary",{})});
}; }),
$globals.AstGenerator);



$core.addClass("CodeGenerator", $globals.AstGenerator, "Compiler-Core");
$globals.CodeGenerator.comment="I am a basic code generator. I generate a valid JavaScript output, but do not perform any inlining.\x0aSee `InliningCodeGenerator` for an optimized JavaScript code generation.";
$core.addMethod(
$core.method({
selector: "irTranslator",
protocol: "compiling",
args: [],
source: "irTranslator\x0a\x09^ self irTranslatorClass new\x0a\x09\x09currentClass: self currentClass;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["currentClass:", "new", "irTranslatorClass", "currentClass", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($self._irTranslatorClass())._new();
$recv($1)._currentClass_($self._currentClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"irTranslator",{})});
}; }),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "irTranslatorClass",
protocol: "compiling",
args: [],
source: "irTranslatorClass\x0a\x09^ IRJSTranslator",
referencedClasses: ["IRJSTranslator"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.IRJSTranslator;

}; }),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "lateIRPragmator",
protocol: "compiling",
args: [],
source: "lateIRPragmator\x0a\x09^ IRLatePragmator new",
referencedClasses: ["IRLatePragmator"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRLatePragmator)._new();
}, function($ctx1) {$ctx1.fill(self,"lateIRPragmator",{})});
}; }),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "transformersDictionary",
protocol: "compiling",
args: [],
source: "transformersDictionary\x0a\x09^ transformersDictionary ifNil: [ transformersDictionary := super transformersDictionary\x0a\x09\x09at: '5000-astToIr' put: self translator;\x0a\x09\x09at: '7000-irLatePragmas' put: self lateIRPragmator;\x0a\x09\x09at: '8000-irToJs' put: self irTranslator;\x0a\x09\x09yourself ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "at:put:", "transformersDictionary", "translator", "lateIRPragmator", "irTranslator", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.transformersDictionary;
if($1 == null || $1.a$nil){
$2=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._transformersDictionary.call($self))
,$ctx1.supercall = false
][0];
[$recv($2)._at_put_("5000-astToIr",$self._translator())
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($2)._at_put_("7000-irLatePragmas",$self._lateIRPragmator())
,$ctx1.sendIdx["at:put:"]=2
][0];
$recv($2)._at_put_("8000-irToJs",$self._irTranslator());
$self.transformersDictionary=$recv($2)._yourself();
return $self.transformersDictionary;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"transformersDictionary",{})});
}; }),
$globals.CodeGenerator);

$core.addMethod(
$core.method({
selector: "translator",
protocol: "compiling",
args: [],
source: "translator\x0a\x09^ IRASTTranslator new\x0a\x09\x09source: self source;\x0a\x09\x09theClass: self currentClass;\x0a\x09\x09yourself",
referencedClasses: ["IRASTTranslator"],
pragmas: [],
messageSends: ["source:", "new", "source", "theClass:", "currentClass", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRASTTranslator)._new();
$recv($1)._source_($self._source());
$recv($1)._theClass_($self._currentClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"translator",{})});
}; }),
$globals.CodeGenerator);



$core.addClass("Compiler", $globals.Object, "Compiler-Core");
$core.setSlots($globals.Compiler, ["currentPackage", "codeGeneratorClass", "codeGenerator"]);
$globals.Compiler.comment="I provide the public interface for compiling Amber source code into JavaScript.\x0a\x0aThe code generator used to produce JavaScript can be plugged with `#codeGeneratorClass`.\x0aThe default code generator is an instance of `InlinedCodeGenerator`";
$core.addMethod(
$core.method({
selector: "ast:forClass:protocol:",
protocol: "compiling",
args: ["aString", "aClass", "anotherString"],
source: "ast: aString forClass: aClass protocol: anotherString\x0a\x09^ self\x0a\x09\x09codeGeneratorClass: AstGenerator;\x0a\x09\x09start: aString forClass: aClass protocol: anotherString;\x0a\x09\x09compileNode: (self parse: aString)",
referencedClasses: ["AstGenerator"],
pragmas: [],
messageSends: ["codeGeneratorClass:", "start:forClass:protocol:", "compileNode:", "parse:"]
}, function ($methodClass){ return function (aString,aClass,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._codeGeneratorClass_($globals.AstGenerator);
$self._start_forClass_protocol_(aString,aClass,anotherString);
return $self._compileNode_($self._parse_(aString));
}, function($ctx1) {$ctx1.fill(self,"ast:forClass:protocol:",{aString:aString,aClass:aClass,anotherString:anotherString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "basicParse:",
protocol: "private",
args: ["aString"],
source: "basicParse: aString\x0a\x09^ smalltalkParser parse: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["parse:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(smalltalkParser)._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"basicParse:",{aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "cleanCodeGenerator",
protocol: "accessing",
args: [],
source: "cleanCodeGenerator\x0a\x09codeGenerator := nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
$self.codeGenerator=nil;
return self;

}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "codeGenerator",
protocol: "accessing",
args: [],
source: "codeGenerator\x0a\x09^ codeGenerator",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.codeGenerator;

}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "codeGenerator:",
protocol: "accessing",
args: ["anObject"],
source: "codeGenerator: anObject\x0a\x09codeGenerator := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.codeGenerator=anObject;
return self;

}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: "accessing",
args: [],
source: "codeGeneratorClass\x0a\x09^ codeGeneratorClass ifNil: [ InliningCodeGenerator ]",
referencedClasses: ["InliningCodeGenerator"],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.codeGeneratorClass;
if($1 == null || $1.a$nil){
return $globals.InliningCodeGenerator;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"codeGeneratorClass",{})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "codeGeneratorClass:",
protocol: "accessing",
args: ["aClass"],
source: "codeGeneratorClass: aClass\x0a\x09codeGeneratorClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.codeGeneratorClass=aClass;
return self;

}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "compile:forClass:protocol:",
protocol: "compiling",
args: ["aString", "aClass", "anotherString"],
source: "compile: aString forClass: aClass protocol: anotherString\x0a\x09| sanitizedSource compilationResult result pragmas closureFactory |\x0a\x09sanitizedSource := aString crlfSanitized.\x0a\x09compilationResult := self\x0a\x09\x09start: sanitizedSource forClass: aClass protocol: anotherString;\x0a\x09\x09compileNode: (self parse: sanitizedSource).\x0a\x09closureFactory := self\x0a\x09\x09eval: (self wrappedSourceOf: compilationResult)\x0a\x09\x09forPackage: self currentPackage.\x0a\x09result := Smalltalk core method: #{\x0a\x09\x09#selector -> compilationResult selector.\x0a\x09\x09#protocol -> anotherString.\x0a\x09\x09#source -> sanitizedSource.\x0a\x09\x09#messageSends -> compilationResult messageSends asArray.\x0a\x09\x09#args -> compilationResult arguments.\x0a\x09\x09#referencedClasses -> compilationResult classReferences asArray.\x0a\x09} withFactory: closureFactory.\x0a\x09result pragmas: compilationResult pragmas.\x0a\x09^ result",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["crlfSanitized", "start:forClass:protocol:", "compileNode:", "parse:", "eval:forPackage:", "wrappedSourceOf:", "currentPackage", "method:withFactory:", "core", "selector", "asArray", "messageSends", "arguments", "classReferences", "pragmas:", "pragmas"]
}, function ($methodClass){ return function (aString,aClass,anotherString){
var self=this,$self=this;
var sanitizedSource,compilationResult,result,pragmas,closureFactory;
return $core.withContext(function($ctx1) {
sanitizedSource=$recv(aString)._crlfSanitized();
$self._start_forClass_protocol_(sanitizedSource,aClass,anotherString);
compilationResult=$self._compileNode_($self._parse_(sanitizedSource));
closureFactory=$self._eval_forPackage_($self._wrappedSourceOf_(compilationResult),$self._currentPackage());
result=$recv($recv($globals.Smalltalk)._core())._method_withFactory_($globals.HashedCollection._newFromPairs_(["selector",$recv(compilationResult)._selector(),"protocol",anotherString,"source",sanitizedSource,"messageSends",[$recv($recv(compilationResult)._messageSends())._asArray()
,$ctx1.sendIdx["asArray"]=1
][0],"args",$recv(compilationResult)._arguments(),"referencedClasses",$recv($recv(compilationResult)._classReferences())._asArray()]),closureFactory);
$recv(result)._pragmas_($recv(compilationResult)._pragmas());
return result;
}, function($ctx1) {$ctx1.fill(self,"compile:forClass:protocol:",{aString:aString,aClass:aClass,anotherString:anotherString,sanitizedSource:sanitizedSource,compilationResult:compilationResult,result:result,pragmas:pragmas,closureFactory:closureFactory})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "compileNode:",
protocol: "compiling",
args: ["aNode"],
source: "compileNode: aNode\x0a    | result |\x0a\x09result := self codeGenerator compileNode: aNode.\x0a\x09self cleanCodeGenerator.\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["compileNode:", "codeGenerator", "cleanCodeGenerator"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
result=$recv($self._codeGenerator())._compileNode_(aNode);
$self._cleanCodeGenerator();
return result;
}, function($ctx1) {$ctx1.fill(self,"compileNode:",{aNode:aNode,result:result})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "currentPackage",
protocol: "accessing",
args: [],
source: "currentPackage\x0a\x09^ currentPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.currentPackage;

}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "currentPackage:",
protocol: "accessing",
args: ["anObject"],
source: "currentPackage: anObject\x0a\x09currentPackage := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.currentPackage=anObject;
return self;

}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "error:",
protocol: "error handling",
args: ["aString"],
source: "error: aString\x0a\x09CompilerError signal: aString",
referencedClasses: ["CompilerError"],
pragmas: [],
messageSends: ["signal:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.CompilerError)._signal_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"error:",{aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: "compiling",
args: ["aString"],
source: "eval: aString\x0a\x09<inlineJS: 'return eval(aString)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return eval(aString)"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return eval(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"eval:",{aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "eval:forPackage:",
protocol: "compiling",
args: ["aString", "aPackage"],
source: "eval: aString forPackage: aPackage\x0a\x09^ aPackage\x0a\x09\x09ifNil: [ self eval: aString ]\x0a\x09\x09ifNotNil: [ aPackage eval: aString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "eval:"]
}, function ($methodClass){ return function (aString,aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(aPackage == null || aPackage.a$nil){
return [$self._eval_(aString)
,$ctx1.sendIdx["eval:"]=1
][0];
} else {
return $recv(aPackage)._eval_(aString);
}
}, function($ctx1) {$ctx1.fill(self,"eval:forPackage:",{aString:aString,aPackage:aPackage})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "evaluateExpression:",
protocol: "compiling",
args: ["aString"],
source: "evaluateExpression: aString\x0a\x09\x22Unlike #eval: evaluate a Smalltalk expression and answer the returned object\x22\x0a\x09^ self evaluateExpression: aString on: DoIt new",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["evaluateExpression:on:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._evaluateExpression_on_(aString,$recv($globals.DoIt)._new());
}, function($ctx1) {$ctx1.fill(self,"evaluateExpression:",{aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "evaluateExpression:on:",
protocol: "compiling",
args: ["aString", "anObject"],
source: "evaluateExpression: aString on: anObject\x0a\x09\x22Unlike #eval: evaluate a Smalltalk expression with anObject as the receiver and answer the returned object\x22\x0a\x09| result method |\x0a\x09method := self\x0a\x09\x09install: (self sourceForExpression: aString)\x0a\x09\x09forClass: anObject class\x0a\x09\x09protocol: '**xxxDoIt'.\x0a\x09result := anObject xxxDoIt.\x0a\x09anObject class removeCompiledMethod: method.\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["install:forClass:protocol:", "sourceForExpression:", "class", "xxxDoIt", "removeCompiledMethod:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
var result,method;
return $core.withContext(function($ctx1) {
method=$self._install_forClass_protocol_($self._sourceForExpression_(aString),[$recv(anObject)._class()
,$ctx1.sendIdx["class"]=1
][0],"**xxxDoIt");
result=$recv(anObject)._xxxDoIt();
$recv($recv(anObject)._class())._removeCompiledMethod_(method);
return result;
}, function($ctx1) {$ctx1.fill(self,"evaluateExpression:on:",{aString:aString,anObject:anObject,result:result,method:method})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "install:forClass:protocol:",
protocol: "compiling",
args: ["aString", "aBehavior", "anotherString"],
source: "install: aString forClass: aBehavior protocol: anotherString\x0a\x09| compiledMethod |\x0a\x09compiledMethod := self compile: aString forClass: aBehavior protocol: anotherString.\x0a\x09aBehavior addCompiledMethod: compiledMethod.\x0a\x09^ compiledMethod",
referencedClasses: [],
pragmas: [],
messageSends: ["compile:forClass:protocol:", "addCompiledMethod:"]
}, function ($methodClass){ return function (aString,aBehavior,anotherString){
var self=this,$self=this;
var compiledMethod;
return $core.withContext(function($ctx1) {
compiledMethod=$self._compile_forClass_protocol_(aString,aBehavior,anotherString);
$recv(aBehavior)._addCompiledMethod_(compiledMethod);
return compiledMethod;
}, function($ctx1) {$ctx1.fill(self,"install:forClass:protocol:",{aString:aString,aBehavior:aBehavior,anotherString:anotherString,compiledMethod:compiledMethod})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: "compiling",
args: ["aString"],
source: "parse: aString\x0a\x09| result |\x0a\x09\x0a\x09[ result := self basicParse: aString ] \x0a\x09\x09tryCatch: [ :ex | (self parseError: ex parsing: aString) signal ].\x0a\x09\x09\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: ["tryCatch:", "basicParse:", "signal", "parseError:parsing:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
result=$self._basicParse_(aString);
return result;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._tryCatch_((function(ex){
return $core.withContext(function($ctx2) {
return $recv($self._parseError_parsing_(ex,aString))._signal();
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,2)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString,result:result})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "parseError:parsing:",
protocol: "error handling",
args: ["anException", "aString"],
source: "parseError: anException parsing: aString\x0a\x09(anException basicAt: 'location')\x0a\x09\x09ifNil: [ ^ anException pass ]\x0a\x09\x09ifNotNil: [ :loc |\x0a\x09\x09\x09^ ParseError new \x0a\x09\x09\x09\x09messageText: \x0a\x09\x09\x09\x09\x09'Parse error on line ', loc start line asString,\x0a\x09\x09\x09\x09\x09' column ' , loc start column asString,\x0a\x09\x09\x09\x09\x09' : Unexpected character ', (anException basicAt: 'found');\x0a\x09\x09\x09\x09yourself ]",
referencedClasses: ["ParseError"],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "basicAt:", "pass", "messageText:", "new", ",", "asString", "line", "start", "column", "yourself"]
}, function ($methodClass){ return function (anException,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$recv(anException)._basicAt_("location")
,$ctx1.sendIdx["basicAt:"]=1
][0];
if($1 == null || $1.a$nil){
return $recv(anException)._pass();
} else {
var loc;
loc=$1;
$2=$recv($globals.ParseError)._new();
$recv($2)._messageText_([$recv([$recv([$recv([$recv("Parse error on line ".__comma([$recv($recv([$recv(loc)._start()
,$ctx1.sendIdx["start"]=1
][0])._line())._asString()
,$ctx1.sendIdx["asString"]=1
][0])).__comma(" column ")
,$ctx1.sendIdx[","]=4
][0]).__comma($recv($recv($recv(loc)._start())._column())._asString())
,$ctx1.sendIdx[","]=3
][0]).__comma(" : Unexpected character ")
,$ctx1.sendIdx[","]=2
][0]).__comma($recv(anException)._basicAt_("found"))
,$ctx1.sendIdx[","]=1
][0]);
return $recv($2)._yourself();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"parseError:parsing:",{anException:anException,aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "parseExpression:",
protocol: "compiling",
args: ["aString"],
source: "parseExpression: aString\x0a\x09^ self parse: (self sourceForExpression: aString)",
referencedClasses: [],
pragmas: [],
messageSends: ["parse:", "sourceForExpression:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._parse_($self._sourceForExpression_(aString));
}, function($ctx1) {$ctx1.fill(self,"parseExpression:",{aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "recompile:",
protocol: "compiling",
args: ["aClass"],
source: "recompile: aClass\x0a\x09aClass includingPossibleMetaDo: [ :eachSide |\x0a\x09\x09eachSide methodDictionary values\x0a\x09\x09\x09do: [ :each | each origin = eachSide ifTrue: [ \x0a\x09\x09\x09\x09self \x0a\x09\x09\x09\x09\x09install: each source \x0a\x09\x09\x09\x09\x09forClass: eachSide \x0a\x09\x09\x09\x09\x09protocol: each protocol ] ]\x0a\x09\x09\x09displayingProgress: 'Recompiling ', eachSide name ]",
referencedClasses: [],
pragmas: [],
messageSends: ["includingPossibleMetaDo:", "do:displayingProgress:", "values", "methodDictionary", "ifTrue:", "=", "origin", "install:forClass:protocol:", "source", "protocol", ",", "name"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aClass)._includingPossibleMetaDo_((function(eachSide){
return $core.withContext(function($ctx2) {
return $recv($recv($recv(eachSide)._methodDictionary())._values())._do_displayingProgress_((function(each){
return $core.withContext(function($ctx3) {
if($core.assert($recv($recv(each)._origin()).__eq(eachSide))){
return $self._install_forClass_protocol_($recv(each)._source(),eachSide,$recv(each)._protocol());
}
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),"Recompiling ".__comma($recv(eachSide)._name()));
}, function($ctx2) {$ctx2.fillBlock({eachSide:eachSide},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"recompile:",{aClass:aClass})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "recompileAll",
protocol: "compiling",
args: [],
source: "recompileAll\x0a\x09Smalltalk classes \x0a\x09\x09do: [ :each | self recompile: each ]\x0a\x09\x09displayingProgress: 'Compiling all classes...'",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["do:displayingProgress:", "classes", "recompile:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._classes())._do_displayingProgress_((function(each){
return $core.withContext(function($ctx2) {
return $self._recompile_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),"Compiling all classes...");
return self;
}, function($ctx1) {$ctx1.fill(self,"recompileAll",{})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "sourceForExpression:",
protocol: "compiling",
args: ["aString"],
source: "sourceForExpression: aString\x0a\x09^ 'xxxDoIt ^ [ ', aString, ' ] value'",
referencedClasses: [],
pragmas: [],
messageSends: [","]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv("xxxDoIt ^ [ ".__comma(aString)).__comma(" ] value")
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"sourceForExpression:",{aString:aString})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "start:forClass:protocol:",
protocol: "compiling",
args: ["aString", "aClass", "anotherString"],
source: "start: aString forClass: aClass protocol: anotherString\x0a\x09| package |\x0a\x09package := aClass packageOfProtocol: anotherString.\x0a\x09self\x0a\x09\x09currentPackage: package;\x0a\x09\x09codeGenerator: (self codeGeneratorClass new\x0a\x09\x09\x09source: aString;\x0a\x09\x09\x09currentClass: aClass;\x0a\x09\x09\x09currentPackage: package;\x0a\x09\x09\x09yourself)",
referencedClasses: [],
pragmas: [],
messageSends: ["packageOfProtocol:", "currentPackage:", "codeGenerator:", "source:", "new", "codeGeneratorClass", "currentClass:", "yourself"]
}, function ($methodClass){ return function (aString,aClass,anotherString){
var self=this,$self=this;
var package_;
return $core.withContext(function($ctx1) {
var $1;
package_=$recv(aClass)._packageOfProtocol_(anotherString);
[$self._currentPackage_(package_)
,$ctx1.sendIdx["currentPackage:"]=1
][0];
$1=$recv($self._codeGeneratorClass())._new();
$recv($1)._source_(aString);
$recv($1)._currentClass_(aClass);
$recv($1)._currentPackage_(package_);
$self._codeGenerator_($recv($1)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"start:forClass:protocol:",{aString:aString,aClass:aClass,anotherString:anotherString,package_:package_})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "transformerAt:put:",
protocol: "compiling",
args: ["aString", "anObject"],
source: "transformerAt: aString put: anObject\x0a\x09self codeGenerator transformersDictionary at: aString put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "transformersDictionary", "codeGenerator"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($self._codeGenerator())._transformersDictionary())._at_put_(aString,anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"transformerAt:put:",{aString:aString,anObject:anObject})});
}; }),
$globals.Compiler);

$core.addMethod(
$core.method({
selector: "wrappedSourceOf:",
protocol: "private",
args: ["anIRMethod"],
source: "wrappedSourceOf: anIRMethod\x0a\x09^ anIRMethod attachments\x0a\x09\x09ifEmpty: [\x0a\x09\x09\x09'(function ($methodClass){ return ',\x0a\x09\x09\x09anIRMethod compiledSource,\x0a\x09\x09\x09'; })' ]\x0a\x09\x09ifNotEmpty: [ :attachments |\x0a\x09\x09\x09'(function ($methodClass){ return Object.defineProperty(',\x0a\x09\x09\x09anIRMethod compiledSource,\x0a\x09\x09\x09',\x22a$atx\x22,{enumerable:false,configurable:true,writable:true,value:',\x0a\x09\x09\x09attachments asJavaScriptSource,\x0a\x09\x09\x09'}); })' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifEmpty:ifNotEmpty:", "attachments", ",", "compiledSource", "asJavaScriptSource"]
}, function ($methodClass){ return function (anIRMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(anIRMethod)._attachments())._ifEmpty_ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return [$recv(["(function ($methodClass){ return ".__comma([$recv(anIRMethod)._compiledSource()
,$ctx2.sendIdx["compiledSource"]=1
][0])
,$ctx2.sendIdx[","]=2
][0]).__comma("; })")
,$ctx2.sendIdx[","]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(attachments){
return $core.withContext(function($ctx2) {
return [$recv([$recv([$recv("(function ($methodClass){ return Object.defineProperty(".__comma($recv(anIRMethod)._compiledSource())).__comma(",\x22a$atx\x22,{enumerable:false,configurable:true,writable:true,value:")
,$ctx2.sendIdx[","]=5
][0]).__comma($recv(attachments)._asJavaScriptSource())
,$ctx2.sendIdx[","]=4
][0]).__comma("}); })")
,$ctx2.sendIdx[","]=3
][0];
}, function($ctx2) {$ctx2.fillBlock({attachments:attachments},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"wrappedSourceOf:",{anIRMethod:anIRMethod})});
}; }),
$globals.Compiler);


$core.addMethod(
$core.method({
selector: "eval:",
protocol: "evaluating",
args: ["aString"],
source: "eval: aString\x0a\x09^ self new eval: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["eval:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._eval_(aString);
}, function($ctx1) {$ctx1.fill(self,"eval:",{aString:aString})});
}; }),
$globals.Compiler.a$cls);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09\x22TODO remove, backward compat\x22\x0a\x09Smalltalk globals at: #SmalltalkParser put: smalltalkParser",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["at:put:", "globals"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._globals())._at_put_("SmalltalkParser",smalltalkParser);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Compiler.a$cls);

$core.addMethod(
$core.method({
selector: "parse:",
protocol: "parsing",
args: ["aString"],
source: "parse: aString\x0a\x09^ self new parse: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["parse:", "new"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._parse_(aString);
}, function($ctx1) {$ctx1.fill(self,"parse:",{aString:aString})});
}; }),
$globals.Compiler.a$cls);

$core.addMethod(
$core.method({
selector: "pseudoVariableNames",
protocol: "parsing",
args: [],
source: "pseudoVariableNames\x0a\x09^ PseudoVar dictionary keys asArray",
referencedClasses: ["PseudoVar"],
pragmas: [],
messageSends: ["asArray", "keys", "dictionary"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($recv($globals.PseudoVar)._dictionary())._keys())._asArray();
}, function($ctx1) {$ctx1.fill(self,"pseudoVariableNames",{})});
}; }),
$globals.Compiler.a$cls);

$core.addMethod(
$core.method({
selector: "recompile:",
protocol: "compiling",
args: ["aClass"],
source: "recompile: aClass\x0a\x09self new recompile: aClass",
referencedClasses: [],
pragmas: [],
messageSends: ["recompile:", "new"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._new())._recompile_(aClass);
return self;
}, function($ctx1) {$ctx1.fill(self,"recompile:",{aClass:aClass})});
}; }),
$globals.Compiler.a$cls);

$core.addMethod(
$core.method({
selector: "recompileAll",
protocol: "compiling",
args: [],
source: "recompileAll\x0a\x09Smalltalk classes do: [ :each |\x0a\x09\x09self recompile: each ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["do:", "classes", "recompile:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Smalltalk)._classes())._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._recompile_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"recompileAll",{})});
}; }),
$globals.Compiler.a$cls);


$core.addClass("DoIt", $globals.Object, "Compiler-Core");
$globals.DoIt.comment="`DoIt` is the class used to compile and evaluate expressions. See `Compiler >> evaluateExpression:`.";


$core.addClass("Evaluator", $globals.Object, "Compiler-Core");
$globals.Evaluator.comment="I evaluate code against a receiver, dispatching #evaluate:on: to the receiver.";
$core.addMethod(
$core.method({
selector: "evaluate:for:",
protocol: "evaluating",
args: ["aString", "anObject"],
source: "evaluate: aString for: anObject\x0a\x09^ anObject evaluate: aString on: self",
referencedClasses: [],
pragmas: [],
messageSends: ["evaluate:on:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anObject)._evaluate_on_(aString,self);
}, function($ctx1) {$ctx1.fill(self,"evaluate:for:",{aString:aString,anObject:anObject})});
}; }),
$globals.Evaluator);

$core.addMethod(
$core.method({
selector: "evaluate:receiver:",
protocol: "evaluating",
args: ["aString", "anObject"],
source: "evaluate: aString receiver: anObject\x0a\x09| compiler |\x0a\x09\x0a\x09compiler := Compiler new.\x0a\x09[ compiler parseExpression: aString ] \x0a\x09\x09on: Error \x0a\x09\x09do: [ :ex | ^ Terminal alert: ex messageText ].\x0a\x0a\x09^ compiler evaluateExpression: aString on: anObject",
referencedClasses: ["Compiler", "Error", "Terminal"],
pragmas: [],
messageSends: ["new", "on:do:", "parseExpression:", "alert:", "messageText", "evaluateExpression:on:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
var compiler;
return $core.withContext(function($ctx1) {
var $early={};
try {
compiler=$recv($globals.Compiler)._new();
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(compiler)._parseExpression_(aString);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
throw $early=[$recv($globals.Terminal)._alert_($recv(ex)._messageText())];
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,2)});
}));
return $recv(compiler)._evaluateExpression_on_(aString,anObject);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"evaluate:receiver:",{aString:aString,anObject:anObject,compiler:compiler})});
}; }),
$globals.Evaluator);


$core.addMethod(
$core.method({
selector: "evaluate:for:",
protocol: "instance creation",
args: ["aString", "anObject"],
source: "evaluate: aString for: anObject\x0a\x09^ self new evaluate: aString for: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["evaluate:for:", "new"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._new())._evaluate_for_(aString,anObject);
}, function($ctx1) {$ctx1.fill(self,"evaluate:for:",{aString:aString,anObject:anObject})});
}; }),
$globals.Evaluator.a$cls);


$core.addClass("ParseError", $globals.Error, "Compiler-Core");
$globals.ParseError.comment="Instance of ParseError are signaled on any parsing error.\x0aSee `Compiler >> #parse:`";


$core.addTrait("TPragmator", "Compiler-Core");
$core.addMethod(
$core.method({
selector: "canProcessPragma:",
protocol: "pragma processing",
args: ["aMessage"],
source: "canProcessPragma: aMessage\x0a\x09^ self class includesSelector: aMessage selector",
referencedClasses: [],
pragmas: [],
messageSends: ["includesSelector:", "class", "selector"]
}, function ($methodClass){ return function (aMessage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._includesSelector_($recv(aMessage)._selector());
}, function($ctx1) {$ctx1.fill(self,"canProcessPragma:",{aMessage:aMessage})});
}; }),
$globals.TPragmator);

$core.addMethod(
$core.method({
selector: "processPragma:",
protocol: "pragma processing",
args: ["aMessage"],
source: "processPragma: aMessage\x0a\x09(self canProcessPragma: aMessage) ifTrue: [\x0a\x09\x09^ aMessage sendTo: self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "canProcessPragma:", "sendTo:"]
}, function ($methodClass){ return function (aMessage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._canProcessPragma_(aMessage))){
return $recv(aMessage)._sendTo_(self);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"processPragma:",{aMessage:aMessage})});
}; }),
$globals.TPragmator);

$core.addMethod(
$core.method({
selector: "processPragmas:",
protocol: "pragma processing",
args: ["aCollection"],
source: "processPragmas: aCollection\x0a\x09aCollection do: [ :each | self processPragma: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "processPragma:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._processPragma_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"processPragmas:",{aCollection:aCollection})});
}; }),
$globals.TPragmator);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: "*Compiler-Core",
args: ["aString"],
source: "eval: aString\x0a\x09^ self context\x0a\x09\x09ifEmpty: [ Compiler eval: aString ]\x0a\x09\x09ifNotEmpty: [ :context |\x0a\x09\x09\x09| wrapperSource |\x0a\x09\x09\x09wrapperSource :=\x0a\x09\x09\x09\x09'(function(', (',' join: context keys), '){return(', aString, ');})'.\x0a\x09\x09\x09(Compiler eval: wrapperSource)\x0a\x09\x09\x09\x09valueWithPossibleArguments: context values ]",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["ifEmpty:ifNotEmpty:", "context", "eval:", ",", "join:", "keys", "valueWithPossibleArguments:", "values"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._context())._ifEmpty_ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return [$recv($globals.Compiler)._eval_(aString)
,$ctx2.sendIdx["eval:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(context){
var wrapperSource;
return $core.withContext(function($ctx2) {
wrapperSource=[$recv([$recv([$recv("(function(".__comma(","._join_($recv(context)._keys()))).__comma("){return(")
,$ctx2.sendIdx[","]=3
][0]).__comma(aString)
,$ctx2.sendIdx[","]=2
][0]).__comma(");})")
,$ctx2.sendIdx[","]=1
][0];
return $recv($recv($globals.Compiler)._eval_(wrapperSource))._valueWithPossibleArguments_($recv(context)._values());
}, function($ctx2) {$ctx2.fillBlock({context:context,wrapperSource:wrapperSource},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"eval:",{aString:aString})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "asVariableName",
protocol: "*Compiler-Core",
args: [],
source: "asVariableName\x0a\x09^ (Smalltalk reservedWords includes: self)\x0a\x09\x09ifTrue: [ self, '_' ]\x0a\x09\x09ifFalse: [ self ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "includes:", "reservedWords", ","]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv($globals.Smalltalk)._reservedWords())._includes_(self))){
return $self.__comma("_");
} else {
return self;
}
}, function($ctx1) {$ctx1.fill(self,"asVariableName",{})});
}; }),
$globals.String);

});

define('amber/core/Compiler-AST',["amber/boot", "require", "amber/core/Compiler-Core", "amber/core/Kernel-Dag", "amber/core/Kernel-Exceptions", "amber/core/Kernel-Methods", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-AST");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ASTNode", $globals.DagParentNode, "Compiler-AST");
$core.setSlots($globals.ASTNode, ["parent", "position", "source"]);
$globals.ASTNode.comment="I am the abstract root class of the abstract syntax tree.\x0a\x0aConcrete classes should implement `#accept:` to allow visiting.\x0a\x0a`position` holds a point containing line and column number of the symbol location in the original source file.";
$core.addMethod(
$core.method({
selector: "inPosition:",
protocol: "testing",
args: ["aPoint"],
source: "inPosition: aPoint\x0a\x09^ (self positionStart <= aPoint and: [\x0a\x09\x09self positionEnd >= aPoint ])",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "<=", "positionStart", ">=", "positionEnd"]
}, function ($methodClass){ return function (aPoint){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self._positionStart()).__lt_eq(aPoint))){
return $recv($self._positionEnd()).__gt_eq(aPoint);
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"inPosition:",{aPoint:aPoint})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "isNavigationNode",
protocol: "testing",
args: [],
source: "isNavigationNode\x0a\x09\x22Answer true if the node can be navigated to\x22\x0a\x09\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "isReturnNode",
protocol: "testing",
args: [],
source: "isReturnNode\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "location:",
protocol: "accessing",
args: ["aLocation"],
source: "location: aLocation\x0a\x09self position: aLocation start line @ aLocation start column",
referencedClasses: [],
pragmas: [],
messageSends: ["position:", "@", "line", "start", "column"]
}, function ($methodClass){ return function (aLocation){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._position_($recv($recv([$recv(aLocation)._start()
,$ctx1.sendIdx["start"]=1
][0])._line()).__at($recv($recv(aLocation)._start())._column()));
return self;
}, function($ctx1) {$ctx1.fill(self,"location:",{aLocation:aLocation})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "navigationNodeAt:ifAbsent:",
protocol: "accessing",
args: ["aPoint", "aBlock"],
source: "navigationNodeAt: aPoint ifAbsent: aBlock\x0a\x09\x22Answer the navigation node in the receiver's tree at aPoint \x0a\x09or nil if no navigation node was found.\x0a\x09\x0a\x09See `node >> isNaviationNode`\x22\x0a\x09\x0a\x09| children |\x0a\x09\x0a\x09children := self allDagChildren select: [ :each | \x0a\x09\x09each isNavigationNode and: [ each inPosition: aPoint ] ].\x0a\x09\x0a\x09children ifEmpty: [ ^ aBlock value ].\x0a\x09\x0a\x09^ (children asArray sort: [ :a :b | \x0a\x09\x09(a positionStart dist: aPoint) <= \x0a\x09\x09(b positionStart dist: aPoint) ]) first",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "allDagChildren", "and:", "isNavigationNode", "inPosition:", "ifEmpty:", "value", "first", "sort:", "asArray", "<=", "dist:", "positionStart"]
}, function ($methodClass){ return function (aPoint,aBlock){
var self=this,$self=this;
var children;
return $core.withContext(function($ctx1) {
var $early={};
try {
children=$recv($self._allDagChildren())._select_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(each)._isNavigationNode())){
return $recv(each)._inPosition_(aPoint);
} else {
return false;
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(children)._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
throw $early=[$recv(aBlock)._value()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return $recv($recv($recv(children)._asArray())._sort_((function(a,b){
return $core.withContext(function($ctx2) {
return $recv([$recv([$recv(a)._positionStart()
,$ctx2.sendIdx["positionStart"]=1
][0])._dist_(aPoint)
,$ctx2.sendIdx["dist:"]=1
][0]).__lt_eq($recv($recv(b)._positionStart())._dist_(aPoint));
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,4)});
})))._first();
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"navigationNodeAt:ifAbsent:",{aPoint:aPoint,aBlock:aBlock,children:children})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "parent",
protocol: "accessing",
args: [],
source: "parent\x0a\x09^ parent",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.parent;

}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "parent:",
protocol: "accessing",
args: ["aNode"],
source: "parent: aNode\x0a\x09parent := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.parent=aNode;
return self;

}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "position",
protocol: "accessing",
args: [],
source: "position\x0a\x09\x22answer the line and column of the receiver in the source code\x22\x0a\x09\x0a\x09^ position ifNil: [ \x0a\x09\x09self parent ifNotNil: [ :node | node position ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "ifNotNil:", "parent", "position"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.position;
if($1 == null || $1.a$nil){
$2=$self._parent();
if($2 == null || $2.a$nil){
return $2;
} else {
var node;
node=$2;
return $recv(node)._position();
}
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"position",{})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "position:",
protocol: "accessing",
args: ["aPosition"],
source: "position: aPosition\x0a\x09position := aPosition",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPosition){
var self=this,$self=this;
$self.position=aPosition;
return self;

}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "positionEnd",
protocol: "accessing",
args: [],
source: "positionEnd\x0a\x09^ self positionStart + ((self source lines size - 1) @ (self source lines last size - 1))",
referencedClasses: [],
pragmas: [],
messageSends: ["+", "positionStart", "@", "-", "size", "lines", "source", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._positionStart()).__plus($recv([$recv([$recv([$recv([$self._source()
,$ctx1.sendIdx["source"]=1
][0])._lines()
,$ctx1.sendIdx["lines"]=1
][0])._size()
,$ctx1.sendIdx["size"]=1
][0]).__minus((1))
,$ctx1.sendIdx["-"]=1
][0]).__at($recv($recv($recv($recv($self._source())._lines())._last())._size()).__minus((1))));
}, function($ctx1) {$ctx1.fill(self,"positionEnd",{})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "positionStart",
protocol: "accessing",
args: [],
source: "positionStart\x0a\x09^ self position",
referencedClasses: [],
pragmas: [],
messageSends: ["position"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._position();
}, function($ctx1) {$ctx1.fill(self,"positionStart",{})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "size",
protocol: "accessing",
args: [],
source: "size\x0a\x09^ self source size",
referencedClasses: [],
pragmas: [],
messageSends: ["size", "source"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._source())._size();
}, function($ctx1) {$ctx1.fill(self,"size",{})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "source",
protocol: "accessing",
args: [],
source: "source\x0a\x09^ source ifNil: [ '' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.source;
if($1 == null || $1.a$nil){
return "";
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"source",{})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "source:",
protocol: "accessing",
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.source=aString;
return self;

}; }),
$globals.ASTNode);



$core.addClass("ExpressionNode", $globals.ASTNode, "Compiler-AST");
$core.setSlots($globals.ExpressionNode, ["shouldBeAliased"]);
$globals.ExpressionNode.comment="I am the abstract root class for expression nodes.";
$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09self deprecatedAPI: 'Use #isIdempotent instead.'.\x0a\x09^ self isIdempotent",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "isIdempotent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #isIdempotent instead.");
return $self._isIdempotent();
}, function($ctx1) {$ctx1.fill(self,"isImmutable",{})});
}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "isSuper",
protocol: "testing",
args: [],
source: "isSuper\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "shouldBeAliased",
protocol: "accessing",
args: [],
source: "shouldBeAliased\x0a\x09^ shouldBeAliased ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.shouldBeAliased;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"shouldBeAliased",{})});
}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "shouldBeAliased:",
protocol: "accessing",
args: ["aBoolean"],
source: "shouldBeAliased: aBoolean\x0a\x09shouldBeAliased := aBoolean",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
$self.shouldBeAliased=aBoolean;
return self;

}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "withTail:",
protocol: "building",
args: ["aCollection"],
source: "withTail: aCollection\x0a\x09^ aCollection inject: self into: [\x0a\x09\x09:receiver :send | SendNode new\x0a\x09\x09\x09position: send position;\x0a\x09\x09\x09source: send source;\x0a\x09\x09\x09receiver: receiver;\x0a\x09\x09\x09selector: send selector;\x0a\x09\x09\x09arguments: send arguments;\x0a\x09\x09\x09yourself ]",
referencedClasses: ["SendNode"],
pragmas: [],
messageSends: ["inject:into:", "position:", "new", "position", "source:", "source", "receiver:", "selector:", "selector", "arguments:", "arguments", "yourself"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv(aCollection)._inject_into_(self,(function(receiver,send){
return $core.withContext(function($ctx2) {
$1=$recv($globals.SendNode)._new();
$recv($1)._position_($recv(send)._position());
$recv($1)._source_($recv(send)._source());
$recv($1)._receiver_(receiver);
$recv($1)._selector_($recv(send)._selector());
$recv($1)._arguments_($recv(send)._arguments());
return $recv($1)._yourself();
}, function($ctx2) {$ctx2.fillBlock({receiver:receiver,send:send},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"withTail:",{aCollection:aCollection})});
}; }),
$globals.ExpressionNode);



$core.addClass("AssignmentNode", $globals.ExpressionNode, "Compiler-AST");
$core.setSlots($globals.AssignmentNode, ["left", "right"]);
$globals.AssignmentNode.comment="I represent an assignment node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitAssignmentNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitAssignmentNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitAssignmentNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09^ { self left. self right }",
referencedClasses: [],
pragmas: [],
messageSends: ["left", "right"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$self._left(),$self._right()];
}, function($ctx1) {$ctx1.fill(self,"dagChildren",{})});
}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "left",
protocol: "accessing",
args: [],
source: "left\x0a\x09^ left",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.left;

}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "left:",
protocol: "accessing",
args: ["aNode"],
source: "left: aNode\x0a\x09left := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.left=aNode;
return self;

}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "right",
protocol: "accessing",
args: [],
source: "right\x0a\x09^ right",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.right;

}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "right:",
protocol: "accessing",
args: ["aNode"],
source: "right: aNode\x0a\x09right := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.right=aNode;
return self;

}; }),
$globals.AssignmentNode);



$core.addClass("BlockNode", $globals.ExpressionNode, "Compiler-AST");
$core.setSlots($globals.BlockNode, ["parameters", "scope", "sequenceNode"]);
$globals.BlockNode.comment="I represent an block closure node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitBlockNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitBlockNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitBlockNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "dagChild",
protocol: "accessing",
args: [],
source: "dagChild\x0a\x09^ self sequenceNode",
referencedClasses: [],
pragmas: [],
messageSends: ["sequenceNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._sequenceNode();
}, function($ctx1) {$ctx1.fill(self,"dagChild",{})});
}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "parameters",
protocol: "accessing",
args: [],
source: "parameters\x0a\x09^ parameters ifNil: [ parameters := Array new ]",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.parameters;
if($1 == null || $1.a$nil){
$self.parameters=$recv($globals.Array)._new();
return $self.parameters;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"parameters",{})});
}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "parameters:",
protocol: "accessing",
args: ["aCollection"],
source: "parameters: aCollection\x0a\x09parameters := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.parameters=aCollection;
return self;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.scope;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: "accessing",
args: ["aLexicalScope"],
source: "scope: aLexicalScope\x0a\x09scope := aLexicalScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aLexicalScope){
var self=this,$self=this;
$self.scope=aLexicalScope;
return self;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "sequenceNode",
protocol: "accessing",
args: [],
source: "sequenceNode\x0a\x09^ sequenceNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.sequenceNode;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "sequenceNode:",
protocol: "accessing",
args: ["anObject"],
source: "sequenceNode: anObject\x0a\x09sequenceNode := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.sequenceNode=anObject;
return self;

}; }),
$globals.BlockNode);



$core.addClass("CascadeNode", $globals.ExpressionNode, "Compiler-AST");
$core.setSlots($globals.CascadeNode, ["receiver"]);
$globals.CascadeNode.comment="I represent an cascade node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitCascadeNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitCascadeNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitCascadeNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: "accessing",
args: ["aNode"],
source: "receiver: aNode\x0a\x09receiver := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.receiver=aNode;
return self;

}; }),
$globals.CascadeNode);



$core.addClass("DynamicArrayNode", $globals.ExpressionNode, "Compiler-AST");
$globals.DynamicArrayNode.comment="I represent an dynamic array node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitDynamicArrayNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDynamicArrayNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitDynamicArrayNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.DynamicArrayNode);



$core.addClass("DynamicDictionaryNode", $globals.ExpressionNode, "Compiler-AST");
$globals.DynamicDictionaryNode.comment="I represent an dynamic dictionary node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitDynamicDictionaryNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDynamicDictionaryNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitDynamicDictionaryNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.DynamicDictionaryNode);



$core.addClass("SendNode", $globals.ExpressionNode, "Compiler-AST");
$core.setSlots($globals.SendNode, ["selector", "arguments", "receiver", "index", "javaScriptSelector", "argumentSwitcher", "isSideEffect"]);
$globals.SendNode.comment="I represent an message send node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitSendNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitSendNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitSendNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "argumentSwitcher",
protocol: "accessing",
args: [],
source: "argumentSwitcher\x0a\x09^ argumentSwitcher",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.argumentSwitcher;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "argumentSwitcher:",
protocol: "accessing",
args: ["aJSFunction"],
source: "argumentSwitcher: aJSFunction\x0a\x09argumentSwitcher := aJSFunction",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aJSFunction){
var self=this,$self=this;
$self.argumentSwitcher=aJSFunction;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ arguments ifNil: [ arguments := #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.arguments;
if($1 == null || $1.a$nil){
$self.arguments=[];
return $self.arguments;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: "accessing",
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.arguments=aCollection;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "beSideEffect",
protocol: "accessing",
args: [],
source: "beSideEffect\x0a\x09isSideEffect := true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
$self.isSideEffect=true;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "dagChildren",
protocol: "accessing",
args: [],
source: "dagChildren\x0a\x09self receiver ifNil: [ ^ self arguments copy ].\x0a\x09\x0a\x09^ self arguments copyWithFirst: self receiver",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "receiver", "copy", "arguments", "copyWithFirst:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._receiver()
,$ctx1.sendIdx["receiver"]=1
][0];
if($1 == null || $1.a$nil){
return $recv([$self._arguments()
,$ctx1.sendIdx["arguments"]=1
][0])._copy();
} else {
$1;
}
return $recv($self._arguments())._copyWithFirst_($self._receiver());
}, function($ctx1) {$ctx1.fill(self,"dagChildren",{})});
}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "index",
protocol: "accessing",
args: [],
source: "index\x0a\x09^ index",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.index;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "index:",
protocol: "accessing",
args: ["anInteger"],
source: "index: anInteger\x0a\x09index := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.index=anInteger;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "isNavigationNode",
protocol: "testing",
args: [],
source: "isNavigationNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "isSideEffect",
protocol: "accessing",
args: [],
source: "isSideEffect\x0a\x09^ isSideEffect ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.isSideEffect;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"isSideEffect",{})});
}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "javaScriptSelector",
protocol: "accessing",
args: [],
source: "javaScriptSelector\x0a\x09^ javaScriptSelector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.javaScriptSelector;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "javaScriptSelector:",
protocol: "accessing",
args: ["aString"],
source: "javaScriptSelector: aString\x0a\x09javaScriptSelector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.javaScriptSelector=aString;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "navigationLink",
protocol: "accessing",
args: [],
source: "navigationLink\x0a\x09^ self selector",
referencedClasses: [],
pragmas: [],
messageSends: ["selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._selector();
}, function($ctx1) {$ctx1.fill(self,"navigationLink",{})});
}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: "accessing",
args: ["aNode"],
source: "receiver: aNode\x0a\x09receiver := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.receiver=aNode;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "superSend",
protocol: "accessing",
args: [],
source: "superSend\x0a\x09^ self receiver ifNil: [ false ] ifNotNil: [ :recv | recv isSuper ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "receiver", "isSuper"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._receiver();
if($1 == null || $1.a$nil){
return false;
} else {
var recv;
recv=$1;
return $recv(recv)._isSuper();
}
}, function($ctx1) {$ctx1.fill(self,"superSend",{})});
}; }),
$globals.SendNode);



$core.addClass("ValueNode", $globals.ExpressionNode, "Compiler-AST");
$core.setSlots($globals.ValueNode, ["value"]);
$globals.ValueNode.comment="I represent a value node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitValueNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitValueNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitValueNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ self value isImmutable",
referencedClasses: [],
pragmas: [],
messageSends: ["isImmutable", "value"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._value())._isImmutable();
}, function($ctx1) {$ctx1.fill(self,"isIdempotent",{})});
}; }),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "value",
protocol: "accessing",
args: [],
source: "value\x0a\x09^ value",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.value;

}; }),
$globals.ValueNode);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "accessing",
args: ["anObject"],
source: "value: anObject\x0a\x09value := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.value=anObject;
return self;

}; }),
$globals.ValueNode);



$core.addClass("VariableNode", $globals.ExpressionNode, "Compiler-AST");
$core.setSlots($globals.VariableNode, ["identifier", "assigned", "binding"]);
$globals.VariableNode.comment="I represent an variable node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitVariableNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitVariableNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitVariableNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "alias",
protocol: "accessing",
args: [],
source: "alias\x0a\x09^ self binding alias",
referencedClasses: [],
pragmas: [],
messageSends: ["alias", "binding"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._binding())._alias();
}, function($ctx1) {$ctx1.fill(self,"alias",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "assigned",
protocol: "accessing",
args: [],
source: "assigned\x0a\x09^ assigned ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.assigned;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"assigned",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "assigned:",
protocol: "accessing",
args: ["aBoolean"],
source: "assigned: aBoolean\x0a\x09assigned := aBoolean",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
$self.assigned=aBoolean;
return self;

}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "binding",
protocol: "accessing",
args: [],
source: "binding\x0a\x09^ binding",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.binding;

}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "binding:",
protocol: "accessing",
args: ["aScopeVar"],
source: "binding: aScopeVar\x0a\x09binding := aScopeVar",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aScopeVar){
var self=this,$self=this;
$self.binding=aScopeVar;
return self;

}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "identifier",
protocol: "accessing",
args: [],
source: "identifier\x0a\x09^ identifier",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.identifier;

}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "identifier:",
protocol: "accessing",
args: ["anObject"],
source: "identifier: anObject\x0a\x09identifier := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.identifier=anObject;
return self;

}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isAssignable",
protocol: "testing",
args: [],
source: "isAssignable\x0a\x09^ self binding isAssignable",
referencedClasses: [],
pragmas: [],
messageSends: ["isAssignable", "binding"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._binding())._isAssignable();
}, function($ctx1) {$ctx1.fill(self,"isAssignable",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ self binding isIdempotent",
referencedClasses: [],
pragmas: [],
messageSends: ["isIdempotent", "binding"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._binding())._isIdempotent();
}, function($ctx1) {$ctx1.fill(self,"isIdempotent",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09self deprecatedAPI: 'Use #isIdempotent / #isAssignable not instead.'.\x0a\x09^ self isIdempotent \x22to be consistent with super\x22",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "isIdempotent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #isIdempotent / #isAssignable not instead.");
return $self._isIdempotent();
}, function($ctx1) {$ctx1.fill(self,"isImmutable",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isNavigationNode",
protocol: "testing",
args: [],
source: "isNavigationNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "isSuper",
protocol: "testing",
args: [],
source: "isSuper\x0a\x09^ self binding isSuper",
referencedClasses: [],
pragmas: [],
messageSends: ["isSuper", "binding"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._binding())._isSuper();
}, function($ctx1) {$ctx1.fill(self,"isSuper",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "navigationLink",
protocol: "accessing",
args: [],
source: "navigationLink\x0a\x09^ self identifier",
referencedClasses: [],
pragmas: [],
messageSends: ["identifier"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._identifier();
}, function($ctx1) {$ctx1.fill(self,"navigationLink",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "value",
protocol: "accessing",
args: [],
source: "value\x0a\x09self deprecatedAPI: 'Use #identifier instead.'.\x0a\x09^ self identifier",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "identifier"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #identifier instead.");
return $self._identifier();
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.VariableNode);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "accessing",
args: ["anObject"],
source: "value: anObject\x0a\x09self deprecatedAPI: 'Use #identifier: instead.'.\x0a\x09self identifier: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "identifier:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #identifier: instead.");
$self._identifier_(anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"value:",{anObject:anObject})});
}; }),
$globals.VariableNode);



$core.addClass("JSStatementNode", $globals.ASTNode, "Compiler-AST");
$globals.JSStatementNode.comment="I represent an JavaScript statement node.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitJSStatementNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitJSStatementNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitJSStatementNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.JSStatementNode);



$core.addClass("MethodNode", $globals.ASTNode, "Compiler-AST");
$core.setSlots($globals.MethodNode, ["selector", "arguments", "pragmas", "scope", "classReferences", "sendIndexes", "sequenceNode"]);
$globals.MethodNode.comment="I represent an method node.\x0a\x0aA method node must be the root and only method node of a valid AST.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitMethodNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitMethodNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitMethodNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ arguments ifNil: [ #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.arguments;
if($1 == null || $1.a$nil){
return [];
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: "accessing",
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.arguments=aCollection;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "classReferences",
protocol: "accessing",
args: [],
source: "classReferences\x0a\x09^ classReferences",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.classReferences;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "classReferences:",
protocol: "accessing",
args: ["aCollection"],
source: "classReferences: aCollection\x0a\x09classReferences := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.classReferences=aCollection;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "dagChild",
protocol: "accessing",
args: [],
source: "dagChild\x0a\x09^ self sequenceNode",
referencedClasses: [],
pragmas: [],
messageSends: ["sequenceNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._sequenceNode();
}, function($ctx1) {$ctx1.fill(self,"dagChild",{})});
}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: "accessing",
args: [],
source: "messageSends\x0a\x09^ self sendIndexes keys",
referencedClasses: [],
pragmas: [],
messageSends: ["keys", "sendIndexes"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._sendIndexes())._keys();
}, function($ctx1) {$ctx1.fill(self,"messageSends",{})});
}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "method",
protocol: "accessing",
args: [],
source: "method\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "pragmas",
protocol: "accessing",
args: [],
source: "pragmas\x0a\x09^ pragmas ifNil: [ #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.pragmas;
if($1 == null || $1.a$nil){
return [];
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"pragmas",{})});
}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "pragmas:",
protocol: "accessing",
args: ["aCollection"],
source: "pragmas: aCollection\x0a\x09pragmas := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.pragmas=aCollection;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.scope;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: "accessing",
args: ["aMethodScope"],
source: "scope: aMethodScope\x0a\x09scope := aMethodScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aMethodScope){
var self=this,$self=this;
$self.scope=aMethodScope;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: "accessing",
args: [],
source: "sendIndexes\x0a\x09^ sendIndexes",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.sendIndexes;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sendIndexes:",
protocol: "accessing",
args: ["aDictionary"],
source: "sendIndexes: aDictionary\x0a\x09sendIndexes := aDictionary",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aDictionary){
var self=this,$self=this;
$self.sendIndexes=aDictionary;
return self;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sequenceNode",
protocol: "accessing",
args: [],
source: "sequenceNode\x0a\x09^ sequenceNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.sequenceNode;

}; }),
$globals.MethodNode);

$core.addMethod(
$core.method({
selector: "sequenceNode:",
protocol: "accessing",
args: ["aSequenceNode"],
source: "sequenceNode: aSequenceNode\x0a\x09sequenceNode := aSequenceNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aSequenceNode){
var self=this,$self=this;
$self.sequenceNode=aSequenceNode;
return self;

}; }),
$globals.MethodNode);



$core.addClass("ReturnNode", $globals.ASTNode, "Compiler-AST");
$core.setSlots($globals.ReturnNode, ["scope", "expression"]);
$globals.ReturnNode.comment="I represent an return node. At the AST level, there is not difference between a local return or non-local return.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitReturnNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitReturnNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitReturnNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "dagChild",
protocol: "accessing",
args: [],
source: "dagChild\x0a\x09^ self expression",
referencedClasses: [],
pragmas: [],
messageSends: ["expression"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._expression();
}, function($ctx1) {$ctx1.fill(self,"dagChild",{})});
}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "expression",
protocol: "accessing",
args: [],
source: "expression\x0a\x09^ expression ifNil: [ nodes first ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "first"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.expression;
if($1 == null || $1.a$nil){
return $recv($self.nodes)._first();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"expression",{})});
}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "expression:",
protocol: "accessing",
args: ["anObject"],
source: "expression: anObject\x0a\x09expression := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.expression=anObject;
return self;

}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "isReturnNode",
protocol: "testing",
args: [],
source: "isReturnNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "nonLocalReturn",
protocol: "testing",
args: [],
source: "nonLocalReturn\x0a\x09^ self scope isMethodScope not",
referencedClasses: [],
pragmas: [],
messageSends: ["not", "isMethodScope", "scope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._scope())._isMethodScope())._not();
}, function($ctx1) {$ctx1.fill(self,"nonLocalReturn",{})});
}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.scope;

}; }),
$globals.ReturnNode);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: "accessing",
args: ["aLexicalScope"],
source: "scope: aLexicalScope\x0a\x09scope := aLexicalScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aLexicalScope){
var self=this,$self=this;
$self.scope=aLexicalScope;
return self;

}; }),
$globals.ReturnNode);



$core.addClass("SequenceNode", $globals.ASTNode, "Compiler-AST");
$core.setSlots($globals.SequenceNode, ["temps"]);
$globals.SequenceNode.comment="I represent an sequence node. A sequence represent a set of instructions inside the same scope (the method scope or a block scope).";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitSequenceNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitSequenceNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitSequenceNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "temps",
protocol: "accessing",
args: [],
source: "temps\x0a\x09^ temps ifNil: [ #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.temps;
if($1 == null || $1.a$nil){
return [];
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"temps",{})});
}; }),
$globals.SequenceNode);

$core.addMethod(
$core.method({
selector: "temps:",
protocol: "accessing",
args: ["aCollection"],
source: "temps: aCollection\x0a\x09temps := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.temps=aCollection;
return self;

}; }),
$globals.SequenceNode);



$core.addClass("BlockSequenceNode", $globals.SequenceNode, "Compiler-AST");
$globals.BlockSequenceNode.comment="I represent an special sequence node for block scopes.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitBlockSequenceNode: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitBlockSequenceNode:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitBlockSequenceNode_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.BlockSequenceNode);



$core.addClass("AstPragmator", $globals.Object, "Compiler-AST");
$core.setSlots($globals.AstPragmator, ["methodNode"]);
$globals.AstPragmator.comment="I am abstract superclass for pragma-processing transformer.\x0a\x0aMy subclasses should implement messages for each pragma\x0athey process. Pragma processing checks if a message is known\x0ato a class but not to its superclass. IOW, each and only those\x0apragmas are processed which are defined as methods in the subclass.\x0a\x0aThese messages can access sequence node in which\x0aa pragma occurred and its containing method node\x0aas `self sequenceNode` and `self methodNode`.\x0a\x0aSee `EarlyPragmator` for an example.";
$core.addMethod(
$core.method({
selector: "methodNode",
protocol: "accessing",
args: [],
source: "methodNode\x0a\x09^ methodNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.methodNode;

}; }),
$globals.AstPragmator);

$core.addMethod(
$core.method({
selector: "methodNode:",
protocol: "accessing",
args: ["anObject"],
source: "methodNode: anObject\x0a\x09methodNode := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.methodNode=anObject;
return self;

}; }),
$globals.AstPragmator);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "visiting",
args: ["aMethodNode"],
source: "value: aMethodNode\x0a\x09self methodNode: aMethodNode.\x0a\x09self processPragmas: aMethodNode pragmas.\x0a\x09^ aMethodNode",
referencedClasses: [],
pragmas: [],
messageSends: ["methodNode:", "processPragmas:", "pragmas"]
}, function ($methodClass){ return function (aMethodNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._methodNode_(aMethodNode);
$self._processPragmas_($recv(aMethodNode)._pragmas());
return aMethodNode;
}, function($ctx1) {$ctx1.fill(self,"value:",{aMethodNode:aMethodNode})});
}; }),
$globals.AstPragmator);



$core.addClass("AstSemanticPragmator", $globals.AstPragmator, "Compiler-AST");
$core.addMethod(
$core.method({
selector: "inlineJS:",
protocol: "pragmas",
args: ["aString"],
source: "inlineJS: aString\x0a\x09self methodNode sequenceNode dagChildren ifNotEmpty: [\x0a\x09\x09CompilerError signal: 'There must be no other code or code generator pragma than a lone inlineJS:' ].\x0a\x09self methodNode sequenceNode addDagChild: (\x0a\x09\x09JSStatementNode new\x0a\x09\x09\x09source: aString;\x0a\x09\x09\x09yourself)",
referencedClasses: ["CompilerError", "JSStatementNode"],
pragmas: [],
messageSends: ["ifNotEmpty:", "dagChildren", "sequenceNode", "methodNode", "signal:", "addDagChild:", "source:", "new", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$recv($recv([$recv([$self._methodNode()
,$ctx1.sendIdx["methodNode"]=1
][0])._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=1
][0])._dagChildren())._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.CompilerError)._signal_("There must be no other code or code generator pragma than a lone inlineJS:");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$1=$recv($self._methodNode())._sequenceNode();
$2=$recv($globals.JSStatementNode)._new();
$recv($2)._source_(aString);
$recv($1)._addDagChild_($recv($2)._yourself());
return self;
}, function($ctx1) {$ctx1.fill(self,"inlineJS:",{aString:aString})});
}; }),
$globals.AstSemanticPragmator);



$core.addClass("CompilerError", $globals.Error, "Compiler-AST");
$globals.CompilerError.comment="I am the common superclass of all compiling errors.";


$core.addClass("ParentFakingPathDagVisitor", $globals.PathDagVisitor, "Compiler-AST");
$core.setSlots($globals.ParentFakingPathDagVisitor, ["setParentSelector"]);
$globals.ParentFakingPathDagVisitor.comment="I am base class of `DagNode` visitor.\x0a\x0aI hold the path of ancestors up to actual node\x0ain `self path`.";
$core.addMethod(
$core.method({
selector: "visit:",
protocol: "visiting",
args: ["aNode"],
source: "visit: aNode\x0a\x09self path ifNotEmpty: [ :p | aNode parent: p last ].\x0a\x09^ super visit: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "path", "parent:", "last", "visit:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._path())._ifNotEmpty_((function(p){
return $core.withContext(function($ctx2) {
return $recv(aNode)._parent_($recv(p)._last());
}, function($ctx2) {$ctx2.fillBlock({p:p},$ctx1,1)});
}));
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visit_.call($self,aNode))
,$ctx1.supercall = false
][0];
}, function($ctx1) {$ctx1.fill(self,"visit:",{aNode:aNode})});
}; }),
$globals.ParentFakingPathDagVisitor);



$core.addClass("NodeVisitor", $globals.ParentFakingPathDagVisitor, "Compiler-AST");
$globals.NodeVisitor.comment="I am the abstract super class of all AST node visitors.";
$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitBlockSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockSequenceNode: aNode\x0a\x09^ self visitSequenceNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitSequenceNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitSequenceNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitBlockSequenceNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitCascadeNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitCascadeNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitCascadeNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitDagNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNode: aNode\x0a\x09^ self visitDagNodeVariantSimple: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNodeVariantSimple:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNodeVariantSimple_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitDagNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitDynamicArrayNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDynamicArrayNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitDynamicArrayNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitDynamicDictionaryNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDynamicDictionaryNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitDynamicDictionaryNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitJSStatementNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitValueNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitValueNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitValueNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09^ self visitDagNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode})});
}; }),
$globals.NodeVisitor);


$core.setTraitComposition([{trait: $globals.TDerivedDagChildren}], $globals.AssignmentNode);
$core.setTraitComposition([{trait: $globals.TSingleDagChild}], $globals.BlockNode);
$core.setTraitComposition([{trait: $globals.TDerivedDagChildren}], $globals.SendNode);
$core.setTraitComposition([{trait: $globals.TDagSink}], $globals.ValueNode);
$core.setTraitComposition([{trait: $globals.TDagSink}], $globals.VariableNode);
$core.setTraitComposition([{trait: $globals.TDagSink}], $globals.JSStatementNode);
$core.setTraitComposition([{trait: $globals.TSingleDagChild}], $globals.MethodNode);
$core.setTraitComposition([{trait: $globals.TSingleDagChild}], $globals.ReturnNode);
$core.setTraitComposition([{trait: $globals.TPragmator}], $globals.AstPragmator);

$core.addMethod(
$core.method({
selector: "ast",
protocol: "*Compiler-AST",
args: [],
source: "ast\x0a\x09self source ifEmpty: [ CompilerError signal: 'Method source is empty' ].\x0a\x09\x0a\x09^ Compiler new\x0a\x09\x09ast: self source\x0a\x09\x09forClass: self origin\x0a\x09\x09protocol: self protocol",
referencedClasses: ["CompilerError", "Compiler"],
pragmas: [],
messageSends: ["ifEmpty:", "source", "signal:", "ast:forClass:protocol:", "new", "origin", "protocol"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._source()
,$ctx1.sendIdx["source"]=1
][0])._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.CompilerError)._signal_("Method source is empty");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return $recv($recv($globals.Compiler)._new())._ast_forClass_protocol_($self._source(),$self._origin(),$self._protocol());
}, function($ctx1) {$ctx1.fill(self,"ast",{})});
}; }),
$globals.CompiledMethod);

});

define('amber/core/Compiler-Semantic',["amber/boot", "require", "amber/core/Compiler-AST", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-Semantic");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("JSSuperSendVisitor", $globals.NodeVisitor, "Compiler-Semantic");
$core.setSlots($globals.JSSuperSendVisitor, ["selector", "arguments", "property", "args"]);
$core.addMethod(
$core.method({
selector: "args",
protocol: "accessing",
args: [],
source: "args\x0a\x09^ args",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.args;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "args:",
protocol: "accessing",
args: ["aCollection"],
source: "args: aCollection\x0a\x09args := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.args=aCollection;
return self;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ arguments",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.arguments;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: "accessing",
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.arguments=aCollection;
return self;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "property",
protocol: "accessing",
args: [],
source: "property\x0a\x09^ property",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.property;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "property:",
protocol: "accessing",
args: ["anObject"],
source: "property: anObject\x0a\x09property := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.property=anObject;
return self;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["anObject"],
source: "selector: anObject\x0a\x09selector := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.selector=anObject;
return self;

}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "switcherFrom:to:",
protocol: "accessing",
args: ["aCollection", "anotherCollection"],
source: "switcherFrom: aCollection to: anotherCollection\x0a\x09^ NativeFunction\x0a\x09\x09constructorNamed: #Function\x0a\x09\x09value: (',' join: aCollection)\x0a\x09\x09value: 'return [', (',' join: anotherCollection), ']'",
referencedClasses: ["NativeFunction"],
pragmas: [],
messageSends: ["constructorNamed:value:value:", "join:", ","]
}, function ($methodClass){ return function (aCollection,anotherCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.NativeFunction)._constructorNamed_value_value_("Function",[","._join_(aCollection)
,$ctx1.sendIdx["join:"]=1
][0],[$recv("return [".__comma(","._join_(anotherCollection))).__comma("]")
,$ctx1.sendIdx[","]=1
][0]);
}, function($ctx1) {$ctx1.fill(self,"switcherFrom:to:",{aCollection:aCollection,anotherCollection:anotherCollection})});
}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: "accessing",
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x09self selector: aNode selector.\x0a\x09self arguments: aNode arguments.\x0a\x09^ super visitMethodNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["selector:", "selector", "arguments:", "arguments", "visitMethodNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._selector_($recv(aNode)._selector());
$self._arguments_($recv(aNode)._arguments());
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitMethodNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode})});
}; }),
$globals.JSSuperSendVisitor);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "accessing",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09| receiver |\x0a\x09receiver := aNode receiver.\x0a\x09receiver isSuper ifTrue: [\x0a\x09\x09aNode selector = self selector ifTrue: [\x0a\x09\x09\x09| old |\x0a\x09\x09\x09old := receiver binding.\x0a\x09\x09\x09receiver binding: (\x0a\x09\x09\x09\x09JavaScriptSuperVar new\x0a\x09\x09\x09\x09\x09scope: old scope;\x0a\x09\x09\x09\x09\x09name: old name;\x0a\x09\x09\x09\x09\x09yourself ).\x0a\x09\x09\x09self args ifNotNil: [ :myArgs |\x0a\x09\x09\x09\x09myArgs = self arguments ifFalse: [\x0a\x09\x09\x09\x09\x09aNode argumentSwitcher:\x0a\x09\x09\x09\x09\x09\x09(self switcherFrom: self arguments to: myArgs) ] ].\x0a\x09\x09\x09aNode javaScriptSelector: self property ] ].\x0a\x09^ super visitSendNode: aNode",
referencedClasses: ["JavaScriptSuperVar"],
pragmas: [],
messageSends: ["receiver", "ifTrue:", "isSuper", "=", "selector", "binding", "binding:", "scope:", "new", "scope", "name:", "name", "yourself", "ifNotNil:", "args", "ifFalse:", "arguments", "argumentSwitcher:", "switcherFrom:to:", "javaScriptSelector:", "property", "visitSendNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var receiver;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
receiver=$recv(aNode)._receiver();
if($core.assert($recv(receiver)._isSuper())){
if($core.assert([$recv([$recv(aNode)._selector()
,$ctx1.sendIdx["selector"]=1
][0]).__eq($self._selector())
,$ctx1.sendIdx["="]=1
][0])){
var old;
old=$recv(receiver)._binding();
$1=receiver;
$2=$recv($globals.JavaScriptSuperVar)._new();
$recv($2)._scope_($recv(old)._scope());
$recv($2)._name_($recv(old)._name());
$recv($1)._binding_($recv($2)._yourself());
$3=$self._args();
if($3 == null || $3.a$nil){
$3;
} else {
var myArgs;
myArgs=$3;
if(!$core.assert($recv(myArgs).__eq([$self._arguments()
,$ctx1.sendIdx["arguments"]=1
][0]))){
$recv(aNode)._argumentSwitcher_($self._switcherFrom_to_($self._arguments(),myArgs));
}
}
$recv(aNode)._javaScriptSelector_($self._property());
}
}
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitSendNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,receiver:receiver})});
}; }),
$globals.JSSuperSendVisitor);



$core.addClass("LexicalScope", $globals.Object, "Compiler-Semantic");
$core.setSlots($globals.LexicalScope, ["node", "instruction", "temps", "args", "outerScope", "blockIndex"]);
$globals.LexicalScope.comment="I represent a lexical scope where variable names are associated with ScopeVars\x0aInstances are used for block scopes. Method scopes are instances of MethodLexicalScope.\x0a\x0aI am attached to a ScopeVar and method/block nodes.\x0aEach context (method/closure) get a fresh scope that inherits from its outer scope.";
$core.addMethod(
$core.method({
selector: "addArg:",
protocol: "adding",
args: ["aString"],
source: "addArg: aString\x0a\x09self args at: aString put: (ArgVar on: aString).\x0a\x09(self args at: aString) scope: self",
referencedClasses: ["ArgVar"],
pragmas: [],
messageSends: ["at:put:", "args", "on:", "scope:", "at:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._args()
,$ctx1.sendIdx["args"]=1
][0])._at_put_(aString,$recv($globals.ArgVar)._on_(aString));
$recv($recv($self._args())._at_(aString))._scope_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addArg:",{aString:aString})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "addTemp:",
protocol: "adding",
args: ["aString"],
source: "addTemp: aString\x0a\x09self temps at: aString put: (TempVar on: aString).\x0a\x09(self temps at: aString) scope: self",
referencedClasses: ["TempVar"],
pragmas: [],
messageSends: ["at:put:", "temps", "on:", "scope:", "at:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._temps()
,$ctx1.sendIdx["temps"]=1
][0])._at_put_(aString,$recv($globals.TempVar)._on_(aString));
$recv($recv($self._temps())._at_(aString))._scope_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addTemp:",{aString:aString})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "alias",
protocol: "accessing",
args: [],
source: "alias\x0a\x09^ '$ctx', self scopeLevel asString",
referencedClasses: [],
pragmas: [],
messageSends: [",", "asString", "scopeLevel"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "$ctx".__comma($recv($self._scopeLevel())._asString());
}, function($ctx1) {$ctx1.fill(self,"alias",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "allVariableNames",
protocol: "accessing",
args: [],
source: "allVariableNames\x0a\x09^ self args keys, self temps keys",
referencedClasses: [],
pragmas: [],
messageSends: [",", "keys", "args", "temps"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$recv($self._args())._keys()
,$ctx1.sendIdx["keys"]=1
][0]).__comma($recv($self._temps())._keys());
}, function($ctx1) {$ctx1.fill(self,"allVariableNames",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "args",
protocol: "accessing",
args: [],
source: "args\x0a\x09^ args ifNil: [ args := Dictionary new ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.args;
if($1 == null || $1.a$nil){
$self.args=$recv($globals.Dictionary)._new();
return $self.args;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"args",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "bindingFor:",
protocol: "accessing",
args: ["aString"],
source: "bindingFor: aString\x0a\x09^ self pseudoVars at: aString ifAbsent: [\x0a\x09\x09self args at: aString ifAbsent: [\x0a\x09\x09\x09self temps at: aString ifAbsent: [ nil ]]]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "pseudoVars", "args", "temps"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv($self._pseudoVars())._at_ifAbsent_(aString,(function(){
return $core.withContext(function($ctx2) {
return [$recv($self._args())._at_ifAbsent_(aString,(function(){
return $core.withContext(function($ctx3) {
return $recv($self._temps())._at_ifAbsent_(aString,(function(){
return nil;

}));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))
,$ctx2.sendIdx["at:ifAbsent:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["at:ifAbsent:"]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"bindingFor:",{aString:aString})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "blockIndex",
protocol: "accessing",
args: [],
source: "blockIndex\x0a\x09^ blockIndex ifNil: [ 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.blockIndex;
if($1 == null || $1.a$nil){
return (0);
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"blockIndex",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "blockIndex:",
protocol: "accessing",
args: ["anInteger"],
source: "blockIndex: anInteger \x0a\x09blockIndex := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.blockIndex=anInteger;
return self;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "canFlattenNonLocalReturns",
protocol: "testing",
args: [],
source: "canFlattenNonLocalReturns\x0a\x09^ self isInlined and: [ self outerScope canFlattenNonLocalReturns ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "isInlined", "canFlattenNonLocalReturns", "outerScope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isInlined())){
return $recv($self._outerScope())._canFlattenNonLocalReturns();
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"canFlattenNonLocalReturns",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "instruction",
protocol: "accessing",
args: [],
source: "instruction\x0a\x09^ instruction",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.instruction;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "instruction:",
protocol: "accessing",
args: ["anIRInstruction"],
source: "instruction: anIRInstruction\x0a\x09instruction := anIRInstruction",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
$self.instruction=anIRInstruction;
return self;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "isBlockScope",
protocol: "testing",
args: [],
source: "isBlockScope\x0a\x09^ self isMethodScope not",
referencedClasses: [],
pragmas: [],
messageSends: ["not", "isMethodScope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._isMethodScope())._not();
}, function($ctx1) {$ctx1.fill(self,"isBlockScope",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: "testing",
args: [],
source: "isInlined\x0a\x09^ self instruction ifNil: [ false ] ifNotNil: [ :instr | instr isInlined ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "instruction", "isInlined"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._instruction();
if($1 == null || $1.a$nil){
return false;
} else {
var instr;
instr=$1;
return $recv(instr)._isInlined();
}
}, function($ctx1) {$ctx1.fill(self,"isInlined",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "isMethodScope",
protocol: "testing",
args: [],
source: "isMethodScope\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "lookupVariable:",
protocol: "accessing",
args: ["aString"],
source: "lookupVariable: aString\x0a\x09| lookup |\x0a\x09lookup := (self bindingFor: aString).\x0a\x09lookup ifNil: [\x0a\x09\x09lookup := self outerScope ifNotNil: [\x0a\x09\x09\x09(self outerScope lookupVariable: aString) ]].\x0a\x09^ lookup",
referencedClasses: [],
pragmas: [],
messageSends: ["bindingFor:", "ifNil:", "ifNotNil:", "outerScope", "lookupVariable:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var lookup;
return $core.withContext(function($ctx1) {
var $1,$2;
lookup=$self._bindingFor_(aString);
$1=lookup;
if($1 == null || $1.a$nil){
$2=[$self._outerScope()
,$ctx1.sendIdx["outerScope"]=1
][0];
if($2 == null || $2.a$nil){
lookup=$2;
} else {
lookup=$recv($self._outerScope())._lookupVariable_(aString);
}
lookup;
} else {
$1;
}
return lookup;
}, function($ctx1) {$ctx1.fill(self,"lookupVariable:",{aString:aString,lookup:lookup})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "methodScope",
protocol: "accessing",
args: [],
source: "methodScope\x0a\x09^ self outerScope ifNotNil: [\x0a\x09\x09self outerScope methodScope ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "outerScope", "methodScope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._outerScope()
,$ctx1.sendIdx["outerScope"]=1
][0];
if($1 == null || $1.a$nil){
return $1;
} else {
return $recv($self._outerScope())._methodScope();
}
}, function($ctx1) {$ctx1.fill(self,"methodScope",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "node",
protocol: "accessing",
args: [],
source: "node\x0a\x09\x22Answer the node in which I am defined\x22\x0a\x09\x0a\x09^ node",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.node;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "node:",
protocol: "accessing",
args: ["aNode"],
source: "node: aNode\x0a\x09node := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.node=aNode;
return self;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "outerScope",
protocol: "accessing",
args: [],
source: "outerScope\x0a\x09^ outerScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.outerScope;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "outerScope:",
protocol: "accessing",
args: ["aLexicalScope"],
source: "outerScope: aLexicalScope\x0a\x09outerScope := aLexicalScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aLexicalScope){
var self=this,$self=this;
$self.outerScope=aLexicalScope;
return self;

}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "pseudoVars",
protocol: "accessing",
args: [],
source: "pseudoVars\x0a\x09^ self methodScope pseudoVars",
referencedClasses: [],
pragmas: [],
messageSends: ["pseudoVars", "methodScope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._methodScope())._pseudoVars();
}, function($ctx1) {$ctx1.fill(self,"pseudoVars",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "scopeLevel",
protocol: "accessing",
args: [],
source: "scopeLevel\x0a\x09self outerScope ifNil: [ ^ 1 ].\x0a\x09self isInlined ifTrue: [ ^ self outerScope scopeLevel ].\x0a\x09\x0a\x09^ self outerScope scopeLevel + 1",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "outerScope", "ifTrue:", "isInlined", "scopeLevel", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._outerScope()
,$ctx1.sendIdx["outerScope"]=1
][0];
if($1 == null || $1.a$nil){
return (1);
} else {
$1;
}
if($core.assert($self._isInlined())){
return [$recv([$self._outerScope()
,$ctx1.sendIdx["outerScope"]=2
][0])._scopeLevel()
,$ctx1.sendIdx["scopeLevel"]=1
][0];
}
return $recv($recv($self._outerScope())._scopeLevel()).__plus((1));
}, function($ctx1) {$ctx1.fill(self,"scopeLevel",{})});
}; }),
$globals.LexicalScope);

$core.addMethod(
$core.method({
selector: "temps",
protocol: "accessing",
args: [],
source: "temps\x0a\x09^ temps ifNil: [ temps := Dictionary new ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.temps;
if($1 == null || $1.a$nil){
$self.temps=$recv($globals.Dictionary)._new();
return $self.temps;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"temps",{})});
}; }),
$globals.LexicalScope);



$core.addClass("MethodLexicalScope", $globals.LexicalScope, "Compiler-Semantic");
$core.setSlots($globals.MethodLexicalScope, ["slotVars", "pseudoVars", "localReturn", "nonLocalReturns"]);
$globals.MethodLexicalScope.comment="I represent a method scope.";
$core.addMethod(
$core.method({
selector: "addNonLocalReturn:",
protocol: "adding",
args: ["aScope"],
source: "addNonLocalReturn: aScope\x0a\x09self nonLocalReturns add: aScope",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "nonLocalReturns"]
}, function ($methodClass){ return function (aScope){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._nonLocalReturns())._add_(aScope);
return self;
}, function($ctx1) {$ctx1.fill(self,"addNonLocalReturn:",{aScope:aScope})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "addSlotVar:",
protocol: "adding",
args: ["aString"],
source: "addSlotVar: aString\x0a\x09self slotVars at: aString put: (SlotVar on: aString).\x0a\x09(self slotVars at: aString) scope: self",
referencedClasses: ["SlotVar"],
pragmas: [],
messageSends: ["at:put:", "slotVars", "on:", "scope:", "at:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._slotVars()
,$ctx1.sendIdx["slotVars"]=1
][0])._at_put_(aString,$recv($globals.SlotVar)._on_(aString));
$recv($recv($self._slotVars())._at_(aString))._scope_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"addSlotVar:",{aString:aString})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "allVariableNames",
protocol: "accessing",
args: [],
source: "allVariableNames\x0a\x09^ super allVariableNames, self slotVars keys",
referencedClasses: [],
pragmas: [],
messageSends: [",", "allVariableNames", "keys", "slotVars"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._allVariableNames.call($self))
,$ctx1.supercall = false
][0]).__comma($recv($self._slotVars())._keys());
}, function($ctx1) {$ctx1.fill(self,"allVariableNames",{})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "bindingFor:",
protocol: "accessing",
args: ["aString"],
source: "bindingFor: aString\x0a\x09^ (super bindingFor: aString) ifNil: [\x0a\x09\x09self slotVars at: aString ifAbsent: [ nil ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "bindingFor:", "at:ifAbsent:", "slotVars"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._bindingFor_.call($self,aString))
,$ctx1.supercall = false
][0];
if($1 == null || $1.a$nil){
return $recv($self._slotVars())._at_ifAbsent_(aString,(function(){
return nil;

}));
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"bindingFor:",{aString:aString})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "canFlattenNonLocalReturns",
protocol: "testing",
args: [],
source: "canFlattenNonLocalReturns\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "hasLocalReturn",
protocol: "testing",
args: [],
source: "hasLocalReturn\x0a\x09^ self localReturn",
referencedClasses: [],
pragmas: [],
messageSends: ["localReturn"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._localReturn();
}, function($ctx1) {$ctx1.fill(self,"hasLocalReturn",{})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "hasNonLocalReturn",
protocol: "testing",
args: [],
source: "hasNonLocalReturn\x0a\x09^ self nonLocalReturns notEmpty",
referencedClasses: [],
pragmas: [],
messageSends: ["notEmpty", "nonLocalReturns"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._nonLocalReturns())._notEmpty();
}, function($ctx1) {$ctx1.fill(self,"hasNonLocalReturn",{})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "isMethodScope",
protocol: "testing",
args: [],
source: "isMethodScope\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "localReturn",
protocol: "accessing",
args: [],
source: "localReturn\x0a\x09^ localReturn ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.localReturn;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"localReturn",{})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "localReturn:",
protocol: "accessing",
args: ["aBoolean"],
source: "localReturn: aBoolean\x0a\x09localReturn := aBoolean",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
$self.localReturn=aBoolean;
return self;

}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "methodScope",
protocol: "accessing",
args: [],
source: "methodScope\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "nonLocalReturns",
protocol: "accessing",
args: [],
source: "nonLocalReturns\x0a\x09^ nonLocalReturns ifNil: [ nonLocalReturns := OrderedCollection new ]",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.nonLocalReturns;
if($1 == null || $1.a$nil){
$self.nonLocalReturns=$recv($globals.OrderedCollection)._new();
return $self.nonLocalReturns;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"nonLocalReturns",{})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "pseudoVars",
protocol: "accessing",
args: [],
source: "pseudoVars\x0a\x09pseudoVars ifNil: [\x0a\x09\x09pseudoVars := Dictionary new.\x0a\x09\x09PseudoVar dictionary keysAndValuesDo: [ :each :impl |\x0a\x09\x09\x09pseudoVars at: each put: ((impl on: each)\x0a\x09\x09\x09\x09scope: self methodScope;\x0a\x09\x09\x09\x09yourself) ] ].\x0a\x09^ pseudoVars",
referencedClasses: ["Dictionary", "PseudoVar"],
pragmas: [],
messageSends: ["ifNil:", "new", "keysAndValuesDo:", "dictionary", "at:put:", "scope:", "on:", "methodScope", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=$self.pseudoVars;
if($1 == null || $1.a$nil){
$self.pseudoVars=$recv($globals.Dictionary)._new();
$recv($recv($globals.PseudoVar)._dictionary())._keysAndValuesDo_((function(each,impl){
return $core.withContext(function($ctx2) {
$2=$self.pseudoVars;
$3=$recv(impl)._on_(each);
$recv($3)._scope_($self._methodScope());
return $recv($2)._at_put_(each,$recv($3)._yourself());
}, function($ctx2) {$ctx2.fillBlock({each:each,impl:impl},$ctx1,2)});
}));
} else {
$1;
}
return $self.pseudoVars;
}, function($ctx1) {$ctx1.fill(self,"pseudoVars",{})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "removeNonLocalReturn:",
protocol: "adding",
args: ["aScope"],
source: "removeNonLocalReturn: aScope\x0a\x09self nonLocalReturns remove: aScope ifAbsent: []",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:ifAbsent:", "nonLocalReturns"]
}, function ($methodClass){ return function (aScope){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._nonLocalReturns())._remove_ifAbsent_(aScope,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"removeNonLocalReturn:",{aScope:aScope})});
}; }),
$globals.MethodLexicalScope);

$core.addMethod(
$core.method({
selector: "slotVars",
protocol: "accessing",
args: [],
source: "slotVars\x0a\x09^ slotVars ifNil: [ slotVars := Dictionary new ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.slotVars;
if($1 == null || $1.a$nil){
$self.slotVars=$recv($globals.Dictionary)._new();
return $self.slotVars;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"slotVars",{})});
}; }),
$globals.MethodLexicalScope);



$core.addClass("ScopeVar", $globals.Object, "Compiler-Semantic");
$core.setSlots($globals.ScopeVar, ["scope", "name"]);
$globals.ScopeVar.comment="I am an entry in a LexicalScope that gets associated with variable nodes of the same name.\x0aThere are 4 different subclasses of vars: temp vars, local vars, args, and unknown/global vars.";
$core.addMethod(
$core.method({
selector: "alias",
protocol: "accessing",
args: [],
source: "alias\x0a\x09^ self name asVariableName",
referencedClasses: [],
pragmas: [],
messageSends: ["asVariableName", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._name())._asVariableName();
}, function($ctx1) {$ctx1.fill(self,"alias",{})});
}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isAssignable",
protocol: "testing",
args: [],
source: "isAssignable\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isImmutable",
protocol: "testing",
args: [],
source: "isImmutable\x0a\x09self deprecatedAPI: 'Use #isIdempotent / #isAssignable not instead.'.\x0a\x09^ self isIdempotent",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "isIdempotent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use #isIdempotent / #isAssignable not instead.");
return $self._isIdempotent();
}, function($ctx1) {$ctx1.fill(self,"isImmutable",{})});
}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isSuper",
protocol: "testing",
args: [],
source: "isSuper\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.name;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "name:",
protocol: "accessing",
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.name=aString;
return self;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.scope;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: "accessing",
args: ["aScope"],
source: "scope: aScope\x0a\x09scope := aScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aScope){
var self=this,$self=this;
$self.scope=aScope;
return self;

}; }),
$globals.ScopeVar);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aString"],
source: "on: aString\x0a\x09^ self new\x0a\x09\x09name: aString;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["name:", "new", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._name_(aString);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aString:aString})});
}; }),
$globals.ScopeVar.a$cls);


$core.addClass("AliasVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.AliasVar.comment="I am an internally defined variable by the compiler";
$core.addMethod(
$core.method({
selector: "isAssignable",
protocol: "testing",
args: [],
source: "isAssignable\x0a\x09self error: 'Alias variable is internal, it should never appear in normal variable context.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Alias variable is internal, it should never appear in normal variable context.");
return self;
}, function($ctx1) {$ctx1.fill(self,"isAssignable",{})});
}; }),
$globals.AliasVar);

$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.AliasVar);



$core.addClass("ArgVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.ArgVar.comment="I am an argument of a method or block.";
$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.ArgVar);



$core.addClass("ClassRefVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.ClassRefVar.comment="I am an class reference variable";
$core.addMethod(
$core.method({
selector: "alias",
protocol: "accessing",
args: [],
source: "alias\x0a\x09^ '$globals.', self name",
referencedClasses: [],
pragmas: [],
messageSends: [",", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "$globals.".__comma($self._name());
}, function($ctx1) {$ctx1.fill(self,"alias",{})});
}; }),
$globals.ClassRefVar);



$core.addClass("ExternallyKnownVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.ExternallyKnownVar.comment="I am a variable known externally (not in method scope).";


$core.addClass("PseudoVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.PseudoVar.comment="I am an pseudo variable.\x0a\x0aThe five Smalltalk pseudo variables are: 'self', 'super', 'nil', 'true' and 'false'";
$core.addMethod(
$core.method({
selector: "alias",
protocol: "accessing",
args: [],
source: "alias\x0a\x09^ self name",
referencedClasses: [],
pragmas: [],
messageSends: ["name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._name();
}, function($ctx1) {$ctx1.fill(self,"alias",{})});
}; }),
$globals.PseudoVar);

$core.addMethod(
$core.method({
selector: "isIdempotent",
protocol: "testing",
args: [],
source: "isIdempotent\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.PseudoVar);


$core.setSlots($globals.PseudoVar.a$cls, ["dictionary", "receiverNames"]);
$core.addMethod(
$core.method({
selector: "dictionary",
protocol: "accessing",
args: [],
source: "dictionary\x0a\x09^ dictionary ifNil: [ dictionary := Dictionary new\x0a\x09\x09at: #self put: PseudoVar;\x0a\x09\x09at: #super put: SuperVar;\x0a\x09\x09at: #nil put: PseudoVar;\x0a\x09\x09at: #false put: PseudoVar;\x0a\x09\x09at: #true put: PseudoVar;\x0a\x09\x09at: #thisContext put: ThisContextVar;\x0a\x09\x09yourself ]",
referencedClasses: ["Dictionary", "PseudoVar", "SuperVar", "ThisContextVar"],
pragmas: [],
messageSends: ["ifNil:", "at:put:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.dictionary;
if($1 == null || $1.a$nil){
$2=$recv($globals.Dictionary)._new();
[$recv($2)._at_put_("self",$globals.PseudoVar)
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($2)._at_put_("super",$globals.SuperVar)
,$ctx1.sendIdx["at:put:"]=2
][0];
[$recv($2)._at_put_("nil",$globals.PseudoVar)
,$ctx1.sendIdx["at:put:"]=3
][0];
[$recv($2)._at_put_("false",$globals.PseudoVar)
,$ctx1.sendIdx["at:put:"]=4
][0];
[$recv($2)._at_put_("true",$globals.PseudoVar)
,$ctx1.sendIdx["at:put:"]=5
][0];
$recv($2)._at_put_("thisContext",$globals.ThisContextVar);
$self.dictionary=$recv($2)._yourself();
return $self.dictionary;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"dictionary",{})});
}; }),
$globals.PseudoVar.a$cls);

$core.addMethod(
$core.method({
selector: "receiverNames",
protocol: "accessing",
args: [],
source: "receiverNames\x0a\x09^ receiverNames ifNil: [ receiverNames := Dictionary new\x0a\x09\x09at: #self put: '$self';\x0a\x09\x09at: #super put: '$self';\x0a\x09\x09at: #nil put: '$nil';\x0a\x09\x09yourself ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "at:put:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.receiverNames;
if($1 == null || $1.a$nil){
$2=$recv($globals.Dictionary)._new();
[$recv($2)._at_put_("self","$self")
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($2)._at_put_("super","$self")
,$ctx1.sendIdx["at:put:"]=2
][0];
$recv($2)._at_put_("nil","$nil");
$self.receiverNames=$recv($2)._yourself();
return $self.receiverNames;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"receiverNames",{})});
}; }),
$globals.PseudoVar.a$cls);


$core.addClass("SuperVar", $globals.PseudoVar, "Compiler-Semantic");
$globals.SuperVar.comment="I am a 'super' pseudo variable.";
$core.addMethod(
$core.method({
selector: "isSuper",
protocol: "testing",
args: [],
source: "isSuper\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.SuperVar);

$core.addMethod(
$core.method({
selector: "lookupAsJavaScriptSource",
protocol: "accessing",
args: [],
source: "lookupAsJavaScriptSource\x0a\x09^ '($methodClass.superclass||$boot.nilAsClass).fn.prototype'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "($methodClass.superclass||$boot.nilAsClass).fn.prototype";

}; }),
$globals.SuperVar);



$core.addClass("JavaScriptSuperVar", $globals.SuperVar, "Compiler-Semantic");
$core.addMethod(
$core.method({
selector: "lookupAsJavaScriptSource",
protocol: "accessing",
args: [],
source: "lookupAsJavaScriptSource\x0a\x09^ 'Object.getPrototypeOf($methodClass.fn.prototype)'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "Object.getPrototypeOf($methodClass.fn.prototype)";

}; }),
$globals.JavaScriptSuperVar);



$core.addClass("ThisContextVar", $globals.PseudoVar, "Compiler-Semantic");
$globals.ThisContextVar.comment="I am a 'thisContext' pseudo variable.";
$core.addMethod(
$core.method({
selector: "alias",
protocol: "accessing",
args: [],
source: "alias\x0a\x09^ '$core.getThisContext()'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "$core.getThisContext()";

}; }),
$globals.ThisContextVar);



$core.addClass("SlotVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.SlotVar.comment="I am a slot variable of a method's class.";
$core.addMethod(
$core.method({
selector: "alias",
protocol: "testing",
args: [],
source: "alias\x0a\x09^ '$self.', self name",
referencedClasses: [],
pragmas: [],
messageSends: [",", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return "$self.".__comma($self._name());
}, function($ctx1) {$ctx1.fill(self,"alias",{})});
}; }),
$globals.SlotVar);

$core.addMethod(
$core.method({
selector: "isAssignable",
protocol: "testing",
args: [],
source: "isAssignable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.SlotVar);



$core.addClass("TempVar", $globals.ScopeVar, "Compiler-Semantic");
$globals.TempVar.comment="I am an temporary variable of a method or block.";
$core.addMethod(
$core.method({
selector: "isAssignable",
protocol: "testing",
args: [],
source: "isAssignable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.TempVar);



$core.addClass("SemanticAnalyzer", $globals.NodeVisitor, "Compiler-Semantic");
$core.setSlots($globals.SemanticAnalyzer, ["currentScope", "blockIndex", "thePackage", "theClass", "classReferences", "messageSends"]);
$globals.SemanticAnalyzer.comment="I semantically analyze the abstract syntax tree and annotate it with informations such as non local returns and variable scopes.";
$core.addMethod(
$core.method({
selector: "bindUnscopedVariable:",
protocol: "private",
args: ["aString"],
source: "bindUnscopedVariable: aString\x0a\x09aString isCapitalized ifTrue: [ \x22Capital letter variables might be globals.\x22\x0a\x09\x09self classReferences add: aString.\x0a\x09\x09^ ClassRefVar new name: aString; yourself ].\x0a\x0a\x09\x22Throw an error if the variable is undeclared in the global JS scope (i.e. window).\x0a\x09We allow all variables listed by Smalltalk>>#globalJsVariables.\x0a\x09This list includes: `window`, `document`,  `process` and `global`\x0a\x09for nodejs and browser environments.\x0a\x09\x0a\x09This is only to make sure compilation works on both browser-based and nodejs environments.\x0a\x09The ideal solution would be to use a pragma instead\x22\x0a\x0a\x09((Smalltalk globalJsVariables includes: aString)\x0a\x09\x09or: [ self isVariableKnown: aString inPackage: self thePackage ]) ifTrue: [\x0a\x09\x09\x09^ ExternallyKnownVar new name: aString; yourself ].\x0a\x0a\x09self errorUnknownVariable: aString",
referencedClasses: ["ClassRefVar", "Smalltalk", "ExternallyKnownVar"],
pragmas: [],
messageSends: ["ifTrue:", "isCapitalized", "add:", "classReferences", "name:", "new", "yourself", "or:", "includes:", "globalJsVariables", "isVariableKnown:inPackage:", "thePackage", "errorUnknownVariable:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
if($core.assert($recv(aString)._isCapitalized())){
$recv($self._classReferences())._add_(aString);
$1=[$recv($globals.ClassRefVar)._new()
,$ctx1.sendIdx["new"]=1
][0];
[$recv($1)._name_(aString)
,$ctx1.sendIdx["name:"]=1
][0];
return [$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0];
}
if($core.assert($recv($recv($globals.Smalltalk)._globalJsVariables())._includes_(aString))){
$2=true;
} else {
$2=$self._isVariableKnown_inPackage_(aString,$self._thePackage());
}
if($core.assert($2)){
$3=$recv($globals.ExternallyKnownVar)._new();
$recv($3)._name_(aString);
return $recv($3)._yourself();
}
$self._errorUnknownVariable_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"bindUnscopedVariable:",{aString:aString})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "classReferences",
protocol: "accessing",
args: [],
source: "classReferences\x0a\x09^ classReferences ifNil: [ classReferences := Set new ]",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.classReferences;
if($1 == null || $1.a$nil){
$self.classReferences=$recv($globals.Set)._new();
return $self.classReferences;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"classReferences",{})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "errorInvalidAssignment:",
protocol: "error handling",
args: ["aString"],
source: "errorInvalidAssignment: aString\x0a\x09InvalidAssignmentError new\x0a\x09\x09variableName: aString;\x0a\x09\x09signal",
referencedClasses: ["InvalidAssignmentError"],
pragmas: [],
messageSends: ["variableName:", "new", "signal"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.InvalidAssignmentError)._new();
$recv($1)._variableName_(aString);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"errorInvalidAssignment:",{aString:aString})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "errorShadowingVariable:",
protocol: "error handling",
args: ["aString"],
source: "errorShadowingVariable: aString\x0a\x09ShadowingVariableError new\x0a\x09\x09variableName: aString;\x0a\x09\x09signal",
referencedClasses: ["ShadowingVariableError"],
pragmas: [],
messageSends: ["variableName:", "new", "signal"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ShadowingVariableError)._new();
$recv($1)._variableName_(aString);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"errorShadowingVariable:",{aString:aString})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "errorUnknownVariable:",
protocol: "error handling",
args: ["aString"],
source: "errorUnknownVariable: aString\x0a\x09UnknownVariableError new\x0a\x09\x09variableName: aString;\x0a\x09\x09signal",
referencedClasses: ["UnknownVariableError"],
pragmas: [],
messageSends: ["variableName:", "new", "signal"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.UnknownVariableError)._new();
$recv($1)._variableName_(aString);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"errorUnknownVariable:",{aString:aString})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "isVariableKnown:inPackage:",
protocol: "testing",
args: ["aString", "aPackage"],
source: "isVariableKnown: aString inPackage: aPackage\x0a\x09aPackage ifNotNil: [\x0a\x09\x09| packageKnownVars |\x0a\x09\x09packageKnownVars := (aPackage imports reject: #isString) collect: #key.\x0a\x09\x09(packageKnownVars includes: aString) ifTrue: [ ^ true ] ].\x0a\x09^ Compiler new\x0a\x09\x09eval: 'typeof(', aString, ')!== \x22undefined\x22||(function(){try{return(', aString, ',true)}catch(_){return false}})()'\x0a\x09\x09forPackage: aPackage",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["ifNotNil:", "collect:", "reject:", "imports", "ifTrue:", "includes:", "eval:forPackage:", "new", ","]
}, function ($methodClass){ return function (aString,aPackage){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(aPackage == null || aPackage.a$nil){
aPackage;
} else {
var packageKnownVars;
packageKnownVars=$recv($recv($recv(aPackage)._imports())._reject_("isString"))._collect_("key");
if($core.assert($recv(packageKnownVars)._includes_(aString))){
return true;
}
}
return $recv($recv($globals.Compiler)._new())._eval_forPackage_([$recv([$recv([$recv("typeof(".__comma(aString)).__comma(")!== \x22undefined\x22||(function(){try{return(")
,$ctx1.sendIdx[","]=3
][0]).__comma(aString)
,$ctx1.sendIdx[","]=2
][0]).__comma(",true)}catch(_){return false}})()")
,$ctx1.sendIdx[","]=1
][0],aPackage);
}, function($ctx1) {$ctx1.fill(self,"isVariableKnown:inPackage:",{aString:aString,aPackage:aPackage})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: "accessing",
args: [],
source: "messageSends\x0a\x09^ messageSends ifNil: [ messageSends := Dictionary new ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.messageSends;
if($1 == null || $1.a$nil){
$self.messageSends=$recv($globals.Dictionary)._new();
return $self.messageSends;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"messageSends",{})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "newBlockScope",
protocol: "factory",
args: [],
source: "newBlockScope\x0a\x09^ self newScopeOfClass: LexicalScope",
referencedClasses: ["LexicalScope"],
pragmas: [],
messageSends: ["newScopeOfClass:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._newScopeOfClass_($globals.LexicalScope);
}, function($ctx1) {$ctx1.fill(self,"newBlockScope",{})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "newMethodScope",
protocol: "factory",
args: [],
source: "newMethodScope\x0a\x09^ self newScopeOfClass: MethodLexicalScope",
referencedClasses: ["MethodLexicalScope"],
pragmas: [],
messageSends: ["newScopeOfClass:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._newScopeOfClass_($globals.MethodLexicalScope);
}, function($ctx1) {$ctx1.fill(self,"newMethodScope",{})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "newScopeOfClass:",
protocol: "factory",
args: ["aLexicalScopeClass"],
source: "newScopeOfClass: aLexicalScopeClass\x0a\x09^ aLexicalScopeClass new\x0a\x09\x09outerScope: currentScope;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["outerScope:", "new", "yourself"]
}, function ($methodClass){ return function (aLexicalScopeClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(aLexicalScopeClass)._new();
$recv($1)._outerScope_($self.currentScope);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"newScopeOfClass:",{aLexicalScopeClass:aLexicalScopeClass})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "nextBlockIndex",
protocol: "private",
args: [],
source: "nextBlockIndex\x0a\x09blockIndex ifNil: [ blockIndex := 0 ].\x0a\x09\x0a\x09blockIndex := blockIndex + 1.\x0a\x09^ blockIndex",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.blockIndex;
if($1 == null || $1.a$nil){
$self.blockIndex=(0);
$self.blockIndex;
} else {
$1;
}
$self.blockIndex=$recv($self.blockIndex).__plus((1));
return $self.blockIndex;
}, function($ctx1) {$ctx1.fill(self,"nextBlockIndex",{})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "popScope",
protocol: "scope",
args: [],
source: "popScope\x0a\x09currentScope ifNotNil: [\x0a\x09\x09currentScope := currentScope outerScope ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "outerScope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.currentScope;
if($1 == null || $1.a$nil){
$1;
} else {
$self.currentScope=$recv($self.currentScope)._outerScope();
$self.currentScope;
}
return self;
}, function($ctx1) {$ctx1.fill(self,"popScope",{})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "pushScope:",
protocol: "scope",
args: ["aScope"],
source: "pushScope: aScope\x0a\x09aScope outerScope: currentScope.\x0a\x09currentScope := aScope",
referencedClasses: [],
pragmas: [],
messageSends: ["outerScope:"]
}, function ($methodClass){ return function (aScope){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aScope)._outerScope_($self.currentScope);
$self.currentScope=aScope;
return self;
}, function($ctx1) {$ctx1.fill(self,"pushScope:",{aScope:aScope})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.theClass=aClass;
return self;

}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "thePackage",
protocol: "accessing",
args: [],
source: "thePackage\x0a\x09^ thePackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.thePackage;

}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "thePackage:",
protocol: "accessing",
args: ["aPackage"],
source: "thePackage: aPackage\x0a\x09thePackage := aPackage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPackage){
var self=this,$self=this;
$self.thePackage=aPackage;
return self;

}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "validateVariableScope:",
protocol: "scope",
args: ["aString"],
source: "validateVariableScope: aString\x0a\x09\x22Validate the variable scope in by doing a recursive lookup, up to the method scope\x22\x0a\x0a\x09(currentScope lookupVariable: aString) ifNotNil: [\x0a\x09\x09self errorShadowingVariable: aString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "lookupVariable:", "errorShadowingVariable:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($self.currentScope)._lookupVariable_(aString);
if($1 == null || $1.a$nil){
$1;
} else {
$self._errorShadowingVariable_(aString);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"validateVariableScope:",{aString:aString})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09| lhs |\x0a\x09super visitAssignmentNode: aNode.\x0a\x09lhs := aNode left.\x0a\x09lhs isAssignable ifFalse: [ self errorInvalidAssignment: lhs identifier ].\x0a\x09lhs assigned: true",
referencedClasses: [],
pragmas: [],
messageSends: ["visitAssignmentNode:", "left", "ifFalse:", "isAssignable", "errorInvalidAssignment:", "identifier", "assigned:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var lhs;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitAssignmentNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
lhs=$recv(aNode)._left();
if(!$core.assert($recv(lhs)._isAssignable())){
$self._errorInvalidAssignment_($recv(lhs)._identifier());
}
$recv(lhs)._assigned_(true);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode,lhs:lhs})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09self pushScope: self newBlockScope.\x0a\x09aNode scope: currentScope.\x0a\x09currentScope node: aNode.\x0a\x09currentScope blockIndex: self nextBlockIndex.\x0a\x0a\x09aNode parameters do: [ :each |\x0a\x09\x09self validateVariableScope: each.\x0a\x09\x09currentScope addArg: each ].\x0a\x0a\x09super visitBlockNode: aNode.\x0a\x09self popScope",
referencedClasses: [],
pragmas: [],
messageSends: ["pushScope:", "newBlockScope", "scope:", "node:", "blockIndex:", "nextBlockIndex", "do:", "parameters", "validateVariableScope:", "addArg:", "visitBlockNode:", "popScope"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._pushScope_($self._newBlockScope());
$recv(aNode)._scope_($self.currentScope);
$recv($self.currentScope)._node_(aNode);
$recv($self.currentScope)._blockIndex_($self._nextBlockIndex());
$recv($recv(aNode)._parameters())._do_((function(each){
return $core.withContext(function($ctx2) {
$self._validateVariableScope_(each);
return $recv($self.currentScope)._addArg_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitBlockNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
$self._popScope();
return self;
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitCascadeNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitCascadeNode: aNode\x0a\x09aNode receiver: aNode dagChildren first receiver.\x0a\x09aNode dagChildren allButLast do: [ :each | each beSideEffect ].\x0a\x09super visitCascadeNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["receiver:", "receiver", "first", "dagChildren", "do:", "allButLast", "beSideEffect", "visitCascadeNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aNode)._receiver_($recv($recv([$recv(aNode)._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._first())._receiver());
$recv($recv($recv(aNode)._dagChildren())._allButLast())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._beSideEffect();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitCascadeNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"visitCascadeNode:",{aNode:aNode})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x09self pushScope: self newMethodScope.\x0a\x09aNode scope: currentScope.\x0a\x09currentScope node: aNode.\x0a\x0a\x09self theClass allSlotNames do: [ :each |\x0a\x09\x09currentScope addSlotVar: each ].\x0a\x09aNode arguments do: [ :each |\x0a\x09\x09self validateVariableScope: each.\x0a\x09\x09currentScope addArg: each ].\x0a\x0a\x09super visitMethodNode: aNode.\x0a\x0a\x09aNode\x0a\x09\x09classReferences: self classReferences;\x0a\x09\x09sendIndexes: self messageSends.\x0a\x09self popScope.\x0a\x09^ aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["pushScope:", "newMethodScope", "scope:", "node:", "do:", "allSlotNames", "theClass", "addSlotVar:", "arguments", "validateVariableScope:", "addArg:", "visitMethodNode:", "classReferences:", "classReferences", "sendIndexes:", "messageSends", "popScope"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._pushScope_($self._newMethodScope());
$recv(aNode)._scope_($self.currentScope);
$recv($self.currentScope)._node_(aNode);
[$recv($recv($self._theClass())._allSlotNames())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv($self.currentScope)._addSlotVar_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
$recv($recv(aNode)._arguments())._do_((function(each){
return $core.withContext(function($ctx2) {
$self._validateVariableScope_(each);
return $recv($self.currentScope)._addArg_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitMethodNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
$recv(aNode)._classReferences_($self._classReferences());
$recv(aNode)._sendIndexes_($self._messageSends());
$self._popScope();
return aNode;
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09aNode scope: currentScope.\x0a\x09currentScope isMethodScope\x0a\x09\x09ifTrue: [ currentScope localReturn: true ]\x0a\x09\x09ifFalse: [ currentScope methodScope addNonLocalReturn: currentScope ].\x0a\x09super visitReturnNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["scope:", "ifTrue:ifFalse:", "isMethodScope", "localReturn:", "addNonLocalReturn:", "methodScope", "visitReturnNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aNode)._scope_($self.currentScope);
if($core.assert($recv($self.currentScope)._isMethodScope())){
$recv($self.currentScope)._localReturn_(true);
} else {
$recv($recv($self.currentScope)._methodScope())._addNonLocalReturn_($self.currentScope);
}
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitReturnNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x0a\x09| sends |\x0a\x09sends := self messageSends at: aNode selector ifAbsentPut: [ OrderedCollection new ].\x0a\x09sends add: aNode.\x0a\x0a\x09aNode index: sends size.\x0a\x0a\x09super visitSendNode: aNode",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["at:ifAbsentPut:", "messageSends", "selector", "new", "add:", "index:", "size", "visitSendNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var sends;
return $core.withContext(function($ctx1) {
sends=$recv($self._messageSends())._at_ifAbsentPut_($recv(aNode)._selector(),(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.OrderedCollection)._new();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(sends)._add_(aNode);
$recv(aNode)._index_($recv(sends)._size());
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitSendNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,sends:sends})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09aNode temps do: [ :each |\x0a\x09\x09self validateVariableScope: each.\x0a\x09\x09currentScope addTemp: each ].\x0a\x0a\x09super visitSequenceNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "temps", "validateVariableScope:", "addTemp:", "visitSequenceNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aNode)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
$self._validateVariableScope_(each);
return $recv($self.currentScope)._addTemp_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitSequenceNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode})});
}; }),
$globals.SemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09\x22Bind a ScopeVar to aNode by doing a lookup in the current scope.\x0a\x09If no var is found in scope, represent an externally known variable or throw an error.\x22\x0a\x0a\x09aNode binding:\x0a\x09\x09((currentScope lookupVariable: aNode identifier) ifNil: [ self bindUnscopedVariable: aNode identifier ])",
referencedClasses: [],
pragmas: [],
messageSends: ["binding:", "ifNil:", "lookupVariable:", "identifier", "bindUnscopedVariable:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($self.currentScope)._lookupVariable_([$recv(aNode)._identifier()
,$ctx1.sendIdx["identifier"]=1
][0]);
if($1 == null || $1.a$nil){
$2=$self._bindUnscopedVariable_($recv(aNode)._identifier());
} else {
$2=$1;
}
$recv(aNode)._binding_($2);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode})});
}; }),
$globals.SemanticAnalyzer);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aClass"],
source: "on: aClass\x0a\x09^ self new\x0a\x09\x09theClass: aClass;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["theClass:", "new", "yourself"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._theClass_(aClass);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aClass:aClass})});
}; }),
$globals.SemanticAnalyzer.a$cls);


$core.addClass("SemanticError", $globals.CompilerError, "Compiler-Semantic");
$globals.SemanticError.comment="I represent an abstract semantic error thrown by the SemanticAnalyzer.\x0aSemantic errors can be unknown variable errors, etc.\x0aSee my subclasses for concrete errors.\x0a\x0aThe IDE should catch instances of Semantic error to deal with them when compiling";


$core.addClass("InvalidAssignmentError", $globals.SemanticError, "Compiler-Semantic");
$core.setSlots($globals.InvalidAssignmentError, ["variableName"]);
$globals.InvalidAssignmentError.comment="I get signaled when a pseudo variable gets assigned.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09^ ' Invalid assignment to variable: ', self variableName",
referencedClasses: [],
pragmas: [],
messageSends: [",", "variableName"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return " Invalid assignment to variable: ".__comma($self._variableName());
}, function($ctx1) {$ctx1.fill(self,"messageText",{})});
}; }),
$globals.InvalidAssignmentError);

$core.addMethod(
$core.method({
selector: "variableName",
protocol: "accessing",
args: [],
source: "variableName\x0a\x09^ variableName",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.variableName;

}; }),
$globals.InvalidAssignmentError);

$core.addMethod(
$core.method({
selector: "variableName:",
protocol: "accessing",
args: ["aString"],
source: "variableName: aString\x0a\x09variableName := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.variableName=aString;
return self;

}; }),
$globals.InvalidAssignmentError);



$core.addClass("ShadowingVariableError", $globals.SemanticError, "Compiler-Semantic");
$core.setSlots($globals.ShadowingVariableError, ["variableName"]);
$globals.ShadowingVariableError.comment="I get signaled when a variable in a block or method scope shadows a variable of the same name in an outer scope.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09^ 'Variable shadowing error: ', self variableName, ' is already defined'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "variableName"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv("Variable shadowing error: ".__comma($self._variableName())).__comma(" is already defined")
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"messageText",{})});
}; }),
$globals.ShadowingVariableError);

$core.addMethod(
$core.method({
selector: "variableName",
protocol: "accessing",
args: [],
source: "variableName\x0a\x09^ variableName",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.variableName;

}; }),
$globals.ShadowingVariableError);

$core.addMethod(
$core.method({
selector: "variableName:",
protocol: "accessing",
args: ["aString"],
source: "variableName: aString\x0a\x09variableName := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.variableName=aString;
return self;

}; }),
$globals.ShadowingVariableError);



$core.addClass("UnknownVariableError", $globals.SemanticError, "Compiler-Semantic");
$core.setSlots($globals.UnknownVariableError, ["variableName"]);
$globals.UnknownVariableError.comment="I get signaled when a variable is not defined.\x0aThe default behavior is to allow it, as this is how Amber currently is able to seamlessly send messages to JavaScript objects.";
$core.addMethod(
$core.method({
selector: "messageText",
protocol: "accessing",
args: [],
source: "messageText\x0a\x09^ 'Unknown Variable error: ', self variableName, ' is not defined'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "variableName"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv("Unknown Variable error: ".__comma($self._variableName())).__comma(" is not defined")
,$ctx1.sendIdx[","]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"messageText",{})});
}; }),
$globals.UnknownVariableError);

$core.addMethod(
$core.method({
selector: "variableName",
protocol: "accessing",
args: [],
source: "variableName\x0a\x09^ variableName",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.variableName;

}; }),
$globals.UnknownVariableError);

$core.addMethod(
$core.method({
selector: "variableName:",
protocol: "accessing",
args: ["aString"],
source: "variableName: aString\x0a\x09variableName := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.variableName=aString;
return self;

}; }),
$globals.UnknownVariableError);


$core.addMethod(
$core.method({
selector: "jsOverride:",
protocol: "*Compiler-Semantic",
args: ["aString"],
source: "jsOverride: aString\x0a\x09(JSSuperSendVisitor new property: aString; yourself)\x0a\x09\x09visit: self methodNode",
referencedClasses: ["JSSuperSendVisitor"],
pragmas: [],
messageSends: ["visit:", "property:", "new", "yourself", "methodNode"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.JSSuperSendVisitor)._new();
$recv($1)._property_(aString);
$recv($recv($1)._yourself())._visit_($self._methodNode());
return self;
}, function($ctx1) {$ctx1.fill(self,"jsOverride:",{aString:aString})});
}; }),
$globals.AstSemanticPragmator);

$core.addMethod(
$core.method({
selector: "jsOverride:args:",
protocol: "*Compiler-Semantic",
args: ["aString", "aCollection"],
source: "jsOverride: aString args: aCollection\x0a\x09(JSSuperSendVisitor new property: aString; args: aCollection; yourself)\x0a\x09\x09visit: self methodNode",
referencedClasses: ["JSSuperSendVisitor"],
pragmas: [],
messageSends: ["visit:", "property:", "new", "args:", "yourself", "methodNode"]
}, function ($methodClass){ return function (aString,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.JSSuperSendVisitor)._new();
$recv($1)._property_(aString);
$recv($1)._args_(aCollection);
$recv($recv($1)._yourself())._visit_($self._methodNode());
return self;
}, function($ctx1) {$ctx1.fill(self,"jsOverride:args:",{aString:aString,aCollection:aCollection})});
}; }),
$globals.AstSemanticPragmator);

});

define('amber/core/Compiler-IR',["amber/boot", "require", "amber/core/Compiler-AST", "amber/core/Compiler-Core", "amber/core/Compiler-Semantic", "amber/core/Kernel-Dag", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-IR");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("IRASTTranslator", $globals.NodeVisitor, "Compiler-IR");
$core.setSlots($globals.IRASTTranslator, ["source", "theClass", "method", "sequence"]);
$globals.IRASTTranslator.comment="I am the AST (abstract syntax tree) visitor responsible for building the intermediate representation graph.";
$core.addMethod(
$core.method({
selector: "addToSequence:",
protocol: "visiting",
args: ["anInstruction"],
source: "addToSequence: anInstruction\x0a\x09anInstruction ifNotNil: [\x0a\x09\x09anInstruction isVariable ifFalse: [\x0a\x09\x09\x09self sequence add: anInstruction ] ].\x0a\x09^ anInstruction",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "ifFalse:", "isVariable", "add:", "sequence"]
}, function ($methodClass){ return function (anInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(anInstruction == null || anInstruction.a$nil){
anInstruction;
} else {
if(!$core.assert($recv(anInstruction)._isVariable())){
$recv($self._sequence())._add_(anInstruction);
}
}
return anInstruction;
}, function($ctx1) {$ctx1.fill(self,"addToSequence:",{anInstruction:anInstruction})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "alias:",
protocol: "visiting",
args: ["anExpressionNode"],
source: "alias: anExpressionNode\x0a\x09| assignment |\x0a\x0a\x09anExpressionNode isIdempotent ifTrue: [ ^ self visit: anExpressionNode ].\x0a\x0a\x09assignment := self method newAliasingOf: (self visit: anExpressionNode).\x0a\x09self addToSequence: assignment.\x0a\x0a\x09^ assignment left",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "isIdempotent", "visit:", "newAliasingOf:", "method", "addToSequence:", "left"]
}, function ($methodClass){ return function (anExpressionNode){
var self=this,$self=this;
var assignment;
return $core.withContext(function($ctx1) {
if($core.assert($recv(anExpressionNode)._isIdempotent())){
return [$self._visit_(anExpressionNode)
,$ctx1.sendIdx["visit:"]=1
][0];
}
assignment=$recv($self._method())._newAliasingOf_($self._visit_(anExpressionNode));
$self._addToSequence_(assignment);
return $recv(assignment)._left();
}, function($ctx1) {$ctx1.fill(self,"alias:",{anExpressionNode:anExpressionNode,assignment:assignment})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "aliasTemporally:",
protocol: "visiting",
args: ["aCollection"],
source: "aliasTemporally: aCollection\x0a\x09\x22https://lolg.it/amber/amber/issues/296\x0a\x09\x0a\x09If a node is aliased, all preceding ones are aliased as well.\x0a\x09The tree is iterated twice. First we get the aliasing dependency,\x0a\x09then the aliasing itself is done\x22\x0a\x0a\x09| threshold shouldAlias |\x0a\x09shouldAlias := false.\x0a\x09threshold := aCollection reversed\x0a\x09\x09detect: [ :each |\x0a\x09\x09\x09shouldAlias or: [\x0a\x09\x09\x09\x09each shouldBeAliased or: [\x0a\x09\x09\x09\x09\x09(each hasOpeningStatements or: [ each subtreeNeedsAliasing ]) ifTrue: [ shouldAlias := true ].\x0a\x09\x09\x09\x09\x09false ] ] ]\x0a\x09\x09ifNone: [ nil ].\x0a\x09threshold ifNil: [ ^ self visitAll: aCollection ].\x0a\x0a\x09shouldAlias := true.\x0a\x09^ aCollection collect: [ :each |\x0a\x09\x09shouldAlias\x0a\x09\x09\x09ifTrue: [ each == threshold ifTrue: [ shouldAlias := false ]. self alias: each ]\x0a\x09\x09\x09ifFalse: [ self visit: each ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["detect:ifNone:", "reversed", "or:", "shouldBeAliased", "ifTrue:", "hasOpeningStatements", "subtreeNeedsAliasing", "ifNil:", "visitAll:", "collect:", "ifTrue:ifFalse:", "==", "alias:", "visit:"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var threshold,shouldAlias;
return $core.withContext(function($ctx1) {
var $1,$2;
shouldAlias=false;
threshold=$recv($recv(aCollection)._reversed())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert(shouldAlias)){
return true;
} else {
if($core.assert($recv(each)._shouldBeAliased())){
return true;
} else {
if($core.assert($recv(each)._hasOpeningStatements())){
$1=true;
} else {
$1=$recv(each)._subtreeNeedsAliasing();
}
if($core.assert($1)){
shouldAlias=true;
shouldAlias;
}
return false;
}
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return nil;

}));
$2=threshold;
if($2 == null || $2.a$nil){
return $self._visitAll_(aCollection);
} else {
$2;
}
shouldAlias=true;
return $recv(aCollection)._collect_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert(shouldAlias)){
if($core.assert($recv(each).__eq_eq(threshold))){
shouldAlias=false;
shouldAlias;
}
return $self._alias_(each);
} else {
return $self._visit_(each);
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,8)});
}));
}, function($ctx1) {$ctx1.fill(self,"aliasTemporally:",{aCollection:aCollection,threshold:threshold,shouldAlias:shouldAlias})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "method",
protocol: "accessing",
args: [],
source: "method\x0a\x09^ method",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.method;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "method:",
protocol: "accessing",
args: ["anIRMethod"],
source: "method: anIRMethod\x0a\x09method := anIRMethod",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anIRMethod){
var self=this,$self=this;
$self.method=anIRMethod;
return self;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "sequence",
protocol: "accessing",
args: [],
source: "sequence\x0a\x09^ sequence",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.sequence;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "sequence:",
protocol: "accessing",
args: ["anIRSequence"],
source: "sequence: anIRSequence\x0a\x09sequence := anIRSequence",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anIRSequence){
var self=this,$self=this;
$self.sequence=anIRSequence;
return self;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "source",
protocol: "accessing",
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.source;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "source:",
protocol: "accessing",
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.source=aString;
return self;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.theClass=aClass;
return self;

}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09| left right assignment |\x0a\x09right := self visit: aNode right.\x0a\x09left := self visit: aNode left.\x0a\x09self addToSequence: (IRAssignment new\x0a\x09\x09add: left;\x0a\x09\x09add: right;\x0a\x09\x09yourself).\x0a\x09^ left",
referencedClasses: ["IRAssignment"],
pragmas: [],
messageSends: ["visit:", "right", "left", "addToSequence:", "add:", "new", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var left,right,assignment;
return $core.withContext(function($ctx1) {
var $1;
right=[$self._visit_($recv(aNode)._right())
,$ctx1.sendIdx["visit:"]=1
][0];
left=$self._visit_($recv(aNode)._left());
$1=$recv($globals.IRAssignment)._new();
[$recv($1)._add_(left)
,$ctx1.sendIdx["add:"]=1
][0];
$recv($1)._add_(right);
$self._addToSequence_($recv($1)._yourself());
return left;
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode,left:left,right:right,assignment:assignment})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09| closure |\x0a\x09closure := IRClosure new\x0a\x09\x09arguments: aNode parameters;\x0a\x09\x09requiresSmalltalkContext: aNode requiresSmalltalkContext;\x0a\x09\x09scope: aNode scope;\x0a\x09\x09yourself.\x0a\x09aNode scope temps do: [ :each |\x0a\x09\x09closure add: (IRTempDeclaration new\x0a\x09\x09\x09name: each name;\x0a\x09\x09\x09scope: aNode scope;\x0a\x09\x09\x09yourself) ].\x0a\x09closure add: (self visit: aNode sequenceNode).\x0a\x09^ closure",
referencedClasses: ["IRClosure", "IRTempDeclaration"],
pragmas: [],
messageSends: ["arguments:", "new", "parameters", "requiresSmalltalkContext:", "requiresSmalltalkContext", "scope:", "scope", "yourself", "do:", "temps", "add:", "name:", "name", "visit:", "sequenceNode"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var closure;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$1=[$recv($globals.IRClosure)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._arguments_($recv(aNode)._parameters());
$recv($1)._requiresSmalltalkContext_($recv(aNode)._requiresSmalltalkContext());
[$recv($1)._scope_([$recv(aNode)._scope()
,$ctx1.sendIdx["scope"]=1
][0])
,$ctx1.sendIdx["scope:"]=1
][0];
closure=[$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0];
$recv($recv([$recv(aNode)._scope()
,$ctx1.sendIdx["scope"]=2
][0])._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
$2=closure;
$3=$recv($globals.IRTempDeclaration)._new();
$recv($3)._name_($recv(each)._name());
$recv($3)._scope_($recv(aNode)._scope());
return [$recv($2)._add_($recv($3)._yourself())
,$ctx2.sendIdx["add:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv(closure)._add_($self._visit_($recv(aNode)._sequenceNode()));
return closure;
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode,closure:closure})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitBlockSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockSequenceNode: aNode\x0a\x09^ self\x0a\x09\x09withSequence: IRBlockSequence new\x0a\x09\x09do: [\x0a\x09\x09\x09aNode dagChildren ifNotEmpty: [\x0a\x09\x09\x09\x09aNode dagChildren allButLast do: [ :each |\x0a\x09\x09\x09\x09\x09self addToSequence: (self visit: each) ].\x0a\x09\x09\x09\x09aNode dagChildren last isReturnNode\x0a\x09\x09\x09\x09\x09ifFalse: [ self addToSequence: (IRBlockReturn new add: (self visit: aNode dagChildren last); yourself) ]\x0a\x09\x09\x09\x09\x09ifTrue: [ self addToSequence: (self visit: aNode dagChildren last) ] ]]",
referencedClasses: ["IRBlockSequence", "IRBlockReturn"],
pragmas: [],
messageSends: ["withSequence:do:", "new", "ifNotEmpty:", "dagChildren", "do:", "allButLast", "addToSequence:", "visit:", "ifFalse:ifTrue:", "isReturnNode", "last", "add:", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $self._withSequence_do_([$recv($globals.IRBlockSequence)._new()
,$ctx1.sendIdx["new"]=1
][0],(function(){
return $core.withContext(function($ctx2) {
return $recv([$recv(aNode)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=1
][0])._ifNotEmpty_((function(){
return $core.withContext(function($ctx3) {
$recv($recv([$recv(aNode)._dagChildren()
,$ctx3.sendIdx["dagChildren"]=2
][0])._allButLast())._do_((function(each){
return $core.withContext(function($ctx4) {
return [$self._addToSequence_([$self._visit_(each)
,$ctx4.sendIdx["visit:"]=1
][0])
,$ctx4.sendIdx["addToSequence:"]=1
][0];
}, function($ctx4) {$ctx4.fillBlock({each:each},$ctx3,3)});
}));
if($core.assert($recv([$recv([$recv(aNode)._dagChildren()
,$ctx3.sendIdx["dagChildren"]=3
][0])._last()
,$ctx3.sendIdx["last"]=1
][0])._isReturnNode())){
return $self._addToSequence_($self._visit_($recv($recv(aNode)._dagChildren())._last()));
} else {
$1=$recv($globals.IRBlockReturn)._new();
$recv($1)._add_([$self._visit_([$recv([$recv(aNode)._dagChildren()
,$ctx3.sendIdx["dagChildren"]=4
][0])._last()
,$ctx3.sendIdx["last"]=2
][0])
,$ctx3.sendIdx["visit:"]=2
][0]);
return [$self._addToSequence_($recv($1)._yourself())
,$ctx3.sendIdx["addToSequence:"]=2
][0];
}
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitBlockSequenceNode:",{aNode:aNode})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitCascadeNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitCascadeNode: aNode\x0a\x09| receiver |\x0a\x09receiver := aNode receiver.\x0a\x09receiver isIdempotent ifFalse: [\x0a\x09\x09| alias |\x0a\x09\x09alias := self alias: receiver.\x0a\x09\x09receiver := VariableNode new binding: alias variable ].\x0a\x09aNode dagChildren do: [ :each | each receiver: receiver ].\x0a\x0a\x09aNode dagChildren allButLast do: [ :each |\x0a\x09\x09self addToSequence: (self visit: each) ].\x0a\x0a\x09^ self visit: aNode dagChildren last",
referencedClasses: ["VariableNode"],
pragmas: [],
messageSends: ["receiver", "ifFalse:", "isIdempotent", "alias:", "binding:", "new", "variable", "do:", "dagChildren", "receiver:", "allButLast", "addToSequence:", "visit:", "last"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var receiver;
return $core.withContext(function($ctx1) {
receiver=$recv(aNode)._receiver();
if(!$core.assert($recv(receiver)._isIdempotent())){
var alias;
alias=$self._alias_(receiver);
receiver=$recv($recv($globals.VariableNode)._new())._binding_($recv(alias)._variable());
receiver;
}
[$recv([$recv(aNode)._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._receiver_(receiver);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
$recv($recv([$recv(aNode)._dagChildren()
,$ctx1.sendIdx["dagChildren"]=2
][0])._allButLast())._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._addToSequence_([$self._visit_(each)
,$ctx2.sendIdx["visit:"]=1
][0]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return $self._visit_($recv($recv(aNode)._dagChildren())._last());
}, function($ctx1) {$ctx1.fill(self,"visitCascadeNode:",{aNode:aNode,receiver:receiver})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitDynamicArrayNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDynamicArrayNode: aNode\x0a\x09| array |\x0a\x09array := IRDynamicArray new.\x0a\x09(self aliasTemporally: aNode dagChildren) do: [ :each | array add: each ].\x0a\x09^ array",
referencedClasses: ["IRDynamicArray"],
pragmas: [],
messageSends: ["new", "do:", "aliasTemporally:", "dagChildren", "add:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=$recv($globals.IRDynamicArray)._new();
$recv($self._aliasTemporally_($recv(aNode)._dagChildren()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(array)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return array;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicArrayNode:",{aNode:aNode,array:array})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitDynamicDictionaryNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDynamicDictionaryNode: aNode\x0a\x09| dictionary |\x0a\x09dictionary := IRDynamicDictionary new.\x0a\x09(self aliasTemporally: aNode dagChildren) do: [ :each | dictionary add: each ].\x0a\x09^ dictionary",
referencedClasses: ["IRDynamicDictionary"],
pragmas: [],
messageSends: ["new", "do:", "aliasTemporally:", "dagChildren", "add:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var dictionary;
return $core.withContext(function($ctx1) {
dictionary=$recv($globals.IRDynamicDictionary)._new();
$recv($self._aliasTemporally_($recv(aNode)._dagChildren()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(dictionary)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return dictionary;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicDictionaryNode:",{aNode:aNode,dictionary:dictionary})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09^ IRVerbatim new\x0a\x09\x09source: aNode source crlfSanitized;\x0a\x09\x09yourself",
referencedClasses: ["IRVerbatim"],
pragmas: [],
messageSends: ["source:", "new", "crlfSanitized", "source", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRVerbatim)._new();
$recv($1)._source_($recv($recv(aNode)._source())._crlfSanitized());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitJSStatementNode:",{aNode:aNode})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitMethodNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitMethodNode: aNode\x0a\x09| irSequence |\x0a\x0a\x09self method: (IRMethod new\x0a\x09\x09source: self source;\x0a\x09\x09pragmas: (aNode pragmas collect: [ :each |\x0a\x09\x09\x09Message\x0a\x09\x09\x09\x09selector: each selector\x0a\x09\x09\x09\x09arguments: (each arguments collect: [ :eachArg |\x0a\x09\x09\x09\x09\x09eachArg isString ifTrue: [ eachArg crlfSanitized ] ifFalse: [ eachArg ]])]);\x0a\x09\x09theClass: self theClass;\x0a\x09\x09arguments: aNode arguments;\x0a\x09\x09selector: aNode selector;\x0a\x09\x09sendIndexes: aNode sendIndexes;\x0a\x09\x09requiresSmalltalkContext: aNode requiresSmalltalkContext;\x0a\x09\x09classReferences: aNode classReferences;\x0a\x09\x09scope: aNode scope;\x0a\x09\x09yourself).\x0a\x0a\x09aNode scope temps do: [ :each |\x0a\x09\x09self method add: (IRTempDeclaration new\x0a\x09\x09\x09name: each name;\x0a\x09\x09\x09scope: aNode scope;\x0a\x09\x09\x09yourself) ].\x0a\x0a\x09self method add: (irSequence := self visit: aNode sequenceNode).\x0a\x0a\x09aNode scope hasLocalReturn ifFalse: [ irSequence\x0a\x09\x09add: (IRReturn new\x0a\x09\x09\x09add: (IRVariable new\x0a\x09\x09\x09\x09variable: (aNode scope pseudoVars at: 'self');\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself) ].\x0a\x0a\x09^ self method",
referencedClasses: ["IRMethod", "Message", "IRTempDeclaration", "IRReturn", "IRVariable"],
pragmas: [],
messageSends: ["method:", "source:", "new", "source", "pragmas:", "collect:", "pragmas", "selector:arguments:", "selector", "arguments", "ifTrue:ifFalse:", "isString", "crlfSanitized", "theClass:", "theClass", "arguments:", "selector:", "sendIndexes:", "sendIndexes", "requiresSmalltalkContext:", "requiresSmalltalkContext", "classReferences:", "classReferences", "scope:", "scope", "yourself", "do:", "temps", "add:", "method", "name:", "name", "visit:", "sequenceNode", "ifFalse:", "hasLocalReturn", "variable:", "at:", "pseudoVars"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var irSequence;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7;
$1=[$recv($globals.IRMethod)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._source_($self._source());
$recv($1)._pragmas_([$recv($recv(aNode)._pragmas())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($globals.Message)._selector_arguments_([$recv(each)._selector()
,$ctx2.sendIdx["selector"]=1
][0],$recv([$recv(each)._arguments()
,$ctx2.sendIdx["arguments"]=1
][0])._collect_((function(eachArg){
return $core.withContext(function($ctx3) {
if($core.assert($recv(eachArg)._isString())){
return $recv(eachArg)._crlfSanitized();
} else {
return eachArg;
}
}, function($ctx3) {$ctx3.fillBlock({eachArg:eachArg},$ctx2,2)});
})));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["collect:"]=1
][0]);
$recv($1)._theClass_($self._theClass());
$recv($1)._arguments_($recv(aNode)._arguments());
$recv($1)._selector_($recv(aNode)._selector());
$recv($1)._sendIndexes_($recv(aNode)._sendIndexes());
$recv($1)._requiresSmalltalkContext_($recv(aNode)._requiresSmalltalkContext());
$recv($1)._classReferences_($recv(aNode)._classReferences());
[$recv($1)._scope_([$recv(aNode)._scope()
,$ctx1.sendIdx["scope"]=1
][0])
,$ctx1.sendIdx["scope:"]=1
][0];
$self._method_([$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]);
$recv($recv([$recv(aNode)._scope()
,$ctx1.sendIdx["scope"]=2
][0])._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
$2=[$self._method()
,$ctx2.sendIdx["method"]=1
][0];
$3=[$recv($globals.IRTempDeclaration)._new()
,$ctx2.sendIdx["new"]=2
][0];
$recv($3)._name_($recv(each)._name());
$recv($3)._scope_([$recv(aNode)._scope()
,$ctx2.sendIdx["scope"]=3
][0]);
return [$recv($2)._add_([$recv($3)._yourself()
,$ctx2.sendIdx["yourself"]=2
][0])
,$ctx2.sendIdx["add:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,5)});
}));
$4=[$self._method()
,$ctx1.sendIdx["method"]=2
][0];
irSequence=$self._visit_($recv(aNode)._sequenceNode());
[$recv($4)._add_(irSequence)
,$ctx1.sendIdx["add:"]=2
][0];
if(!$core.assert($recv([$recv(aNode)._scope()
,$ctx1.sendIdx["scope"]=4
][0])._hasLocalReturn())){
$5=irSequence;
$6=[$recv($globals.IRReturn)._new()
,$ctx1.sendIdx["new"]=3
][0];
$7=$recv($globals.IRVariable)._new();
$recv($7)._variable_($recv($recv($recv(aNode)._scope())._pseudoVars())._at_("self"));
$recv($6)._add_([$recv($7)._yourself()
,$ctx1.sendIdx["yourself"]=3
][0]);
[$recv($5)._add_($recv($6)._yourself())
,$ctx1.sendIdx["add:"]=3
][0];
}
return $self._method();
}, function($ctx1) {$ctx1.fill(self,"visitMethodNode:",{aNode:aNode,irSequence:irSequence})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09^ (aNode nonLocalReturn\x0a\x09\x09ifTrue: [ IRNonLocalReturn new ]\x0a\x09\x09ifFalse: [ IRReturn new ])\x0a\x09\x09scope: aNode scope;\x0a\x09\x09add: (self visit: aNode expression);\x0a\x09\x09yourself",
referencedClasses: ["IRNonLocalReturn", "IRReturn"],
pragmas: [],
messageSends: ["scope:", "ifTrue:ifFalse:", "nonLocalReturn", "new", "scope", "add:", "visit:", "expression", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($recv(aNode)._nonLocalReturn())){
$1=[$recv($globals.IRNonLocalReturn)._new()
,$ctx1.sendIdx["new"]=1
][0];
} else {
$1=$recv($globals.IRReturn)._new();
}
$recv($1)._scope_($recv(aNode)._scope());
$recv($1)._add_($self._visit_($recv(aNode)._expression()));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09| send |\x0a\x09send := IRSend new.\x0a\x09send\x0a\x09\x09selector: aNode selector;\x0a\x09\x09javaScriptSelector: aNode javaScriptSelector;\x0a\x09\x09argumentSwitcher: aNode argumentSwitcher;\x0a\x09\x09index: aNode index.\x0a\x09\x0a\x09(self aliasTemporally: aNode dagChildren) do: [ :each | send add: each ].\x0a\x0a\x09^ send",
referencedClasses: ["IRSend"],
pragmas: [],
messageSends: ["new", "selector:", "selector", "javaScriptSelector:", "javaScriptSelector", "argumentSwitcher:", "argumentSwitcher", "index:", "index", "do:", "aliasTemporally:", "dagChildren", "add:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var send;
return $core.withContext(function($ctx1) {
var $1;
send=$recv($globals.IRSend)._new();
$1=send;
$recv($1)._selector_($recv(aNode)._selector());
$recv($1)._javaScriptSelector_($recv(aNode)._javaScriptSelector());
$recv($1)._argumentSwitcher_($recv(aNode)._argumentSwitcher());
$recv($1)._index_($recv(aNode)._index());
$recv($self._aliasTemporally_($recv(aNode)._dagChildren()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(send)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return send;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,send:send})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09^ self\x0a\x09\x09withSequence: IRSequence new\x0a\x09\x09do: [ aNode dagChildren do: [ :each |\x0a\x09\x09\x09self addToSequence: (self visit: each) ] ]",
referencedClasses: ["IRSequence"],
pragmas: [],
messageSends: ["withSequence:do:", "new", "do:", "dagChildren", "addToSequence:", "visit:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._withSequence_do_($recv($globals.IRSequence)._new(),(function(){
return $core.withContext(function($ctx2) {
return $recv($recv(aNode)._dagChildren())._do_((function(each){
return $core.withContext(function($ctx3) {
return $self._addToSequence_($self._visit_(each));
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitValueNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitValueNode: aNode\x0a\x09^ IRValue new\x0a\x09\x09value: aNode value;\x0a\x09\x09yourself",
referencedClasses: ["IRValue"],
pragmas: [],
messageSends: ["value:", "new", "value", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRValue)._new();
$recv($1)._value_($recv(aNode)._value());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitValueNode:",{aNode:aNode})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09^ IRVariable new\x0a\x09\x09variable: aNode binding;\x0a\x09\x09yourself",
referencedClasses: ["IRVariable"],
pragmas: [],
messageSends: ["variable:", "new", "binding", "yourself"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRVariable)._new();
$recv($1)._variable_($recv(aNode)._binding());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode})});
}; }),
$globals.IRASTTranslator);

$core.addMethod(
$core.method({
selector: "withSequence:do:",
protocol: "accessing",
args: ["aSequence", "aBlock"],
source: "withSequence: aSequence do: aBlock\x0a\x09| outerSequence |\x0a\x09outerSequence := self sequence.\x0a\x09self sequence: aSequence.\x0a\x09aBlock value.\x0a\x09self sequence: outerSequence.\x0a\x09^ aSequence",
referencedClasses: [],
pragmas: [],
messageSends: ["sequence", "sequence:", "value"]
}, function ($methodClass){ return function (aSequence,aBlock){
var self=this,$self=this;
var outerSequence;
return $core.withContext(function($ctx1) {
outerSequence=$self._sequence();
[$self._sequence_(aSequence)
,$ctx1.sendIdx["sequence:"]=1
][0];
$recv(aBlock)._value();
$self._sequence_(outerSequence);
return aSequence;
}, function($ctx1) {$ctx1.fill(self,"withSequence:do:",{aSequence:aSequence,aBlock:aBlock,outerSequence:outerSequence})});
}; }),
$globals.IRASTTranslator);



$core.addClass("IRAliasFactory", $globals.Object, "Compiler-IR");
$core.setSlots($globals.IRAliasFactory, ["counter"]);
$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09counter := 0",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.counter=(0);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.IRAliasFactory);

$core.addMethod(
$core.method({
selector: "next",
protocol: "accessing",
args: [],
source: "next\x0a\x09counter := counter + 1.\x0a\x09^ AliasVar new\x0a\x09\x09name: '$', counter asString;\x0a\x09\x09yourself",
referencedClasses: ["AliasVar"],
pragmas: [],
messageSends: ["+", "name:", "new", ",", "asString", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.counter=$recv($self.counter).__plus((1));
$1=$recv($globals.AliasVar)._new();
$recv($1)._name_("$".__comma($recv($self.counter)._asString()));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"next",{})});
}; }),
$globals.IRAliasFactory);



$core.addClass("IRInstruction", $globals.DagParentNode, "Compiler-IR");
$core.setSlots($globals.IRInstruction, ["parent"]);
$globals.IRInstruction.comment="I am the abstract root class of the IR (intermediate representation) instructions class hierarchy.\x0aThe IR graph is used to emit JavaScript code using a JSStream.";
$core.addMethod(
$core.method({
selector: "add:",
protocol: "building",
args: ["anObject"],
source: "add: anObject\x0a\x09^ self addDagChild: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["addDagChild:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._addDagChild_(anObject);
}, function($ctx1) {$ctx1.fill(self,"add:",{anObject:anObject})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "asReceiver",
protocol: "converting",
args: [],
source: "asReceiver\x0a\x09\x22Return customized form to act as receiver.\x0a\x09Return self to use standard $recv(...) boxing.\x22\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isClosure",
protocol: "testing",
args: [],
source: "isClosure\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: "testing",
args: [],
source: "isInlined\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isMethod",
protocol: "testing",
args: [],
source: "isMethod\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isSend",
protocol: "testing",
args: [],
source: "isSend\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isSequence",
protocol: "testing",
args: [],
source: "isSequence\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isSuper",
protocol: "testing",
args: [],
source: "isSuper\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isTempDeclaration",
protocol: "testing",
args: [],
source: "isTempDeclaration\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "isVariable",
protocol: "testing",
args: [],
source: "isVariable\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "method",
protocol: "accessing",
args: [],
source: "method\x0a\x09^ self parent method",
referencedClasses: [],
pragmas: [],
messageSends: ["method", "parent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._parent())._method();
}, function($ctx1) {$ctx1.fill(self,"method",{})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "needsBoxingAsReceiver",
protocol: "testing",
args: [],
source: "needsBoxingAsReceiver\x0a\x09self deprecatedAPI: 'Use asReceiver isNil instead.'.\x0a\x09^ self asReceiver isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["deprecatedAPI:", "isNil", "asReceiver"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._deprecatedAPI_("Use asReceiver isNil instead.");
return $recv($self._asReceiver())._isNil();
}, function($ctx1) {$ctx1.fill(self,"needsBoxingAsReceiver",{})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "parent",
protocol: "accessing",
args: [],
source: "parent\x0a\x09^ parent",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.parent;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "parent:",
protocol: "accessing",
args: ["anIRInstruction"],
source: "parent: anIRInstruction\x0a\x09parent := anIRInstruction",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
$self.parent=anIRInstruction;
return self;

}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "remove:",
protocol: "building",
args: ["anIRInstruction"],
source: "remove: anIRInstruction\x0a\x09self dagChildren remove: anIRInstruction",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:", "dagChildren"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._dagChildren())._remove_(anIRInstruction);
return self;
}, function($ctx1) {$ctx1.fill(self,"remove:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "replace:with:",
protocol: "building",
args: ["anIRInstruction", "anotherIRInstruction"],
source: "replace: anIRInstruction with: anotherIRInstruction\x0a\x09anotherIRInstruction parent: self.\x0a\x09self dagChildren\x0a\x09\x09at: (self dagChildren indexOf: anIRInstruction)\x0a\x09\x09put: anotherIRInstruction",
referencedClasses: [],
pragmas: [],
messageSends: ["parent:", "at:put:", "dagChildren", "indexOf:"]
}, function ($methodClass){ return function (anIRInstruction,anotherIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anotherIRInstruction)._parent_(self);
$recv([$self._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._at_put_($recv($self._dagChildren())._indexOf_(anIRInstruction),anotherIRInstruction);
return self;
}, function($ctx1) {$ctx1.fill(self,"replace:with:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "replaceWith:",
protocol: "building",
args: ["anIRInstruction"],
source: "replaceWith: anIRInstruction\x0a\x09self parent replace: self with: anIRInstruction",
referencedClasses: [],
pragmas: [],
messageSends: ["replace:with:", "parent"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._parent())._replace_with_(self,anIRInstruction);
return self;
}, function($ctx1) {$ctx1.fill(self,"replaceWith:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ self parent ifNotNil: [ :node | \x0a\x09\x09node scope ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "parent", "scope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._parent();
if($1 == null || $1.a$nil){
return $1;
} else {
var node;
node=$1;
return $recv(node)._scope();
}
}, function($ctx1) {$ctx1.fill(self,"scope",{})});
}; }),
$globals.IRInstruction);

$core.addMethod(
$core.method({
selector: "yieldsValue",
protocol: "testing",
args: [],
source: "yieldsValue\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRInstruction);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aBuilder"],
source: "on: aBuilder\x0a\x09^ self new\x0a\x09\x09builder: aBuilder;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["builder:", "new", "yourself"]
}, function ($methodClass){ return function (aBuilder){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._builder_(aBuilder);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{aBuilder:aBuilder})});
}; }),
$globals.IRInstruction.a$cls);


$core.addClass("IRAssignment", $globals.IRInstruction, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRAssignment: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRAssignment:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRAssignment_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRAssignment);

$core.addMethod(
$core.method({
selector: "left",
protocol: "accessing",
args: [],
source: "left\x0a\x09^ self dagChildren first",
referencedClasses: [],
pragmas: [],
messageSends: ["first", "dagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._first();
}, function($ctx1) {$ctx1.fill(self,"left",{})});
}; }),
$globals.IRAssignment);

$core.addMethod(
$core.method({
selector: "right",
protocol: "accessing",
args: [],
source: "right\x0a\x09^ self dagChildren last",
referencedClasses: [],
pragmas: [],
messageSends: ["last", "dagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._last();
}, function($ctx1) {$ctx1.fill(self,"right",{})});
}; }),
$globals.IRAssignment);



$core.addClass("IRDynamicArray", $globals.IRInstruction, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRDynamicArray: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRDynamicArray:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRDynamicArray_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRDynamicArray);



$core.addClass("IRDynamicDictionary", $globals.IRInstruction, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRDynamicDictionary: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRDynamicDictionary:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRDynamicDictionary_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRDynamicDictionary);



$core.addClass("IRScopedInstruction", $globals.IRInstruction, "Compiler-IR");
$core.setSlots($globals.IRScopedInstruction, ["scope"]);
$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ scope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.scope;

}; }),
$globals.IRScopedInstruction);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: "accessing",
args: ["aScope"],
source: "scope: aScope\x0a\x09scope := aScope",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aScope){
var self=this,$self=this;
$self.scope=aScope;
return self;

}; }),
$globals.IRScopedInstruction);



$core.addClass("IRClosureInstruction", $globals.IRScopedInstruction, "Compiler-IR");
$core.setSlots($globals.IRClosureInstruction, ["arguments", "requiresSmalltalkContext"]);
$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ arguments ifNil: [ #() ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.arguments;
if($1 == null || $1.a$nil){
return [];
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "arguments:",
protocol: "accessing",
args: ["aCollection"],
source: "arguments: aCollection\x0a\x09arguments := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.arguments=aCollection;
return self;

}; }),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "locals",
protocol: "accessing",
args: [],
source: "locals\x0a\x09^ self arguments, (self tempDeclarations collect: [ :each | each name ])",
referencedClasses: [],
pragmas: [],
messageSends: [",", "arguments", "collect:", "tempDeclarations", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._arguments()).__comma($recv($self._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._name();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})));
}, function($ctx1) {$ctx1.fill(self,"locals",{})});
}; }),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: "accessing",
args: [],
source: "requiresSmalltalkContext\x0a\x09^ requiresSmalltalkContext ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.requiresSmalltalkContext;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"requiresSmalltalkContext",{})});
}; }),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext:",
protocol: "accessing",
args: ["anObject"],
source: "requiresSmalltalkContext: anObject\x0a\x09requiresSmalltalkContext := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.requiresSmalltalkContext=anObject;
return self;

}; }),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "scope:",
protocol: "accessing",
args: ["aScope"],
source: "scope: aScope\x0a\x09super scope: aScope.\x0a\x09aScope instruction: self",
referencedClasses: [],
pragmas: [],
messageSends: ["scope:", "instruction:"]
}, function ($methodClass){ return function (aScope){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._scope_.call($self,aScope))
,$ctx1.supercall = false
][0];
$recv(aScope)._instruction_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"scope:",{aScope:aScope})});
}; }),
$globals.IRClosureInstruction);

$core.addMethod(
$core.method({
selector: "tempDeclarations",
protocol: "accessing",
args: [],
source: "tempDeclarations\x0a\x09^ self dagChildren select: [ :each |\x0a\x09\x09each isTempDeclaration ]",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "dagChildren", "isTempDeclaration"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isTempDeclaration();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"tempDeclarations",{})});
}; }),
$globals.IRClosureInstruction);



$core.addClass("IRClosure", $globals.IRClosureInstruction, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRClosure: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRClosure:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRClosure_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRClosure);

$core.addMethod(
$core.method({
selector: "isClosure",
protocol: "testing",
args: [],
source: "isClosure\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRClosure);

$core.addMethod(
$core.method({
selector: "sequence",
protocol: "accessing",
args: [],
source: "sequence\x0a\x09^ self dagChildren last",
referencedClasses: [],
pragmas: [],
messageSends: ["last", "dagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._last();
}, function($ctx1) {$ctx1.fill(self,"sequence",{})});
}; }),
$globals.IRClosure);



$core.addClass("IRMethod", $globals.IRClosureInstruction, "Compiler-IR");
$core.setSlots($globals.IRMethod, ["theClass", "source", "compiledSource", "attachments", "selector", "pragmas", "classReferences", "sendIndexes", "internalVariables", "aliasFactory"]);
$globals.IRMethod.comment="I am a method instruction";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRMethod: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRMethod:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRMethod_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "aliasFactory",
protocol: "accessing",
args: [],
source: "aliasFactory\x0a\x09^ aliasFactory ifNil: [ aliasFactory := IRAliasFactory new ]",
referencedClasses: ["IRAliasFactory"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.aliasFactory;
if($1 == null || $1.a$nil){
$self.aliasFactory=$recv($globals.IRAliasFactory)._new();
return $self.aliasFactory;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"aliasFactory",{})});
}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "attachments",
protocol: "accessing",
args: [],
source: "attachments\x0a\x09^ attachments ifNil: [ attachments := #{} ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.attachments;
if($1 == null || $1.a$nil){
$self.attachments=$globals.HashedCollection._newFromPairs_([]);
return $self.attachments;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"attachments",{})});
}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "classReferences",
protocol: "accessing",
args: [],
source: "classReferences\x0a\x09^ classReferences",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.classReferences;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "classReferences:",
protocol: "accessing",
args: ["aCollection"],
source: "classReferences: aCollection\x0a\x09classReferences := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.classReferences=aCollection;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "compiledSource",
protocol: "accessing",
args: [],
source: "compiledSource\x0a\x09^ compiledSource",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.compiledSource;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "compiledSource:",
protocol: "accessing",
args: ["anObject"],
source: "compiledSource: anObject\x0a\x09compiledSource := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.compiledSource=anObject;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "internalVariables",
protocol: "accessing",
args: [],
source: "internalVariables\x0a\x09^ internalVariables ifNil: [ internalVariables := Set new ]",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.internalVariables;
if($1 == null || $1.a$nil){
$self.internalVariables=$recv($globals.Set)._new();
return $self.internalVariables;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"internalVariables",{})});
}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "isMethod",
protocol: "testing",
args: [],
source: "isMethod\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "messageSends",
protocol: "accessing",
args: [],
source: "messageSends\x0a\x09^ self sendIndexes keys",
referencedClasses: [],
pragmas: [],
messageSends: ["keys", "sendIndexes"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._sendIndexes())._keys();
}, function($ctx1) {$ctx1.fill(self,"messageSends",{})});
}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "method",
protocol: "accessing",
args: [],
source: "method\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "newAliasingOf:",
protocol: "accessing",
args: ["anIRInstruction"],
source: "newAliasingOf: anIRInstruction\x0a\x09| variable |\x0a\x0a\x09variable := IRVariable new\x0a\x09\x09variable: self aliasFactory next;\x0a\x09\x09yourself.\x0a\x0a\x09self internalVariables add: variable.\x0a\x0a\x09^ IRAssignment new\x0a\x09\x09add: variable;\x0a\x09\x09add: anIRInstruction;\x0a\x09\x09yourself",
referencedClasses: ["IRVariable", "IRAssignment"],
pragmas: [],
messageSends: ["variable:", "new", "next", "aliasFactory", "yourself", "add:", "internalVariables"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
var variable;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$recv($globals.IRVariable)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._variable_($recv($self._aliasFactory())._next());
variable=[$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0];
[$recv($self._internalVariables())._add_(variable)
,$ctx1.sendIdx["add:"]=1
][0];
$2=$recv($globals.IRAssignment)._new();
[$recv($2)._add_(variable)
,$ctx1.sendIdx["add:"]=2
][0];
$recv($2)._add_(anIRInstruction);
return $recv($2)._yourself();
}, function($ctx1) {$ctx1.fill(self,"newAliasingOf:",{anIRInstruction:anIRInstruction,variable:variable})});
}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "pragmas",
protocol: "accessing",
args: [],
source: "pragmas\x0a\x09^ pragmas",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.pragmas;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "pragmas:",
protocol: "accessing",
args: ["aCollection"],
source: "pragmas: aCollection\x0a\x09pragmas := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.pragmas=aCollection;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: "accessing",
args: [],
source: "sendIndexes\x0a\x09^ sendIndexes",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.sendIndexes;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "sendIndexes:",
protocol: "accessing",
args: ["aDictionary"],
source: "sendIndexes: aDictionary\x0a\x09sendIndexes := aDictionary",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aDictionary){
var self=this,$self=this;
$self.sendIndexes=aDictionary;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "source",
protocol: "accessing",
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.source;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "source:",
protocol: "accessing",
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.source=aString;
return self;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.IRMethod);

$core.addMethod(
$core.method({
selector: "theClass:",
protocol: "accessing",
args: ["aClass"],
source: "theClass: aClass\x0a\x09theClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.theClass=aClass;
return self;

}; }),
$globals.IRMethod);



$core.addClass("IRReturn", $globals.IRScopedInstruction, "Compiler-IR");
$globals.IRReturn.comment="I am a local return instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRReturn: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRReturn:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "expression",
protocol: "accessing",
args: [],
source: "expression\x0a\x09^ self dagChildren single",
referencedClasses: [],
pragmas: [],
messageSends: ["single", "dagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._single();
}, function($ctx1) {$ctx1.fill(self,"expression",{})});
}; }),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "scope",
protocol: "accessing",
args: [],
source: "scope\x0a\x09^ scope ifNil: [ self parent scope ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "scope", "parent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.scope;
if($1 == null || $1.a$nil){
return $recv($self._parent())._scope();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"scope",{})});
}; }),
$globals.IRReturn);

$core.addMethod(
$core.method({
selector: "yieldsValue",
protocol: "testing",
args: [],
source: "yieldsValue\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.IRReturn);



$core.addClass("IRBlockReturn", $globals.IRReturn, "Compiler-IR");
$globals.IRBlockReturn.comment="Smalltalk blocks return their last statement. I am a implicit block return instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRBlockReturn: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRBlockReturn:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRBlockReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRBlockReturn);



$core.addClass("IRNonLocalReturn", $globals.IRReturn, "Compiler-IR");
$globals.IRNonLocalReturn.comment="I am a non local return instruction.\x0aNon local returns are handled using a try/catch JavaScript statement.\x0a\x0aSee `IRNonLocalReturnHandling` class.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRNonLocalReturn: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRNonLocalReturn:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRNonLocalReturn_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRNonLocalReturn);



$core.addClass("IRTempDeclaration", $globals.IRScopedInstruction, "Compiler-IR");
$core.setSlots($globals.IRTempDeclaration, ["name"]);
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRTempDeclaration: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRTempDeclaration:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRTempDeclaration_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRTempDeclaration);

$core.addMethod(
$core.method({
selector: "isTempDeclaration",
protocol: "testing",
args: [],
source: "isTempDeclaration\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRTempDeclaration);

$core.addMethod(
$core.method({
selector: "name",
protocol: "accessing",
args: [],
source: "name\x0a\x09^ name",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.name;

}; }),
$globals.IRTempDeclaration);

$core.addMethod(
$core.method({
selector: "name:",
protocol: "accessing",
args: ["aString"],
source: "name: aString\x0a\x09name := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.name=aString;
return self;

}; }),
$globals.IRTempDeclaration);



$core.addClass("IRSend", $globals.IRInstruction, "Compiler-IR");
$core.setSlots($globals.IRSend, ["selector", "javaScriptSelector", "argumentSwitcher", "index"]);
$globals.IRSend.comment="I am a message send instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRSend: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRSend:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRSend_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "argumentSwitcher",
protocol: "accessing",
args: [],
source: "argumentSwitcher\x0a\x09^ argumentSwitcher",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.argumentSwitcher;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "argumentSwitcher:",
protocol: "accessing",
args: ["aJSFunction"],
source: "argumentSwitcher: aJSFunction\x0a\x09argumentSwitcher := aJSFunction",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aJSFunction){
var self=this,$self=this;
$self.argumentSwitcher=aJSFunction;
return self;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ self dagChildren allButFirst",
referencedClasses: [],
pragmas: [],
messageSends: ["allButFirst", "dagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._allButFirst();
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "index",
protocol: "accessing",
args: [],
source: "index\x0a\x09^ index",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.index;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "index:",
protocol: "accessing",
args: ["anInteger"],
source: "index: anInteger\x0a\x09index := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.index=anInteger;
return self;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "isSend",
protocol: "testing",
args: [],
source: "isSend\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "javaScriptSelector",
protocol: "accessing",
args: [],
source: "javaScriptSelector\x0a\x09^ javaScriptSelector ifNil: [ javaScriptSelector := self selector asJavaScriptMethodName ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "asJavaScriptMethodName", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.javaScriptSelector;
if($1 == null || $1.a$nil){
$self.javaScriptSelector=$recv($self._selector())._asJavaScriptMethodName();
return $self.javaScriptSelector;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"javaScriptSelector",{})});
}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "javaScriptSelector:",
protocol: "accessing",
args: ["aString"],
source: "javaScriptSelector: aString\x0a\x09javaScriptSelector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.javaScriptSelector=aString;
return self;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ self dagChildren first",
referencedClasses: [],
pragmas: [],
messageSends: ["first", "dagChildren"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._first();
}, function($ctx1) {$ctx1.fill(self,"receiver",{})});
}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.IRSend);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.IRSend);



$core.addClass("IRSequence", $globals.IRInstruction, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRSequence: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRSequence:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRSequence_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRSequence);

$core.addMethod(
$core.method({
selector: "isSequence",
protocol: "testing",
args: [],
source: "isSequence\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRSequence);



$core.addClass("IRBlockSequence", $globals.IRSequence, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRBlockSequence: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRBlockSequence:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRBlockSequence_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRBlockSequence);



$core.addClass("IRValue", $globals.IRInstruction, "Compiler-IR");
$core.setSlots($globals.IRValue, ["value"]);
$globals.IRValue.comment="I am the simplest possible instruction. I represent a value.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRValue: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRValue:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRValue_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRValue);

$core.addMethod(
$core.method({
selector: "asReceiver",
protocol: "converting",
args: [],
source: "asReceiver\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.IRValue);

$core.addMethod(
$core.method({
selector: "value",
protocol: "accessing",
args: [],
source: "value\x0a\x09^ value",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.value;

}; }),
$globals.IRValue);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "accessing",
args: ["aString"],
source: "value: aString\x0a\x09value := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.value=aString;
return self;

}; }),
$globals.IRValue);



$core.addClass("IRVariable", $globals.IRInstruction, "Compiler-IR");
$core.setSlots($globals.IRVariable, ["variable"]);
$globals.IRVariable.comment="I am a variable instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRVariable: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRVariable:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRVariable_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "asReceiver",
protocol: "converting",
args: [],
source: "asReceiver\x0a\x09self variable asReceiver\x0a\x09\x09ifNil: [ ^ super asReceiver ]\x0a\x09\x09ifNotNil: [ :receiverVar |\x0a\x09\x09\x09self variable == receiverVar ifTrue: [ ^ self ].\x0a\x09\x09\x09^ self copy variable: receiverVar; yourself ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:ifNotNil:", "asReceiver", "variable", "ifTrue:", "==", "variable:", "copy", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$recv([$self._variable()
,$ctx1.sendIdx["variable"]=1
][0])._asReceiver()
,$ctx1.sendIdx["asReceiver"]=1
][0];
if($1 == null || $1.a$nil){
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._asReceiver.call($self))
,$ctx1.supercall = false
][0];
} else {
var receiverVar;
receiverVar=$1;
if($core.assert($recv($self._variable()).__eq_eq(receiverVar))){
return self;
}
$2=$self._copy();
$recv($2)._variable_(receiverVar);
return $recv($2)._yourself();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"asReceiver",{})});
}; }),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "isSuper",
protocol: "testing",
args: [],
source: "isSuper\x0a\x09^ self variable isSuper",
referencedClasses: [],
pragmas: [],
messageSends: ["isSuper", "variable"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._variable())._isSuper();
}, function($ctx1) {$ctx1.fill(self,"isSuper",{})});
}; }),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "isVariable",
protocol: "testing",
args: [],
source: "isVariable\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "variable",
protocol: "accessing",
args: [],
source: "variable\x0a\x09^ variable",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.variable;

}; }),
$globals.IRVariable);

$core.addMethod(
$core.method({
selector: "variable:",
protocol: "accessing",
args: ["aScopeVariable"],
source: "variable: aScopeVariable\x0a\x09variable := aScopeVariable",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aScopeVariable){
var self=this,$self=this;
$self.variable=aScopeVariable;
return self;

}; }),
$globals.IRVariable);



$core.addClass("IRVerbatim", $globals.IRInstruction, "Compiler-IR");
$core.setSlots($globals.IRVerbatim, ["source"]);
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09^ aVisitor visitIRVerbatim: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRVerbatim:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aVisitor)._visitIRVerbatim_(self);
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRVerbatim);

$core.addMethod(
$core.method({
selector: "source",
protocol: "accessing",
args: [],
source: "source\x0a\x09^ source",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.source;

}; }),
$globals.IRVerbatim);

$core.addMethod(
$core.method({
selector: "source:",
protocol: "accessing",
args: ["aString"],
source: "source: aString\x0a\x09source := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.source=aString;
return self;

}; }),
$globals.IRVerbatim);



$core.addClass("IRPragmator", $globals.Object, "Compiler-IR");
$core.setSlots($globals.IRPragmator, ["irMethod"]);
$core.addMethod(
$core.method({
selector: "irMethod",
protocol: "accessing",
args: [],
source: "irMethod\x0a\x09^ irMethod",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.irMethod;

}; }),
$globals.IRPragmator);

$core.addMethod(
$core.method({
selector: "irMethod:",
protocol: "accessing",
args: ["anObject"],
source: "irMethod: anObject\x0a\x09irMethod := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.irMethod=anObject;
return self;

}; }),
$globals.IRPragmator);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "visiting",
args: ["anIRMethod"],
source: "value: anIRMethod\x0a\x09self irMethod: anIRMethod.\x0a\x09self processPragmas: anIRMethod pragmas.\x0a\x09^ anIRMethod",
referencedClasses: [],
pragmas: [],
messageSends: ["irMethod:", "processPragmas:", "pragmas"]
}, function ($methodClass){ return function (anIRMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._irMethod_(anIRMethod);
$self._processPragmas_($recv(anIRMethod)._pragmas());
return anIRMethod;
}, function($ctx1) {$ctx1.fill(self,"value:",{anIRMethod:anIRMethod})});
}; }),
$globals.IRPragmator);



$core.addClass("IRLatePragmator", $globals.IRPragmator, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "jsOverride:",
protocol: "pragmas",
args: ["aString"],
source: "jsOverride: aString\x0a\x09self irMethod arguments ifNotEmpty: [\x0a\x09\x09CompilerError signal: 'Must use <jsOverride:> in unary method.' ].\x0a\x09self irMethod attachments\x0a\x09\x09at: aString\x0a\x09\x09put: (NativeFunction\x0a\x09\x09\x09constructorNamed: #Function\x0a\x09\x09\x09value: 'return this.', irMethod selector asJavaScriptMethodName, '()')",
referencedClasses: ["CompilerError", "NativeFunction"],
pragmas: [],
messageSends: ["ifNotEmpty:", "arguments", "irMethod", "signal:", "at:put:", "attachments", "constructorNamed:value:", ",", "asJavaScriptMethodName", "selector"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv([$self._irMethod()
,$ctx1.sendIdx["irMethod"]=1
][0])._arguments())._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.CompilerError)._signal_("Must use <jsOverride:> in unary method.");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv($recv($self._irMethod())._attachments())._at_put_(aString,$recv($globals.NativeFunction)._constructorNamed_value_("Function",[$recv("return this.".__comma($recv($recv($self.irMethod)._selector())._asJavaScriptMethodName())).__comma("()")
,$ctx1.sendIdx[","]=1
][0]));
return self;
}, function($ctx1) {$ctx1.fill(self,"jsOverride:",{aString:aString})});
}; }),
$globals.IRLatePragmator);

$core.addMethod(
$core.method({
selector: "jsOverride:args:",
protocol: "pragmas",
args: ["aString", "aCollection"],
source: "jsOverride: aString args: aCollection\x0a\x09| myArgs |\x0a\x09myArgs := self irMethod arguments.\x0a\x09myArgs size = aCollection size ifFalse: [\x0a\x09\x09CompilerError signal: 'Should have ', self irMethod arguments size asString, ' args in <jsOverride:args:>.' ].\x0a\x09myArgs asSet = aCollection asSet ifFalse: [\x0a\x09\x09CompilerError signal: 'Argument mismatch in <jsOverride:args:>.' ].\x0a\x09self irMethod attachments\x0a\x09\x09at: aString\x0a\x09\x09put: (NativeFunction\x0a\x09\x09\x09constructorNamed: #Function\x0a\x09\x09\x09value: (',' join: aCollection)\x0a\x09\x09\x09value: 'return this.', irMethod selector asJavaScriptMethodName, '(', (',' join: myArgs), ')')",
referencedClasses: ["CompilerError", "NativeFunction"],
pragmas: [],
messageSends: ["arguments", "irMethod", "ifFalse:", "=", "size", "signal:", ",", "asString", "asSet", "at:put:", "attachments", "constructorNamed:value:value:", "join:", "asJavaScriptMethodName", "selector"]
}, function ($methodClass){ return function (aString,aCollection){
var self=this,$self=this;
var myArgs;
return $core.withContext(function($ctx1) {
myArgs=[$recv([$self._irMethod()
,$ctx1.sendIdx["irMethod"]=1
][0])._arguments()
,$ctx1.sendIdx["arguments"]=1
][0];
if(!$core.assert([$recv([$recv(myArgs)._size()
,$ctx1.sendIdx["size"]=1
][0]).__eq([$recv(aCollection)._size()
,$ctx1.sendIdx["size"]=2
][0])
,$ctx1.sendIdx["="]=1
][0])){
[$recv($globals.CompilerError)._signal_([$recv(["Should have ".__comma($recv($recv($recv([$self._irMethod()
,$ctx1.sendIdx["irMethod"]=2
][0])._arguments())._size())._asString())
,$ctx1.sendIdx[","]=2
][0]).__comma(" args in <jsOverride:args:>.")
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["signal:"]=1
][0];
}
if(!$core.assert($recv([$recv(myArgs)._asSet()
,$ctx1.sendIdx["asSet"]=1
][0]).__eq($recv(aCollection)._asSet()))){
$recv($globals.CompilerError)._signal_("Argument mismatch in <jsOverride:args:>.");
}
$recv($recv($self._irMethod())._attachments())._at_put_(aString,$recv($globals.NativeFunction)._constructorNamed_value_value_("Function",[","._join_(aCollection)
,$ctx1.sendIdx["join:"]=1
][0],[$recv([$recv([$recv("return this.".__comma($recv($recv($self.irMethod)._selector())._asJavaScriptMethodName())).__comma("(")
,$ctx1.sendIdx[","]=5
][0]).__comma(","._join_(myArgs))
,$ctx1.sendIdx[","]=4
][0]).__comma(")")
,$ctx1.sendIdx[","]=3
][0]));
return self;
}, function($ctx1) {$ctx1.fill(self,"jsOverride:args:",{aString:aString,aCollection:aCollection,myArgs:myArgs})});
}; }),
$globals.IRLatePragmator);



$core.addClass("IRVisitor", $globals.ParentFakingPathDagVisitor, "Compiler-IR");
$core.addMethod(
$core.method({
selector: "visitDagNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNode: aNode\x0a\x09^ self visitDagNodeVariantSimple: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNodeVariantSimple:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNodeVariantSimple_(aNode);
}, function($ctx1) {$ctx1.fill(self,"visitDagNode:",{aNode:aNode})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRAssignment:",
protocol: "visiting",
args: ["anIRAssignment"],
source: "visitIRAssignment: anIRAssignment\x0a\x09^ self visitDagNode: anIRAssignment",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRAssignment){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRAssignment);
}, function($ctx1) {$ctx1.fill(self,"visitIRAssignment:",{anIRAssignment:anIRAssignment})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRBlockReturn:",
protocol: "visiting",
args: ["anIRBlockReturn"],
source: "visitIRBlockReturn: anIRBlockReturn\x0a\x09^ self visitIRReturn: anIRBlockReturn",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRReturn:"]
}, function ($methodClass){ return function (anIRBlockReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitIRReturn_(anIRBlockReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRBlockReturn:",{anIRBlockReturn:anIRBlockReturn})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRBlockSequence:",
protocol: "visiting",
args: ["anIRBlockSequence"],
source: "visitIRBlockSequence: anIRBlockSequence\x0a\x09^ self visitIRSequence: anIRBlockSequence",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRSequence:"]
}, function ($methodClass){ return function (anIRBlockSequence){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitIRSequence_(anIRBlockSequence);
}, function($ctx1) {$ctx1.fill(self,"visitIRBlockSequence:",{anIRBlockSequence:anIRBlockSequence})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRClosure:",
protocol: "visiting",
args: ["anIRClosure"],
source: "visitIRClosure: anIRClosure\x0a\x09^ self visitDagNode: anIRClosure",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRClosure);
}, function($ctx1) {$ctx1.fill(self,"visitIRClosure:",{anIRClosure:anIRClosure})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRDynamicArray:",
protocol: "visiting",
args: ["anIRDynamicArray"],
source: "visitIRDynamicArray: anIRDynamicArray\x0a\x09^ self visitDagNode: anIRDynamicArray",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRDynamicArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRDynamicArray);
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicArray:",{anIRDynamicArray:anIRDynamicArray})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRDynamicDictionary:",
protocol: "visiting",
args: ["anIRDynamicDictionary"],
source: "visitIRDynamicDictionary: anIRDynamicDictionary\x0a\x09^ self visitDagNode: anIRDynamicDictionary",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRDynamicDictionary){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRDynamicDictionary);
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicDictionary:",{anIRDynamicDictionary:anIRDynamicDictionary})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRMethod:",
protocol: "visiting",
args: ["anIRMethod"],
source: "visitIRMethod: anIRMethod\x0a\x09^ self visitDagNode: anIRMethod",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRMethod);
}, function($ctx1) {$ctx1.fill(self,"visitIRMethod:",{anIRMethod:anIRMethod})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturn:",
protocol: "visiting",
args: ["anIRNonLocalReturn"],
source: "visitIRNonLocalReturn: anIRNonLocalReturn\x0a\x09^ self visitDagNode: anIRNonLocalReturn",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRNonLocalReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRNonLocalReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturnHandling:",
protocol: "visiting",
args: ["anIRNonLocalReturnHandling"],
source: "visitIRNonLocalReturnHandling: anIRNonLocalReturnHandling\x0a\x09^ self visitDagNode: anIRNonLocalReturnHandling",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRNonLocalReturnHandling){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRNonLocalReturnHandling);
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturnHandling:",{anIRNonLocalReturnHandling:anIRNonLocalReturnHandling})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRReturn:",
protocol: "visiting",
args: ["anIRReturn"],
source: "visitIRReturn: anIRReturn\x0a\x09^ self visitDagNode: anIRReturn",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRReturn);
}, function($ctx1) {$ctx1.fill(self,"visitIRReturn:",{anIRReturn:anIRReturn})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRSend:",
protocol: "visiting",
args: ["anIRSend"],
source: "visitIRSend: anIRSend\x0a\x09^ self visitDagNode: anIRSend",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRSend);
}, function($ctx1) {$ctx1.fill(self,"visitIRSend:",{anIRSend:anIRSend})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRSequence:",
protocol: "visiting",
args: ["anIRSequence"],
source: "visitIRSequence: anIRSequence\x0a\x09^ self visitDagNode: anIRSequence",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRSequence){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRSequence);
}, function($ctx1) {$ctx1.fill(self,"visitIRSequence:",{anIRSequence:anIRSequence})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRTempDeclaration:",
protocol: "visiting",
args: ["anIRTempDeclaration"],
source: "visitIRTempDeclaration: anIRTempDeclaration\x0a\x09^ self visitDagNode: anIRTempDeclaration",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRTempDeclaration){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRTempDeclaration);
}, function($ctx1) {$ctx1.fill(self,"visitIRTempDeclaration:",{anIRTempDeclaration:anIRTempDeclaration})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRValue:",
protocol: "visiting",
args: ["anIRValue"],
source: "visitIRValue: anIRValue\x0a\x09^ self visitDagNode: anIRValue",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRValue);
}, function($ctx1) {$ctx1.fill(self,"visitIRValue:",{anIRValue:anIRValue})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRVariable:",
protocol: "visiting",
args: ["anIRVariable"],
source: "visitIRVariable: anIRVariable\x0a\x09^ self visitDagNode: anIRVariable",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRVariable){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRVariable);
}, function($ctx1) {$ctx1.fill(self,"visitIRVariable:",{anIRVariable:anIRVariable})});
}; }),
$globals.IRVisitor);

$core.addMethod(
$core.method({
selector: "visitIRVerbatim:",
protocol: "visiting",
args: ["anIRVerbatim"],
source: "visitIRVerbatim: anIRVerbatim\x0a\x09^ self visitDagNode: anIRVerbatim",
referencedClasses: [],
pragmas: [],
messageSends: ["visitDagNode:"]
}, function ($methodClass){ return function (anIRVerbatim){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitDagNode_(anIRVerbatim);
}, function($ctx1) {$ctx1.fill(self,"visitIRVerbatim:",{anIRVerbatim:anIRVerbatim})});
}; }),
$globals.IRVisitor);



$core.addClass("IRJSTranslator", $globals.IRVisitor, "Compiler-IR");
$core.setSlots($globals.IRJSTranslator, ["stream", "currentClass"]);
$core.addMethod(
$core.method({
selector: "contents",
protocol: "accessing",
args: [],
source: "contents\x0a\x09^ self stream contents",
referencedClasses: [],
pragmas: [],
messageSends: ["contents", "stream"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._stream())._contents();
}, function($ctx1) {$ctx1.fill(self,"contents",{})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "currentClass",
protocol: "accessing",
args: [],
source: "currentClass\x0a\x09^ currentClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.currentClass;

}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "currentClass:",
protocol: "accessing",
args: ["aClass"],
source: "currentClass: aClass\x0a\x09currentClass := aClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
$self.currentClass=aClass;
return self;

}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09stream := JSStream new.",
referencedClasses: ["JSStream"],
pragmas: [],
messageSends: ["initialize", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.stream=$recv($globals.JSStream)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "stream",
protocol: "accessing",
args: [],
source: "stream\x0a\x09^ stream",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.stream;

}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "stream:",
protocol: "accessing",
args: ["aStream"],
source: "stream: aStream\x0a\x09stream := aStream",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aStream){
var self=this,$self=this;
$self.stream=aStream;
return self;

}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRAssignment:",
protocol: "visiting",
args: ["anIRAssignment"],
source: "visitIRAssignment: anIRAssignment\x0a\x09self stream\x0a\x09\x09nextPutAssignLhs: [self visit: anIRAssignment left]\x0a\x09\x09rhs: [self visit: anIRAssignment right].",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAssignLhs:rhs:", "stream", "visit:", "left", "right"]
}, function ($methodClass){ return function (anIRAssignment){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutAssignLhs_rhs_((function(){
return $core.withContext(function($ctx2) {
return [$self._visit_($recv(anIRAssignment)._left())
,$ctx2.sendIdx["visit:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $self._visit_($recv(anIRAssignment)._right());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRAssignment:",{anIRAssignment:anIRAssignment})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRClosure:",
protocol: "visiting",
args: ["anIRClosure"],
source: "visitIRClosure: anIRClosure\x0a\x09self stream\x0a\x09\x09nextPutClosureWith: [\x0a\x09\x09\x09self stream nextPutVars: (anIRClosure tempDeclarations collect: [ :each |\x0a\x09\x09\x09\x09\x09each name asVariableName ]).\x0a\x09\x09\x09self stream\x0a\x09\x09\x09\x09nextPutBlockContextFor: anIRClosure\x0a\x09\x09\x09\x09during: [ super visitIRClosure: anIRClosure ] ]\x0a\x09\x09arguments: anIRClosure arguments",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutClosureWith:arguments:", "stream", "nextPutVars:", "collect:", "tempDeclarations", "asVariableName", "name", "nextPutBlockContextFor:during:", "visitIRClosure:", "arguments"]
}, function ($methodClass){ return function (anIRClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutClosureWith_arguments_((function(){
return $core.withContext(function($ctx2) {
$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutVars_($recv($recv(anIRClosure)._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx3) {
return $recv($recv(each)._name())._asVariableName();
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
})));
return $recv($self._stream())._nextPutBlockContextFor_during_(anIRClosure,(function(){
return $core.withContext(function($ctx3) {
return [(
$ctx3.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRClosure_.call($self,anIRClosure))
,$ctx3.supercall = false
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$recv(anIRClosure)._arguments());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRClosure:",{anIRClosure:anIRClosure})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRDynamicArray:",
protocol: "visiting",
args: ["anIRDynamicArray"],
source: "visitIRDynamicArray: anIRDynamicArray\x0a\x09self\x0a\x09\x09visitInstructionList: anIRDynamicArray dagChildren\x0a\x09\x09enclosedBetween: '[' and: ']'",
referencedClasses: [],
pragmas: [],
messageSends: ["visitInstructionList:enclosedBetween:and:", "dagChildren"]
}, function ($methodClass){ return function (anIRDynamicArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._visitInstructionList_enclosedBetween_and_($recv(anIRDynamicArray)._dagChildren(),"[","]");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicArray:",{anIRDynamicArray:anIRDynamicArray})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRDynamicDictionary:",
protocol: "visiting",
args: ["anIRDynamicDictionary"],
source: "visitIRDynamicDictionary: anIRDynamicDictionary\x0a\x09self\x0a\x09\x09visitInstructionList: anIRDynamicDictionary dagChildren\x0a\x09\x09enclosedBetween: '$globals.HashedCollection._newFromPairs_([' and: '])'",
referencedClasses: [],
pragmas: [],
messageSends: ["visitInstructionList:enclosedBetween:and:", "dagChildren"]
}, function ($methodClass){ return function (anIRDynamicDictionary){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._visitInstructionList_enclosedBetween_and_($recv(anIRDynamicDictionary)._dagChildren(),"$globals.HashedCollection._newFromPairs_([","])");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRDynamicDictionary:",{anIRDynamicDictionary:anIRDynamicDictionary})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRMethod:",
protocol: "visiting",
args: ["anIRMethod"],
source: "visitIRMethod: anIRMethod\x0a\x0a\x09self stream\x0a\x09\x09\x09nextPutFunctionWith: [\x0a\x09\x09\x09\x09self stream nextPutVars: (anIRMethod tempDeclarations collect: [ :each |\x0a\x09\x09\x09\x09\x09each name asVariableName ]).\x0a\x09\x09\x09\x09self stream nextPutContextFor: anIRMethod during: [\x0a\x09\x09\x09\x09\x09anIRMethod internalVariables ifNotEmpty: [ :internalVars |\x0a\x09\x09\x09\x09\x09\x09self stream nextPutVars: \x0a\x09\x09\x09\x09\x09\x09\x09(internalVars collect: [ :each | each variable alias ]) asSet ].\x0a\x09\x09\x09\x09anIRMethod scope hasNonLocalReturn\x0a\x09\x09\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09\x09\x09self stream nextPutNonLocalReturnHandlingWith: [\x0a\x09\x09\x09\x09\x09\x09\x09super visitIRMethod: anIRMethod ] ]\x0a\x09\x09\x09\x09\x09ifFalse: [ super visitIRMethod: anIRMethod ] ]]\x0a\x09\x09\x09arguments: anIRMethod arguments.\x0a\x09\x09\x09\x0a\x09^ anIRMethod compiledSource: self contents; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutFunctionWith:arguments:", "stream", "nextPutVars:", "collect:", "tempDeclarations", "asVariableName", "name", "nextPutContextFor:during:", "ifNotEmpty:", "internalVariables", "asSet", "alias", "variable", "ifTrue:ifFalse:", "hasNonLocalReturn", "scope", "nextPutNonLocalReturnHandlingWith:", "visitIRMethod:", "arguments", "compiledSource:", "contents", "yourself"]
}, function ($methodClass){ return function (anIRMethod){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutFunctionWith_arguments_((function(){
return $core.withContext(function($ctx2) {
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutVars_([$recv($recv(anIRMethod)._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx3) {
return $recv($recv(each)._name())._asVariableName();
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}))
,$ctx2.sendIdx["collect:"]=1
][0])
,$ctx2.sendIdx["nextPutVars:"]=1
][0];
return $recv([$self._stream()
,$ctx2.sendIdx["stream"]=3
][0])._nextPutContextFor_during_(anIRMethod,(function(){
return $core.withContext(function($ctx3) {
$recv($recv(anIRMethod)._internalVariables())._ifNotEmpty_((function(internalVars){
return $core.withContext(function($ctx4) {
return $recv([$self._stream()
,$ctx4.sendIdx["stream"]=4
][0])._nextPutVars_($recv($recv(internalVars)._collect_((function(each){
return $core.withContext(function($ctx5) {
return $recv($recv(each)._variable())._alias();
}, function($ctx5) {$ctx5.fillBlock({each:each},$ctx4,5)});
})))._asSet());
}, function($ctx4) {$ctx4.fillBlock({internalVars:internalVars},$ctx3,4)});
}));
if($core.assert($recv($recv(anIRMethod)._scope())._hasNonLocalReturn())){
return $recv($self._stream())._nextPutNonLocalReturnHandlingWith_((function(){
return $core.withContext(function($ctx4) {
return [(
$ctx4.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRMethod_.call($self,anIRMethod))
,$ctx4.sendIdx["visitIRMethod:"]=1,$ctx4.supercall = false
][0];
}, function($ctx4) {$ctx4.fillBlock({},$ctx3,7)});
}));
} else {
return [(
$ctx3.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRMethod_.call($self,anIRMethod))
,$ctx3.supercall = false
][0];
}
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$recv(anIRMethod)._arguments());
$recv(anIRMethod)._compiledSource_($self._contents());
return $recv(anIRMethod)._yourself();
}, function($ctx1) {$ctx1.fill(self,"visitIRMethod:",{anIRMethod:anIRMethod})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturn:",
protocol: "visiting",
args: ["anIRNonLocalReturn"],
source: "visitIRNonLocalReturn: anIRNonLocalReturn\x0a\x09self stream nextPutNonLocalReturnWith: [\x0a\x09\x09super visitIRNonLocalReturn: anIRNonLocalReturn ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutNonLocalReturnWith:", "stream", "visitIRNonLocalReturn:"]
}, function ($methodClass){ return function (anIRNonLocalReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutNonLocalReturnWith_((function(){
return $core.withContext(function($ctx2) {
return [(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRNonLocalReturn_.call($self,anIRNonLocalReturn))
,$ctx2.supercall = false
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRReturn:",
protocol: "visiting",
args: ["anIRReturn"],
source: "visitIRReturn: anIRReturn\x0a\x09self stream nextPutReturnWith: [\x0a\x09\x09super visitIRReturn: anIRReturn ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutReturnWith:", "stream", "visitIRReturn:"]
}, function ($methodClass){ return function (anIRReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutReturnWith_((function(){
return $core.withContext(function($ctx2) {
return [(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRReturn_.call($self,anIRReturn))
,$ctx2.supercall = false
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRReturn:",{anIRReturn:anIRReturn})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRSend:",
protocol: "visiting",
args: ["anIRSend"],
source: "visitIRSend: anIRSend\x0a\x09| prefixes suffixes workBlock |\x0a\x09prefixes := #().\x0a\x09suffixes := #().\x0a\x09workBlock := [ self visitSend: anIRSend ].\x0a\x09\x0a\x09anIRSend index < (anIRSend method sendIndexes at: anIRSend selector) size ifTrue: [\x0a\x09\x09suffixes add:\x0a\x09\x09\x09anIRSend scope alias,\x0a\x09\x09\x09'.sendIdx[',\x0a\x09\x09\x09anIRSend selector asJavaScriptSource,\x0a\x09\x09\x09']=',\x0a\x09\x09\x09anIRSend index asString ].\x0a\x09\x0a\x09anIRSend receiver isSuper ifTrue: [\x0a\x09\x09prefixes add: anIRSend scope alias, '.supercall = true'.\x0a\x09\x09suffixes add: anIRSend scope alias, '.supercall = false'.\x0a\x09\x09workBlock := [ self visitSuperSend: anIRSend ] ].\x0a\x0a\x09self stream nextPutBefore: prefixes after: suffixes with: workBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["visitSend:", "ifTrue:", "<", "index", "size", "at:", "sendIndexes", "method", "selector", "add:", ",", "alias", "scope", "asJavaScriptSource", "asString", "isSuper", "receiver", "visitSuperSend:", "nextPutBefore:after:with:", "stream"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
var prefixes,suffixes,workBlock;
return $core.withContext(function($ctx1) {
prefixes=[];
suffixes=[];
workBlock=(function(){
return $core.withContext(function($ctx2) {
return $self._visitSend_(anIRSend);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
});
if($core.assert($recv([$recv(anIRSend)._index()
,$ctx1.sendIdx["index"]=1
][0]).__lt($recv($recv($recv($recv(anIRSend)._method())._sendIndexes())._at_([$recv(anIRSend)._selector()
,$ctx1.sendIdx["selector"]=1
][0]))._size()))){
[$recv(suffixes)._add_([$recv([$recv([$recv([$recv([$recv([$recv(anIRSend)._scope()
,$ctx1.sendIdx["scope"]=1
][0])._alias()
,$ctx1.sendIdx["alias"]=1
][0]).__comma(".sendIdx[")
,$ctx1.sendIdx[","]=4
][0]).__comma($recv($recv(anIRSend)._selector())._asJavaScriptSource())
,$ctx1.sendIdx[","]=3
][0]).__comma("]=")
,$ctx1.sendIdx[","]=2
][0]).__comma($recv($recv(anIRSend)._index())._asString())
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["add:"]=1
][0];
}
if($core.assert($recv($recv(anIRSend)._receiver())._isSuper())){
[$recv(prefixes)._add_([$recv([$recv([$recv(anIRSend)._scope()
,$ctx1.sendIdx["scope"]=2
][0])._alias()
,$ctx1.sendIdx["alias"]=2
][0]).__comma(".supercall = true")
,$ctx1.sendIdx[","]=5
][0])
,$ctx1.sendIdx["add:"]=2
][0];
$recv(suffixes)._add_($recv($recv($recv(anIRSend)._scope())._alias()).__comma(".supercall = false"));
workBlock=(function(){
return $core.withContext(function($ctx2) {
return $self._visitSuperSend_(anIRSend);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
});
workBlock;
}
$recv($self._stream())._nextPutBefore_after_with_(prefixes,suffixes,workBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRSend:",{anIRSend:anIRSend,prefixes:prefixes,suffixes:suffixes,workBlock:workBlock})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRSequence:",
protocol: "visiting",
args: ["anIRSequence"],
source: "visitIRSequence: anIRSequence\x0a\x09anIRSequence dagChildren do: [ :each |\x0a\x09\x09self stream nextPutStatementWith: [ self visit: each ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "dagChildren", "nextPutStatementWith:", "stream", "visit:"]
}, function ($methodClass){ return function (anIRSequence){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(anIRSequence)._dagChildren())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv($self._stream())._nextPutStatementWith_((function(){
return $core.withContext(function($ctx3) {
return $self._visit_(each);
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRSequence:",{anIRSequence:anIRSequence})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRTempDeclaration:",
protocol: "visiting",
args: ["anIRTempDeclaration"],
source: "visitIRTempDeclaration: anIRTempDeclaration\x0a\x09\x22self stream\x0a\x09\x09nextPutAll: 'var ', anIRTempDeclaration name asVariableName, ';';\x0a\x09\x09lf\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anIRTempDeclaration){
var self=this,$self=this;
return self;

}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRValue:",
protocol: "visiting",
args: ["anIRValue"],
source: "visitIRValue: anIRValue\x0a\x09self stream nextPutAll: anIRValue value asJavaScriptSource",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "stream", "asJavaScriptSource", "value"]
}, function ($methodClass){ return function (anIRValue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutAll_($recv($recv(anIRValue)._value())._asJavaScriptSource());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRValue:",{anIRValue:anIRValue})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRVariable:",
protocol: "visiting",
args: ["anIRVariable"],
source: "visitIRVariable: anIRVariable\x0a\x09self stream nextPutAll: anIRVariable variable alias",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "stream", "alias", "variable"]
}, function ($methodClass){ return function (anIRVariable){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutAll_($recv($recv(anIRVariable)._variable())._alias());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRVariable:",{anIRVariable:anIRVariable})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRVerbatim:",
protocol: "visiting",
args: ["anIRVerbatim"],
source: "visitIRVerbatim: anIRVerbatim\x0a\x09self stream nextPutAll: anIRVerbatim source",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "stream", "source"]
}, function ($methodClass){ return function (anIRVerbatim){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutAll_($recv(anIRVerbatim)._source());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRVerbatim:",{anIRVerbatim:anIRVerbatim})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitInstructionList:enclosedBetween:and:",
protocol: "visiting",
args: ["anArray", "aString", "anotherString"],
source: "visitInstructionList: anArray enclosedBetween: aString and: anotherString\x0a\x09self stream nextPutAll: aString.\x0a\x09anArray\x0a\x09\x09do: [ :each | self visit: each ]\x0a\x09\x09separatedBy: [ self stream nextPutAll: ',' ].\x0a\x09stream nextPutAll: anotherString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "stream", "do:separatedBy:", "visit:"]
}, function ($methodClass){ return function (anArray,aString,anotherString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutAll_(aString)
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$recv(anArray)._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return $self._visit_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$recv($self._stream())._nextPutAll_(",")
,$ctx2.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv($self.stream)._nextPutAll_(anotherString);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitInstructionList:enclosedBetween:and:",{anArray:anArray,aString:aString,anotherString:anotherString})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitReceiver:",
protocol: "visiting",
args: ["anIRInstruction"],
source: "visitReceiver: anIRInstruction\x0a\x09anIRInstruction asReceiver\x0a\x09\x09ifNotNil: [ :instr | self visit: instr ]\x0a\x09\x09ifNil: [\x0a\x09\x09\x09self stream nextPutAll: '$recv('.\x0a\x09\x09\x09self visit: anIRInstruction.\x0a\x09\x09\x09self stream nextPutAll: ')' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:ifNil:", "asReceiver", "visit:", "nextPutAll:", "stream"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv(anIRInstruction)._asReceiver();
if($1 == null || $1.a$nil){
[$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutAll_("$recv(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$self._visit_(anIRInstruction);
$recv($self._stream())._nextPutAll_(")");
} else {
var instr;
instr=$1;
[$self._visit_(instr)
,$ctx1.sendIdx["visit:"]=1
][0];
}
return self;
}, function($ctx1) {$ctx1.fill(self,"visitReceiver:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitSend:",
protocol: "visiting",
args: ["anIRSend"],
source: "visitSend: anIRSend\x0a\x09self visitReceiver: anIRSend receiver.\x0a\x09self stream nextPutAll: '.', anIRSend javaScriptSelector.\x0a\x09self\x0a\x09\x09visitInstructionList: anIRSend arguments\x0a\x09\x09enclosedBetween: '(' and: ')'",
referencedClasses: [],
pragmas: [],
messageSends: ["visitReceiver:", "receiver", "nextPutAll:", "stream", ",", "javaScriptSelector", "visitInstructionList:enclosedBetween:and:", "arguments"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._visitReceiver_($recv(anIRSend)._receiver());
$recv($self._stream())._nextPutAll_(".".__comma($recv(anIRSend)._javaScriptSelector()));
$self._visitInstructionList_enclosedBetween_and_($recv(anIRSend)._arguments(),"(",")");
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSend:",{anIRSend:anIRSend})});
}; }),
$globals.IRJSTranslator);

$core.addMethod(
$core.method({
selector: "visitSuperSend:",
protocol: "visiting",
args: ["anIRSend"],
source: "visitSuperSend: anIRSend\x0a\x09self stream\x0a\x09\x09nextPutAll: anIRSend receiver variable lookupAsJavaScriptSource, '.';\x0a\x09\x09nextPutAll: anIRSend javaScriptSelector.\x0a\x09anIRSend arguments\x0a\x09\x09ifEmpty: [\x0a\x09\x09\x09self stream nextPutAll: '.call('.\x0a\x09\x09\x09self visitReceiver: anIRSend receiver.\x0a\x09\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09ifNotEmpty: [\x0a\x09\x09\x09anIRSend argumentSwitcher\x0a\x09\x09\x09\x09ifNil: [\x0a\x09\x09\x09\x09\x09self stream nextPutAll: '.call('.\x0a\x09\x09\x09\x09\x09self visitReceiver: anIRSend receiver.\x0a\x09\x09\x09\x09\x09self\x0a\x09\x09\x09\x09\x09\x09visitInstructionList: anIRSend arguments\x0a\x09\x09\x09\x09\x09\x09enclosedBetween: ',' and: ')' ]\x0a\x09\x09\x09\x09ifNotNil: [ :switcher |\x0a\x09\x09\x09\x09\x09self stream nextPutAll: '.apply('.\x0a\x09\x09\x09\x09\x09self visitReceiver: anIRSend receiver.\x0a\x09\x09\x09\x09\x09self\x0a\x09\x09\x09\x09\x09\x09visitInstructionList: anIRSend arguments\x0a\x09\x09\x09\x09\x09\x09enclosedBetween: ',(', switcher asJavaScriptSource, ')('\x0a\x09\x09\x09\x09\x09\x09and: '))' ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "stream", ",", "lookupAsJavaScriptSource", "variable", "receiver", "javaScriptSelector", "ifEmpty:ifNotEmpty:", "arguments", "visitReceiver:", "ifNil:ifNotNil:", "argumentSwitcher", "visitInstructionList:enclosedBetween:and:", "asJavaScriptSource"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$self._stream()
,$ctx1.sendIdx["stream"]=1
][0];
[$recv($1)._nextPutAll_([$recv($recv($recv([$recv(anIRSend)._receiver()
,$ctx1.sendIdx["receiver"]=1
][0])._variable())._lookupAsJavaScriptSource()).__comma(".")
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv($1)._nextPutAll_($recv(anIRSend)._javaScriptSelector())
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv([$recv(anIRSend)._arguments()
,$ctx1.sendIdx["arguments"]=1
][0])._ifEmpty_ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutAll_(".call(")
,$ctx2.sendIdx["nextPutAll:"]=3
][0];
[$self._visitReceiver_([$recv(anIRSend)._receiver()
,$ctx2.sendIdx["receiver"]=2
][0])
,$ctx2.sendIdx["visitReceiver:"]=1
][0];
return [$recv([$self._stream()
,$ctx2.sendIdx["stream"]=3
][0])._nextPutAll_(")")
,$ctx2.sendIdx["nextPutAll:"]=4
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
$2=$recv(anIRSend)._argumentSwitcher();
if($2 == null || $2.a$nil){
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=4
][0])._nextPutAll_(".call(")
,$ctx2.sendIdx["nextPutAll:"]=5
][0];
[$self._visitReceiver_([$recv(anIRSend)._receiver()
,$ctx2.sendIdx["receiver"]=3
][0])
,$ctx2.sendIdx["visitReceiver:"]=2
][0];
return [$self._visitInstructionList_enclosedBetween_and_([$recv(anIRSend)._arguments()
,$ctx2.sendIdx["arguments"]=2
][0],",",")")
,$ctx2.sendIdx["visitInstructionList:enclosedBetween:and:"]=1
][0];
} else {
var switcher;
switcher=$2;
$recv($self._stream())._nextPutAll_(".apply(");
$self._visitReceiver_($recv(anIRSend)._receiver());
return $self._visitInstructionList_enclosedBetween_and_($recv(anIRSend)._arguments(),[$recv(",(".__comma($recv(switcher)._asJavaScriptSource())).__comma(")(")
,$ctx2.sendIdx[","]=2
][0],"))");
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSuperSend:",{anIRSend:anIRSend})});
}; }),
$globals.IRJSTranslator);



$core.addClass("JSStream", $globals.Object, "Compiler-IR");
$core.setSlots($globals.JSStream, ["stream", "omitSemicolon"]);
$core.addMethod(
$core.method({
selector: "contents",
protocol: "accessing",
args: [],
source: "contents\x0a\x09^ stream contents",
referencedClasses: [],
pragmas: [],
messageSends: ["contents"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.stream)._contents();
}, function($ctx1) {$ctx1.fill(self,"contents",{})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09stream := '' writeStream.",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "writeStream"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.stream=""._writeStream();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "lf",
protocol: "streaming",
args: [],
source: "lf\x0a\x09stream lf",
referencedClasses: [],
pragmas: [],
messageSends: ["lf"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.stream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"lf",{})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPut:",
protocol: "streaming",
args: ["aString"],
source: "nextPut: aString\x0a\x09stream nextPut: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPut:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.stream)._nextPut_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPut:",{aString:aString})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutAll:",
protocol: "streaming",
args: ["aString"],
source: "nextPutAll: aString\x0a\x09stream nextPutAll: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.stream)._nextPutAll_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAll:",{aString:aString})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutAssignLhs:rhs:",
protocol: "streaming",
args: ["aBlock", "anotherBlock"],
source: "nextPutAssignLhs: aBlock rhs: anotherBlock\x0a\x09aBlock value.\x0a\x09stream nextPutAll: '='.\x0a\x09anotherBlock value",
referencedClasses: [],
pragmas: [],
messageSends: ["value", "nextPutAll:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aBlock)._value()
,$ctx1.sendIdx["value"]=1
][0];
$recv($self.stream)._nextPutAll_("=");
$recv(anotherBlock)._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutAssignLhs:rhs:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutBefore:after:with:",
protocol: "streaming",
args: ["prefixCollection", "suffixCollection", "aBlock"],
source: "nextPutBefore: prefixCollection after: suffixCollection with: aBlock\x0a\x09suffixCollection isEmpty\x0a\x09\x09ifTrue: [ self nextPutBefore: prefixCollection with: aBlock ]\x0a\x09\x09ifFalse: [\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09nextPutAll: '['; nextPutBefore: prefixCollection with: aBlock; lf;\x0a\x09\x09\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);'; lf.\x0a\x09\x09\x09suffixCollection do: [ :each | self nextPutAll: ','; nextPutAll: each ].\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09lf;\x0a\x09\x09\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'; lf;\x0a\x09\x09\x09\x09nextPutAll: '][0]' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", "nextPutBefore:with:", "nextPutAll:", "lf", "do:"]
}, function ($methodClass){ return function (prefixCollection,suffixCollection,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv(suffixCollection)._isEmpty())){
[$self._nextPutBefore_with_(prefixCollection,aBlock)
,$ctx1.sendIdx["nextPutBefore:with:"]=1
][0];
} else {
[$self._nextPutAll_("[")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$self._nextPutBefore_with_(prefixCollection,aBlock);
[$self._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);")
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=2
][0];
$recv(suffixCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
[$self._nextPutAll_(",")
,$ctx2.sendIdx["nextPutAll:"]=3
][0];
return [$self._nextPutAll_(each)
,$ctx2.sendIdx["nextPutAll:"]=4
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
[$self._lf()
,$ctx1.sendIdx["lf"]=3
][0];
[$self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);")
,$ctx1.sendIdx["nextPutAll:"]=5
][0];
$self._lf();
$self._nextPutAll_("][0]");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutBefore:after:with:",{prefixCollection:prefixCollection,suffixCollection:suffixCollection,aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutBefore:with:",
protocol: "streaming",
args: ["aCollection", "aBlock"],
source: "nextPutBefore: aCollection with: aBlock\x0a\x09aCollection isEmpty ifTrue: [ aBlock value ] ifFalse: [\x0a\x09\x09self nextPutAll: '('; lf; nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);'; lf.\x0a\x09\x09aCollection do: [ :each | self nextPutAll: each; nextPutAll: ',' ].\x0a\x09\x09self lf; nextPutAll: '//>>excludeEnd(\x22ctx\x22);'; lf.\x0a\x09\x09aBlock value.\x0a\x09\x09self nextPutAll: ')' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isEmpty", "value", "nextPutAll:", "lf", "do:"]
}, function ($methodClass){ return function (aCollection,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv(aCollection)._isEmpty())){
[$recv(aBlock)._value()
,$ctx1.sendIdx["value"]=1
][0];
} else {
[$self._nextPutAll_("(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);")
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=2
][0];
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
[$self._nextPutAll_(each)
,$ctx2.sendIdx["nextPutAll:"]=3
][0];
return [$self._nextPutAll_(",")
,$ctx2.sendIdx["nextPutAll:"]=4
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
[$self._lf()
,$ctx1.sendIdx["lf"]=3
][0];
[$self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);")
,$ctx1.sendIdx["nextPutAll:"]=5
][0];
$self._lf();
$recv(aBlock)._value();
$self._nextPutAll_(")");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutBefore:with:",{aCollection:aCollection,aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutBlockContextFor:during:",
protocol: "streaming",
args: ["anIRClosure", "aBlock"],
source: "nextPutBlockContextFor: anIRClosure during: aBlock\x0a\x09anIRClosure requiresSmalltalkContext ifFalse: [ ^ aBlock value ].\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: 'return $core.withContext(function(', anIRClosure scope alias, ') {';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);';\x0a\x09\x09lf.\x0a\x09\x0a\x09aBlock value.\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '}, function(', anIRClosure scope alias, ') {';\x0a\x09\x09nextPutAll: anIRClosure scope alias, '.fillBlock({'.\x0a\x09\x0a\x09anIRClosure locals\x0a\x09\x09do: [ :each |\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09nextPutAll: each asVariableName;\x0a\x09\x09\x09\x09nextPutAll: ':';\x0a\x09\x09\x09\x09nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ self nextPutAll: ',' ].\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '},';\x0a\x09\x09nextPutAll: anIRClosure scope outerScope alias, ',', anIRClosure scope blockIndex asString, ')});';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "requiresSmalltalkContext", "value", "nextPutAll:", "lf", ",", "alias", "scope", "do:separatedBy:", "locals", "asVariableName", "outerScope", "asString", "blockIndex"]
}, function ($methodClass){ return function (anIRClosure,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(anIRClosure)._requiresSmalltalkContext())){
return [$recv(aBlock)._value()
,$ctx1.sendIdx["value"]=1
][0];
}
[$self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$self._nextPutAll_([$recv(["return $core.withContext(function(".__comma([$recv([$recv(anIRClosure)._scope()
,$ctx1.sendIdx["scope"]=1
][0])._alias()
,$ctx1.sendIdx["alias"]=1
][0])
,$ctx1.sendIdx[","]=2
][0]).__comma(") {")
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=2
][0];
[$self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=3
][0];
$recv(aBlock)._value();
[$self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);")
,$ctx1.sendIdx["nextPutAll:"]=4
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=4
][0];
[$self._nextPutAll_([$recv(["}, function(".__comma([$recv([$recv(anIRClosure)._scope()
,$ctx1.sendIdx["scope"]=2
][0])._alias()
,$ctx1.sendIdx["alias"]=2
][0])
,$ctx1.sendIdx[","]=4
][0]).__comma(") {")
,$ctx1.sendIdx[","]=3
][0])
,$ctx1.sendIdx["nextPutAll:"]=5
][0];
[$self._nextPutAll_([$recv([$recv([$recv(anIRClosure)._scope()
,$ctx1.sendIdx["scope"]=3
][0])._alias()
,$ctx1.sendIdx["alias"]=3
][0]).__comma(".fillBlock({")
,$ctx1.sendIdx[","]=5
][0])
,$ctx1.sendIdx["nextPutAll:"]=6
][0];
$recv($recv(anIRClosure)._locals())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
[$self._nextPutAll_([$recv(each)._asVariableName()
,$ctx2.sendIdx["asVariableName"]=1
][0])
,$ctx2.sendIdx["nextPutAll:"]=7
][0];
[$self._nextPutAll_(":")
,$ctx2.sendIdx["nextPutAll:"]=8
][0];
return [$self._nextPutAll_($recv(each)._asVariableName())
,$ctx2.sendIdx["nextPutAll:"]=9
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$self._nextPutAll_(",")
,$ctx2.sendIdx["nextPutAll:"]=10
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
[$self._nextPutAll_("},")
,$ctx1.sendIdx["nextPutAll:"]=11
][0];
[$self._nextPutAll_([$recv([$recv($recv($recv($recv([$recv(anIRClosure)._scope()
,$ctx1.sendIdx["scope"]=4
][0])._outerScope())._alias()).__comma(",")).__comma($recv($recv($recv(anIRClosure)._scope())._blockIndex())._asString())
,$ctx1.sendIdx[","]=7
][0]).__comma(")});")
,$ctx1.sendIdx[","]=6
][0])
,$ctx1.sendIdx["nextPutAll:"]=12
][0];
$self._lf();
$self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutBlockContextFor:during:",{anIRClosure:anIRClosure,aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutClosureWith:arguments:",
protocol: "streaming",
args: ["aBlock", "anArray"],
source: "nextPutClosureWith: aBlock arguments: anArray\x0a\x09stream nextPutAll: '(function('.\x0a\x09anArray\x0a\x09\x09do: [ :each | stream nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ stream nextPut: ',' ].\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09aBlock value.\x0a\x09stream lf; nextPutAll: '})'",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "do:separatedBy:", "asVariableName", "nextPut:", "lf", "value"]
}, function ($methodClass){ return function (aBlock,anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
[$recv($self.stream)._nextPutAll_("(function(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$recv(anArray)._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return [$recv($self.stream)._nextPutAll_($recv(each)._asVariableName())
,$ctx2.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv($self.stream)._nextPut_(",");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$1=$self.stream;
[$recv($1)._nextPutAll_("){")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
[$recv($1)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$recv(aBlock)._value();
$2=$self.stream;
$recv($2)._lf();
$recv($2)._nextPutAll_("})");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutClosureWith:arguments:",{aBlock:aBlock,anArray:anArray})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutContextFor:during:",
protocol: "streaming",
args: ["aMethod", "aBlock"],
source: "nextPutContextFor: aMethod during: aBlock\x0a\x09aMethod requiresSmalltalkContext ifFalse: [ ^ aBlock value ].\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: 'return $core.withContext(function(', aMethod scope alias, ') {';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);';\x0a\x09\x09lf.\x0a\x0a\x09aBlock value.\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '}, function(', aMethod scope alias, ') {', aMethod scope alias;\x0a\x09\x09nextPutAll: '.fill(self,', aMethod selector asJavaScriptSource, ',{'.\x0a\x0a\x09aMethod locals\x0a\x09\x09do: [ :each |\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09nextPutAll: each asVariableName;\x0a\x09\x09\x09\x09nextPutAll: ':';\x0a\x09\x09\x09\x09nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ self nextPutAll: ',' ].\x0a\x09\x0a\x09self\x0a\x09\x09nextPutAll: '})});';\x0a\x09\x09lf;\x0a\x09\x09nextPutAll: '//>>excludeEnd(\x22ctx\x22);'",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "requiresSmalltalkContext", "value", "nextPutAll:", "lf", ",", "alias", "scope", "asJavaScriptSource", "selector", "do:separatedBy:", "locals", "asVariableName"]
}, function ($methodClass){ return function (aMethod,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(aMethod)._requiresSmalltalkContext())){
return [$recv(aBlock)._value()
,$ctx1.sendIdx["value"]=1
][0];
}
[$self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$self._nextPutAll_([$recv(["return $core.withContext(function(".__comma([$recv([$recv(aMethod)._scope()
,$ctx1.sendIdx["scope"]=1
][0])._alias()
,$ctx1.sendIdx["alias"]=1
][0])
,$ctx1.sendIdx[","]=2
][0]).__comma(") {")
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=2
][0];
[$self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=3
][0];
$recv(aBlock)._value();
[$self._nextPutAll_("//>>excludeStart(\x22ctx\x22, pragmas.excludeDebugContexts);")
,$ctx1.sendIdx["nextPutAll:"]=4
][0];
[$self._lf()
,$ctx1.sendIdx["lf"]=4
][0];
[$self._nextPutAll_([$recv([$recv(["}, function(".__comma([$recv([$recv(aMethod)._scope()
,$ctx1.sendIdx["scope"]=2
][0])._alias()
,$ctx1.sendIdx["alias"]=2
][0])
,$ctx1.sendIdx[","]=5
][0]).__comma(") {")
,$ctx1.sendIdx[","]=4
][0]).__comma($recv($recv(aMethod)._scope())._alias())
,$ctx1.sendIdx[","]=3
][0])
,$ctx1.sendIdx["nextPutAll:"]=5
][0];
[$self._nextPutAll_([$recv(".fill(self,".__comma($recv($recv(aMethod)._selector())._asJavaScriptSource())).__comma(",{")
,$ctx1.sendIdx[","]=6
][0])
,$ctx1.sendIdx["nextPutAll:"]=6
][0];
$recv($recv(aMethod)._locals())._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
[$self._nextPutAll_([$recv(each)._asVariableName()
,$ctx2.sendIdx["asVariableName"]=1
][0])
,$ctx2.sendIdx["nextPutAll:"]=7
][0];
[$self._nextPutAll_(":")
,$ctx2.sendIdx["nextPutAll:"]=8
][0];
return [$self._nextPutAll_($recv(each)._asVariableName())
,$ctx2.sendIdx["nextPutAll:"]=9
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$self._nextPutAll_(",")
,$ctx2.sendIdx["nextPutAll:"]=10
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
[$self._nextPutAll_("})});")
,$ctx1.sendIdx["nextPutAll:"]=11
][0];
$self._lf();
$self._nextPutAll_("//>>excludeEnd(\x22ctx\x22);");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutContextFor:during:",{aMethod:aMethod,aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutFunctionWith:arguments:",
protocol: "streaming",
args: ["aBlock", "anArray"],
source: "nextPutFunctionWith: aBlock arguments: anArray\x0a\x09stream nextPutAll: 'function ('.\x0a\x09anArray\x0a\x09\x09do: [ :each | stream nextPutAll: each asVariableName ]\x0a\x09\x09separatedBy: [ stream nextPut: ',' ].\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09stream nextPutAll: 'var self=this,$self=this;'; lf.\x0a\x09aBlock value.\x0a\x09stream lf; nextPutAll: '}'",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "do:separatedBy:", "asVariableName", "nextPut:", "lf", "value"]
}, function ($methodClass){ return function (aBlock,anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
[$recv($self.stream)._nextPutAll_("function (")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$recv(anArray)._do_separatedBy_((function(each){
return $core.withContext(function($ctx2) {
return [$recv($self.stream)._nextPutAll_($recv(each)._asVariableName())
,$ctx2.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv($self.stream)._nextPut_(",");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$1=$self.stream;
[$recv($1)._nextPutAll_("){")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
[$recv($1)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
$2=$self.stream;
[$recv($2)._nextPutAll_("var self=this,$self=this;")
,$ctx1.sendIdx["nextPutAll:"]=4
][0];
[$recv($2)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
$recv(aBlock)._value();
$3=$self.stream;
$recv($3)._lf();
$recv($3)._nextPutAll_("}");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutFunctionWith:arguments:",{aBlock:aBlock,anArray:anArray})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutIf:then:",
protocol: "streaming",
args: ["aBlock", "anotherBlock"],
source: "nextPutIf: aBlock then: anotherBlock\x0a\x09stream nextPutAll: 'if('.\x0a\x09aBlock value.\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09anotherBlock value.\x0a\x09stream nextPutAll: '}'.\x0a\x09self omitSemicolon: true",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "value", "lf", "omitSemicolon:"]
}, function ($methodClass){ return function (aBlock,anotherBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
[$recv($self.stream)._nextPutAll_("if(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aBlock)._value()
,$ctx1.sendIdx["value"]=1
][0];
$1=$self.stream;
[$recv($1)._nextPutAll_("){")
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
$recv($1)._lf();
$recv(anotherBlock)._value();
$recv($self.stream)._nextPutAll_("}");
$self._omitSemicolon_(true);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutIf:then:",{aBlock:aBlock,anotherBlock:anotherBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutIf:then:else:",
protocol: "streaming",
args: ["aBlock", "ifBlock", "elseBlock"],
source: "nextPutIf: aBlock then: ifBlock else: elseBlock\x0a\x09stream nextPutAll: 'if('.\x0a\x09aBlock value.\x0a\x09stream nextPutAll: '){'; lf.\x0a\x09ifBlock value.\x0a\x09stream nextPutAll: '} else {'; lf.\x0a\x09elseBlock value.\x0a\x09stream nextPutAll: '}'.\x0a\x09self omitSemicolon: true",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "value", "lf", "omitSemicolon:"]
}, function ($methodClass){ return function (aBlock,ifBlock,elseBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
[$recv($self.stream)._nextPutAll_("if(")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv(aBlock)._value()
,$ctx1.sendIdx["value"]=1
][0];
$1=$self.stream;
[$recv($1)._nextPutAll_("){")
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$recv($1)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$recv(ifBlock)._value()
,$ctx1.sendIdx["value"]=2
][0];
$2=$self.stream;
[$recv($2)._nextPutAll_("} else {")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
$recv($2)._lf();
$recv(elseBlock)._value();
$recv($self.stream)._nextPutAll_("}");
$self._omitSemicolon_(true);
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutIf:then:else:",{aBlock:aBlock,ifBlock:ifBlock,elseBlock:elseBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutNonLocalReturnHandlingWith:",
protocol: "streaming",
args: ["aBlock"],
source: "nextPutNonLocalReturnHandlingWith: aBlock\x0a\x09stream\x0a\x09\x09nextPutAll: 'var $early={};'; lf;\x0a\x09\x09nextPutAll: 'try {'; lf.\x0a\x09aBlock value.\x0a\x09stream\x0a\x09\x09nextPutAll: '}'; lf;\x0a\x09\x09nextPutAll: 'catch(e) {if(e===$early)return e[0]; throw e}'; lf",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "lf", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.stream;
[$recv($1)._nextPutAll_("var $early={};")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
[$recv($1)._lf()
,$ctx1.sendIdx["lf"]=1
][0];
[$recv($1)._nextPutAll_("try {")
,$ctx1.sendIdx["nextPutAll:"]=2
][0];
[$recv($1)._lf()
,$ctx1.sendIdx["lf"]=2
][0];
$recv(aBlock)._value();
$2=$self.stream;
[$recv($2)._nextPutAll_("}")
,$ctx1.sendIdx["nextPutAll:"]=3
][0];
[$recv($2)._lf()
,$ctx1.sendIdx["lf"]=3
][0];
$recv($2)._nextPutAll_("catch(e) {if(e===$early)return e[0]; throw e}");
$recv($2)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutNonLocalReturnHandlingWith:",{aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutNonLocalReturnWith:",
protocol: "streaming",
args: ["aBlock"],
source: "nextPutNonLocalReturnWith: aBlock\x0a\x09stream nextPutAll: 'throw $early=['.\x0a\x09aBlock value.\x0a\x09stream nextPutAll: ']'",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv($self.stream)._nextPutAll_("throw $early=[")
,$ctx1.sendIdx["nextPutAll:"]=1
][0];
$recv(aBlock)._value();
$recv($self.stream)._nextPutAll_("]");
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutNonLocalReturnWith:",{aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutReturnWith:",
protocol: "streaming",
args: ["aBlock"],
source: "nextPutReturnWith: aBlock\x0a\x09stream nextPutAll: 'return '.\x0a\x09aBlock value",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutAll:", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.stream)._nextPutAll_("return ");
$recv(aBlock)._value();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutReturnWith:",{aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutStatementWith:",
protocol: "streaming",
args: ["aBlock"],
source: "nextPutStatementWith: aBlock\x0a\x09self omitSemicolon: false.\x0a\x09aBlock value.\x0a\x09self omitSemicolon ifFalse: [ stream nextPutAll: ';' ].\x0a\x09self omitSemicolon: false.\x0a\x09stream lf",
referencedClasses: [],
pragmas: [],
messageSends: ["omitSemicolon:", "value", "ifFalse:", "omitSemicolon", "nextPutAll:", "lf"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._omitSemicolon_(false)
,$ctx1.sendIdx["omitSemicolon:"]=1
][0];
$recv(aBlock)._value();
if(!$core.assert($self._omitSemicolon())){
$recv($self.stream)._nextPutAll_(";");
}
$self._omitSemicolon_(false);
$recv($self.stream)._lf();
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutStatementWith:",{aBlock:aBlock})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "nextPutVars:",
protocol: "streaming",
args: ["aCollection"],
source: "nextPutVars: aCollection\x0a\x09aCollection ifNotEmpty: [\x0a\x09\x09stream nextPutAll: 'var '.\x0a\x09\x09aCollection\x0a\x09\x09\x09do: [ :each | stream nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ stream nextPutAll: ',' ].\x0a\x09\x09stream nextPutAll: ';'; lf ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:", "nextPutAll:", "do:separatedBy:", "lf"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$recv(aCollection)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
[$recv($self.stream)._nextPutAll_("var ")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
$recv(aCollection)._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return [$recv($self.stream)._nextPutAll_(each)
,$ctx3.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return [$recv($self.stream)._nextPutAll_(",")
,$ctx3.sendIdx["nextPutAll:"]=3
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
$1=$self.stream;
$recv($1)._nextPutAll_(";");
return $recv($1)._lf();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"nextPutVars:",{aCollection:aCollection})});
}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "omitSemicolon",
protocol: "accessing",
args: [],
source: "omitSemicolon\x0a\x09^ omitSemicolon",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.omitSemicolon;

}; }),
$globals.JSStream);

$core.addMethod(
$core.method({
selector: "omitSemicolon:",
protocol: "accessing",
args: ["aBoolean"],
source: "omitSemicolon: aBoolean\x0a\x09omitSemicolon := aBoolean",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
$self.omitSemicolon=aBoolean;
return self;

}; }),
$globals.JSStream);


$core.setTraitComposition([{trait: $globals.TPragmator}], $globals.IRPragmator);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: "*Compiler-IR",
args: [],
source: "requiresSmalltalkContext\x0a\x09\x22Answer true if the receiver requires a smalltalk context.\x0a\x09Only send nodes require a context.\x0a\x09\x0a\x09If no node requires a context, the method will be compiled without one.\x0a\x09See `IRJSTranslator` and `JSStream` for context creation\x22\x0a\x09\x0a\x09^ self dagChildren anySatisfy: [ :each | each requiresSmalltalkContext ]",
referencedClasses: [],
pragmas: [],
messageSends: ["anySatisfy:", "dagChildren", "requiresSmalltalkContext"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._requiresSmalltalkContext();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"requiresSmalltalkContext",{})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "hasOpeningStatements",
protocol: "*Compiler-IR",
args: [],
source: "hasOpeningStatements\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "subtreeNeedsAliasing",
protocol: "*Compiler-IR",
args: [],
source: "subtreeNeedsAliasing\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "hasOpeningStatements",
protocol: "*Compiler-IR",
args: [],
source: "hasOpeningStatements\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.CascadeNode);

$core.addMethod(
$core.method({
selector: "hasOpeningStatements",
protocol: "*Compiler-IR",
args: [],
source: "hasOpeningStatements\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "subtreeNeedsAliasing",
protocol: "*Compiler-IR",
args: [],
source: "subtreeNeedsAliasing\x0a\x09^ self dagChildren anySatisfy: [ :each |\x0a\x09\x09each shouldBeAliased or: [\x0a\x09\x09\x09each hasOpeningStatements or: [\x0a\x09\x09\x09\x09each subtreeNeedsAliasing ] ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["anySatisfy:", "dagChildren", "or:", "shouldBeAliased", "hasOpeningStatements", "subtreeNeedsAliasing"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._dagChildren())._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(each)._shouldBeAliased())){
return true;
} else {
if($core.assert($recv(each)._hasOpeningStatements())){
return true;
} else {
return $recv(each)._subtreeNeedsAliasing();
}
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"subtreeNeedsAliasing",{})});
}; }),
$globals.ExpressionNode);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: "*Compiler-IR",
args: [],
source: "requiresSmalltalkContext\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.JSStatementNode);

$core.addMethod(
$core.method({
selector: "asReceiver",
protocol: "*Compiler-IR",
args: [],
source: "asReceiver\x0a\x09^ self class receiverNames\x0a\x09\x09at: self name\x0a\x09\x09ifPresent: [ :newName | self copy name: newName; yourself ]\x0a\x09\x09ifAbsent: [ self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:", "receiverNames", "class", "name", "name:", "copy", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($recv($self._class())._receiverNames())._at_ifPresent_ifAbsent_($self._name(),(function(newName){
return $core.withContext(function($ctx2) {
$1=$self._copy();
$recv($1)._name_(newName);
return $recv($1)._yourself();
}, function($ctx2) {$ctx2.fillBlock({newName:newName},$ctx1,1)});
}),(function(){
return self;

}));
}, function($ctx1) {$ctx1.fill(self,"asReceiver",{})});
}; }),
$globals.PseudoVar);

$core.addMethod(
$core.method({
selector: "asReceiver",
protocol: "*Compiler-IR",
args: [],
source: "asReceiver\x0a\x09\x22Return customized copy to use as receiver,\x0a\x09or self if suffices.\x22\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "requiresSmalltalkContext",
protocol: "*Compiler-IR",
args: [],
source: "requiresSmalltalkContext\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.SendNode);

});

define('amber/core/Compiler-Inlining',["amber/boot", "require", "amber/core/Compiler-AST", "amber/core/Compiler-Core", "amber/core/Compiler-IR", "amber/core/Compiler-Semantic", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-Inlining");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ASTPreInliner", $globals.NodeVisitor, "Compiler-Inlining");
$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x0a\x09aNode superSend ifFalse: [ \x0a\x09\x09(IRSendInliner inlinedSelectors includes: aNode selector) ifTrue: [\x0a\x09\x09\x09aNode shouldBeAliased: true.\x0a\x09\x09\x09aNode receiver ifNotNil: [ :receiver |\x0a\x09\x09\x09\x09(IRSendInliner inlinedSelectorsNeedingIdempotentReceiver includes: aNode selector) ifTrue: [\x0a\x09\x09\x09\x09\x09receiver shouldBeAliased: true ] ] ] ].\x0a\x0a\x09^ super visitSendNode: aNode",
referencedClasses: ["IRSendInliner"],
pragmas: [],
messageSends: ["ifFalse:", "superSend", "ifTrue:", "includes:", "inlinedSelectors", "selector", "shouldBeAliased:", "ifNotNil:", "receiver", "inlinedSelectorsNeedingIdempotentReceiver", "visitSendNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if(!$core.assert($recv(aNode)._superSend())){
if($core.assert([$recv($recv($globals.IRSendInliner)._inlinedSelectors())._includes_([$recv(aNode)._selector()
,$ctx1.sendIdx["selector"]=1
][0])
,$ctx1.sendIdx["includes:"]=1
][0])){
[$recv(aNode)._shouldBeAliased_(true)
,$ctx1.sendIdx["shouldBeAliased:"]=1
][0];
$1=$recv(aNode)._receiver();
if($1 == null || $1.a$nil){
$1;
} else {
var receiver;
receiver=$1;
if($core.assert($recv($recv($globals.IRSendInliner)._inlinedSelectorsNeedingIdempotentReceiver())._includes_($recv(aNode)._selector()))){
$recv(receiver)._shouldBeAliased_(true);
}
}
}
}
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitSendNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode})});
}; }),
$globals.ASTPreInliner);



$core.addClass("IRInlinedClosure", $globals.IRClosure, "Compiler-Inlining");
$globals.IRInlinedClosure.comment="I represent an inlined closure instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitIRInlinedClosure: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRInlinedClosure:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedClosure_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedClosure);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: "testing",
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRInlinedClosure);



$core.addClass("IRInlinedSend", $globals.IRSend, "Compiler-Inlining");
$globals.IRInlinedSend.comment="I am the abstract super class of inlined message send instructions.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitInlinedSend: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitInlinedSend:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitInlinedSend_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedSend);

$core.addMethod(
$core.method({
selector: "internalVariables",
protocol: "accessing",
args: [],
source: "internalVariables\x0a\x09\x22Answer a collection of internal variables required \x0a\x09to perform the inlining\x22\x0a\x09\x0a\x09^ #()",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [];

}; }),
$globals.IRInlinedSend);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: "testing",
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRInlinedSend);



$core.addClass("IRInlinedIfFalse", $globals.IRInlinedSend, "Compiler-Inlining");
$globals.IRInlinedIfFalse.comment="I represent an inlined `#ifFalse:` message send instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitIRInlinedIfFalse: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRInlinedIfFalse:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfFalse_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedIfFalse);



$core.addClass("IRInlinedIfNilIfNotNil", $globals.IRInlinedSend, "Compiler-Inlining");
$globals.IRInlinedIfNilIfNotNil.comment="I represent an inlined `#ifNil:ifNotNil:` message send instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitIRInlinedIfNilIfNotNil: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRInlinedIfNilIfNotNil:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfNilIfNotNil_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedIfNilIfNotNil);



$core.addClass("IRInlinedIfTrue", $globals.IRInlinedSend, "Compiler-Inlining");
$globals.IRInlinedIfTrue.comment="I represent an inlined `#ifTrue:` message send instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitIRInlinedIfTrue: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRInlinedIfTrue:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfTrue_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedIfTrue);



$core.addClass("IRInlinedIfTrueIfFalse", $globals.IRInlinedSend, "Compiler-Inlining");
$globals.IRInlinedIfTrueIfFalse.comment="I represent an inlined `#ifTrue:ifFalse:` message send instruction.";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitIRInlinedIfTrueIfFalse: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRInlinedIfTrueIfFalse:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedIfTrueIfFalse_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedIfTrueIfFalse);



$core.addClass("IRInlinedSequence", $globals.IRBlockSequence, "Compiler-Inlining");
$globals.IRInlinedSequence.comment="I represent a (block) sequence inside an inlined closure instruction (instance of `IRInlinedClosure`).";
$core.addMethod(
$core.method({
selector: "acceptDagVisitor:",
protocol: "visiting",
args: ["aVisitor"],
source: "acceptDagVisitor: aVisitor\x0a\x09aVisitor visitIRInlinedSequence: self",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRInlinedSequence:"]
}, function ($methodClass){ return function (aVisitor){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aVisitor)._visitIRInlinedSequence_(self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptDagVisitor:",{aVisitor:aVisitor})});
}; }),
$globals.IRInlinedSequence);

$core.addMethod(
$core.method({
selector: "isInlined",
protocol: "testing",
args: [],
source: "isInlined\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.IRInlinedSequence);



$core.addClass("IRInliner", $globals.IRVisitor, "Compiler-Inlining");
$globals.IRInliner.comment="I visit an IR tree, inlining message sends and block closures.\x0a\x0aMessage selectors that can be inlined are answered by `IRSendInliner >> #inlinedSelectors`";
$core.addMethod(
$core.method({
selector: "assignmentInliner",
protocol: "factory",
args: [],
source: "assignmentInliner\x0a\x09^ IRAssignmentInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRAssignmentInliner"],
pragmas: [],
messageSends: ["translator:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRAssignmentInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"assignmentInliner",{})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "flattenedReturn:",
protocol: "visiting",
args: ["anIRNonLocalReturn"],
source: "flattenedReturn: anIRNonLocalReturn\x0a\x09| localReturn |\x0a\x09localReturn := IRReturn new\x0a\x09\x09scope: anIRNonLocalReturn scope;\x0a\x09\x09yourself.\x0a\x09anIRNonLocalReturn dagChildren do: [ :each | localReturn add: each ].\x0a\x09^ localReturn",
referencedClasses: ["IRReturn"],
pragmas: [],
messageSends: ["scope:", "new", "scope", "yourself", "do:", "dagChildren", "add:"]
}, function ($methodClass){ return function (anIRNonLocalReturn){
var self=this,$self=this;
var localReturn;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRReturn)._new();
$recv($1)._scope_($recv(anIRNonLocalReturn)._scope());
localReturn=$recv($1)._yourself();
$recv($recv(anIRNonLocalReturn)._dagChildren())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(localReturn)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return localReturn;
}, function($ctx1) {$ctx1.fill(self,"flattenedReturn:",{anIRNonLocalReturn:anIRNonLocalReturn,localReturn:localReturn})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "nonLocalReturnInliner",
protocol: "factory",
args: [],
source: "nonLocalReturnInliner\x0a\x09^ IRNonLocalReturnInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRNonLocalReturnInliner"],
pragmas: [],
messageSends: ["translator:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRNonLocalReturnInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"nonLocalReturnInliner",{})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "returnInliner",
protocol: "factory",
args: [],
source: "returnInliner\x0a\x09^ IRReturnInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRReturnInliner"],
pragmas: [],
messageSends: ["translator:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRReturnInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"returnInliner",{})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "sendInliner",
protocol: "factory",
args: [],
source: "sendInliner\x0a\x09^ IRSendInliner new\x0a\x09\x09translator: self;\x0a\x09\x09yourself",
referencedClasses: ["IRSendInliner"],
pragmas: [],
messageSends: ["translator:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.IRSendInliner)._new();
$recv($1)._translator_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"sendInliner",{})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "shouldInlineAssignment:",
protocol: "testing",
args: ["anIRAssignment"],
source: "shouldInlineAssignment: anIRAssignment\x0a\x09^ anIRAssignment isInlined not and: [\x0a\x09\x09anIRAssignment right isSend and: [\x0a\x09\x09\x09self shouldInlineSend: anIRAssignment right ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "not", "isInlined", "isSend", "right", "shouldInlineSend:"]
}, function ($methodClass){ return function (anIRAssignment){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv(anIRAssignment)._isInlined())._not())){
if($core.assert($recv([$recv(anIRAssignment)._right()
,$ctx1.sendIdx["right"]=1
][0])._isSend())){
return $self._shouldInlineSend_($recv(anIRAssignment)._right());
} else {
return false;
}
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"shouldInlineAssignment:",{anIRAssignment:anIRAssignment})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "shouldInlineReturn:",
protocol: "testing",
args: ["anIRReturn"],
source: "shouldInlineReturn: anIRReturn\x0a\x09^ anIRReturn isInlined not and: [\x0a\x09\x09anIRReturn expression isSend and: [\x0a\x09\x09\x09self shouldInlineSend: anIRReturn expression ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "not", "isInlined", "isSend", "expression", "shouldInlineSend:"]
}, function ($methodClass){ return function (anIRReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv(anIRReturn)._isInlined())._not())){
if($core.assert($recv([$recv(anIRReturn)._expression()
,$ctx1.sendIdx["expression"]=1
][0])._isSend())){
return $self._shouldInlineSend_($recv(anIRReturn)._expression());
} else {
return false;
}
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"shouldInlineReturn:",{anIRReturn:anIRReturn})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "shouldInlineSend:",
protocol: "testing",
args: ["anIRSend"],
source: "shouldInlineSend: anIRSend\x0a\x09^ anIRSend isInlined not and: [\x0a\x09\x09IRSendInliner shouldInline: anIRSend ]",
referencedClasses: ["IRSendInliner"],
pragmas: [],
messageSends: ["and:", "not", "isInlined", "shouldInline:"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($recv(anIRSend)._isInlined())._not())){
return $recv($globals.IRSendInliner)._shouldInline_(anIRSend);
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"shouldInlineSend:",{anIRSend:anIRSend})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRAssignment:",
protocol: "visiting",
args: ["anIRAssignment"],
source: "visitIRAssignment: anIRAssignment\x0a\x09^ (self shouldInlineAssignment: anIRAssignment)\x0a\x09\x09ifTrue: [ self assignmentInliner inlineAssignment: anIRAssignment ]\x0a\x09\x09ifFalse: [ super visitIRAssignment: anIRAssignment ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "shouldInlineAssignment:", "inlineAssignment:", "assignmentInliner", "visitIRAssignment:"]
}, function ($methodClass){ return function (anIRAssignment){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._shouldInlineAssignment_(anIRAssignment))){
return $recv($self._assignmentInliner())._inlineAssignment_(anIRAssignment);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRAssignment_.call($self,anIRAssignment))
,$ctx1.supercall = false
][0];
}
}, function($ctx1) {$ctx1.fill(self,"visitIRAssignment:",{anIRAssignment:anIRAssignment})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRNonLocalReturn:",
protocol: "visiting",
args: ["anIRNonLocalReturn"],
source: "visitIRNonLocalReturn: anIRNonLocalReturn\x0a\x09anIRNonLocalReturn scope canFlattenNonLocalReturns ifTrue: [\x0a\x09\x09| localReturn |\x0a\x09\x09anIRNonLocalReturn scope methodScope removeNonLocalReturn: anIRNonLocalReturn scope.\x0a\x09\x09localReturn := self flattenedReturn: anIRNonLocalReturn.\x0a\x09\x09anIRNonLocalReturn replaceWith: localReturn.\x0a\x09\x09^ self visitIRReturn: localReturn ].\x0a\x09^ (self shouldInlineReturn: anIRNonLocalReturn)\x0a\x09\x09ifTrue: [ self nonLocalReturnInliner inlineReturn: anIRNonLocalReturn ]\x0a\x09\x09ifFalse: [ super visitIRNonLocalReturn: anIRNonLocalReturn ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "canFlattenNonLocalReturns", "scope", "removeNonLocalReturn:", "methodScope", "flattenedReturn:", "replaceWith:", "visitIRReturn:", "ifTrue:ifFalse:", "shouldInlineReturn:", "inlineReturn:", "nonLocalReturnInliner", "visitIRNonLocalReturn:"]
}, function ($methodClass){ return function (anIRNonLocalReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$recv(anIRNonLocalReturn)._scope()
,$ctx1.sendIdx["scope"]=1
][0])._canFlattenNonLocalReturns())){
var localReturn;
$recv($recv([$recv(anIRNonLocalReturn)._scope()
,$ctx1.sendIdx["scope"]=2
][0])._methodScope())._removeNonLocalReturn_($recv(anIRNonLocalReturn)._scope());
localReturn=$self._flattenedReturn_(anIRNonLocalReturn);
$recv(anIRNonLocalReturn)._replaceWith_(localReturn);
return $self._visitIRReturn_(localReturn);
}
if($core.assert($self._shouldInlineReturn_(anIRNonLocalReturn))){
return $recv($self._nonLocalReturnInliner())._inlineReturn_(anIRNonLocalReturn);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRNonLocalReturn_.call($self,anIRNonLocalReturn))
,$ctx1.supercall = false
][0];
}
}, function($ctx1) {$ctx1.fill(self,"visitIRNonLocalReturn:",{anIRNonLocalReturn:anIRNonLocalReturn})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRReturn:",
protocol: "visiting",
args: ["anIRReturn"],
source: "visitIRReturn: anIRReturn\x0a\x09^ (self shouldInlineReturn: anIRReturn)\x0a\x09\x09ifTrue: [ self returnInliner inlineReturn: anIRReturn ]\x0a\x09\x09ifFalse: [ super visitIRReturn: anIRReturn ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "shouldInlineReturn:", "inlineReturn:", "returnInliner", "visitIRReturn:"]
}, function ($methodClass){ return function (anIRReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._shouldInlineReturn_(anIRReturn))){
return $recv($self._returnInliner())._inlineReturn_(anIRReturn);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRReturn_.call($self,anIRReturn))
,$ctx1.supercall = false
][0];
}
}, function($ctx1) {$ctx1.fill(self,"visitIRReturn:",{anIRReturn:anIRReturn})});
}; }),
$globals.IRInliner);

$core.addMethod(
$core.method({
selector: "visitIRSend:",
protocol: "visiting",
args: ["anIRSend"],
source: "visitIRSend: anIRSend\x0a\x09^ (self shouldInlineSend: anIRSend)\x0a\x09\x09ifTrue: [ self sendInliner inlineSend: anIRSend ]\x0a\x09\x09ifFalse: [ super visitIRSend: anIRSend ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "shouldInlineSend:", "inlineSend:", "sendInliner", "visitIRSend:"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._shouldInlineSend_(anIRSend))){
return $recv($self._sendInliner())._inlineSend_(anIRSend);
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitIRSend_.call($self,anIRSend))
,$ctx1.supercall = false
][0];
}
}, function($ctx1) {$ctx1.fill(self,"visitIRSend:",{anIRSend:anIRSend})});
}; }),
$globals.IRInliner);



$core.addClass("IRInliningJSTranslator", $globals.IRJSTranslator, "Compiler-Inlining");
$globals.IRInliningJSTranslator.comment="I am a specialized JavaScript translator able to write inlined IR instructions to JavaScript stream (`JSStream` instance).";
$core.addMethod(
$core.method({
selector: "visitIRInlinedClosure:",
protocol: "visiting",
args: ["anIRInlinedClosure"],
source: "visitIRInlinedClosure: anIRInlinedClosure\x0a\x09self stream nextPutVars: (anIRInlinedClosure tempDeclarations collect: [ :each |\x0a\x09\x09each name asVariableName ]).\x0a\x09self visitAllChildren: anIRInlinedClosure",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutVars:", "stream", "collect:", "tempDeclarations", "asVariableName", "name", "visitAllChildren:"]
}, function ($methodClass){ return function (anIRInlinedClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._stream())._nextPutVars_($recv($recv(anIRInlinedClosure)._tempDeclarations())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._name())._asVariableName();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})));
$self._visitAllChildren_(anIRInlinedClosure);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedClosure:",{anIRInlinedClosure:anIRInlinedClosure})});
}; }),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfFalse:",
protocol: "visiting",
args: ["anIRInlinedIfFalse"],
source: "visitIRInlinedIfFalse: anIRInlinedIfFalse\x0a\x09self stream nextPutIf: [\x0a\x09\x09self stream nextPutAll: '!$core.assert('.\x0a\x09\x09self visit: anIRInlinedIfFalse dagChildren first.\x0a\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfFalse dagChildren last ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutIf:then:", "stream", "nextPutAll:", "visit:", "first", "dagChildren", "last"]
}, function ($methodClass){ return function (anIRInlinedIfFalse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutIf_then_((function(){
return $core.withContext(function($ctx2) {
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutAll_("!$core.assert(")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
[$self._visit_($recv([$recv(anIRInlinedIfFalse)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=1
][0])._first())
,$ctx2.sendIdx["visit:"]=1
][0];
return $recv($self._stream())._nextPutAll_(")");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $self._visit_($recv($recv(anIRInlinedIfFalse)._dagChildren())._last());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfFalse:",{anIRInlinedIfFalse:anIRInlinedIfFalse})});
}; }),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfNilIfNotNil:",
protocol: "visiting",
args: ["anIRInlinedIfNilIfNotNil"],
source: "visitIRInlinedIfNilIfNotNil: anIRInlinedIfNilIfNotNil\x0a\x09self stream\x0a\x09\x09nextPutIf: [\x0a\x09\x09\x09self visit: anIRInlinedIfNilIfNotNil dagChildren first.\x0a\x09\x09\x09self stream nextPutAll: ' == null || '.\x0a\x09\x09\x09self visit: anIRInlinedIfNilIfNotNil dagChildren first.\x0a\x09\x09\x09self stream nextPutAll: '.a$nil' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfNilIfNotNil dagChildren second ]\x0a\x09\x09else: [ self visit: anIRInlinedIfNilIfNotNil dagChildren third ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutIf:then:else:", "stream", "visit:", "first", "dagChildren", "nextPutAll:", "second", "third"]
}, function ($methodClass){ return function (anIRInlinedIfNilIfNotNil){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutIf_then_else_((function(){
return $core.withContext(function($ctx2) {
[$self._visit_([$recv([$recv(anIRInlinedIfNilIfNotNil)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=1
][0])._first()
,$ctx2.sendIdx["first"]=1
][0])
,$ctx2.sendIdx["visit:"]=1
][0];
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutAll_(" == null || ")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
[$self._visit_($recv([$recv(anIRInlinedIfNilIfNotNil)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=2
][0])._first())
,$ctx2.sendIdx["visit:"]=2
][0];
return $recv($self._stream())._nextPutAll_(".a$nil");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$self._visit_($recv([$recv(anIRInlinedIfNilIfNotNil)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=3
][0])._second())
,$ctx2.sendIdx["visit:"]=3
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return $self._visit_($recv($recv(anIRInlinedIfNilIfNotNil)._dagChildren())._third());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfNilIfNotNil:",{anIRInlinedIfNilIfNotNil:anIRInlinedIfNilIfNotNil})});
}; }),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfTrue:",
protocol: "visiting",
args: ["anIRInlinedIfTrue"],
source: "visitIRInlinedIfTrue: anIRInlinedIfTrue\x0a\x09self stream nextPutIf: [\x0a\x09\x09self stream nextPutAll: '$core.assert('.\x0a\x09\x09self visit: anIRInlinedIfTrue dagChildren first.\x0a\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfTrue dagChildren last ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutIf:then:", "stream", "nextPutAll:", "visit:", "first", "dagChildren", "last"]
}, function ($methodClass){ return function (anIRInlinedIfTrue){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutIf_then_((function(){
return $core.withContext(function($ctx2) {
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutAll_("$core.assert(")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
[$self._visit_($recv([$recv(anIRInlinedIfTrue)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=1
][0])._first())
,$ctx2.sendIdx["visit:"]=1
][0];
return $recv($self._stream())._nextPutAll_(")");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $self._visit_($recv($recv(anIRInlinedIfTrue)._dagChildren())._last());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfTrue:",{anIRInlinedIfTrue:anIRInlinedIfTrue})});
}; }),
$globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "visitIRInlinedIfTrueIfFalse:",
protocol: "visiting",
args: ["anIRInlinedIfTrueIfFalse"],
source: "visitIRInlinedIfTrueIfFalse: anIRInlinedIfTrueIfFalse\x0a\x09self stream\x0a\x09\x09nextPutIf: [\x0a\x09\x09\x09self stream nextPutAll: '$core.assert('.\x0a\x09\x09\x09self visit: anIRInlinedIfTrueIfFalse dagChildren first.\x0a\x09\x09\x09self stream nextPutAll: ')' ]\x0a\x09\x09then: [ self visit: anIRInlinedIfTrueIfFalse dagChildren second ]\x0a\x09\x09else: [ self visit: anIRInlinedIfTrueIfFalse dagChildren third ]",
referencedClasses: [],
pragmas: [],
messageSends: ["nextPutIf:then:else:", "stream", "nextPutAll:", "visit:", "first", "dagChildren", "second", "third"]
}, function ($methodClass){ return function (anIRInlinedIfTrueIfFalse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv([$self._stream()
,$ctx1.sendIdx["stream"]=1
][0])._nextPutIf_then_else_((function(){
return $core.withContext(function($ctx2) {
[$recv([$self._stream()
,$ctx2.sendIdx["stream"]=2
][0])._nextPutAll_("$core.assert(")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
[$self._visit_($recv([$recv(anIRInlinedIfTrueIfFalse)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=1
][0])._first())
,$ctx2.sendIdx["visit:"]=1
][0];
return $recv($self._stream())._nextPutAll_(")");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return [$self._visit_($recv([$recv(anIRInlinedIfTrueIfFalse)._dagChildren()
,$ctx2.sendIdx["dagChildren"]=2
][0])._second())
,$ctx2.sendIdx["visit:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),(function(){
return $core.withContext(function($ctx2) {
return $self._visit_($recv($recv(anIRInlinedIfTrueIfFalse)._dagChildren())._third());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedIfTrueIfFalse:",{anIRInlinedIfTrueIfFalse:anIRInlinedIfTrueIfFalse})});
}; }),
$globals.IRInliningJSTranslator);



$core.addClass("IRSendInliner", $globals.Object, "Compiler-Inlining");
$core.setSlots($globals.IRSendInliner, ["send", "translator"]);
$globals.IRSendInliner.comment="I inline some message sends and block closure arguments. I heavily rely on #perform: to dispatch inlining methods.";
$core.addMethod(
$core.method({
selector: "and:",
protocol: "inlining",
args: ["anIRInstruction"],
source: "and: anIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09^ self\x0a\x09\x09inlinedSend: IRInlinedIfTrueIfFalse new\x0a\x09\x09withBlock: anIRInstruction\x0a\x09\x09withBlock: (IRClosure new\x0a\x09\x09\x09scope: anIRInstruction scope copy;\x0a\x09\x09\x09add: (IRBlockSequence new\x0a\x09\x09\x09\x09add: (IRValue new value: false; yourself);\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself)",
referencedClasses: ["IRInlinedIfTrueIfFalse", "IRClosure", "IRBlockSequence", "IRValue"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:withBlock:", "new", "scope:", "copy", "scope", "add:", "value:", "yourself"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
$self._mustBeNiladicClosure_(anIRInstruction);
$1=[$recv($globals.IRInlinedIfTrueIfFalse)._new()
,$ctx1.sendIdx["new"]=1
][0];
$2=[$recv($globals.IRClosure)._new()
,$ctx1.sendIdx["new"]=2
][0];
$recv($2)._scope_($recv($recv(anIRInstruction)._scope())._copy());
$3=[$recv($globals.IRBlockSequence)._new()
,$ctx1.sendIdx["new"]=3
][0];
$4=$recv($globals.IRValue)._new();
$recv($4)._value_(false);
$recv($3)._add_([$recv($4)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]);
[$recv($2)._add_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0])
,$ctx1.sendIdx["add:"]=1
][0];
return $self._inlinedSend_withBlock_withBlock_($1,anIRInstruction,$recv($2)._yourself());
}, function($ctx1) {$ctx1.fill(self,"and:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifFalse:",
protocol: "inlining",
args: ["anIRInstruction"],
source: "ifFalse: anIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09^ self inlinedSend: IRInlinedIfFalse new withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfFalse"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:", "new"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._mustBeNiladicClosure_(anIRInstruction);
return $self._inlinedSend_withBlock_($recv($globals.IRInlinedIfFalse)._new(),anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifFalse:ifTrue:",
protocol: "inlining",
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifFalse: anIRInstruction ifTrue: anotherIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09self mustBeNiladicClosure: anotherIRInstruction.\x0a\x09^ self inlinedSend: IRInlinedIfTrueIfFalse new withBlock: anotherIRInstruction withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfTrueIfFalse"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:withBlock:", "new"]
}, function ($methodClass){ return function (anIRInstruction,anotherIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._mustBeNiladicClosure_(anIRInstruction)
,$ctx1.sendIdx["mustBeNiladicClosure:"]=1
][0];
$self._mustBeNiladicClosure_(anotherIRInstruction);
return $self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfTrueIfFalse)._new(),anotherIRInstruction,anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifFalse:ifTrue:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNil:",
protocol: "inlining",
args: ["anIRInstruction"],
source: "ifNil: anIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09^ self\x0a\x09\x09inlinedSend: IRInlinedIfNilIfNotNil new\x0a\x09\x09withBlock: anIRInstruction\x0a\x09\x09withBlock: (IRClosure new\x0a\x09\x09\x09scope: anIRInstruction scope copy;\x0a\x09\x09\x09add: (IRBlockSequence new\x0a\x09\x09\x09\x09add: self send receiver;\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself)",
referencedClasses: ["IRInlinedIfNilIfNotNil", "IRClosure", "IRBlockSequence"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:withBlock:", "new", "scope:", "copy", "scope", "add:", "receiver", "send", "yourself"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$self._mustBeNiladicClosure_(anIRInstruction);
$1=[$recv($globals.IRInlinedIfNilIfNotNil)._new()
,$ctx1.sendIdx["new"]=1
][0];
$2=[$recv($globals.IRClosure)._new()
,$ctx1.sendIdx["new"]=2
][0];
$recv($2)._scope_($recv($recv(anIRInstruction)._scope())._copy());
$3=$recv($globals.IRBlockSequence)._new();
$recv($3)._add_($recv($self._send())._receiver());
[$recv($2)._add_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0])
,$ctx1.sendIdx["add:"]=1
][0];
return $self._inlinedSend_withBlock_withBlock_($1,anIRInstruction,$recv($2)._yourself());
}, function($ctx1) {$ctx1.fill(self,"ifNil:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNil:ifNotNil:",
protocol: "inlining",
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifNil: anIRInstruction ifNotNil: anotherIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09self mustBeNiladicOrUnaryClosure: anotherIRInstruction.\x0a\x09^ self inlinedSend: IRInlinedIfNilIfNotNil new withBlock: anIRInstruction withBlock: anotherIRInstruction",
referencedClasses: ["IRInlinedIfNilIfNotNil"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "mustBeNiladicOrUnaryClosure:", "inlinedSend:withBlock:withBlock:", "new"]
}, function ($methodClass){ return function (anIRInstruction,anotherIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._mustBeNiladicClosure_(anIRInstruction);
$self._mustBeNiladicOrUnaryClosure_(anotherIRInstruction);
return $self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfNilIfNotNil)._new(),anIRInstruction,anotherIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifNil:ifNotNil:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNotNil:",
protocol: "inlining",
args: ["anIRInstruction"],
source: "ifNotNil: anIRInstruction\x0a\x09self mustBeNiladicOrUnaryClosure: anIRInstruction.\x0a\x09^ self\x0a\x09\x09inlinedSend: IRInlinedIfNilIfNotNil new\x0a\x09\x09withBlock: (IRClosure new\x0a\x09\x09\x09scope: anIRInstruction scope copy;\x0a\x09\x09\x09add: (IRBlockSequence new\x0a\x09\x09\x09\x09add: self send receiver;\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself)\x0a\x09\x09withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfNilIfNotNil", "IRClosure", "IRBlockSequence"],
pragmas: [],
messageSends: ["mustBeNiladicOrUnaryClosure:", "inlinedSend:withBlock:withBlock:", "new", "scope:", "copy", "scope", "add:", "receiver", "send", "yourself"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
$self._mustBeNiladicOrUnaryClosure_(anIRInstruction);
$1=[$recv($globals.IRInlinedIfNilIfNotNil)._new()
,$ctx1.sendIdx["new"]=1
][0];
$2=[$recv($globals.IRClosure)._new()
,$ctx1.sendIdx["new"]=2
][0];
$recv($2)._scope_($recv($recv(anIRInstruction)._scope())._copy());
$3=$recv($globals.IRBlockSequence)._new();
$recv($3)._add_($recv($self._send())._receiver());
[$recv($2)._add_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0])
,$ctx1.sendIdx["add:"]=1
][0];
return $self._inlinedSend_withBlock_withBlock_($1,$recv($2)._yourself(),anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifNotNil:ifNil:",
protocol: "inlining",
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifNotNil: anIRInstruction ifNil: anotherIRInstruction\x0a\x09self mustBeNiladicOrUnaryClosure: anIRInstruction.\x0a\x09self mustBeNiladicClosure: anotherIRInstruction.\x0a\x09^ self inlinedSend: IRInlinedIfNilIfNotNil new withBlock: anotherIRInstruction withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfNilIfNotNil"],
pragmas: [],
messageSends: ["mustBeNiladicOrUnaryClosure:", "mustBeNiladicClosure:", "inlinedSend:withBlock:withBlock:", "new"]
}, function ($methodClass){ return function (anIRInstruction,anotherIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._mustBeNiladicOrUnaryClosure_(anIRInstruction);
$self._mustBeNiladicClosure_(anotherIRInstruction);
return $self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfNilIfNotNil)._new(),anotherIRInstruction,anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifNotNil:ifNil:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifTrue:",
protocol: "inlining",
args: ["anIRInstruction"],
source: "ifTrue: anIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09^ self inlinedSend: IRInlinedIfTrue new withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfTrue"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:", "new"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._mustBeNiladicClosure_(anIRInstruction);
return $self._inlinedSend_withBlock_($recv($globals.IRInlinedIfTrue)._new(),anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifTrue:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "ifTrue:ifFalse:",
protocol: "inlining",
args: ["anIRInstruction", "anotherIRInstruction"],
source: "ifTrue: anIRInstruction ifFalse: anotherIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09self mustBeNiladicClosure: anotherIRInstruction.\x0a\x09^ self inlinedSend: IRInlinedIfTrueIfFalse new withBlock: anIRInstruction withBlock: anotherIRInstruction",
referencedClasses: ["IRInlinedIfTrueIfFalse"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:withBlock:", "new"]
}, function ($methodClass){ return function (anIRInstruction,anotherIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._mustBeNiladicClosure_(anIRInstruction)
,$ctx1.sendIdx["mustBeNiladicClosure:"]=1
][0];
$self._mustBeNiladicClosure_(anotherIRInstruction);
return $self._inlinedSend_withBlock_withBlock_($recv($globals.IRInlinedIfTrueIfFalse)._new(),anIRInstruction,anotherIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"ifTrue:ifFalse:",{anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: "inlining",
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09| inlinedClosure sequence statements |\x0a\x0a\x09inlinedClosure := self inlinedClosure.\x0a\x09inlinedClosure \x0a\x09\x09scope: anIRClosure scope;\x0a\x09\x09parent: anIRClosure parent.\x0a\x0a\x09\x22Add the possible temp declarations\x22\x0a\x09anIRClosure tempDeclarations do: [ :each |\x0a\x09\x09\x09inlinedClosure add: each ].\x0a\x0a\x09\x22Add a block sequence\x22\x0a\x09sequence := self inlinedSequence.\x0a\x0a\x09\x22Map the closure arguments to the receiver of the message send\x22\x0a\x09anIRClosure arguments do: [ :each |\x0a\x09\x09inlinedClosure add: (IRTempDeclaration new name: each; yourself).\x0a\x09\x09sequence add: (IRAssignment new\x0a\x09\x09\x09add: (IRVariable new variable: (ArgVar new scope: inlinedClosure scope; name: each; yourself));\x0a\x09\x09\x09add: self send receiver;\x0a\x09\x09\x09yourself) ].\x0a\x09\x09\x09\x0a\x09\x22To ensure the correct order of the closure instructions: first the temps then the sequence\x22\x0a\x09inlinedClosure add: sequence.\x0a\x0a\x09\x22Get all the statements\x22\x0a\x09statements := anIRClosure sequence dagChildren.\x0a\x09\x0a\x09statements ifNotEmpty: [\x0a\x09\x09statements allButLast do: [ :each | sequence add: each ].\x0a\x0a\x09\x09\x22Inlined closures change local returns into result value itself\x22\x0a\x09\x09sequence add: statements last asInlinedBlockResult ].\x0a\x0a\x09^ inlinedClosure",
referencedClasses: ["IRTempDeclaration", "IRAssignment", "IRVariable", "ArgVar"],
pragmas: [],
messageSends: ["inlinedClosure", "scope:", "scope", "parent:", "parent", "do:", "tempDeclarations", "add:", "inlinedSequence", "arguments", "name:", "new", "yourself", "variable:", "receiver", "send", "dagChildren", "sequence", "ifNotEmpty:", "allButLast", "asInlinedBlockResult", "last"]
}, function ($methodClass){ return function (anIRClosure){
var self=this,$self=this;
var inlinedClosure,sequence,statements;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7;
inlinedClosure=$self._inlinedClosure();
$1=inlinedClosure;
[$recv($1)._scope_([$recv(anIRClosure)._scope()
,$ctx1.sendIdx["scope"]=1
][0])
,$ctx1.sendIdx["scope:"]=1
][0];
$recv($1)._parent_($recv(anIRClosure)._parent());
[$recv($recv(anIRClosure)._tempDeclarations())._do_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(inlinedClosure)._add_(each)
,$ctx2.sendIdx["add:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
sequence=$self._inlinedSequence();
[$recv($recv(anIRClosure)._arguments())._do_((function(each){
return $core.withContext(function($ctx2) {
$2=inlinedClosure;
$3=[$recv($globals.IRTempDeclaration)._new()
,$ctx2.sendIdx["new"]=1
][0];
[$recv($3)._name_(each)
,$ctx2.sendIdx["name:"]=1
][0];
[$recv($2)._add_([$recv($3)._yourself()
,$ctx2.sendIdx["yourself"]=1
][0])
,$ctx2.sendIdx["add:"]=2
][0];
$4=sequence;
$5=[$recv($globals.IRAssignment)._new()
,$ctx2.sendIdx["new"]=2
][0];
$6=[$recv($globals.IRVariable)._new()
,$ctx2.sendIdx["new"]=3
][0];
$7=$recv($globals.ArgVar)._new();
$recv($7)._scope_($recv(inlinedClosure)._scope());
$recv($7)._name_(each);
[$recv($5)._add_($recv($6)._variable_([$recv($7)._yourself()
,$ctx2.sendIdx["yourself"]=2
][0]))
,$ctx2.sendIdx["add:"]=4
][0];
[$recv($5)._add_($recv($self._send())._receiver())
,$ctx2.sendIdx["add:"]=5
][0];
return [$recv($4)._add_($recv($5)._yourself())
,$ctx2.sendIdx["add:"]=3
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}))
,$ctx1.sendIdx["do:"]=2
][0];
[$recv(inlinedClosure)._add_(sequence)
,$ctx1.sendIdx["add:"]=6
][0];
statements=$recv($recv(anIRClosure)._sequence())._dagChildren();
$recv(statements)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
$recv($recv(statements)._allButLast())._do_((function(each){
return $core.withContext(function($ctx3) {
return [$recv(sequence)._add_(each)
,$ctx3.sendIdx["add:"]=7
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,4)});
}));
return $recv(sequence)._add_($recv($recv(statements)._last())._asInlinedBlockResult());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return inlinedClosure;
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure,inlinedClosure:inlinedClosure,sequence:sequence,statements:statements})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlineSend:",
protocol: "inlining",
args: ["anIRSend"],
source: "inlineSend: anIRSend\x0a\x09self send: anIRSend.\x0a\x09^ self\x0a\x09\x09perform: self send selector\x0a\x09\x09withArguments: self send arguments",
referencedClasses: [],
pragmas: [],
messageSends: ["send:", "perform:withArguments:", "selector", "send", "arguments"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._send_(anIRSend);
return $self._perform_withArguments_($recv([$self._send()
,$ctx1.sendIdx["send"]=1
][0])._selector(),$recv($self._send())._arguments());
}, function($ctx1) {$ctx1.fill(self,"inlineSend:",{anIRSend:anIRSend})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlineSend:andReplace:",
protocol: "private",
args: ["anIRSend", "anIRInstruction"],
source: "inlineSend: anIRSend andReplace: anIRInstruction\x0a\x09anIRInstruction replaceWith: anIRSend.\x0a\x09^ self inlineSend: anIRSend",
referencedClasses: [],
pragmas: [],
messageSends: ["replaceWith:", "inlineSend:"]
}, function ($methodClass){ return function (anIRSend,anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(anIRInstruction)._replaceWith_(anIRSend);
return $self._inlineSend_(anIRSend);
}, function($ctx1) {$ctx1.fill(self,"inlineSend:andReplace:",{anIRSend:anIRSend,anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedClosure",
protocol: "factory",
args: [],
source: "inlinedClosure\x0a\x09^ IRInlinedClosure new",
referencedClasses: ["IRInlinedClosure"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInlinedClosure)._new();
}, function($ctx1) {$ctx1.fill(self,"inlinedClosure",{})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedClosure:wrapFinalValueIn:",
protocol: "inlining",
args: ["closure", "aBlock"],
source: "inlinedClosure: closure wrapFinalValueIn: aBlock\x0a\x09| sequence final |\x0a\x0a\x09sequence := closure sequence.\x0a\x09\x0a\x09sequence dagChildren ifEmpty: [ sequence add: (IRVariable new\x0a\x09\x09variable: (closure scope pseudoVars at: 'nil');\x0a\x09\x09yourself) ].\x0a\x09final := sequence dagChildren last.\x0a\x09final yieldsValue ifTrue: [ sequence replace: final with: (aBlock value: final) ].\x0a\x0a\x09^ closure",
referencedClasses: ["IRVariable"],
pragmas: [],
messageSends: ["sequence", "ifEmpty:", "dagChildren", "add:", "variable:", "new", "at:", "pseudoVars", "scope", "yourself", "last", "ifTrue:", "yieldsValue", "replace:with:", "value:"]
}, function ($methodClass){ return function (closure,aBlock){
var self=this,$self=this;
var sequence,final;
return $core.withContext(function($ctx1) {
var $1,$2;
sequence=$recv(closure)._sequence();
$recv([$recv(sequence)._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._ifEmpty_((function(){
return $core.withContext(function($ctx2) {
$1=sequence;
$2=$recv($globals.IRVariable)._new();
$recv($2)._variable_($recv($recv($recv(closure)._scope())._pseudoVars())._at_("nil"));
return $recv($1)._add_($recv($2)._yourself());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
final=$recv($recv(sequence)._dagChildren())._last();
if($core.assert($recv(final)._yieldsValue())){
$recv(sequence)._replace_with_(final,$recv(aBlock)._value_(final));
}
return closure;
}, function($ctx1) {$ctx1.fill(self,"inlinedClosure:wrapFinalValueIn:",{closure:closure,aBlock:aBlock,sequence:sequence,final:final})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedSend:withBlock:",
protocol: "private",
args: ["inlinedSend", "anIRInstruction"],
source: "inlinedSend: inlinedSend withBlock: anIRInstruction\x0a\x09| inlinedClosure |\x0a\x0a\x09inlinedClosure := self translator visit: (self inlineClosure: anIRInstruction).\x0a\x0a\x09inlinedSend\x0a\x09\x09add: self send receiver;\x0a\x09\x09add: inlinedClosure.\x0a\x0a\x09self send replaceWith: inlinedSend.\x0a\x09inlinedSend method internalVariables \x0a\x09\x09addAll: inlinedSend internalVariables.\x0a\x0a\x09^ inlinedSend",
referencedClasses: [],
pragmas: [],
messageSends: ["visit:", "translator", "inlineClosure:", "add:", "receiver", "send", "replaceWith:", "addAll:", "internalVariables", "method"]
}, function ($methodClass){ return function (inlinedSend,anIRInstruction){
var self=this,$self=this;
var inlinedClosure;
return $core.withContext(function($ctx1) {
inlinedClosure=$recv($self._translator())._visit_($self._inlineClosure_(anIRInstruction));
[$recv(inlinedSend)._add_($recv([$self._send()
,$ctx1.sendIdx["send"]=1
][0])._receiver())
,$ctx1.sendIdx["add:"]=1
][0];
$recv(inlinedSend)._add_(inlinedClosure);
$recv($self._send())._replaceWith_(inlinedSend);
$recv([$recv($recv(inlinedSend)._method())._internalVariables()
,$ctx1.sendIdx["internalVariables"]=1
][0])._addAll_($recv(inlinedSend)._internalVariables());
return inlinedSend;
}, function($ctx1) {$ctx1.fill(self,"inlinedSend:withBlock:",{inlinedSend:inlinedSend,anIRInstruction:anIRInstruction,inlinedClosure:inlinedClosure})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedSend:withBlock:withBlock:",
protocol: "private",
args: ["inlinedSend", "anIRInstruction", "anotherIRInstruction"],
source: "inlinedSend: inlinedSend withBlock: anIRInstruction withBlock: anotherIRInstruction\x0a\x09| inlinedClosure1 inlinedClosure2 |\x0a\x0a\x09inlinedClosure1 := self translator visit: (self inlineClosure: anIRInstruction).\x0a\x09inlinedClosure2 := self translator visit: (self inlineClosure: anotherIRInstruction).\x0a\x0a\x09inlinedSend\x0a\x09\x09add: self send receiver;\x0a\x09\x09add: inlinedClosure1;\x0a\x09\x09add: inlinedClosure2.\x0a\x0a\x09self send replaceWith: inlinedSend.\x0a\x09inlinedSend method internalVariables \x0a\x09\x09addAll: inlinedSend internalVariables.\x0a\x09\x09\x0a\x09^ inlinedSend",
referencedClasses: [],
pragmas: [],
messageSends: ["visit:", "translator", "inlineClosure:", "add:", "receiver", "send", "replaceWith:", "addAll:", "internalVariables", "method"]
}, function ($methodClass){ return function (inlinedSend,anIRInstruction,anotherIRInstruction){
var self=this,$self=this;
var inlinedClosure1,inlinedClosure2;
return $core.withContext(function($ctx1) {
inlinedClosure1=[$recv([$self._translator()
,$ctx1.sendIdx["translator"]=1
][0])._visit_([$self._inlineClosure_(anIRInstruction)
,$ctx1.sendIdx["inlineClosure:"]=1
][0])
,$ctx1.sendIdx["visit:"]=1
][0];
inlinedClosure2=$recv($self._translator())._visit_($self._inlineClosure_(anotherIRInstruction));
[$recv(inlinedSend)._add_($recv([$self._send()
,$ctx1.sendIdx["send"]=1
][0])._receiver())
,$ctx1.sendIdx["add:"]=1
][0];
[$recv(inlinedSend)._add_(inlinedClosure1)
,$ctx1.sendIdx["add:"]=2
][0];
$recv(inlinedSend)._add_(inlinedClosure2);
$recv($self._send())._replaceWith_(inlinedSend);
$recv([$recv($recv(inlinedSend)._method())._internalVariables()
,$ctx1.sendIdx["internalVariables"]=1
][0])._addAll_($recv(inlinedSend)._internalVariables());
return inlinedSend;
}, function($ctx1) {$ctx1.fill(self,"inlinedSend:withBlock:withBlock:",{inlinedSend:inlinedSend,anIRInstruction:anIRInstruction,anotherIRInstruction:anotherIRInstruction,inlinedClosure1:inlinedClosure1,inlinedClosure2:inlinedClosure2})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inlinedSequence",
protocol: "factory",
args: [],
source: "inlinedSequence\x0a\x09^ IRInlinedSequence new",
referencedClasses: ["IRInlinedSequence"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInlinedSequence)._new();
}, function($ctx1) {$ctx1.fill(self,"inlinedSequence",{})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "inliningError:",
protocol: "error handling",
args: ["aString"],
source: "inliningError: aString\x0a\x09InliningError signal: aString",
referencedClasses: ["InliningError"],
pragmas: [],
messageSends: ["signal:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.InliningError)._signal_(aString);
return self;
}, function($ctx1) {$ctx1.fill(self,"inliningError:",{aString:aString})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "mustBeNiladicClosure:",
protocol: "testing",
args: ["anIRInstruction"],
source: "mustBeNiladicClosure: anIRInstruction\x0a\x09anIRInstruction isClosure ifFalse: [ self inliningError: 'Message argument should be a block' ].\x0a\x09anIRInstruction arguments size = 0 ifFalse: [ self inliningError: 'Inlined block should have zero argument' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "isClosure", "inliningError:", "=", "size", "arguments"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(anIRInstruction)._isClosure())){
[$self._inliningError_("Message argument should be a block")
,$ctx1.sendIdx["inliningError:"]=1
][0];
}
if(!$core.assert($recv($recv($recv(anIRInstruction)._arguments())._size()).__eq((0)))){
$self._inliningError_("Inlined block should have zero argument");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"mustBeNiladicClosure:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "mustBeNiladicOrUnaryClosure:",
protocol: "testing",
args: ["anIRInstruction"],
source: "mustBeNiladicOrUnaryClosure: anIRInstruction\x0a\x09anIRInstruction isClosure ifFalse: [ self inliningError: 'Message argument should be a block' ].\x0a\x09anIRInstruction arguments size <= 1 ifFalse: [ self inliningError: 'Inlined block should have at most one argument' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "isClosure", "inliningError:", "<=", "size", "arguments"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv(anIRInstruction)._isClosure())){
[$self._inliningError_("Message argument should be a block")
,$ctx1.sendIdx["inliningError:"]=1
][0];
}
if(!$core.assert($recv($recv($recv(anIRInstruction)._arguments())._size()).__lt_eq((1)))){
$self._inliningError_("Inlined block should have at most one argument");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"mustBeNiladicOrUnaryClosure:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "or:",
protocol: "inlining",
args: ["anIRInstruction"],
source: "or: anIRInstruction\x0a\x09self mustBeNiladicClosure: anIRInstruction.\x0a\x09^ self\x0a\x09\x09inlinedSend: IRInlinedIfTrueIfFalse new\x0a\x09\x09withBlock: (IRClosure new\x0a\x09\x09\x09scope: anIRInstruction scope copy;\x0a\x09\x09\x09add: (IRBlockSequence new\x0a\x09\x09\x09\x09add: (IRValue new value: true; yourself);\x0a\x09\x09\x09\x09yourself);\x0a\x09\x09\x09yourself)\x0a\x09\x09withBlock: anIRInstruction",
referencedClasses: ["IRInlinedIfTrueIfFalse", "IRClosure", "IRBlockSequence", "IRValue"],
pragmas: [],
messageSends: ["mustBeNiladicClosure:", "inlinedSend:withBlock:withBlock:", "new", "scope:", "copy", "scope", "add:", "value:", "yourself"]
}, function ($methodClass){ return function (anIRInstruction){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
$self._mustBeNiladicClosure_(anIRInstruction);
$1=[$recv($globals.IRInlinedIfTrueIfFalse)._new()
,$ctx1.sendIdx["new"]=1
][0];
$2=[$recv($globals.IRClosure)._new()
,$ctx1.sendIdx["new"]=2
][0];
$recv($2)._scope_($recv($recv(anIRInstruction)._scope())._copy());
$3=[$recv($globals.IRBlockSequence)._new()
,$ctx1.sendIdx["new"]=3
][0];
$4=$recv($globals.IRValue)._new();
$recv($4)._value_(true);
$recv($3)._add_([$recv($4)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]);
[$recv($2)._add_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0])
,$ctx1.sendIdx["add:"]=1
][0];
return $self._inlinedSend_withBlock_withBlock_($1,$recv($2)._yourself(),anIRInstruction);
}, function($ctx1) {$ctx1.fill(self,"or:",{anIRInstruction:anIRInstruction})});
}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "send",
protocol: "accessing",
args: [],
source: "send\x0a\x09^ send",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.send;

}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "send:",
protocol: "accessing",
args: ["anIRSend"],
source: "send: anIRSend\x0a\x09send := anIRSend",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
$self.send=anIRSend;
return self;

}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "translator",
protocol: "accessing",
args: [],
source: "translator\x0a\x09^ translator",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.translator;

}; }),
$globals.IRSendInliner);

$core.addMethod(
$core.method({
selector: "translator:",
protocol: "accessing",
args: ["anASTTranslator"],
source: "translator: anASTTranslator\x0a\x09translator := anASTTranslator",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anASTTranslator){
var self=this,$self=this;
$self.translator=anASTTranslator;
return self;

}; }),
$globals.IRSendInliner);


$core.addMethod(
$core.method({
selector: "inlinedSelectors",
protocol: "accessing",
args: [],
source: "inlinedSelectors\x0a\x09^ #(\x0a\x09\x09ifTrue: ifFalse: ifTrue:ifFalse: ifFalse:ifTrue:\x0a\x09\x09ifNil: ifNotNil: ifNil:ifNotNil: ifNotNil:ifNil:\x0a\x09\x09and: or:\x0a\x09)",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return ["ifTrue:", "ifFalse:", "ifTrue:ifFalse:", "ifFalse:ifTrue:", "ifNil:", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:", "and:", "or:"];

}; }),
$globals.IRSendInliner.a$cls);

$core.addMethod(
$core.method({
selector: "inlinedSelectorsNeedingIdempotentReceiver",
protocol: "accessing",
args: [],
source: "inlinedSelectorsNeedingIdempotentReceiver\x0a\x09^ #(\x0a\x09\x09ifNil: ifNotNil: ifNil:ifNotNil: ifNotNil:ifNil:\x0a\x09)",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return ["ifNil:", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:"];

}; }),
$globals.IRSendInliner.a$cls);

$core.addMethod(
$core.method({
selector: "shouldInline:",
protocol: "accessing",
args: ["anIRSend"],
source: "shouldInline: anIRSend\x0a\x09^ (self inlinedSelectors includes: anIRSend selector) and: [\x0a\x09\x09anIRSend receiver isSuper not and: [\x0a\x09\x09\x09anIRSend arguments allSatisfy: [ :each | each isClosure ] ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["and:", "includes:", "inlinedSelectors", "selector", "not", "isSuper", "receiver", "allSatisfy:", "arguments", "isClosure"]
}, function ($methodClass){ return function (anIRSend){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self._inlinedSelectors())._includes_($recv(anIRSend)._selector()))){
if($core.assert($recv($recv($recv(anIRSend)._receiver())._isSuper())._not())){
return $recv($recv(anIRSend)._arguments())._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isClosure();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
} else {
return false;
}
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"shouldInline:",{anIRSend:anIRSend})});
}; }),
$globals.IRSendInliner.a$cls);


$core.addClass("IRAssignmentInliner", $globals.IRSendInliner, "Compiler-Inlining");
$core.setSlots($globals.IRAssignmentInliner, ["target"]);
$globals.IRAssignmentInliner.comment="I inline message sends together with assignments by moving them around into the inline closure instructions.\x0a\x0a##Example\x0a\x0a\x09foo\x0a\x09\x09| a |\x0a\x09\x09a := true ifTrue: [ 1 ]\x0a\x0aWill produce:\x0a\x0a\x09if($core.assert(true) {\x0a\x09\x09a = 1;\x0a\x09};";
$core.addMethod(
$core.method({
selector: "inlineAssignment:",
protocol: "inlining",
args: ["anIRAssignment"],
source: "inlineAssignment: anIRAssignment\x0a\x09self target: anIRAssignment left.\x0a\x09^ self inlineSend: anIRAssignment right andReplace: anIRAssignment",
referencedClasses: [],
pragmas: [],
messageSends: ["target:", "left", "inlineSend:andReplace:", "right"]
}, function ($methodClass){ return function (anIRAssignment){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._target_($recv(anIRAssignment)._left());
return $self._inlineSend_andReplace_($recv(anIRAssignment)._right(),anIRAssignment);
}, function($ctx1) {$ctx1.fill(self,"inlineAssignment:",{anIRAssignment:anIRAssignment})});
}; }),
$globals.IRAssignmentInliner);

$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: "inlining",
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09^ self\x0a\x09\x09inlinedClosure: (super inlineClosure: anIRClosure)\x0a\x09\x09wrapFinalValueIn: [ :final |\x0a\x09\x09\x09IRAssignment new\x0a\x09\x09\x09\x09add: self target;\x0a\x09\x09\x09\x09add: final copy;\x0a\x09\x09\x09\x09yourself ]",
referencedClasses: ["IRAssignment"],
pragmas: [],
messageSends: ["inlinedClosure:wrapFinalValueIn:", "inlineClosure:", "add:", "new", "target", "copy", "yourself"]
}, function ($methodClass){ return function (anIRClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $self._inlinedClosure_wrapFinalValueIn_([(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._inlineClosure_.call($self,anIRClosure))
,$ctx1.supercall = false
][0],(function(final){
return $core.withContext(function($ctx2) {
$1=$recv($globals.IRAssignment)._new();
[$recv($1)._add_($self._target())
,$ctx2.sendIdx["add:"]=1
][0];
$recv($1)._add_($recv(final)._copy());
return $recv($1)._yourself();
}, function($ctx2) {$ctx2.fillBlock({final:final},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure})});
}; }),
$globals.IRAssignmentInliner);

$core.addMethod(
$core.method({
selector: "target",
protocol: "accessing",
args: [],
source: "target\x0a\x09^ target",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.target;

}; }),
$globals.IRAssignmentInliner);

$core.addMethod(
$core.method({
selector: "target:",
protocol: "accessing",
args: ["anObject"],
source: "target: anObject\x0a\x09target := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.target=anObject;
return self;

}; }),
$globals.IRAssignmentInliner);



$core.addClass("IRNonLocalReturnInliner", $globals.IRSendInliner, "Compiler-Inlining");
$globals.IRNonLocalReturnInliner.comment="I inline message sends with inlined closure together with a return instruction.";
$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: "inlining",
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09^ self\x0a\x09\x09inlinedClosure: (super inlineClosure: anIRClosure)\x0a\x09\x09wrapFinalValueIn: [ :final |\x0a\x09\x09\x09IRNonLocalReturn new\x0a\x09\x09\x09\x09add: final copy;\x0a\x09\x09\x09\x09yourself ]",
referencedClasses: ["IRNonLocalReturn"],
pragmas: [],
messageSends: ["inlinedClosure:wrapFinalValueIn:", "inlineClosure:", "add:", "new", "copy", "yourself"]
}, function ($methodClass){ return function (anIRClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $self._inlinedClosure_wrapFinalValueIn_([(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._inlineClosure_.call($self,anIRClosure))
,$ctx1.supercall = false
][0],(function(final){
return $core.withContext(function($ctx2) {
$1=$recv($globals.IRNonLocalReturn)._new();
$recv($1)._add_($recv(final)._copy());
return $recv($1)._yourself();
}, function($ctx2) {$ctx2.fillBlock({final:final},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure})});
}; }),
$globals.IRNonLocalReturnInliner);

$core.addMethod(
$core.method({
selector: "inlineReturn:",
protocol: "inlining",
args: ["anIRReturn"],
source: "inlineReturn: anIRReturn\x0a\x09^ self inlineSend: anIRReturn expression andReplace: anIRReturn",
referencedClasses: [],
pragmas: [],
messageSends: ["inlineSend:andReplace:", "expression"]
}, function ($methodClass){ return function (anIRReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._inlineSend_andReplace_($recv(anIRReturn)._expression(),anIRReturn);
}, function($ctx1) {$ctx1.fill(self,"inlineReturn:",{anIRReturn:anIRReturn})});
}; }),
$globals.IRNonLocalReturnInliner);



$core.addClass("IRReturnInliner", $globals.IRSendInliner, "Compiler-Inlining");
$globals.IRReturnInliner.comment="I inline message sends with inlined closure together with a return instruction.";
$core.addMethod(
$core.method({
selector: "inlineClosure:",
protocol: "inlining",
args: ["anIRClosure"],
source: "inlineClosure: anIRClosure\x0a\x09^ self\x0a\x09\x09inlinedClosure: (super inlineClosure: anIRClosure)\x0a\x09\x09wrapFinalValueIn: [ :final |\x0a\x09\x09\x09IRReturn new\x0a\x09\x09\x09\x09add: final copy;\x0a\x09\x09\x09\x09yourself ]",
referencedClasses: ["IRReturn"],
pragmas: [],
messageSends: ["inlinedClosure:wrapFinalValueIn:", "inlineClosure:", "add:", "new", "copy", "yourself"]
}, function ($methodClass){ return function (anIRClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $self._inlinedClosure_wrapFinalValueIn_([(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._inlineClosure_.call($self,anIRClosure))
,$ctx1.supercall = false
][0],(function(final){
return $core.withContext(function($ctx2) {
$1=$recv($globals.IRReturn)._new();
$recv($1)._add_($recv(final)._copy());
return $recv($1)._yourself();
}, function($ctx2) {$ctx2.fillBlock({final:final},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inlineClosure:",{anIRClosure:anIRClosure})});
}; }),
$globals.IRReturnInliner);

$core.addMethod(
$core.method({
selector: "inlineReturn:",
protocol: "inlining",
args: ["anIRReturn"],
source: "inlineReturn: anIRReturn\x0a\x09^ self inlineSend: anIRReturn expression andReplace: anIRReturn",
referencedClasses: [],
pragmas: [],
messageSends: ["inlineSend:andReplace:", "expression"]
}, function ($methodClass){ return function (anIRReturn){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._inlineSend_andReplace_($recv(anIRReturn)._expression(),anIRReturn);
}, function($ctx1) {$ctx1.fill(self,"inlineReturn:",{anIRReturn:anIRReturn})});
}; }),
$globals.IRReturnInliner);



$core.addClass("InliningCodeGenerator", $globals.CodeGenerator, "Compiler-Inlining");
$globals.InliningCodeGenerator.comment="I am a specialized code generator that uses inlining to produce more optimized JavaScript output";
$core.addMethod(
$core.method({
selector: "inliner",
protocol: "compiling",
args: [],
source: "inliner\x0a\x09^ IRInliner new",
referencedClasses: ["IRInliner"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.IRInliner)._new();
}, function($ctx1) {$ctx1.fill(self,"inliner",{})});
}; }),
$globals.InliningCodeGenerator);

$core.addMethod(
$core.method({
selector: "irTranslatorClass",
protocol: "compiling",
args: [],
source: "irTranslatorClass\x0a\x09^ IRInliningJSTranslator",
referencedClasses: ["IRInliningJSTranslator"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.IRInliningJSTranslator;

}; }),
$globals.InliningCodeGenerator);

$core.addMethod(
$core.method({
selector: "preInliner",
protocol: "compiling",
args: [],
source: "preInliner\x0a\x09^ ASTPreInliner new",
referencedClasses: ["ASTPreInliner"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.ASTPreInliner)._new();
}, function($ctx1) {$ctx1.fill(self,"preInliner",{})});
}; }),
$globals.InliningCodeGenerator);

$core.addMethod(
$core.method({
selector: "transformersDictionary",
protocol: "compiling",
args: [],
source: "transformersDictionary\x0a\x09^ transformersDictionary ifNil: [ transformersDictionary := super transformersDictionary\x0a\x09\x09at: '3000-inlinerTagging' put: self preInliner;\x0a\x09\x09at: '6000-inliner' put: self inliner;\x0a\x09\x09at: '8000-irToJs' put: self irTranslator;\x0a\x09\x09yourself ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "at:put:", "transformersDictionary", "preInliner", "inliner", "irTranslator", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$self.transformersDictionary;
if($1 == null || $1.a$nil){
$2=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._transformersDictionary.call($self))
,$ctx1.supercall = false
][0];
[$recv($2)._at_put_("3000-inlinerTagging",$self._preInliner())
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($2)._at_put_("6000-inliner",$self._inliner())
,$ctx1.sendIdx["at:put:"]=2
][0];
$recv($2)._at_put_("8000-irToJs",$self._irTranslator());
$self.transformersDictionary=$recv($2)._yourself();
return $self.transformersDictionary;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"transformersDictionary",{})});
}; }),
$globals.InliningCodeGenerator);



$core.addClass("InliningError", $globals.SemanticError, "Compiler-Inlining");
$globals.InliningError.comment="Instances of InliningError are signaled when using an `InliningCodeGenerator`in a `Compiler`.";


$core.addTrait("TIRInlinedVisitor", "Compiler-Inlining");
$core.addMethod(
$core.method({
selector: "visitIRInlinedClosure:",
protocol: "visiting",
args: ["anIRInlinedClosure"],
source: "visitIRInlinedClosure: anIRInlinedClosure\x0a\x09^ self visitIRClosure: anIRInlinedClosure",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRClosure:"]
}, function ($methodClass){ return function (anIRInlinedClosure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitIRClosure_(anIRInlinedClosure);
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedClosure:",{anIRInlinedClosure:anIRInlinedClosure})});
}; }),
$globals.TIRInlinedVisitor);

$core.addMethod(
$core.method({
selector: "visitIRInlinedSequence:",
protocol: "visiting",
args: ["anIRInlinedSequence"],
source: "visitIRInlinedSequence: anIRInlinedSequence\x0a\x09^ self visitIRSequence: anIRInlinedSequence",
referencedClasses: [],
pragmas: [],
messageSends: ["visitIRSequence:"]
}, function ($methodClass){ return function (anIRInlinedSequence){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._visitIRSequence_(anIRInlinedSequence);
}, function($ctx1) {$ctx1.fill(self,"visitIRInlinedSequence:",{anIRInlinedSequence:anIRInlinedSequence})});
}; }),
$globals.TIRInlinedVisitor);

$core.setTraitComposition([{trait: $globals.TIRInlinedVisitor}], $globals.IRInliner);
$core.setTraitComposition([{trait: $globals.TIRInlinedVisitor}], $globals.IRInliningJSTranslator);

$core.addMethod(
$core.method({
selector: "asInlinedBlockResult",
protocol: "*Compiler-Inlining",
args: [],
source: "asInlinedBlockResult\x0a\x09^ self expression",
referencedClasses: [],
pragmas: [],
messageSends: ["expression"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._expression();
}, function($ctx1) {$ctx1.fill(self,"asInlinedBlockResult",{})});
}; }),
$globals.IRBlockReturn);

$core.addMethod(
$core.method({
selector: "asInlinedBlockResult",
protocol: "*Compiler-Inlining",
args: [],
source: "asInlinedBlockResult\x0a\x09^ self",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.IRInstruction);

});

define('amber/core/Compiler-Interpreter',["amber/boot", "require", "amber/core/Compiler-AST", "amber/core/Compiler-Core", "amber/core/Compiler-Semantic", "amber/core/Kernel-Exceptions", "amber/core/Kernel-Methods", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-Interpreter");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AIBlockClosure", $globals.BlockClosure, "Compiler-Interpreter");
$core.setSlots($globals.AIBlockClosure, ["node", "outerContext"]);
$globals.AIBlockClosure.comment="I am a special `BlockClosure` subclass used by an interpreter to interpret a block node.\x0a\x0aWhile I am polymorphic with `BlockClosure`, some methods such as `#new` will raise interpretation errors. Unlike a `BlockClosure`, my instance are not JavaScript functions.\x0a\x0aEvaluating an instance will result in interpreting the `node` instance variable (instance of `BlockNode`).";
$core.addMethod(
$core.method({
selector: "applyTo:arguments:",
protocol: "evaluating",
args: ["anObject", "aCollection"],
source: "applyTo: anObject arguments: aCollection\x0a\x09self interpreterError",
referencedClasses: [],
pragmas: [],
messageSends: ["interpreterError"]
}, function ($methodClass){ return function (anObject,aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._interpreterError();
return self;
}, function($ctx1) {$ctx1.fill(self,"applyTo:arguments:",{anObject:anObject,aCollection:aCollection})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "compiledSource",
protocol: "accessing",
args: [],
source: "compiledSource\x0a\x09\x22Unlike blocks, the receiver doesn't represent a JS function\x22\x0a\x09\x0a\x09^ '[ AST Block closure ]'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "[ AST Block closure ]";

}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "currySelf",
protocol: "converting",
args: [],
source: "currySelf\x0a\x09self interpreterError",
referencedClasses: [],
pragmas: [],
messageSends: ["interpreterError"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._interpreterError();
return self;
}, function($ctx1) {$ctx1.fill(self,"currySelf",{})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "initializeWithContext:node:",
protocol: "initialization",
args: ["aContext", "aNode"],
source: "initializeWithContext: aContext node: aNode\x0a\x09node := aNode.\x0a\x09outerContext := aContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aContext,aNode){
var self=this,$self=this;
$self.node=aNode;
$self.outerContext=aContext;
return self;

}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "interpreterError",
protocol: "error handling",
args: [],
source: "interpreterError\x0a\x09ASTInterpreterError signal: 'Method cannot be interpreted by the interpreter.'",
referencedClasses: ["ASTInterpreterError"],
pragmas: [],
messageSends: ["signal:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.ASTInterpreterError)._signal_("Method cannot be interpreted by the interpreter.");
return self;
}, function($ctx1) {$ctx1.fill(self,"interpreterError",{})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "numArgs",
protocol: "accessing",
args: [],
source: "numArgs\x0a\x09^ node temps size",
referencedClasses: [],
pragmas: [],
messageSends: ["size", "temps"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self.node)._temps())._size();
}, function($ctx1) {$ctx1.fill(self,"numArgs",{})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value",
protocol: "evaluating",
args: [],
source: "value\x0a\x09^ self valueWithPossibleArguments: #()",
referencedClasses: [],
pragmas: [],
messageSends: ["valueWithPossibleArguments:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._valueWithPossibleArguments_([]);
}, function($ctx1) {$ctx1.fill(self,"value",{})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value:",
protocol: "evaluating",
args: ["anArgument"],
source: "value: anArgument\x0a\x09^ self valueWithPossibleArguments: {anArgument}",
referencedClasses: [],
pragmas: [],
messageSends: ["valueWithPossibleArguments:"]
}, function ($methodClass){ return function (anArgument){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._valueWithPossibleArguments_([anArgument]);
}, function($ctx1) {$ctx1.fill(self,"value:",{anArgument:anArgument})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:",
protocol: "evaluating",
args: ["firstArgument", "secondArgument"],
source: "value: firstArgument value: secondArgument\x0a\x09^ self valueWithPossibleArguments: {firstArgument . secondArgument}",
referencedClasses: [],
pragmas: [],
messageSends: ["valueWithPossibleArguments:"]
}, function ($methodClass){ return function (firstArgument,secondArgument){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._valueWithPossibleArguments_([firstArgument,secondArgument]);
}, function($ctx1) {$ctx1.fill(self,"value:value:",{firstArgument:firstArgument,secondArgument:secondArgument})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "value:value:value:",
protocol: "evaluating",
args: ["firstArgument", "secondArgument", "thirdArgument"],
source: "value: firstArgument value: secondArgument value: thirdArgument\x0a\x09^ self valueWithPossibleArguments: {firstArgument . secondArgument . thirdArgument}",
referencedClasses: [],
pragmas: [],
messageSends: ["valueWithPossibleArguments:"]
}, function ($methodClass){ return function (firstArgument,secondArgument,thirdArgument){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._valueWithPossibleArguments_([firstArgument,secondArgument,thirdArgument]);
}, function($ctx1) {$ctx1.fill(self,"value:value:value:",{firstArgument:firstArgument,secondArgument:secondArgument,thirdArgument:thirdArgument})});
}; }),
$globals.AIBlockClosure);

$core.addMethod(
$core.method({
selector: "valueWithPossibleArguments:",
protocol: "evaluating",
args: ["aCollection"],
source: "valueWithPossibleArguments: aCollection\x0a\x09| context sequenceNode |\x0a\x09context := outerContext newInnerContext.\x0a\x0a\x09\x22Interpret a copy of the sequence node to avoid creating a new AIBlockClosure\x22\x0a\x09sequenceNode := node sequenceNode copy\x0a\x09\x09parent: nil;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09\x22Define locals in the context\x22\x0a\x09sequenceNode temps do: [ :each |\x0a\x09\x09context defineLocal: each ].\x0a\x09\x09\x0a\x09\x22Populate the arguments into the context locals\x22\x09\x0a\x09node parameters withIndexDo: [ :each :index |\x0a\x09\x09context defineLocal: each.\x0a\x09\x09context localAt: each put: (aCollection at: index ifAbsent: [ nil ]) ].\x0a\x0a\x09\x22Interpret the first node of the BlockSequenceNode\x22\x0a\x09context interpreter\x0a\x09\x09node: sequenceNode;\x0a\x09\x09enterNode;\x0a\x09\x09proceed.\x0a\x09\x09\x0a\x09outerContext interpreter\x0a\x09\x09setNonLocalReturnFromContext: context.\x0a\x09\x09\x0a\x09^ context interpreter pop",
referencedClasses: [],
pragmas: [],
messageSends: ["newInnerContext", "parent:", "copy", "sequenceNode", "yourself", "do:", "temps", "defineLocal:", "withIndexDo:", "parameters", "localAt:put:", "at:ifAbsent:", "node:", "interpreter", "enterNode", "proceed", "setNonLocalReturnFromContext:", "pop"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
var context,sequenceNode;
return $core.withContext(function($ctx1) {
var $1,$2;
context=$recv($self.outerContext)._newInnerContext();
$1=$recv($recv($self.node)._sequenceNode())._copy();
$recv($1)._parent_(nil);
sequenceNode=$recv($1)._yourself();
$recv($recv(sequenceNode)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(context)._defineLocal_(each)
,$ctx2.sendIdx["defineLocal:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$recv($recv($self.node)._parameters())._withIndexDo_((function(each,index){
return $core.withContext(function($ctx2) {
$recv(context)._defineLocal_(each);
return $recv(context)._localAt_put_(each,$recv(aCollection)._at_ifAbsent_(index,(function(){
return nil;

})));
}, function($ctx2) {$ctx2.fillBlock({each:each,index:index},$ctx1,2)});
}));
$2=[$recv(context)._interpreter()
,$ctx1.sendIdx["interpreter"]=1
][0];
$recv($2)._node_(sequenceNode);
$recv($2)._enterNode();
$recv($2)._proceed();
$recv([$recv($self.outerContext)._interpreter()
,$ctx1.sendIdx["interpreter"]=2
][0])._setNonLocalReturnFromContext_(context);
return $recv($recv(context)._interpreter())._pop();
}, function($ctx1) {$ctx1.fill(self,"valueWithPossibleArguments:",{aCollection:aCollection,context:context,sequenceNode:sequenceNode})});
}; }),
$globals.AIBlockClosure);


$core.addMethod(
$core.method({
selector: "forContext:node:",
protocol: "instance creation",
args: ["aContext", "aNode"],
source: "forContext: aContext node: aNode\x0a\x09^ self new\x0a\x09\x09initializeWithContext: aContext node: aNode;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["initializeWithContext:node:", "new", "yourself"]
}, function ($methodClass){ return function (aContext,aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._initializeWithContext_node_(aContext,aNode);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"forContext:node:",{aContext:aContext,aNode:aNode})});
}; }),
$globals.AIBlockClosure.a$cls);


$core.addClass("AIContext", $globals.Object, "Compiler-Interpreter");
$core.setSlots($globals.AIContext, ["outerContext", "innerContext", "pc", "locals", "selector", "index", "sendIndexes", "evaluatedSelector", "ast", "interpreter", "supercall"]);
$globals.AIContext.comment="I am like a `MethodContext`, used by the `ASTInterpreter`.\x0aUnlike a `MethodContext`, my instances are not read-only.\x0a\x0aWhen debugging, my instances are created by copying the current `MethodContext` (thisContext)";
$core.addMethod(
$core.method({
selector: "arguments",
protocol: "interpreting",
args: [],
source: "arguments\x0a\x09^ self ast arguments collect: [ :each |\x0a\x09\x09self localAt: each ifAbsent: [ self error: 'Argument not in context' ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "arguments", "ast", "localAt:ifAbsent:", "error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._ast())._arguments())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $self._localAt_ifAbsent_(each,(function(){
return $core.withContext(function($ctx3) {
return $self._error_("Argument not in context");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"arguments",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "ast",
protocol: "interpreting",
args: [],
source: "ast\x0a\x09self isBlockContext ifTrue: [ \x0a\x09\x09^ self outerContext ifNotNil: [ :context | context ast ] ].\x0a\x0a\x09ast ifNil: [ self initializeAST ].\x0a\x09^ ast",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "isBlockContext", "ifNotNil:", "outerContext", "ast", "ifNil:", "initializeAST"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
if($core.assert($self._isBlockContext())){
$1=$self._outerContext();
if($1 == null || $1.a$nil){
return $1;
} else {
var context;
context=$1;
return $recv(context)._ast();
}
}
$2=$self.ast;
if($2 == null || $2.a$nil){
$self._initializeAST();
} else {
$2;
}
return $self.ast;
}, function($ctx1) {$ctx1.fill(self,"ast",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "basicLocalAt:",
protocol: "private",
args: ["aString"],
source: "basicLocalAt: aString\x0a\x09^ self locals at: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["at:", "locals"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._locals())._at_(aString);
}, function($ctx1) {$ctx1.fill(self,"basicLocalAt:",{aString:aString})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "basicLocalAt:put:",
protocol: "private",
args: ["aString", "anObject"],
source: "basicLocalAt: aString put: anObject\x0a\x09self locals at: aString put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "locals"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._locals())._at_put_(aString,anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"basicLocalAt:put:",{aString:aString,anObject:anObject})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "basicReceiver",
protocol: "interpreting",
args: [],
source: "basicReceiver\x0a\x09^ self localAt: 'self'",
referencedClasses: [],
pragmas: [],
messageSends: ["localAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._localAt_("self");
}, function($ctx1) {$ctx1.fill(self,"basicReceiver",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "defineLocal:",
protocol: "accessing",
args: ["aString"],
source: "defineLocal: aString\x0a\x09self locals at: aString put: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "locals"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._locals())._at_put_(aString,nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"defineLocal:",{aString:aString})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluate:on:",
protocol: "evaluating",
args: ["aString", "anEvaluator"],
source: "evaluate: aString on: anEvaluator\x0a\x09^ anEvaluator evaluate: aString context: self",
referencedClasses: [],
pragmas: [],
messageSends: ["evaluate:context:"]
}, function ($methodClass){ return function (aString,anEvaluator){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(anEvaluator)._evaluate_context_(aString,self);
}, function($ctx1) {$ctx1.fill(self,"evaluate:on:",{aString:aString,anEvaluator:anEvaluator})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluateNode:",
protocol: "evaluating",
args: ["aNode"],
source: "evaluateNode: aNode\x0a\x09^ ASTInterpreter new\x0a\x09\x09context: self;\x0a\x09\x09node: aNode;\x0a\x09\x09enterNode;\x0a\x09\x09proceed;\x0a\x09\x09result",
referencedClasses: ["ASTInterpreter"],
pragmas: [],
messageSends: ["context:", "new", "node:", "enterNode", "proceed", "result"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ASTInterpreter)._new();
$recv($1)._context_(self);
$recv($1)._node_(aNode);
$recv($1)._enterNode();
$recv($1)._proceed();
return $recv($1)._result();
}, function($ctx1) {$ctx1.fill(self,"evaluateNode:",{aNode:aNode})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluatedSelector",
protocol: "accessing",
args: [],
source: "evaluatedSelector\x0a\x09^ evaluatedSelector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.evaluatedSelector;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "evaluatedSelector:",
protocol: "accessing",
args: ["aString"],
source: "evaluatedSelector: aString\x0a\x09evaluatedSelector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.evaluatedSelector=aString;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "home",
protocol: "accessing",
args: [],
source: "home\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "index",
protocol: "accessing",
args: [],
source: "index\x0a\x09^ index ifNil: [ 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.index;
if($1 == null || $1.a$nil){
return (0);
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"index",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "index:",
protocol: "accessing",
args: ["anInteger"],
source: "index: anInteger\x0a\x09index := anInteger",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
$self.index=anInteger;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeAST",
protocol: "initialization",
args: [],
source: "initializeAST\x0a\x09ast := self method ast.\x0a\x09(SemanticAnalyzer on: self method origin)\x0a\x09\x09visit: ast",
referencedClasses: ["SemanticAnalyzer"],
pragmas: [],
messageSends: ["ast", "method", "visit:", "on:", "origin"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.ast=$recv([$self._method()
,$ctx1.sendIdx["method"]=1
][0])._ast();
$recv($recv($globals.SemanticAnalyzer)._on_($recv($self._method())._origin()))._visit_($self.ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeAST",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeFromMethodContext:",
protocol: "initialization",
args: ["aMethodContext"],
source: "initializeFromMethodContext: aMethodContext\x0a\x0a\x09self\x0a\x09\x09evaluatedSelector: aMethodContext evaluatedSelector;\x0a\x09\x09index: aMethodContext index;\x0a\x09\x09sendIndexes: aMethodContext sendIndexes;\x0a\x09\x09receiver: aMethodContext receiver;\x0a\x09\x09supercall: aMethodContext supercall;\x0a\x09\x09selector: aMethodContext selector.\x0a\x09\x09\x0a\x09aMethodContext outerContext ifNotNil: [ :outer |\x0a\x09\x09\x22If the method context is nil, the block was defined in JS, so ignore it\x22\x0a\x09\x09outer methodContext ifNotNil: [\x0a\x09\x09\x09self outerContext: (self class fromMethodContext: aMethodContext outerContext) ].\x0a\x09\x09\x09aMethodContext locals keysAndValuesDo: [ :key :value |\x0a\x09\x09\x09\x09self locals at: key put: value ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["evaluatedSelector:", "evaluatedSelector", "index:", "index", "sendIndexes:", "sendIndexes", "receiver:", "receiver", "supercall:", "supercall", "selector:", "selector", "ifNotNil:", "outerContext", "methodContext", "outerContext:", "fromMethodContext:", "class", "keysAndValuesDo:", "locals", "at:put:"]
}, function ($methodClass){ return function (aMethodContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self._evaluatedSelector_($recv(aMethodContext)._evaluatedSelector());
$self._index_($recv(aMethodContext)._index());
$self._sendIndexes_($recv(aMethodContext)._sendIndexes());
$self._receiver_($recv(aMethodContext)._receiver());
$self._supercall_($recv(aMethodContext)._supercall());
$self._selector_($recv(aMethodContext)._selector());
$1=[$recv(aMethodContext)._outerContext()
,$ctx1.sendIdx["outerContext"]=1
][0];
if($1 == null || $1.a$nil){
$1;
} else {
var outer;
outer=$1;
$2=$recv(outer)._methodContext();
if($2 == null || $2.a$nil){
$2;
} else {
$self._outerContext_($recv($self._class())._fromMethodContext_($recv(aMethodContext)._outerContext()));
}
$recv([$recv(aMethodContext)._locals()
,$ctx1.sendIdx["locals"]=1
][0])._keysAndValuesDo_((function(key,value){
return $core.withContext(function($ctx2) {
return $recv($self._locals())._at_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,3)});
}));
}
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeFromMethodContext:",{aMethodContext:aMethodContext})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeInterpreter",
protocol: "initialization",
args: [],
source: "initializeInterpreter\x0a\x09interpreter := ASTInterpreter new\x0a\x09\x09context: self;\x0a\x09\x09yourself.\x0a\x09\x0a\x09self innerContext ifNotNil: [\x0a\x09\x09self setupInterpreter: interpreter ]",
referencedClasses: ["ASTInterpreter"],
pragmas: [],
messageSends: ["context:", "new", "yourself", "ifNotNil:", "innerContext", "setupInterpreter:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.ASTInterpreter)._new();
$recv($1)._context_(self);
$self.interpreter=$recv($1)._yourself();
$2=$self._innerContext();
if($2 == null || $2.a$nil){
$2;
} else {
$self._setupInterpreter_($self.interpreter);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeInterpreter",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "initializeLocals",
protocol: "initialization",
args: [],
source: "initializeLocals\x0a\x09locals := Dictionary new.\x0a\x09locals at: 'thisContext' put: self.",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["new", "at:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.locals=$recv($globals.Dictionary)._new();
$recv($self.locals)._at_put_("thisContext",self);
return self;
}, function($ctx1) {$ctx1.fill(self,"initializeLocals",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "innerContext",
protocol: "accessing",
args: [],
source: "innerContext\x0a\x09^ innerContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.innerContext;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "innerContext:",
protocol: "accessing",
args: ["anAIContext"],
source: "innerContext: anAIContext\x0a\x09innerContext := anAIContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anAIContext){
var self=this,$self=this;
$self.innerContext=anAIContext;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "interpreter",
protocol: "interpreting",
args: [],
source: "interpreter\x0a\x09interpreter ifNil: [ self initializeInterpreter ].\x0a\x09^ interpreter",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "initializeInterpreter"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.interpreter;
if($1 == null || $1.a$nil){
$self._initializeInterpreter();
} else {
$1;
}
return $self.interpreter;
}, function($ctx1) {$ctx1.fill(self,"interpreter",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "interpreter:",
protocol: "interpreting",
args: ["anInterpreter"],
source: "interpreter: anInterpreter\x0a\x09interpreter := anInterpreter",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anInterpreter){
var self=this,$self=this;
$self.interpreter=anInterpreter;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "isTopContext",
protocol: "testing",
args: [],
source: "isTopContext\x0a\x09^ self innerContext isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["isNil", "innerContext"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._innerContext())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isTopContext",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "localAt:",
protocol: "accessing",
args: ["aString"],
source: "localAt: aString\x0a\x09\x22Lookup the local value up to the method context\x22\x0a\x0a\x09| context |\x0a\x09\x0a\x09context := self lookupContextForLocal: aString.\x0a\x09^ context basicLocalAt: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["lookupContextForLocal:", "basicLocalAt:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var context;
return $core.withContext(function($ctx1) {
context=$self._lookupContextForLocal_(aString);
return $recv(context)._basicLocalAt_(aString);
}, function($ctx1) {$ctx1.fill(self,"localAt:",{aString:aString,context:context})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "localAt:ifAbsent:",
protocol: "accessing",
args: ["aString", "aBlock"],
source: "localAt: aString ifAbsent: aBlock\x0a\x09\x22Lookup the local value up to the method context\x22\x0a\x0a\x09| context |\x0a\x09\x0a\x09context := self \x09\x0a\x09\x09lookupContextForLocal: aString \x0a\x09\x09ifNone: [ ^ aBlock value ].\x0a\x09\x0a\x09^ context basicLocalAt: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["lookupContextForLocal:ifNone:", "value", "basicLocalAt:"]
}, function ($methodClass){ return function (aString,aBlock){
var self=this,$self=this;
var context;
return $core.withContext(function($ctx1) {
var $early={};
try {
context=$self._lookupContextForLocal_ifNone_(aString,(function(){
return $core.withContext(function($ctx2) {
throw $early=[$recv(aBlock)._value()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return $recv(context)._basicLocalAt_(aString);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"localAt:ifAbsent:",{aString:aString,aBlock:aBlock,context:context})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "localAt:put:",
protocol: "accessing",
args: ["aString", "anObject"],
source: "localAt: aString put: anObject\x0a\x09| context |\x0a\x09\x0a\x09context := self lookupContextForLocal: aString.\x0a\x09context basicLocalAt: aString put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["lookupContextForLocal:", "basicLocalAt:put:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
var context;
return $core.withContext(function($ctx1) {
context=$self._lookupContextForLocal_(aString);
$recv(context)._basicLocalAt_put_(aString,anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"localAt:put:",{aString:aString,anObject:anObject,context:context})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "locals",
protocol: "accessing",
args: [],
source: "locals\x0a\x09locals ifNil: [ self initializeLocals ].\x0a\x09\x0a\x09^ locals",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "initializeLocals"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.locals;
if($1 == null || $1.a$nil){
$self._initializeLocals();
} else {
$1;
}
return $self.locals;
}, function($ctx1) {$ctx1.fill(self,"locals",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "lookupContextForLocal:",
protocol: "private",
args: ["aString"],
source: "lookupContextForLocal: aString\x0a\x09\x22Lookup the context defining the local named `aString` \x0a\x09up to the method context\x22\x0a\x0a\x09^ self \x0a\x09\x09lookupContextForLocal: aString \x0a\x09\x09ifNone: [ self variableNotFound ]",
referencedClasses: [],
pragmas: [],
messageSends: ["lookupContextForLocal:ifNone:", "variableNotFound"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._lookupContextForLocal_ifNone_(aString,(function(){
return $core.withContext(function($ctx2) {
return $self._variableNotFound();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"lookupContextForLocal:",{aString:aString})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "lookupContextForLocal:ifNone:",
protocol: "private",
args: ["aString", "aBlock"],
source: "lookupContextForLocal: aString ifNone: aBlock\x0a\x09\x22Lookup the context defining the local named `aString` \x0a\x09up to the method context\x22\x0a\x0a\x09^ self locals \x0a\x09\x09at: aString\x0a\x09\x09ifPresent: [ self ]\x0a\x09\x09ifAbsent: [ \x0a\x09\x09\x09self outerContext \x0a\x09\x09\x09\x09ifNil: aBlock\x0a\x09\x09\x09\x09ifNotNil: [ :context | \x0a\x09\x09\x09\x09\x09context lookupContextForLocal: aString ifNone: aBlock ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:", "locals", "ifNil:ifNotNil:", "outerContext", "lookupContextForLocal:ifNone:"]
}, function ($methodClass){ return function (aString,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
return $recv($self._locals())._at_ifPresent_ifAbsent_(aString,(function(){
return self;

}),(function(){
return $core.withContext(function($ctx2) {
$1=$self._outerContext();
return $recv($1)._ifNil_ifNotNil_(aBlock,(function(context){
return $core.withContext(function($ctx3) {
return $recv(context)._lookupContextForLocal_ifNone_(aString,aBlock);
}, function($ctx3) {$ctx3.fillBlock({context:context},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"lookupContextForLocal:ifNone:",{aString:aString,aBlock:aBlock})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "newInnerContext",
protocol: "factory",
args: [],
source: "newInnerContext\x0a\x09^ self class new\x0a\x09\x09outerContext: self;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["outerContext:", "new", "class", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($self._class())._new();
$recv($1)._outerContext_(self);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"newInnerContext",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "outerContext",
protocol: "accessing",
args: [],
source: "outerContext\x0a\x09^ outerContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.outerContext;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "outerContext:",
protocol: "accessing",
args: ["anAIContext"],
source: "outerContext: anAIContext\x0a\x09outerContext := anAIContext.\x0a\x09outerContext ifNotNil: [ :context | \x0a\x09\x09context innerContext: self ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "innerContext:"]
}, function ($methodClass){ return function (anAIContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.outerContext=anAIContext;
$1=$self.outerContext;
if($1 == null || $1.a$nil){
$1;
} else {
var context;
context=$1;
$recv(context)._innerContext_(self);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"outerContext:",{anAIContext:anAIContext})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "receiver:",
protocol: "interpreting",
args: ["anObject"],
source: "receiver: anObject\x0a\x09self locals at: 'self' put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "locals"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._locals())._at_put_("self",anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"receiver:",{anObject:anObject})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "sendIndexAt:",
protocol: "accessing",
args: ["aString"],
source: "sendIndexAt: aString\x0a\x09^ self sendIndexes at: aString ifAbsent: [ 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "sendIndexes"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._sendIndexes())._at_ifAbsent_(aString,(function(){
return (0);

}));
}, function($ctx1) {$ctx1.fill(self,"sendIndexAt:",{aString:aString})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "sendIndexes",
protocol: "accessing",
args: [],
source: "sendIndexes\x0a\x09^ sendIndexes ifNil: [ Dictionary new ]",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.sendIndexes;
if($1 == null || $1.a$nil){
return $recv($globals.Dictionary)._new();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"sendIndexes",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "sendIndexes:",
protocol: "accessing",
args: ["aDictionary"],
source: "sendIndexes: aDictionary\x0a\x09sendIndexes := aDictionary",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aDictionary){
var self=this,$self=this;
$self.sendIndexes=aDictionary;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "setupInterpreter:",
protocol: "interpreting",
args: ["anInterpreter"],
source: "setupInterpreter: anInterpreter\x0a\x09| currentNode |\x0a\x09\x0a\x09\x22Retrieve the current node\x22\x0a\x09currentNode := ASTPCNodeVisitor new\x0a\x09\x09\x09selector: self evaluatedSelector;\x0a\x09\x09\x09index: (self sendIndexAt: self evaluatedSelector);\x0a\x09\x09\x09visit: self ast;\x0a\x09\x09\x09currentNode.\x0a\x09\x0a\x09\x22Define locals for the context\x22\x0a\x09self ast sequenceNode ifNotNil: [ :sequence |\x0a\x09\x09sequence temps do: [ :each |\x0a\x09\x09\x09self defineLocal: each ] ].\x0a\x09\x0a\x09anInterpreter node: currentNode.\x0a\x0a\x09\x22Push the send args and receiver to the interpreter stack\x22\x09\x0a\x09self innerContext arguments reversed do: [ :each | \x0a\x09\x09anInterpreter push: each ].\x0a\x09\x09\x0a\x09anInterpreter push: (self innerContext receiver)",
referencedClasses: ["ASTPCNodeVisitor"],
pragmas: [],
messageSends: ["selector:", "new", "evaluatedSelector", "index:", "sendIndexAt:", "visit:", "ast", "currentNode", "ifNotNil:", "sequenceNode", "do:", "temps", "defineLocal:", "node:", "reversed", "arguments", "innerContext", "push:", "receiver"]
}, function ($methodClass){ return function (anInterpreter){
var self=this,$self=this;
var currentNode;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.ASTPCNodeVisitor)._new();
$recv($1)._selector_([$self._evaluatedSelector()
,$ctx1.sendIdx["evaluatedSelector"]=1
][0]);
$recv($1)._index_($self._sendIndexAt_($self._evaluatedSelector()));
$recv($1)._visit_([$self._ast()
,$ctx1.sendIdx["ast"]=1
][0]);
currentNode=$recv($1)._currentNode();
$2=$recv($self._ast())._sequenceNode();
if($2 == null || $2.a$nil){
$2;
} else {
var sequence;
sequence=$2;
[$recv($recv(sequence)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._defineLocal_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
}
$recv(anInterpreter)._node_(currentNode);
$recv($recv($recv([$self._innerContext()
,$ctx1.sendIdx["innerContext"]=1
][0])._arguments())._reversed())._do_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(anInterpreter)._push_(each)
,$ctx2.sendIdx["push:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
$recv(anInterpreter)._push_($recv($self._innerContext())._receiver());
return self;
}, function($ctx1) {$ctx1.fill(self,"setupInterpreter:",{anInterpreter:anInterpreter,currentNode:currentNode})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "supercall",
protocol: "interpreting",
args: [],
source: "supercall\x0a\x09^ supercall ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.supercall;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"supercall",{})});
}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "supercall:",
protocol: "interpreting",
args: ["aBoolean"],
source: "supercall: aBoolean\x0a\x09supercall := aBoolean",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
$self.supercall=aBoolean;
return self;

}; }),
$globals.AIContext);

$core.addMethod(
$core.method({
selector: "variableNotFound",
protocol: "error handling",
args: [],
source: "variableNotFound\x0a\x09\x22Error thrown whenever a variable lookup fails\x22\x0a\x09\x0a\x09self error: 'Variable missing'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Variable missing");
return self;
}, function($ctx1) {$ctx1.fill(self,"variableNotFound",{})});
}; }),
$globals.AIContext);


$core.addMethod(
$core.method({
selector: "fromMethodContext:",
protocol: "instance creation",
args: ["aMethodContext"],
source: "fromMethodContext: aMethodContext\x0a\x09^ self new\x0a\x09\x09initializeFromMethodContext: aMethodContext;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["initializeFromMethodContext:", "new", "yourself"]
}, function ($methodClass){ return function (aMethodContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._initializeFromMethodContext_(aMethodContext);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"fromMethodContext:",{aMethodContext:aMethodContext})});
}; }),
$globals.AIContext.a$cls);


$core.addClass("AISemanticAnalyzer", $globals.SemanticAnalyzer, "Compiler-Interpreter");
$core.setSlots($globals.AISemanticAnalyzer, ["context"]);
$globals.AISemanticAnalyzer.comment="I perform the same semantic analysis than `SemanticAnalyzer`, with the difference that provided an `AIContext` context, variables are bound with the context variables.";
$core.addMethod(
$core.method({
selector: "context",
protocol: "accessing",
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.context;

}; }),
$globals.AISemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "context:",
protocol: "accessing",
args: ["anAIContext"],
source: "context: anAIContext\x0a\x09context := anAIContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anAIContext){
var self=this,$self=this;
$self.context=anAIContext;
return self;

}; }),
$globals.AISemanticAnalyzer);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09self context \x0a\x09\x09localAt: aNode identifier \x0a\x09\x09ifAbsent: [ ^ super visitVariableNode: aNode ].\x0a\x0a\x09aNode binding: ASTContextVar new",
referencedClasses: ["ASTContextVar"],
pragmas: [],
messageSends: ["localAt:ifAbsent:", "context", "identifier", "visitVariableNode:", "binding:", "new"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv($self._context())._localAt_ifAbsent_($recv(aNode)._identifier(),(function(){
return $core.withContext(function($ctx2) {
throw $early=[[(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitVariableNode_.call($self,aNode))
,$ctx2.supercall = false
][0]];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
$recv(aNode)._binding_($recv($globals.ASTContextVar)._new());
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode})});
}; }),
$globals.AISemanticAnalyzer);



$core.addClass("ASTContextVar", $globals.ScopeVar, "Compiler-Interpreter");
$core.setSlots($globals.ASTContextVar, ["context"]);
$globals.ASTContextVar.comment="I am a variable defined in a `context`.";
$core.addMethod(
$core.method({
selector: "context",
protocol: "accessing",
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.context;

}; }),
$globals.ASTContextVar);

$core.addMethod(
$core.method({
selector: "context:",
protocol: "accessing",
args: ["anObject"],
source: "context: anObject\x0a\x09context := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.context=anObject;
return self;

}; }),
$globals.ASTContextVar);



$core.addClass("ASTDebugger", $globals.Object, "Compiler-Interpreter");
$core.setSlots($globals.ASTDebugger, ["interpreter", "context", "result"]);
$globals.ASTDebugger.comment="I am a stepping debugger interface for Amber code.\x0aI internally use an instance of `ASTInterpreter` to actually step through node and interpret them.\x0a\x0aMy instances are created from an `AIContext` with `ASTDebugger class >> context:`.\x0aThey hold an `AIContext` instance internally, recursive copy of the `MethodContext`.\x0a\x0a## API\x0a\x0aUse the methods of the `'stepping'` protocol to do stepping.";
$core.addMethod(
$core.method({
selector: "atEnd",
protocol: "testing",
args: [],
source: "atEnd\x09\x0a\x09self context ifNil: [ ^ true ].\x0a\x09\x0a\x09^ self interpreter atEnd and: [ \x0a\x09\x09self context isTopContext ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "context", "and:", "atEnd", "interpreter", "isTopContext"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._context()
,$ctx1.sendIdx["context"]=1
][0];
if($1 == null || $1.a$nil){
return true;
} else {
$1;
}
if($core.assert($recv($self._interpreter())._atEnd())){
return $recv($self._context())._isTopContext();
} else {
return false;
}
}, function($ctx1) {$ctx1.fill(self,"atEnd",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "context",
protocol: "accessing",
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.context;

}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "context:",
protocol: "accessing",
args: ["aContext"],
source: "context: aContext\x0a\x09context := aContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
$self.context=aContext;
return self;

}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "flushInnerContexts",
protocol: "actions",
args: [],
source: "flushInnerContexts\x0a\x09\x22When stepping, the inner contexts are not relevent anymore,\x0a\x09and can be flushed\x22\x0a\x09\x0a\x09self context ifNotNil: [ :cxt | \x0a\x09\x09cxt innerContext: nil ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "context", "innerContext:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._context();
if($1 == null || $1.a$nil){
$1;
} else {
var cxt;
cxt=$1;
$recv(cxt)._innerContext_(nil);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"flushInnerContexts",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "interpreter",
protocol: "accessing",
args: [],
source: "interpreter\x0a\x09^ self context ifNotNil: [ :ctx | \x0a\x09\x09ctx interpreter ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "context", "interpreter"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._context();
if($1 == null || $1.a$nil){
return $1;
} else {
var ctx;
ctx=$1;
return $recv(ctx)._interpreter();
}
}, function($ctx1) {$ctx1.fill(self,"interpreter",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "node",
protocol: "accessing",
args: [],
source: "node\x0a\x09^ self interpreter ifNotNil: [\x0a\x09\x09self interpreter node ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "interpreter", "node"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$self._interpreter()
,$ctx1.sendIdx["interpreter"]=1
][0];
if($1 == null || $1.a$nil){
return $1;
} else {
return $recv($self._interpreter())._node();
}
}, function($ctx1) {$ctx1.fill(self,"node",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "onStep",
protocol: "private",
args: [],
source: "onStep\x0a\x09\x22After each step, check if the interpreter is at the end,\x0a\x09and if it is move to its outer context if any, skipping its \x0a\x09current node (which was just evaluated by the current \x0a\x09interpreter).\x0a\x09\x0a\x09After each step we also flush inner contexts.\x22\x0a\x09\x0a\x09result := self interpreter result.\x0a\x09\x0a\x09self interpreter atEnd ifTrue: [\x0a\x09\x09self context outerContext ifNotNil: [ :outerContext | \x0a\x09\x09\x09self context: outerContext ].\x0a\x09\x09self interpreter atEnd ifFalse: [ self interpreter skip ] ].\x0a\x09\x09\x0a\x09self flushInnerContexts",
referencedClasses: [],
pragmas: [],
messageSends: ["result", "interpreter", "ifTrue:", "atEnd", "ifNotNil:", "outerContext", "context", "context:", "ifFalse:", "skip", "flushInnerContexts"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.result=$recv([$self._interpreter()
,$ctx1.sendIdx["interpreter"]=1
][0])._result();
if($core.assert([$recv([$self._interpreter()
,$ctx1.sendIdx["interpreter"]=2
][0])._atEnd()
,$ctx1.sendIdx["atEnd"]=1
][0])){
$1=$recv($self._context())._outerContext();
if($1 == null || $1.a$nil){
$1;
} else {
var outerContext;
outerContext=$1;
$self._context_(outerContext);
}
if(!$core.assert($recv([$self._interpreter()
,$ctx1.sendIdx["interpreter"]=3
][0])._atEnd())){
$recv($self._interpreter())._skip();
}
}
$self._flushInnerContexts();
return self;
}, function($ctx1) {$ctx1.fill(self,"onStep",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "proceed",
protocol: "stepping",
args: [],
source: "proceed\x0a\x09[ self atEnd ] whileFalse: [ self stepOver ]",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", "atEnd", "stepOver"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return $self._stepOver();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"proceed",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "restart",
protocol: "stepping",
args: [],
source: "restart\x0a\x09self interpreter restart.\x0a\x09self flushInnerContexts",
referencedClasses: [],
pragmas: [],
messageSends: ["restart", "interpreter", "flushInnerContexts"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._interpreter())._restart();
$self._flushInnerContexts();
return self;
}, function($ctx1) {$ctx1.fill(self,"restart",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "result",
protocol: "accessing",
args: [],
source: "result\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.result;

}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "stepInto",
protocol: "stepping",
args: [],
source: "stepInto\x0a\x09self shouldBeImplemented",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldBeImplemented"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldBeImplemented();
return self;
}, function($ctx1) {$ctx1.fill(self,"stepInto",{})});
}; }),
$globals.ASTDebugger);

$core.addMethod(
$core.method({
selector: "stepOver",
protocol: "stepping",
args: [],
source: "stepOver\x0a\x09self context isTopContext \x0a\x09\x09ifFalse: [ self interpreter skip ]\x0a\x09\x09ifTrue: [ self interpreter stepOver ].\x0a\x09self onStep",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:ifTrue:", "isTopContext", "context", "skip", "interpreter", "stepOver", "onStep"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self._context())._isTopContext())){
$recv($self._interpreter())._stepOver();
} else {
$recv([$self._interpreter()
,$ctx1.sendIdx["interpreter"]=1
][0])._skip();
}
$self._onStep();
return self;
}, function($ctx1) {$ctx1.fill(self,"stepOver",{})});
}; }),
$globals.ASTDebugger);


$core.addMethod(
$core.method({
selector: "context:",
protocol: "instance creation",
args: ["aContext"],
source: "context: aContext\x0a\x09^ self new\x0a\x09\x09context: aContext;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["context:", "new", "yourself"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._context_(aContext);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"context:",{aContext:aContext})});
}; }),
$globals.ASTDebugger.a$cls);


$core.addClass("ASTEnterNode", $globals.NodeVisitor, "Compiler-Interpreter");
$core.setSlots($globals.ASTEnterNode, ["interpreter"]);
$core.addMethod(
$core.method({
selector: "interpreter",
protocol: "accessing",
args: [],
source: "interpreter\x0a\x09^ interpreter",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.interpreter;

}; }),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "interpreter:",
protocol: "accessing",
args: ["anObject"],
source: "interpreter: anObject\x0a\x09interpreter := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.interpreter=anObject;
return self;

}; }),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09\x22Answer the node as we want to avoid eager evaluation\x22\x0a\x09\x0a\x09^ aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return aNode;

}; }),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "visitDagNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNode: aNode\x0a\x09^ aNode dagChildren\x0a\x09\x09ifEmpty: [ aNode ]\x0a\x09\x09ifNotEmpty: [ :nodes | self visit: nodes first ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifEmpty:ifNotEmpty:", "dagChildren", "visit:", "first"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aNode)._dagChildren())._ifEmpty_ifNotEmpty_((function(){
return aNode;

}),(function(nodes){
return $core.withContext(function($ctx2) {
return $self._visit_($recv(nodes)._first());
}, function($ctx2) {$ctx2.fillBlock({nodes:nodes},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"visitDagNode:",{aNode:aNode})});
}; }),
$globals.ASTEnterNode);

$core.addMethod(
$core.method({
selector: "visitSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSequenceNode: aNode\x0a\x09aNode temps do: [ :each |\x0a\x09\x09self interpreter context defineLocal: each ].\x0a\x09^ super visitSequenceNode: aNode",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "temps", "defineLocal:", "context", "interpreter", "visitSequenceNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aNode)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv($self._interpreter())._context())._defineLocal_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitSequenceNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
}, function($ctx1) {$ctx1.fill(self,"visitSequenceNode:",{aNode:aNode})});
}; }),
$globals.ASTEnterNode);


$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["anInterpreter"],
source: "on: anInterpreter\x0a\x09^ self new\x0a\x09\x09interpreter: anInterpreter;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["interpreter:", "new", "yourself"]
}, function ($methodClass){ return function (anInterpreter){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._interpreter_(anInterpreter);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"on:",{anInterpreter:anInterpreter})});
}; }),
$globals.ASTEnterNode.a$cls);


$core.addClass("ASTInterpreter", $globals.NodeVisitor, "Compiler-Interpreter");
$core.setSlots($globals.ASTInterpreter, ["node", "context", "stack", "returnValue", "returned", "forceAtEnd"]);
$globals.ASTInterpreter.comment="I visit an AST, interpreting (evaluating) nodes one after the other, using a small stack machine.\x0a\x0a## API\x0a\x0aWhile my instances should be used from within an `ASTDebugger`, which provides a more high level interface,\x0ayou can use methods from the `interpreting` protocol:\x0a\x0a- `#step` evaluates the current `node` only\x0a- `#stepOver` evaluates the AST from the current `node` up to the next stepping node (most likely the next send node)\x0a- `#proceed` evaluates eagerly the AST\x0a- `#restart` select the first node of the AST\x0a- `#skip` skips the current node, moving to the next one if any";
$core.addMethod(
$core.method({
selector: "assign:to:",
protocol: "private",
args: ["aNode", "anObject"],
source: "assign: aNode to: anObject\x0a\x09aNode binding inContext: self context put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["inContext:put:", "binding", "context"]
}, function ($methodClass){ return function (aNode,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aNode)._binding())._inContext_put_($self._context(),anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"assign:to:",{aNode:aNode,anObject:anObject})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "atEnd",
protocol: "testing",
args: [],
source: "atEnd\x0a\x09^ forceAtEnd or: [ self hasReturned or: [ self node isNil ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["or:", "hasReturned", "isNil", "node"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self.forceAtEnd)){
return true;
} else {
if($core.assert($self._hasReturned())){
return true;
} else {
return $recv($self._node())._isNil();
}
}
}, function($ctx1) {$ctx1.fill(self,"atEnd",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "context",
protocol: "accessing",
args: [],
source: "context\x0a\x09^ context",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.context;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "context:",
protocol: "accessing",
args: ["aContext"],
source: "context: aContext\x0a\x09context := aContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
$self.context=aContext;
return self;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "enterNode",
protocol: "interpreting",
args: [],
source: "enterNode\x0a\x09self node: ((ASTEnterNode on: self) visit: self node)",
referencedClasses: ["ASTEnterNode"],
pragmas: [],
messageSends: ["node:", "visit:", "on:", "node"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._node_($recv($recv($globals.ASTEnterNode)._on_(self))._visit_($self._node()));
return self;
}, function($ctx1) {$ctx1.fill(self,"enterNode",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: "private",
args: ["aString"],
source: "eval: aString\x0a\x09\x22Evaluate aString as JS source inside an JS function.\x0a\x09aString is not sandboxed.\x22\x0a\x09\x0a\x09| source function |\x0a\x09\x0a\x09source := String streamContents: [ :str |\x0a\x09\x09str nextPutAll: '0,(function('.\x0a\x09\x09self context locals keys\x0a\x09\x09\x09do: [ :each | str nextPutAll: each ]\x0a\x09\x09\x09separatedBy: [ str nextPutAll: ',' ].\x0a\x09\x09str\x0a\x09\x09\x09nextPutAll: '){ return (function() {';\x0a\x09\x09\x09nextPutAll: aString;\x0a\x09\x09\x09nextPutAll: '})()})' ].\x0a\x09\x09\x09\x0a\x09function := Compiler eval: source.\x0a\x09\x0a\x09^ function valueWithPossibleArguments: self context locals values",
referencedClasses: ["String", "Compiler"],
pragmas: [],
messageSends: ["streamContents:", "nextPutAll:", "do:separatedBy:", "keys", "locals", "context", "eval:", "valueWithPossibleArguments:", "values"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
var source,function_;
return $core.withContext(function($ctx1) {
source=$recv($globals.String)._streamContents_((function(str){
return $core.withContext(function($ctx2) {
[$recv(str)._nextPutAll_("0,(function(")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
$recv($recv([$recv([$self._context()
,$ctx2.sendIdx["context"]=1
][0])._locals()
,$ctx2.sendIdx["locals"]=1
][0])._keys())._do_separatedBy_((function(each){
return $core.withContext(function($ctx3) {
return [$recv(str)._nextPutAll_(each)
,$ctx3.sendIdx["nextPutAll:"]=2
][0];
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,2)});
}),(function(){
return $core.withContext(function($ctx3) {
return [$recv(str)._nextPutAll_(",")
,$ctx3.sendIdx["nextPutAll:"]=3
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}));
[$recv(str)._nextPutAll_("){ return (function() {")
,$ctx2.sendIdx["nextPutAll:"]=4
][0];
[$recv(str)._nextPutAll_(aString)
,$ctx2.sendIdx["nextPutAll:"]=5
][0];
return $recv(str)._nextPutAll_("})()})");
}, function($ctx2) {$ctx2.fillBlock({str:str},$ctx1,1)});
}));
function_=$recv($globals.Compiler)._eval_(source);
return $recv(function_)._valueWithPossibleArguments_($recv($recv($self._context())._locals())._values());
}, function($ctx1) {$ctx1.fill(self,"eval:",{aString:aString,source:source,function_:function_})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "hasReturned",
protocol: "testing",
args: [],
source: "hasReturned\x0a\x09^ returned ifNil: [ false ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.returned;
if($1 == null || $1.a$nil){
return false;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"hasReturned",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09forceAtEnd := false",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.forceAtEnd=false;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "interpret",
protocol: "interpreting",
args: [],
source: "interpret\x0a\x09\x22Interpret the next node to be evaluated\x22\x0a\x09\x0a\x09self visit: self node",
referencedClasses: [],
pragmas: [],
messageSends: ["visit:", "node"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._visit_($self._node());
return self;
}, function($ctx1) {$ctx1.fill(self,"interpret",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "messageFromSendNode:arguments:",
protocol: "private",
args: ["aSendNode", "anArray"],
source: "messageFromSendNode: aSendNode arguments: anArray\x0a\x09^ Message selector: aSendNode selector arguments: anArray",
referencedClasses: ["Message"],
pragmas: [],
messageSends: ["selector:arguments:", "selector"]
}, function ($methodClass){ return function (aSendNode,anArray){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.Message)._selector_arguments_($recv(aSendNode)._selector(),anArray);
}, function($ctx1) {$ctx1.fill(self,"messageFromSendNode:arguments:",{aSendNode:aSendNode,anArray:anArray})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "messageNotUnderstood:receiver:",
protocol: "private",
args: ["aMessage", "anObject"],
source: "messageNotUnderstood: aMessage receiver: anObject\x0a\x09MessageNotUnderstood new\x0a\x09\x09message: aMessage;\x0a\x09\x09receiver: anObject;\x0a\x09\x09signal",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["message:", "new", "receiver:", "signal"]
}, function ($methodClass){ return function (aMessage,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageNotUnderstood)._new();
$recv($1)._message_(aMessage);
$recv($1)._receiver_(anObject);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"messageNotUnderstood:receiver:",{aMessage:aMessage,anObject:anObject})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "next",
protocol: "interpreting",
args: [],
source: "next\x0a\x09| nd parent |\x0a\x09nd := self node.\x0a\x09parent := nd parent.\x0a\x09(parent ifNotNil: [ parent nextSiblingNode: nd ])\x0a\x09\x09ifNil: [ self node: parent ]\x0a\x09\x09ifNotNil: [ :sibling | self node: sibling; enterNode ]",
referencedClasses: [],
pragmas: [],
messageSends: ["node", "parent", "ifNil:ifNotNil:", "ifNotNil:", "nextSiblingNode:", "node:", "enterNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var nd,parent;
return $core.withContext(function($ctx1) {
var $1,$2;
nd=$self._node();
parent=$recv(nd)._parent();
$1=parent;
if($1 == null || $1.a$nil){
$2=$1;
} else {
$2=$recv(parent)._nextSiblingNode_(nd);
}
if($2 == null || $2.a$nil){
[$self._node_(parent)
,$ctx1.sendIdx["node:"]=1
][0];
} else {
var sibling;
sibling=$2;
$self._node_(sibling);
$self._enterNode();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"next",{nd:nd,parent:parent})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "node",
protocol: "accessing",
args: [],
source: "node\x0a\x09\x22Answer the next node, ie the node to be evaluated in the next step\x22\x0a\x09\x0a\x09^ node",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.node;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "node:",
protocol: "accessing",
args: ["aNode"],
source: "node: aNode\x0a\x09node := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.node=aNode;
return self;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "peek",
protocol: "stack",
args: [],
source: "peek\x0a\x09\x22Peek the top object of the context stack\x22\x0a\x09\x0a\x09self stack ifEmpty: [ ^ nil ].\x0a\x09\x0a\x09^ self stack last",
referencedClasses: [],
pragmas: [],
messageSends: ["ifEmpty:", "stack", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv([$self._stack()
,$ctx1.sendIdx["stack"]=1
][0])._ifEmpty_((function(){
throw $early=[nil];

}));
return $recv($self._stack())._last();
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"peek",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "pop",
protocol: "stack",
args: [],
source: "pop\x0a\x09\x22Pop an object from the context stack\x22\x0a\x09\x0a\x09| peekedValue |\x0a\x09\x0a\x09peekedValue := self peek.\x0a\x09self stack removeLast.\x0a\x09^ peekedValue",
referencedClasses: [],
pragmas: [],
messageSends: ["peek", "removeLast", "stack"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var peekedValue;
return $core.withContext(function($ctx1) {
peekedValue=$self._peek();
$recv($self._stack())._removeLast();
return peekedValue;
}, function($ctx1) {$ctx1.fill(self,"pop",{peekedValue:peekedValue})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "proceed",
protocol: "interpreting",
args: [],
source: "proceed\x0a\x09\x22Eagerly evaluate the ast\x22\x0a\x09\x0a\x09[ self atEnd ] \x0a\x09\x09whileFalse: [ self step ]",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", "atEnd", "step"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._atEnd();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return $self._step();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"proceed",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "push:",
protocol: "stack",
args: ["anObject"],
source: "push: anObject\x0a\x09\x22Push an object to the context stack\x22\x0a\x09\x0a\x09^ self stack add: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "stack"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._stack())._add_(anObject);
}, function($ctx1) {$ctx1.fill(self,"push:",{anObject:anObject})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "restart",
protocol: "interpreting",
args: [],
source: "restart\x0a\x09self node: self context ast; enterNode",
referencedClasses: [],
pragmas: [],
messageSends: ["node:", "ast", "context", "enterNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._node_($recv($self._context())._ast());
$self._enterNode();
return self;
}, function($ctx1) {$ctx1.fill(self,"restart",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "result",
protocol: "accessing",
args: [],
source: "result\x0a\x09^ self hasReturned \x0a\x09\x09ifTrue: [ self returnValue ] \x0a\x09\x09ifFalse: [ self context receiver ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "hasReturned", "returnValue", "receiver", "context"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._hasReturned())){
return $self._returnValue();
} else {
return $recv($self._context())._receiver();
}
}, function($ctx1) {$ctx1.fill(self,"result",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "returnValue",
protocol: "accessing",
args: [],
source: "returnValue\x0a\x09^ returnValue",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.returnValue;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "returnValue:",
protocol: "accessing",
args: ["anObject"],
source: "returnValue: anObject\x0a\x09returnValue := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.returnValue=anObject;
return self;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "sendJavaScript:superMessage:switcher:to:",
protocol: "private",
args: ["aString", "aMessage", "aJSFunction", "anObject"],
source: "sendJavaScript: aString superMessage: aMessage switcher: aJSFunction to: anObject\x0a\x09| methodBlock parent |\x0a\x09\x0a\x09parent := self context method methodClass superPrototype.\x0a\x09parent ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x0a\x09methodBlock := (parent at: aString)\x0a\x09\x09ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x09\x0a\x09^ methodBlock applyTo: anObject arguments: (aJSFunction applyTo: nil arguments: aMessage arguments)",
referencedClasses: [],
pragmas: [],
messageSends: ["superPrototype", "methodClass", "method", "context", "ifNil:", "messageNotUnderstood:receiver:", "at:", "applyTo:arguments:", "arguments"]
}, function ($methodClass){ return function (aString,aMessage,aJSFunction,anObject){
var self=this,$self=this;
var methodBlock,parent;
return $core.withContext(function($ctx1) {
var $1,$2;
parent=$recv($recv($recv($self._context())._method())._methodClass())._superPrototype();
$1=parent;
if($1 == null || $1.a$nil){
return [$self._messageNotUnderstood_receiver_(aMessage,anObject)
,$ctx1.sendIdx["messageNotUnderstood:receiver:"]=1
][0];
} else {
$1;
}
$2=$recv(parent)._at_(aString);
if($2 == null || $2.a$nil){
return $self._messageNotUnderstood_receiver_(aMessage,anObject);
} else {
methodBlock=$2;
}
return [$recv(methodBlock)._applyTo_arguments_(anObject,$recv(aJSFunction)._applyTo_arguments_(nil,$recv(aMessage)._arguments()))
,$ctx1.sendIdx["applyTo:arguments:"]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"sendJavaScript:superMessage:switcher:to:",{aString:aString,aMessage:aMessage,aJSFunction:aJSFunction,anObject:anObject,methodBlock:methodBlock,parent:parent})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "sendJavaScript:superMessage:to:",
protocol: "private",
args: ["aString", "aMessage", "anObject"],
source: "sendJavaScript: aString superMessage: aMessage to: anObject\x0a\x09| methodBlock parent |\x0a\x09\x0a\x09parent := self context method methodClass superPrototype.\x0a\x09parent ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x0a\x09methodBlock := (parent at: aString)\x0a\x09\x09ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x09\x0a\x09^ methodBlock applyTo: anObject arguments: aMessage arguments",
referencedClasses: [],
pragmas: [],
messageSends: ["superPrototype", "methodClass", "method", "context", "ifNil:", "messageNotUnderstood:receiver:", "at:", "applyTo:arguments:", "arguments"]
}, function ($methodClass){ return function (aString,aMessage,anObject){
var self=this,$self=this;
var methodBlock,parent;
return $core.withContext(function($ctx1) {
var $1,$2;
parent=$recv($recv($recv($self._context())._method())._methodClass())._superPrototype();
$1=parent;
if($1 == null || $1.a$nil){
return [$self._messageNotUnderstood_receiver_(aMessage,anObject)
,$ctx1.sendIdx["messageNotUnderstood:receiver:"]=1
][0];
} else {
$1;
}
$2=$recv(parent)._at_(aString);
if($2 == null || $2.a$nil){
return $self._messageNotUnderstood_receiver_(aMessage,anObject);
} else {
methodBlock=$2;
}
return $recv(methodBlock)._applyTo_arguments_(anObject,$recv(aMessage)._arguments());
}, function($ctx1) {$ctx1.fill(self,"sendJavaScript:superMessage:to:",{aString:aString,aMessage:aMessage,anObject:anObject,methodBlock:methodBlock,parent:parent})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "sendSuperMessage:to:",
protocol: "private",
args: ["aMessage", "anObject"],
source: "sendSuperMessage: aMessage to: anObject\x0a\x09| method parent |\x0a\x09\x0a\x09parent := self context method methodClass superclass.\x0a\x09parent ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x0a\x09method := (parent lookupSelector: aMessage selector)\x0a\x09\x09ifNil: [ ^ self messageNotUnderstood: aMessage receiver: anObject ].\x0a\x09\x09\x0a\x09^ method sendTo: anObject arguments: aMessage arguments",
referencedClasses: [],
pragmas: [],
messageSends: ["superclass", "methodClass", "method", "context", "ifNil:", "messageNotUnderstood:receiver:", "lookupSelector:", "selector", "sendTo:arguments:", "arguments"]
}, function ($methodClass){ return function (aMessage,anObject){
var self=this,$self=this;
var method,parent;
return $core.withContext(function($ctx1) {
var $1,$2;
parent=$recv($recv($recv($self._context())._method())._methodClass())._superclass();
$1=parent;
if($1 == null || $1.a$nil){
return [$self._messageNotUnderstood_receiver_(aMessage,anObject)
,$ctx1.sendIdx["messageNotUnderstood:receiver:"]=1
][0];
} else {
$1;
}
$2=$recv(parent)._lookupSelector_($recv(aMessage)._selector());
if($2 == null || $2.a$nil){
return $self._messageNotUnderstood_receiver_(aMessage,anObject);
} else {
method=$2;
}
return $recv(method)._sendTo_arguments_(anObject,$recv(aMessage)._arguments());
}, function($ctx1) {$ctx1.fill(self,"sendSuperMessage:to:",{aMessage:aMessage,anObject:anObject,method:method,parent:parent})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "setNonLocalReturnFromContext:",
protocol: "interpreting",
args: ["aContext"],
source: "setNonLocalReturnFromContext: aContext\x0a\x09aContext interpreter hasReturned ifTrue: [\x0a\x09\x09returned := true.\x0a\x09\x09self returnValue: aContext interpreter returnValue ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "hasReturned", "interpreter", "returnValue:", "returnValue"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv([$recv(aContext)._interpreter()
,$ctx1.sendIdx["interpreter"]=1
][0])._hasReturned())){
$self.returned=true;
$self._returnValue_($recv($recv(aContext)._interpreter())._returnValue());
}
return self;
}, function($ctx1) {$ctx1.fill(self,"setNonLocalReturnFromContext:",{aContext:aContext})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "skip",
protocol: "interpreting",
args: [],
source: "skip\x0a\x09self next",
referencedClasses: [],
pragmas: [],
messageSends: ["next"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._next();
return self;
}, function($ctx1) {$ctx1.fill(self,"skip",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "stack",
protocol: "accessing",
args: [],
source: "stack\x0a\x09^ stack ifNil: [ stack := OrderedCollection new ]",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["ifNil:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.stack;
if($1 == null || $1.a$nil){
$self.stack=$recv($globals.OrderedCollection)._new();
return $self.stack;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"stack",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "step",
protocol: "interpreting",
args: [],
source: "step\x0a\x09self \x0a\x09\x09interpret; \x0a\x09\x09next",
referencedClasses: [],
pragmas: [],
messageSends: ["interpret", "next"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._interpret();
$self._next();
return self;
}, function($ctx1) {$ctx1.fill(self,"step",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "stepOver",
protocol: "interpreting",
args: [],
source: "stepOver\x0a\x09self step.\x0a\x09\x0a\x09[ self node isNil or: [ self node isSteppingNode ] ] whileFalse: [ \x0a\x09\x09self step ]",
referencedClasses: [],
pragmas: [],
messageSends: ["step", "whileFalse:", "or:", "isNil", "node", "isSteppingNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._step()
,$ctx1.sendIdx["step"]=1
][0];
$recv((function(){
return $core.withContext(function($ctx2) {
if($core.assert($recv([$self._node()
,$ctx2.sendIdx["node"]=1
][0])._isNil())){
return true;
} else {
return $recv($self._node())._isSteppingNode();
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
return $self._step();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"stepOver",{})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visit:",
protocol: "visiting",
args: ["aNode"],
source: "visit: aNode\x0a\x09self hasReturned ifFalse: [ super visit: aNode ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "hasReturned", "visit:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($self._hasReturned())){
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visit_.call($self,aNode))
,$ctx1.supercall = false
][0];
}
return self;
}, function($ctx1) {$ctx1.fill(self,"visit:",{aNode:aNode})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitAssignmentNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitAssignmentNode: aNode\x0a\x09| poppedValue |\x0a\x09\x0a\x09poppedValue := self pop.\x0a\x09\x0a\x09\x22Pop the left side of the assignment.\x0a\x09It already has been visited, and we don't need its value.\x22\x0a\x09self pop.\x0a\x09\x0a\x09self push: poppedValue.\x0a\x09self assign: aNode left to: poppedValue",
referencedClasses: [],
pragmas: [],
messageSends: ["pop", "push:", "assign:to:", "left"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var poppedValue;
return $core.withContext(function($ctx1) {
poppedValue=[$self._pop()
,$ctx1.sendIdx["pop"]=1
][0];
$self._pop();
$self._push_(poppedValue);
$self._assign_to_($recv(aNode)._left(),poppedValue);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitAssignmentNode:",{aNode:aNode,poppedValue:poppedValue})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitBlockNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockNode: aNode\x0a\x09\x22Do not evaluate the block node.\x0a\x09Instead, put all instructions into a block that we push to the stack for later evaluation\x22\x0a\x09\x0a\x09| block |\x0a\x09\x0a\x09block := AIBlockClosure forContext: self context node: aNode.\x0a\x09\x0a\x09self push: block",
referencedClasses: ["AIBlockClosure"],
pragmas: [],
messageSends: ["forContext:node:", "context", "push:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var block;
return $core.withContext(function($ctx1) {
block=$recv($globals.AIBlockClosure)._forContext_node_($self._context(),aNode);
$self._push_(block);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitBlockNode:",{aNode:aNode,block:block})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitBlockSequenceNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitBlockSequenceNode: aNode\x0a\x09\x22If the receiver is actually visiting a BlockSequenceNode,\x0a\x09it means the the context is a block context. Evaluation should \x0a\x09stop right after evaluating the block sequence and the outer\x0a\x09context's interpreter should take over. \x0a\x09Therefore we force #atEnd.\x22\x0a\x09\x0a\x09super visitBlockSequenceNode: aNode.\x0a\x09forceAtEnd := true",
referencedClasses: [],
pragmas: [],
messageSends: ["visitBlockSequenceNode:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitBlockSequenceNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
$self.forceAtEnd=true;
return self;
}, function($ctx1) {$ctx1.fill(self,"visitBlockSequenceNode:",{aNode:aNode})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitDagNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDagNode: aNode\x0a\x09\x22Do nothing by default. Especially, do not visit children recursively.\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return self;

}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitDynamicArrayNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDynamicArrayNode: aNode\x0a\x09| array |\x0a\x09\x0a\x09array := #().\x0a\x09aNode dagChildren do: [ :each |\x0a\x09\x09array addFirst: self pop ].\x0a\x09\x0a\x09self push: array",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "dagChildren", "addFirst:", "pop", "push:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=[];
$recv($recv(aNode)._dagChildren())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(array)._addFirst_($self._pop());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._push_(array);
return self;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicArrayNode:",{aNode:aNode,array:array})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitDynamicDictionaryNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitDynamicDictionaryNode: aNode\x0a\x09| keyValueList |\x0a\x09\x0a\x09keyValueList := OrderedCollection new.\x0a\x09\x0a\x09aNode dagChildren do: [ :each | \x0a\x09\x09keyValueList add: self pop ].\x0a\x09\x0a\x09self push: (HashedCollection newFromPairs: keyValueList reversed)",
referencedClasses: ["OrderedCollection", "HashedCollection"],
pragmas: [],
messageSends: ["new", "do:", "dagChildren", "add:", "pop", "push:", "newFromPairs:", "reversed"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var keyValueList;
return $core.withContext(function($ctx1) {
keyValueList=$recv($globals.OrderedCollection)._new();
$recv($recv(aNode)._dagChildren())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(keyValueList)._add_($self._pop());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._push_($recv($globals.HashedCollection)._newFromPairs_($recv(keyValueList)._reversed()));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitDynamicDictionaryNode:",{aNode:aNode,keyValueList:keyValueList})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09returned := true.\x0a\x09self returnValue: (self eval: aNode source)",
referencedClasses: [],
pragmas: [],
messageSends: ["returnValue:", "eval:", "source"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.returned=true;
$self._returnValue_($self._eval_($recv(aNode)._source()));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitJSStatementNode:",{aNode:aNode})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitReturnNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitReturnNode: aNode\x0a\x09returned := true.\x0a\x09self returnValue: self pop",
referencedClasses: [],
pragmas: [],
messageSends: ["returnValue:", "pop"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.returned=true;
$self._returnValue_($self._pop());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitReturnNode:",{aNode:aNode})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09| receiver args message result |\x0a\x09\x0a\x09args := aNode arguments collect: [ :each | self pop ].\x0a\x09receiver := self peek.\x0a\x09\x0a\x09message := self\x0a\x09\x09messageFromSendNode: aNode\x0a\x09\x09arguments: args reversed.\x0a\x09\x0a\x09result := aNode superSend\x0a\x09\x09ifFalse: [ message sendTo: receiver ]\x0a\x09\x09ifTrue: [ aNode receiver binding isJavaScriptSuper\x0a\x09\x09\x09ifFalse: [ self sendSuperMessage: message to: receiver ]\x0a\x09\x09\x09ifTrue: [ aNode argumentSwitcher\x0a\x09\x09\x09\x09ifNil: [ self sendJavaScript: aNode javaScriptSelector superMessage: message to: receiver ]\x0a\x09\x09\x09\x09ifNotNil: [ :switcher | self sendJavaScript: aNode javaScriptSelector superMessage: message switcher: switcher to: receiver ] ] ].\x0a\x09\x0a\x09\x22For cascade sends, push the reciever if the send is not the last one\x22\x0a\x09aNode isSideEffect ifFalse: [ self pop; push: result ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "arguments", "pop", "peek", "messageFromSendNode:arguments:", "reversed", "ifFalse:ifTrue:", "superSend", "sendTo:", "isJavaScriptSuper", "binding", "receiver", "sendSuperMessage:to:", "ifNil:ifNotNil:", "argumentSwitcher", "sendJavaScript:superMessage:to:", "javaScriptSelector", "sendJavaScript:superMessage:switcher:to:", "ifFalse:", "isSideEffect", "push:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
var receiver,args,message,result;
return $core.withContext(function($ctx1) {
var $1;
args=$recv($recv(aNode)._arguments())._collect_((function(each){
return $core.withContext(function($ctx2) {
return [$self._pop()
,$ctx2.sendIdx["pop"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
receiver=$self._peek();
message=$self._messageFromSendNode_arguments_(aNode,$recv(args)._reversed());
if($core.assert($recv(aNode)._superSend())){
if($core.assert($recv($recv($recv(aNode)._receiver())._binding())._isJavaScriptSuper())){
$1=$recv(aNode)._argumentSwitcher();
if($1 == null || $1.a$nil){
result=$self._sendJavaScript_superMessage_to_([$recv(aNode)._javaScriptSelector()
,$ctx1.sendIdx["javaScriptSelector"]=1
][0],message,receiver);
} else {
var switcher;
switcher=$1;
result=$self._sendJavaScript_superMessage_switcher_to_($recv(aNode)._javaScriptSelector(),message,switcher,receiver);
}
} else {
result=$self._sendSuperMessage_to_(message,receiver);
}
} else {
result=$recv(message)._sendTo_(receiver);
}
if(!$core.assert($recv(aNode)._isSideEffect())){
$self._pop();
$self._push_(result);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode,receiver:receiver,args:args,message:message,result:result})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitValueNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitValueNode: aNode\x0a\x09self push: aNode value",
referencedClasses: [],
pragmas: [],
messageSends: ["push:", "value"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._push_($recv(aNode)._value());
return self;
}, function($ctx1) {$ctx1.fill(self,"visitValueNode:",{aNode:aNode})});
}; }),
$globals.ASTInterpreter);

$core.addMethod(
$core.method({
selector: "visitVariableNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitVariableNode: aNode\x0a\x09self push: (aNode binding inContext: self context)",
referencedClasses: [],
pragmas: [],
messageSends: ["push:", "inContext:", "binding", "context"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._push_($recv($recv(aNode)._binding())._inContext_($self._context()));
return self;
}, function($ctx1) {$ctx1.fill(self,"visitVariableNode:",{aNode:aNode})});
}; }),
$globals.ASTInterpreter);



$core.addClass("ASTInterpreterError", $globals.Error, "Compiler-Interpreter");
$globals.ASTInterpreterError.comment="I get signaled when an AST interpreter is unable to interpret a node.";


$core.addClass("ASTPCNodeVisitor", $globals.NodeVisitor, "Compiler-Interpreter");
$core.setSlots($globals.ASTPCNodeVisitor, ["index", "trackedIndex", "selector", "currentNode"]);
$globals.ASTPCNodeVisitor.comment="I visit an AST until I get to the current node for the `context` and answer it.\x0a\x0a## API\x0a\x0aMy instances must be filled with a context object using `#context:`.\x0a\x0aAfter visiting the AST the current node is answered by `#currentNode`";
$core.addMethod(
$core.method({
selector: "currentNode",
protocol: "accessing",
args: [],
source: "currentNode\x0a\x09^ currentNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.currentNode;

}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "increaseTrackedIndex",
protocol: "accessing",
args: [],
source: "increaseTrackedIndex\x0a\x09trackedIndex := self trackedIndex + 1",
referencedClasses: [],
pragmas: [],
messageSends: ["+", "trackedIndex"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.trackedIndex=$recv($self._trackedIndex()).__plus((1));
return self;
}, function($ctx1) {$ctx1.fill(self,"increaseTrackedIndex",{})});
}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "index",
protocol: "accessing",
args: [],
source: "index\x0a\x09^ index",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.index;

}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "index:",
protocol: "accessing",
args: ["aNumber"],
source: "index: aNumber\x0a\x09index := aNumber",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
$self.index=aNumber;
return self;

}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.selector;

}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aString"],
source: "selector: aString\x0a\x09selector := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.selector=aString;
return self;

}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "trackedIndex",
protocol: "accessing",
args: [],
source: "trackedIndex\x0a\x09^ trackedIndex ifNil: [ trackedIndex := 0 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.trackedIndex;
if($1 == null || $1.a$nil){
$self.trackedIndex=(0);
return $self.trackedIndex;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"trackedIndex",{})});
}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "visitJSStatementNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitJSStatementNode: aNode\x0a\x09\x22If a JSStatementNode is encountered, it always is the current node.\x0a\x09Stop visiting the AST there\x22\x0a\x09\x0a\x09currentNode := aNode",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
$self.currentNode=aNode;
return self;

}; }),
$globals.ASTPCNodeVisitor);

$core.addMethod(
$core.method({
selector: "visitSendNode:",
protocol: "visiting",
args: ["aNode"],
source: "visitSendNode: aNode\x0a\x09super visitSendNode: aNode.\x0a\x09\x0a\x09self selector = aNode selector ifTrue: [\x0a\x09\x09self trackedIndex = self index ifTrue: [ currentNode := aNode ].\x0a\x09\x09self increaseTrackedIndex ]",
referencedClasses: [],
pragmas: [],
messageSends: ["visitSendNode:", "ifTrue:", "=", "selector", "trackedIndex", "index", "increaseTrackedIndex"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._visitSendNode_.call($self,aNode))
,$ctx1.supercall = false
][0];
if($core.assert([$recv([$self._selector()
,$ctx1.sendIdx["selector"]=1
][0]).__eq($recv(aNode)._selector())
,$ctx1.sendIdx["="]=1
][0])){
if($core.assert($recv($self._trackedIndex()).__eq($self._index()))){
$self.currentNode=aNode;
$self.currentNode;
}
$self._increaseTrackedIndex();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"visitSendNode:",{aNode:aNode})});
}; }),
$globals.ASTPCNodeVisitor);


$core.setTraitComposition([{trait: $globals.TMethodContext}], $globals.AIContext);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "nextSiblingNode:",
protocol: "*Compiler-Interpreter",
args: ["aNode"],
source: "nextSiblingNode: aNode\x0a\x09\x22Answer the next node after aNode or nil\x22\x0a\x09\x0a\x09^ self dagChildren \x0a\x09\x09at: (self dagChildren indexOf: aNode) + 1\x0a\x09\x09ifAbsent: [ nil ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "dagChildren", "+", "indexOf:"]
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$self._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._at_ifAbsent_($recv($recv($self._dagChildren())._indexOf_(aNode)).__plus((1)),(function(){
return nil;

}));
}, function($ctx1) {$ctx1.fill(self,"nextSiblingNode:",{aNode:aNode})});
}; }),
$globals.ASTNode);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09self error: 'Alias variable is internal, it should never appear in normal variable context.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Alias variable is internal, it should never appear in normal variable context.");
return self;
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.AliasVar);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.AssignmentNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "nextSiblingNode:",
protocol: "*Compiler-Interpreter",
args: ["aNode"],
source: "nextSiblingNode: aNode\x0a\x09\x22Answer nil as we want to avoid eager evaluation\x22\x0a\x09\x0a\x09\x22In fact, this should not have been called, ever. IMO. -- herby\x22\x0a\x09\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNode){
var self=this,$self=this;
return nil;

}; }),
$globals.BlockNode);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09^ Smalltalk globals \x0a\x09\x09at: self name \x0a\x09\x09ifAbsent: [ Platform globals at: self name ]",
referencedClasses: ["Smalltalk", "Platform"],
pragmas: [],
messageSends: ["at:ifAbsent:", "globals", "name", "at:"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$recv($globals.Smalltalk)._globals()
,$ctx1.sendIdx["globals"]=1
][0])._at_ifAbsent_([$self._name()
,$ctx1.sendIdx["name"]=1
][0],(function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Platform)._globals())._at_($self._name());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.ClassRefVar);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.DynamicArrayNode);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.DynamicDictionaryNode);

$core.addMethod(
$core.method({
selector: "evaluate:context:",
protocol: "*Compiler-Interpreter",
args: ["aString", "aContext"],
source: "evaluate: aString context: aContext\x0a\x09\x22Similar to #evaluate:for:, with the following differences:\x0a\x09- instead of compiling and running `aString`, `aString` is interpreted using an `ASTInterpreter`\x0a\x09- instead of evaluating against a receiver, evaluate in the context of `aContext`\x22\x0a\x0a\x09| compiler ast |\x0a\x09\x0a\x09compiler := Compiler new.\x0a\x09[ ast := compiler parseExpression: aString ] \x0a\x09\x09on: Error \x0a\x09\x09do: [ :ex | ^ Terminal alert: ex messageText ].\x0a\x09\x09\x0a\x09(AISemanticAnalyzer on: aContext receiver class)\x0a\x09\x09context: aContext;\x0a\x09\x09visit: ast.\x0a\x0a\x09^ aContext evaluateNode: ast",
referencedClasses: ["Compiler", "Error", "Terminal", "AISemanticAnalyzer"],
pragmas: [],
messageSends: ["new", "on:do:", "parseExpression:", "alert:", "messageText", "context:", "on:", "class", "receiver", "visit:", "evaluateNode:"]
}, function ($methodClass){ return function (aString,aContext){
var self=this,$self=this;
var compiler,ast;
return $core.withContext(function($ctx1) {
var $1;
var $early={};
try {
compiler=$recv($globals.Compiler)._new();
$recv((function(){
return $core.withContext(function($ctx2) {
ast=$recv(compiler)._parseExpression_(aString);
return ast;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
throw $early=[$recv($globals.Terminal)._alert_($recv(ex)._messageText())];
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,2)});
}));
$1=$recv($globals.AISemanticAnalyzer)._on_($recv($recv(aContext)._receiver())._class());
$recv($1)._context_(aContext);
$recv($1)._visit_(ast);
return $recv(aContext)._evaluateNode_(ast);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"evaluate:context:",{aString:aString,aContext:aContext,compiler:compiler,ast:ast})});
}; }),
$globals.Evaluator);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09^ Platform globals at: self name ifAbsent: [ self error: 'Unknown variable' ]",
referencedClasses: ["Platform"],
pragmas: [],
messageSends: ["at:ifAbsent:", "globals", "name", "error:"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Platform)._globals())._at_ifAbsent_($self._name(),(function(){
return $core.withContext(function($ctx2) {
return $self._error_("Unknown variable");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.ExternallyKnownVar);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.JSStatementNode);

$core.addMethod(
$core.method({
selector: "isJavaScriptSuper",
protocol: "*Compiler-Interpreter",
args: [],
source: "isJavaScriptSuper\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.JavaScriptSuperVar);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09^ #{'nil'->nil. 'true'->true. 'false'->false}\x0a\x09\x09at: self name\x0a\x09\x09ifAbsent: [ super inContext: aContext ]",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "name", "inContext:"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.HashedCollection._newFromPairs_(["nil",nil,"true",true,"false",false]))._at_ifAbsent_($self._name(),(function(){
return $core.withContext(function($ctx2) {
return [(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._inContext_.call($self,aContext))
,$ctx2.supercall = false
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.PseudoVar);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09^ aContext localAt: self name",
referencedClasses: [],
pragmas: [],
messageSends: ["localAt:", "name"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aContext)._localAt_($self._name());
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "inContext:put:",
protocol: "*Compiler-Interpreter",
args: ["aContext", "anObject"],
source: "inContext: aContext put: anObject\x0a\x09self error: 'Non-assignable variables should not be changed.'",
referencedClasses: [],
pragmas: [],
messageSends: ["error:"]
}, function ($methodClass){ return function (aContext,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._error_("Non-assignable variables should not be changed.");
return self;
}, function($ctx1) {$ctx1.fill(self,"inContext:put:",{aContext:aContext,anObject:anObject})});
}; }),
$globals.ScopeVar);

$core.addMethod(
$core.method({
selector: "isSteppingNode",
protocol: "*Compiler-Interpreter",
args: [],
source: "isSteppingNode\x0a\x09^ true",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return true;

}; }),
$globals.SendNode);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09^ aContext receiver instVarNamed: self name",
referencedClasses: [],
pragmas: [],
messageSends: ["instVarNamed:", "receiver", "name"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aContext)._receiver())._instVarNamed_($self._name());
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.SlotVar);

$core.addMethod(
$core.method({
selector: "inContext:put:",
protocol: "*Compiler-Interpreter",
args: ["aContext", "anObject"],
source: "inContext: aContext put: anObject\x0a\x09aContext receiver instVarNamed: self name put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["instVarNamed:put:", "receiver", "name"]
}, function ($methodClass){ return function (aContext,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(aContext)._receiver())._instVarNamed_put_($self._name(),anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"inContext:put:",{aContext:aContext,anObject:anObject})});
}; }),
$globals.SlotVar);

$core.addMethod(
$core.method({
selector: "inContext:",
protocol: "*Compiler-Interpreter",
args: ["aContext"],
source: "inContext: aContext\x0a\x09^ aContext localAt: 'self'",
referencedClasses: [],
pragmas: [],
messageSends: ["localAt:"]
}, function ($methodClass){ return function (aContext){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aContext)._localAt_("self");
}, function($ctx1) {$ctx1.fill(self,"inContext:",{aContext:aContext})});
}; }),
$globals.SuperVar);

$core.addMethod(
$core.method({
selector: "isJavaScriptSuper",
protocol: "*Compiler-Interpreter",
args: [],
source: "isJavaScriptSuper\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.SuperVar);

$core.addMethod(
$core.method({
selector: "inContext:put:",
protocol: "*Compiler-Interpreter",
args: ["aContext", "anObject"],
source: "inContext: aContext put: anObject\x0a\x09aContext localAt: self name put: anObject",
referencedClasses: [],
pragmas: [],
messageSends: ["localAt:put:", "name"]
}, function ($methodClass){ return function (aContext,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aContext)._localAt_put_($self._name(),anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"inContext:put:",{aContext:aContext,anObject:anObject})});
}; }),
$globals.TempVar);

});

define('amber/lang',[
    './deploy',
    './boot', // pre-fetch, dep of ./helpers
    './helpers', // pre-fetch, dep of ./deploy
    './parser',
    // --- packages for the Amber reflection begin here ---
    'amber/core/Platform-ImportExport',
    'amber/core/Compiler-Core',
    'amber/core/Compiler-AST',
    'amber/core/Compiler-Semantic',
    'amber/core/Compiler-IR',
    'amber/core/Compiler-Inlining',
    'amber/core/Compiler-Interpreter'
    // --- packages for the Amber reflection end here ---
], function (amber) {
    return amber;
});

define('amber/core/Platform-DOM',["amber/boot", "require", "amber/core/Kernel-Collections", "amber/core/Kernel-Infrastructure", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Platform-DOM");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("PlatformDom", $globals.Object, "Platform-DOM");

$core.addMethod(
$core.method({
selector: "isDomNode:",
protocol: "testing",
args: ["anObject"],
source: "isDomNode: anObject\x0a<inlineJS: '\x0a\x09return anObject.nodeType > 0 &&\x0a\x09\x09Object.prototype.toString.call(anObject) !== \x22[object Object]\x22\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09return anObject.nodeType > 0 &&\x0a\x09\x09Object.prototype.toString.call(anObject) !== \x22[object Object]\x22"]]],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	return anObject.nodeType > 0 &&
		Object.prototype.toString.call(anObject) !== "[object Object]";
return self;
}, function($ctx1) {$ctx1.fill(self,"isDomNode:",{anObject:anObject})});
}; }),
$globals.PlatformDom.a$cls);

$core.addMethod(
$core.method({
selector: "isFeasible",
protocol: "testing",
args: [],
source: "isFeasible\x0a<inlineJS: '\x0a  if (typeof document === \x22undefined\x22) return false;\x0a  try {\x0a    var d = document.createElement(\x22div\x22),\x0a\x09  f = document.createDocumentFragment(),\x0a\x09  t = document.createTextNode(\x22Hello, Amber!\x22);\x0a\x09f.appendChild(t);\x0a\x09d.insertBefore(f, null);\x0a\x09return d.innerHTML === \x22Hello, Amber!\x22;\x0a  } catch (e) {\x0a    return false;\x0a  }\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a  if (typeof document === \x22undefined\x22) return false;\x0a  try {\x0a    var d = document.createElement(\x22div\x22),\x0a\x09  f = document.createDocumentFragment(),\x0a\x09  t = document.createTextNode(\x22Hello, Amber!\x22);\x0a\x09f.appendChild(t);\x0a\x09d.insertBefore(f, null);\x0a\x09return d.innerHTML === \x22Hello, Amber!\x22;\x0a  } catch (e) {\x0a    return false;\x0a  }"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

  if (typeof document === "undefined") return false;
  try {
    var d = document.createElement("div"),
	  f = document.createDocumentFragment(),
	  t = document.createTextNode("Hello, Amber!");
	f.appendChild(t);
	d.insertBefore(f, null);
	return d.innerHTML === "Hello, Amber!";
  } catch (e) {
    return false;
  };
return self;
}, function($ctx1) {$ctx1.fill(self,"isFeasible",{})});
}; }),
$globals.PlatformDom.a$cls);

$core.addMethod(
$core.method({
selector: "newCustomEvent:detail:",
protocol: "creation",
args: ["aString", "anObject"],
source: "newCustomEvent: aString detail: anObject\x0a<inlineJS: 'return new CustomEvent(aString, {detail: anObject})'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return new CustomEvent(aString, {detail: anObject})"]]],
messageSends: []
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return new CustomEvent(aString, {detail: anObject});
return self;
}, function($ctx1) {$ctx1.fill(self,"newCustomEvent:detail:",{aString:aString,anObject:anObject})});
}; }),
$globals.PlatformDom.a$cls);

$core.addMethod(
$core.method({
selector: "toArray:",
protocol: "converting",
args: ["aDomList"],
source: "toArray: aDomList\x0a<inlineJS: 'return Array.prototype.slice.call(aDomList)'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return Array.prototype.slice.call(aDomList)"]]],
messageSends: []
}, function ($methodClass){ return function (aDomList){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return Array.prototype.slice.call(aDomList);
return self;
}, function($ctx1) {$ctx1.fill(self,"toArray:",{aDomList:aDomList})});
}; }),
$globals.PlatformDom.a$cls);

$core.addMethod(
$core.method({
selector: "asDomNode",
protocol: "*Platform-DOM",
args: [],
source: "asDomNode\x0a\x09| fragment |\x0a\x09fragment := document createDocumentFragment.\x0a\x09self do: [ :each | fragment appendChild: each asDomNode ].\x0a\x09^ fragment",
referencedClasses: [],
pragmas: [],
messageSends: ["createDocumentFragment", "do:", "appendChild:", "asDomNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var fragment;
return $core.withContext(function($ctx1) {
fragment=$recv(document)._createDocumentFragment();
$self._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(fragment)._appendChild_($recv(each)._asDomNode());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return fragment;
}, function($ctx1) {$ctx1.fill(self,"asDomNode",{fragment:fragment})});
}; }),
$globals.Collection);

$core.addMethod(
$core.method({
selector: "asDomNode",
protocol: "*Platform-DOM",
args: [],
source: "asDomNode\x0a\x09(PlatformDom isDomNode: jsObject)\x0a\x09\x09ifTrue: [ ^ jsObject ]\x0a\x09\x09ifFalse: [ ^ super asDomNode ]",
referencedClasses: ["PlatformDom"],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "isDomNode:", "asDomNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($globals.PlatformDom)._isDomNode_($self.jsObject))){
return $self.jsObject;
} else {
return [(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._asDomNode.call($self))
,$ctx1.supercall = false
][0];
}
return self;
}, function($ctx1) {$ctx1.fill(self,"asDomNode",{})});
}; }),
$globals.JSObjectProxy);

$core.addMethod(
$core.method({
selector: "asDomNode",
protocol: "*Platform-DOM",
args: [],
source: "asDomNode\x0a\x09^ document createTextNode: self asString",
referencedClasses: [],
pragmas: [],
messageSends: ["createTextNode:", "asString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(document)._createTextNode_($self._asString());
}, function($ctx1) {$ctx1.fill(self,"asDomNode",{})});
}; }),
$globals.String);

$core.addMethod(
$core.method({
selector: "htmlTextContent",
protocol: "*Platform-DOM",
args: [],
source: "htmlTextContent\x0a<inlineJS: 'var d=document.createElement(\x22div\x22);d.innerHTML=self;return d.textContent||d.innerText;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["var d=document.createElement(\x22div\x22);d.innerHTML=self;return d.textContent||d.innerText;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var d=document.createElement("div");d.innerHTML=self;return d.textContent||d.innerText;;
return self;
}, function($ctx1) {$ctx1.fill(self,"htmlTextContent",{})});
}; }),
$globals.String);

});

define('amber/core/SUnit',["amber/boot", "require", "amber/core/Kernel-Classes", "amber/core/Kernel-Exceptions", "amber/core/Kernel-Infrastructure", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("SUnit");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ResultAnnouncement", $globals.Object, "SUnit");
$core.setSlots($globals.ResultAnnouncement, ["result"]);
$globals.ResultAnnouncement.comment="I get signaled when a `TestCase` has been run.\x0a\x0aMy instances hold the result (instance of `TestResult`) of the test run.";
$core.addMethod(
$core.method({
selector: "result",
protocol: "accessing",
args: [],
source: "result\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.result;

}; }),
$globals.ResultAnnouncement);

$core.addMethod(
$core.method({
selector: "result:",
protocol: "accessing",
args: ["aTestResult"],
source: "result: aTestResult\x0a\x09result := aTestResult",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aTestResult){
var self=this,$self=this;
$self.result=aTestResult;
return self;

}; }),
$globals.ResultAnnouncement);



$core.addClass("Teachable", $globals.Object, "SUnit");
$core.setSlots($globals.Teachable, ["learnings"]);
$globals.Teachable.comment="An object you can teach how to behave. Have a look at the \x0aclass side for an example.\x0a\x0aFor more infos have a look at: http://lists.squeakfoundation.org/pipermail/squeak-dev/2002-April/038170.html";
$core.addMethod(
$core.method({
selector: "acceptSend:",
protocol: "teaching",
args: ["aSymbol"],
source: "acceptSend: aSymbol\x0a\x0a\x09self whenSend: aSymbol return: self",
referencedClasses: [],
pragmas: [],
messageSends: ["whenSend:return:"]
}, function ($methodClass){ return function (aSymbol){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._whenSend_return_(aSymbol,self);
return self;
}, function($ctx1) {$ctx1.fill(self,"acceptSend:",{aSymbol:aSymbol})});
}; }),
$globals.Teachable);

$core.addMethod(
$core.method({
selector: "doesNotUnderstand:",
protocol: "private",
args: ["aMessage"],
source: "doesNotUnderstand: aMessage\x0a\x0a\x09| learning |\x0a\x09learning := self learnings \x0a\x09\x09at: aMessage selector \x0a\x09\x09ifAbsent:[ ^super doesNotUnderstand: aMessage ].\x0a\x09^ learning class == Association\x0a\x09\x09ifTrue: [learning value]\x0a\x09\x09ifFalse: [learning valueWithPossibleArguments: aMessage arguments]",
referencedClasses: ["Association"],
pragmas: [],
messageSends: ["at:ifAbsent:", "learnings", "selector", "doesNotUnderstand:", "ifTrue:ifFalse:", "==", "class", "value", "valueWithPossibleArguments:", "arguments"]
}, function ($methodClass){ return function (aMessage){
var self=this,$self=this;
var learning;
return $core.withContext(function($ctx1) {
var $early={};
try {
learning=$recv($self._learnings())._at_ifAbsent_($recv(aMessage)._selector(),(function(){
return $core.withContext(function($ctx2) {
throw $early=[[(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._doesNotUnderstand_.call($self,aMessage))
,$ctx2.supercall = false
][0]];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
if($core.assert($recv($recv(learning)._class()).__eq_eq($globals.Association))){
return $recv(learning)._value();
} else {
return $recv(learning)._valueWithPossibleArguments_($recv(aMessage)._arguments());
}
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"doesNotUnderstand:",{aMessage:aMessage,learning:learning})});
}; }),
$globals.Teachable);

$core.addMethod(
$core.method({
selector: "learnings",
protocol: "private",
args: [],
source: "learnings\x0a\x0a\x09learnings isNil ifTrue: [learnings := Dictionary new].\x0a\x09^learnings",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["ifTrue:", "isNil", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self.learnings)._isNil())){
$self.learnings=$recv($globals.Dictionary)._new();
$self.learnings;
}
return $self.learnings;
}, function($ctx1) {$ctx1.fill(self,"learnings",{})});
}; }),
$globals.Teachable);

$core.addMethod(
$core.method({
selector: "whenSend:evaluate:",
protocol: "teaching",
args: ["aSymbol", "aBlock"],
source: "whenSend: aSymbol evaluate: aBlock\x0a\x0a\x09self learnings at: aSymbol put: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "learnings"]
}, function ($methodClass){ return function (aSymbol,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._learnings())._at_put_(aSymbol,aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"whenSend:evaluate:",{aSymbol:aSymbol,aBlock:aBlock})});
}; }),
$globals.Teachable);

$core.addMethod(
$core.method({
selector: "whenSend:return:",
protocol: "teaching",
args: ["aSymbol", "anObject"],
source: "whenSend: aSymbol return: anObject\x0a\x0a\x09self learnings at: aSymbol put: (#return -> anObject)",
referencedClasses: [],
pragmas: [],
messageSends: ["at:put:", "learnings", "->"]
}, function ($methodClass){ return function (aSymbol,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._learnings())._at_put_(aSymbol,"return".__minus_gt(anObject));
return self;
}, function($ctx1) {$ctx1.fill(self,"whenSend:return:",{aSymbol:aSymbol,anObject:anObject})});
}; }),
$globals.Teachable);


$core.addMethod(
$core.method({
selector: "example",
protocol: "examples",
args: [],
source: "example\x0a\x09| teachable |\x0a\x09teachable := self new.\x0a\x09teachable \x0a\x09\x09whenSend: #help return: 'ok';\x0a\x09\x09whenSend: #doit evaluate: [1 inspect];\x0a\x09\x09acceptSend: #noDebugger;\x0a\x09\x09whenSend: #negate: evaluate: [:num | num negated].\x0a\x09teachable help.\x0a\x09teachable doit.\x0a\x09teachable noDebugger.\x0a\x09teachable negate: 120",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "whenSend:return:", "whenSend:evaluate:", "inspect", "acceptSend:", "negated", "help", "doit", "noDebugger", "negate:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var teachable;
return $core.withContext(function($ctx1) {
var $1;
teachable=$self._new();
$1=teachable;
$recv($1)._whenSend_return_("help","ok");
[$recv($1)._whenSend_evaluate_("doit",(function(){
return $core.withContext(function($ctx2) {
return (1)._inspect();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["whenSend:evaluate:"]=1
][0];
$recv($1)._acceptSend_("noDebugger");
$recv($1)._whenSend_evaluate_("negate:",(function(num){
return $core.withContext(function($ctx2) {
return $recv(num)._negated();
}, function($ctx2) {$ctx2.fillBlock({num:num},$ctx1,2)});
}));
$recv(teachable)._help();
$recv(teachable)._doit();
$recv(teachable)._noDebugger();
$recv(teachable)._negate_((120));
return self;
}, function($ctx1) {$ctx1.fill(self,"example",{teachable:teachable})});
}; }),
$globals.Teachable.a$cls);


$core.addClass("TestCase", $globals.Object, "SUnit");
$core.setSlots($globals.TestCase, ["testSelector", "asyncTimeout", "context"]);
$globals.TestCase.comment="I am an implementation of the command pattern to run a test.\x0a\x0a## API\x0a\x0aMy instances are created with the class method `#selector:`,\x0apassing the symbol that names the method to be executed when the test case runs.\x0a\x0aWhen you discover a new fixture, subclass `TestCase` and create a `#test...` method for the first test.\x0aAs that method develops and more `#test...` methods are added, you will find yourself refactoring temps\x0ainto instance variables for the objects in the fixture and overriding `#setUp` to initialize these variables.\x0aAs required, override `#tearDown` to nil references, release objects and deallocate.";
$core.addMethod(
$core.method({
selector: "assert:",
protocol: "testing",
args: ["aBoolean"],
source: "assert: aBoolean\x0a\x09self assert: aBoolean description: 'Assertion failed'",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:description:"]
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_description_(aBoolean,"Assertion failed");
return self;
}, function($ctx1) {$ctx1.fill(self,"assert:",{aBoolean:aBoolean})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "assert:description:",
protocol: "testing",
args: ["aBoolean", "aString"],
source: "assert: aBoolean description: aString\x0a\x09aBoolean ifFalse: [ self signalFailure: aString ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "signalFailure:"]
}, function ($methodClass){ return function (aBoolean,aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert(aBoolean)){
$self._signalFailure_(aString);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"assert:description:",{aBoolean:aBoolean,aString:aString})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "assert:equals:",
protocol: "testing",
args: ["actual", "expected"],
source: "assert: actual equals: expected\x0a\x09^ self assert: (actual = expected) description: 'Expected: ', expected printString, ' but was: ', actual printString",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:description:", "=", ",", "printString"]
}, function ($methodClass){ return function (actual,expected){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._assert_description_($recv(actual).__eq(expected),[$recv([$recv("Expected: ".__comma([$recv(expected)._printString()
,$ctx1.sendIdx["printString"]=1
][0])).__comma(" but was: ")
,$ctx1.sendIdx[","]=2
][0]).__comma($recv(actual)._printString())
,$ctx1.sendIdx[","]=1
][0]);
}, function($ctx1) {$ctx1.fill(self,"assert:equals:",{actual:actual,expected:expected})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "async:",
protocol: "async",
args: ["aBlock"],
source: "async: aBlock\x0a\x09| c |\x0a\x09self errorIfNotAsync: '#async'.\x0a\x09c := context.\x0a\x09^ [ self isAsync ifTrue: [ c execute: aBlock ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["errorIfNotAsync:", "ifTrue:", "isAsync", "execute:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var c;
return $core.withContext(function($ctx1) {
$self._errorIfNotAsync_("#async");
c=$self.context;
return (function(){
return $core.withContext(function($ctx2) {
if($core.assert($self._isAsync())){
return $recv(c)._execute_(aBlock);
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
});
}, function($ctx1) {$ctx1.fill(self,"async:",{aBlock:aBlock,c:c})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "context:",
protocol: "accessing",
args: ["aRunningTestContext"],
source: "context: aRunningTestContext\x0a\x09context := aRunningTestContext",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aRunningTestContext){
var self=this,$self=this;
$self.context=aRunningTestContext;
return self;

}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "debugCase",
protocol: "running",
args: [],
source: "debugCase\x0a\x09\x22Runs a test case in isolated context, debugging all errors.\x22\x0a\x0a\x09(DebugTestContext testCase: self) start",
referencedClasses: ["DebugTestContext"],
pragmas: [],
messageSends: ["start", "testCase:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.DebugTestContext)._testCase_(self))._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"debugCase",{})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "deny:",
protocol: "testing",
args: ["aBoolean"],
source: "deny: aBoolean\x0a\x09self assert: aBoolean not",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "not"]
}, function ($methodClass){ return function (aBoolean){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv(aBoolean)._not());
return self;
}, function($ctx1) {$ctx1.fill(self,"deny:",{aBoolean:aBoolean})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "errorIfNotAsync:",
protocol: "error handling",
args: ["aString"],
source: "errorIfNotAsync: aString\x0a\x09self isAsync ifFalse: [\x0a\x09\x09self error: aString, ' used without prior #timeout:' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "isAsync", "error:", ","]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($self._isAsync())){
$self._error_($recv(aString).__comma(" used without prior #timeout:"));
}
return self;
}, function($ctx1) {$ctx1.fill(self,"errorIfNotAsync:",{aString:aString})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "finished",
protocol: "async",
args: [],
source: "finished\x0a\x09self errorIfNotAsync: '#finished'.\x0a\x09asyncTimeout := nil",
referencedClasses: [],
pragmas: [],
messageSends: ["errorIfNotAsync:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._errorIfNotAsync_("#finished");
$self.asyncTimeout=nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"finished",{})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "isAsync",
protocol: "testing",
args: [],
source: "isAsync\x0a\x09^ asyncTimeout notNil",
referencedClasses: [],
pragmas: [],
messageSends: ["notNil"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.asyncTimeout)._notNil();
}, function($ctx1) {$ctx1.fill(self,"isAsync",{})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "performTest",
protocol: "running",
args: [],
source: "performTest\x0a\x09asyncTimeout := nil.\x0a\x09self perform: self selector",
referencedClasses: [],
pragmas: [],
messageSends: ["perform:", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.asyncTimeout=nil;
$self._perform_($self._selector());
return self;
}, function($ctx1) {$ctx1.fill(self,"performTest",{})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "runCase",
protocol: "running",
args: [],
source: "runCase\x0a\x09\x22Runs a test case in isolated context, leaking all errors.\x22\x0a\x0a\x09(TestContext testCase: self) start",
referencedClasses: ["TestContext"],
pragmas: [],
messageSends: ["start", "testCase:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.TestContext)._testCase_(self))._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"runCase",{})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "selector",
protocol: "accessing",
args: [],
source: "selector\x0a\x09^ testSelector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.testSelector;

}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "setTestSelector:",
protocol: "accessing",
args: ["aSelector"],
source: "setTestSelector: aSelector\x0a\x09testSelector := aSelector",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aSelector){
var self=this,$self=this;
$self.testSelector=aSelector;
return self;

}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "should:",
protocol: "testing",
args: ["aBlock"],
source: "should: aBlock\x0a\x09self assert: aBlock value",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv(aBlock)._value());
return self;
}, function($ctx1) {$ctx1.fill(self,"should:",{aBlock:aBlock})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "should:raise:",
protocol: "testing",
args: ["aBlock", "anExceptionClass"],
source: "should: aBlock raise: anExceptionClass\x0a\x09self assert: ([ aBlock value. false ]\x0a\x09\x09on: anExceptionClass\x0a\x09\x09do: [ :ex | true ])",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "on:do:", "value"]
}, function ($methodClass){ return function (aBlock,anExceptionClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value();
return false;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_(anExceptionClass,(function(ex){
return true;

})));
return self;
}, function($ctx1) {$ctx1.fill(self,"should:raise:",{aBlock:aBlock,anExceptionClass:anExceptionClass})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "shouldnt:raise:",
protocol: "testing",
args: ["aBlock", "anExceptionClass"],
source: "shouldnt: aBlock raise: anExceptionClass\x0a\x09self assert: ([ aBlock value. true ]\x0a\x09\x09on: anExceptionClass\x0a\x09\x09do: [ :ex | false ])",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "on:do:", "value"]
}, function ($methodClass){ return function (aBlock,anExceptionClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv((function(){
return $core.withContext(function($ctx2) {
$recv(aBlock)._value();
return true;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_(anExceptionClass,(function(ex){
return false;

})));
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldnt:raise:",{aBlock:aBlock,anExceptionClass:anExceptionClass})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "signalFailure:",
protocol: "private",
args: ["aString"],
source: "signalFailure: aString\x0a\x09TestFailure new\x0a\x09\x09messageText: aString;\x0a\x09\x09signal",
referencedClasses: ["TestFailure"],
pragmas: [],
messageSends: ["messageText:", "new", "signal"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.TestFailure)._new();
$recv($1)._messageText_(aString);
$recv($1)._signal();
return self;
}, function($ctx1) {$ctx1.fill(self,"signalFailure:",{aString:aString})});
}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: "running",
args: [],
source: "tearDown",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.TestCase);

$core.addMethod(
$core.method({
selector: "timeout:",
protocol: "async",
args: ["aNumber"],
source: "timeout: aNumber\x0a\x09\x22Set a grace time timeout in milliseconds to run the test asynchronously\x22\x0a\x09\x0a\x09asyncTimeout ifNotNil: [ asyncTimeout clearTimeout ].\x0a\x09\x0a\x09\x22to allow #async: message send without throwing an error\x22\x0a\x09asyncTimeout := 0.\x0a\x09\x0a\x09asyncTimeout := (self async: [\x0a\x09\x09self assert: false description: 'SUnit grace time exhausted' ])\x0a\x09\x09\x09valueWithTimeout: aNumber",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:", "clearTimeout", "valueWithTimeout:", "async:", "assert:description:"]
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.asyncTimeout;
if($1 == null || $1.a$nil){
$1;
} else {
$recv($self.asyncTimeout)._clearTimeout();
}
$self.asyncTimeout=(0);
$self.asyncTimeout=$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
return $self._assert_description_(false,"SUnit grace time exhausted");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
})))._valueWithTimeout_(aNumber);
return self;
}, function($ctx1) {$ctx1.fill(self,"timeout:",{aNumber:aNumber})});
}; }),
$globals.TestCase);


$core.addMethod(
$core.method({
selector: "allTestSelectors",
protocol: "accessing",
args: [],
source: "allTestSelectors\x0a\x09| selectors |\x0a\x09selectors := self testSelectors.\x0a\x09self shouldInheritSelectors ifTrue: [\x0a\x09\x09selectors addAll: self superclass allTestSelectors ].\x0a\x09^ selectors asSet",
referencedClasses: [],
pragmas: [],
messageSends: ["testSelectors", "ifTrue:", "shouldInheritSelectors", "addAll:", "allTestSelectors", "superclass", "asSet"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var selectors;
return $core.withContext(function($ctx1) {
selectors=$self._testSelectors();
if($core.assert($self._shouldInheritSelectors())){
$recv(selectors)._addAll_($recv($self._superclass())._allTestSelectors());
}
return $recv(selectors)._asSet();
}, function($ctx1) {$ctx1.fill(self,"allTestSelectors",{selectors:selectors})});
}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "buildSuite",
protocol: "accessing",
args: [],
source: "buildSuite\x0a\x09^ self allTestSelectors collect: [ :each | self selector: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "allTestSelectors", "selector:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._allTestSelectors())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $self._selector_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"buildSuite",{})});
}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "classTag",
protocol: "accessing",
args: [],
source: "classTag\x0a\x09\x22Returns a tag or general category for this class.\x0a\x09Typically used to help tools do some reflection.\x0a\x09Helios, for example, uses this to decide what icon the class should display.\x22\x0a\x09\x0a\x09^ 'test'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "test";

}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: "testing",
args: [],
source: "isAbstract\x0a\x09^ self name = TestCase name",
referencedClasses: ["TestCase"],
pragmas: [],
messageSends: ["=", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$self._name()
,$ctx1.sendIdx["name"]=1
][0]).__eq($recv($globals.TestCase)._name());
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{})});
}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "isTestClass",
protocol: "testing",
args: [],
source: "isTestClass\x0a\x09^ self isAbstract not",
referencedClasses: [],
pragmas: [],
messageSends: ["not", "isAbstract"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._isAbstract())._not();
}, function($ctx1) {$ctx1.fill(self,"isTestClass",{})});
}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "lookupHierarchyRoot",
protocol: "accessing",
args: [],
source: "lookupHierarchyRoot\x0a\x09^ TestCase",
referencedClasses: ["TestCase"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.TestCase;

}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "selector:",
protocol: "accessing",
args: ["aSelector"],
source: "selector: aSelector\x0a\x09^ self new\x0a\x09\x09setTestSelector: aSelector;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["setTestSelector:", "new", "yourself"]
}, function ($methodClass){ return function (aSelector){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._setTestSelector_(aSelector);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"selector:",{aSelector:aSelector})});
}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "shouldInheritSelectors",
protocol: "testing",
args: [],
source: "shouldInheritSelectors\x0a\x09^ self ~= self lookupHierarchyRoot",
referencedClasses: [],
pragmas: [],
messageSends: ["~=", "lookupHierarchyRoot"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self.__tild_eq($self._lookupHierarchyRoot());
}, function($ctx1) {$ctx1.fill(self,"shouldInheritSelectors",{})});
}; }),
$globals.TestCase.a$cls);

$core.addMethod(
$core.method({
selector: "testSelectors",
protocol: "accessing",
args: [],
source: "testSelectors\x0a\x09^ self methodDictionary keys select: [ :each | each match: '^test' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["select:", "keys", "methodDictionary", "match:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._methodDictionary())._keys())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^test");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"testSelectors",{})});
}; }),
$globals.TestCase.a$cls);


$core.addClass("TestContext", $globals.Object, "SUnit");
$core.setSlots($globals.TestContext, ["testCase"]);
$globals.TestContext.comment="I govern running a particular test case.\x0a\x0aMy main added value is `#execute:` method which runs a block as a part of test case (restores context, nilling it afterwards, cleaning/calling `#tearDown` as appropriate for sync/async scenario).";
$core.addMethod(
$core.method({
selector: "execute:",
protocol: "running",
args: ["aBlock"],
source: "execute: aBlock\x0a\x09| failed |\x0a\x09\x0a\x09testCase context: self.\x0a\x09[\x0a\x09\x09failed := true.\x0a\x09\x09aBlock value.\x0a\x09\x09failed := false\x0a\x09]\x0a\x09\x09ensure: [\x0a\x09\x09\x09testCase context: nil.\x0a\x09\x09\x09\x0a\x09\x09\x09(failed and: [ testCase isAsync ]) ifTrue: [\x0a\x09\x09\x09\x09testCase finished ].\x0a\x09\x09\x09testCase isAsync ifFalse: [\x0a\x09\x09\x09\x09testCase tearDown ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["context:", "ensure:", "value", "ifTrue:", "and:", "isAsync", "finished", "ifFalse:", "tearDown"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var failed;
return $core.withContext(function($ctx1) {
var $1;
[$recv($self.testCase)._context_(self)
,$ctx1.sendIdx["context:"]=1
][0];
$recv((function(){
return $core.withContext(function($ctx2) {
failed=true;
$recv(aBlock)._value();
failed=false;
return failed;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
$recv($self.testCase)._context_(nil);
if($core.assert(failed)){
$1=[$recv($self.testCase)._isAsync()
,$ctx2.sendIdx["isAsync"]=1
][0];
} else {
$1=false;
}
if($core.assert($1)){
$recv($self.testCase)._finished();
}
if(!$core.assert($recv($self.testCase)._isAsync())){
return $recv($self.testCase)._tearDown();
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"execute:",{aBlock:aBlock,failed:failed})});
}; }),
$globals.TestContext);

$core.addMethod(
$core.method({
selector: "start",
protocol: "running",
args: [],
source: "start\x0a\x09self execute: [\x0a\x09\x09testCase setUp.\x0a\x09\x09testCase performTest ]",
referencedClasses: [],
pragmas: [],
messageSends: ["execute:", "setUp", "performTest"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._execute_((function(){
return $core.withContext(function($ctx2) {
$recv($self.testCase)._setUp();
return $recv($self.testCase)._performTest();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{})});
}; }),
$globals.TestContext);

$core.addMethod(
$core.method({
selector: "testCase:",
protocol: "accessing",
args: ["aTestCase"],
source: "testCase: aTestCase\x0a\x09testCase := aTestCase",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aTestCase){
var self=this,$self=this;
$self.testCase=aTestCase;
return self;

}; }),
$globals.TestContext);


$core.addMethod(
$core.method({
selector: "testCase:",
protocol: "instance creation",
args: ["aTestCase"],
source: "testCase: aTestCase\x0a\x09^ self new\x0a\x09\x09testCase: aTestCase;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["testCase:", "new", "yourself"]
}, function ($methodClass){ return function (aTestCase){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._new();
$recv($1)._testCase_(aTestCase);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"testCase:",{aTestCase:aTestCase})});
}; }),
$globals.TestContext.a$cls);


$core.addClass("DebugTestContext", $globals.TestContext, "SUnit");
$core.setSlots($globals.DebugTestContext, ["finished", "result"]);
$globals.DebugTestContext.comment="I add error debugging to `TestContext`.\x0a\x0aErrors are caught and explicitly passed to `ErrorHandler`.\x0aI am used in `TestCase >> debugCase`.";
$core.addMethod(
$core.method({
selector: "execute:",
protocol: "running",
args: ["aBlock"],
source: "execute: aBlock\x0a\x09self withErrorDebugging: [ super execute: aBlock ]",
referencedClasses: [],
pragmas: [],
messageSends: ["withErrorDebugging:", "execute:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._withErrorDebugging_((function(){
return $core.withContext(function($ctx2) {
return [(
$ctx2.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._execute_.call($self,aBlock))
,$ctx2.supercall = false
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"execute:",{aBlock:aBlock})});
}; }),
$globals.DebugTestContext);

$core.addMethod(
$core.method({
selector: "withErrorDebugging:",
protocol: "private",
args: ["aBlock"],
source: "withErrorDebugging: aBlock\x0a\x09aBlock\x0a\x09\x09on: Error\x0a\x09\x09do: [ :ex | ErrorHandler handleError: ex ]",
referencedClasses: ["Error", "ErrorHandler"],
pragmas: [],
messageSends: ["on:do:", "handleError:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
return $recv($globals.ErrorHandler)._handleError_(ex);
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"withErrorDebugging:",{aBlock:aBlock})});
}; }),
$globals.DebugTestContext);


$core.addMethod(
$core.method({
selector: "testCase:result:finished:",
protocol: "instance creation",
args: ["aTestCase", "aTestResult", "aBlock"],
source: "testCase: aTestCase result: aTestResult finished: aBlock\x0a\x09^ (super testCase: aTestCase)\x0a\x09\x09result: aTestResult;\x0a\x09\x09finished: aBlock;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["result:", "testCase:", "finished:", "yourself"]
}, function ($methodClass){ return function (aTestCase,aTestResult,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._testCase_.call($self,aTestCase))
,$ctx1.supercall = false
][0];
$recv($1)._result_(aTestResult);
$recv($1)._finished_(aBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"testCase:result:finished:",{aTestCase:aTestCase,aTestResult:aTestResult,aBlock:aBlock})});
}; }),
$globals.DebugTestContext.a$cls);


$core.addClass("ReportingTestContext", $globals.TestContext, "SUnit");
$core.setSlots($globals.ReportingTestContext, ["finished", "result"]);
$globals.ReportingTestContext.comment="I add `TestResult` reporting to `TestContext`.\x0a\x0aErrors are caught and save into a `TestResult`,\x0aWhen test case is finished (which can be later for async tests), a callback block is executed; this is used by a `TestSuiteRunner`.";
$core.addMethod(
$core.method({
selector: "execute:",
protocol: "running",
args: ["aBlock"],
source: "execute: aBlock\x0a\x09[\x0a\x09\x09self withErrorReporting: [ super execute: aBlock ]\x0a\x09]\x0a\x09\x09ensure: [\x0a\x09\x09\x09testCase isAsync ifFalse: [\x0a\x09\x09\x09\x09result increaseRuns. finished value ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ensure:", "withErrorReporting:", "execute:", "ifFalse:", "isAsync", "increaseRuns", "value"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._withErrorReporting_((function(){
return $core.withContext(function($ctx3) {
return [(
$ctx3.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._execute_.call($self,aBlock))
,$ctx3.supercall = false
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
if(!$core.assert($recv($self.testCase)._isAsync())){
$recv($self.result)._increaseRuns();
return $recv($self.finished)._value();
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"execute:",{aBlock:aBlock})});
}; }),
$globals.ReportingTestContext);

$core.addMethod(
$core.method({
selector: "finished:",
protocol: "accessing",
args: ["aBlock"],
source: "finished: aBlock\x0a\x09finished := aBlock",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
$self.finished=aBlock;
return self;

}; }),
$globals.ReportingTestContext);

$core.addMethod(
$core.method({
selector: "result:",
protocol: "accessing",
args: ["aTestResult"],
source: "result: aTestResult\x0a\x09result := aTestResult",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aTestResult){
var self=this,$self=this;
$self.result=aTestResult;
return self;

}; }),
$globals.ReportingTestContext);

$core.addMethod(
$core.method({
selector: "withErrorReporting:",
protocol: "private",
args: ["aBlock"],
source: "withErrorReporting: aBlock\x0a\x09[ aBlock\x0a\x09\x09on: TestFailure\x0a\x09\x09do: [ :ex | result addFailure: testCase ]\x0a\x09]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :ex | result addError: testCase ]",
referencedClasses: ["TestFailure", "Error"],
pragmas: [],
messageSends: ["on:do:", "addFailure:", "addError:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._on_do_($globals.TestFailure,(function(ex){
return $core.withContext(function($ctx3) {
return $recv($self.result)._addFailure_($self.testCase);
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
return $recv($self.result)._addError_($self.testCase);
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,3)});
}))
,$ctx1.sendIdx["on:do:"]=1
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"withErrorReporting:",{aBlock:aBlock})});
}; }),
$globals.ReportingTestContext);


$core.addMethod(
$core.method({
selector: "testCase:result:finished:",
protocol: "instance creation",
args: ["aTestCase", "aTestResult", "aBlock"],
source: "testCase: aTestCase result: aTestResult finished: aBlock\x0a\x09^ (super testCase: aTestCase)\x0a\x09\x09result: aTestResult;\x0a\x09\x09finished: aBlock;\x0a\x09\x09yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["result:", "testCase:", "finished:", "yourself"]
}, function ($methodClass){ return function (aTestCase,aTestResult,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._testCase_.call($self,aTestCase))
,$ctx1.supercall = false
][0];
$recv($1)._result_(aTestResult);
$recv($1)._finished_(aBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"testCase:result:finished:",{aTestCase:aTestCase,aTestResult:aTestResult,aBlock:aBlock})});
}; }),
$globals.ReportingTestContext.a$cls);


$core.addClass("TestFailure", $globals.Error, "SUnit");
$globals.TestFailure.comment="I am raised when the boolean parameter of an #`assert:` or `#deny:` call is the opposite of what the assertion claims.\x0a\x0aThe test framework distinguishes between failures and errors.\x0aA failure is an event whose possibiity is explicitly anticipated and checked for in an assertion,\x0awhereas an error is an unanticipated problem like a division by 0 or an index out of bounds.";


$core.addClass("TestResult", $globals.Object, "SUnit");
$core.setSlots($globals.TestResult, ["timestamp", "runs", "errors", "failures", "total"]);
$globals.TestResult.comment="I implement the collecting parameter pattern for running a bunch of tests.\x0a\x0aMy instances hold tests that have run, sorted into the result categories of passed, failures and errors.\x0a\x0a`TestResult` is an interesting object to subclass or substitute. `#runCase:` is the external protocol you need to reproduce";
$core.addMethod(
$core.method({
selector: "addError:",
protocol: "accessing",
args: ["anError"],
source: "addError: anError\x0a\x09self errors add: anError",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "errors"]
}, function ($methodClass){ return function (anError){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._errors())._add_(anError);
return self;
}, function($ctx1) {$ctx1.fill(self,"addError:",{anError:anError})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "addFailure:",
protocol: "accessing",
args: ["aFailure"],
source: "addFailure: aFailure\x0a\x09self failures add: aFailure",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "failures"]
}, function ($methodClass){ return function (aFailure){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._failures())._add_(aFailure);
return self;
}, function($ctx1) {$ctx1.fill(self,"addFailure:",{aFailure:aFailure})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "errors",
protocol: "accessing",
args: [],
source: "errors\x0a\x09^ errors",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.errors;

}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "failures",
protocol: "accessing",
args: [],
source: "failures\x0a\x09^ failures",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.failures;

}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "increaseRuns",
protocol: "accessing",
args: [],
source: "increaseRuns\x0a\x09runs := runs + 1",
referencedClasses: [],
pragmas: [],
messageSends: ["+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.runs=$recv($self.runs).__plus((1));
return self;
}, function($ctx1) {$ctx1.fill(self,"increaseRuns",{})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09timestamp := Date now.\x0a\x09runs := 0.\x0a\x09errors := Array new.\x0a\x09failures := Array new.\x0a\x09total := 0",
referencedClasses: ["Date", "Array"],
pragmas: [],
messageSends: ["initialize", "now", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.timestamp=$recv($globals.Date)._now();
$self.runs=(0);
$self.errors=[$recv($globals.Array)._new()
,$ctx1.sendIdx["new"]=1
][0];
$self.failures=$recv($globals.Array)._new();
$self.total=(0);
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "nextRunDo:",
protocol: "running",
args: ["aBlock"],
source: "nextRunDo: aBlock\x0a\x09\x22Runs aBlock with index of next run or does nothing if no more runs\x22\x0a\x09^ self runs == self total\x0a\x09\x09ifFalse: [ aBlock value: self runs + 1 ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "==", "runs", "total", "value:", "+"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv([$self._runs()
,$ctx1.sendIdx["runs"]=1
][0]).__eq_eq($self._total()))){
return $recv(aBlock)._value_($recv($self._runs()).__plus((1)));
}
}, function($ctx1) {$ctx1.fill(self,"nextRunDo:",{aBlock:aBlock})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "runCase:",
protocol: "running",
args: ["aTestCase"],
source: "runCase: aTestCase\x0a\x09[ [ self increaseRuns.\x0a\x09\x09aTestCase runCase ]\x0a\x09on: TestFailure do: [ :ex | self addFailure: aTestCase ]]\x0a\x09on: Error do: [ :ex | self addError: aTestCase ]",
referencedClasses: ["TestFailure", "Error"],
pragmas: [],
messageSends: ["on:do:", "increaseRuns", "runCase", "addFailure:", "addError:"]
}, function ($methodClass){ return function (aTestCase){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
$self._increaseRuns();
return $recv(aTestCase)._runCase();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._on_do_($globals.TestFailure,(function(ex){
return $core.withContext(function($ctx3) {
return $self._addFailure_(aTestCase);
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx2) {
return $self._addError_(aTestCase);
}, function($ctx2) {$ctx2.fillBlock({ex:ex},$ctx1,4)});
}))
,$ctx1.sendIdx["on:do:"]=1
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"runCase:",{aTestCase:aTestCase})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "runs",
protocol: "accessing",
args: [],
source: "runs\x0a\x09^ runs",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.runs;

}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "status",
protocol: "accessing",
args: [],
source: "status\x0a\x09^ self errors ifNotEmpty: [ 'error' ] ifEmpty: [\x0a\x09\x09self failures ifNotEmpty: [ 'failure' ] ifEmpty: [\x0a\x09\x09\x09'success' ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotEmpty:ifEmpty:", "errors", "failures"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [$recv($self._errors())._ifNotEmpty_ifEmpty_((function(){
return "error";

}),(function(){
return $core.withContext(function($ctx2) {
return $recv($self._failures())._ifNotEmpty_ifEmpty_((function(){
return "failure";

}),(function(){
return "success";

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))
,$ctx1.sendIdx["ifNotEmpty:ifEmpty:"]=1
][0];
}, function($ctx1) {$ctx1.fill(self,"status",{})});
}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "timestamp",
protocol: "accessing",
args: [],
source: "timestamp\x0a\x09^ timestamp",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.timestamp;

}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "total",
protocol: "accessing",
args: [],
source: "total\x0a\x09^ total",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.total;

}; }),
$globals.TestResult);

$core.addMethod(
$core.method({
selector: "total:",
protocol: "accessing",
args: ["aNumber"],
source: "total: aNumber\x0a\x09total := aNumber",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
$self.total=aNumber;
return self;

}; }),
$globals.TestResult);



$core.addClass("TestSuiteRunner", $globals.Object, "SUnit");
$core.setSlots($globals.TestSuiteRunner, ["suite", "result", "announcer", "runNextTest"]);
$globals.TestSuiteRunner.comment="I am responsible for running a collection (`suite`) of tests.\x0a\x0a## API\x0a\x0aInstances should be created using the class-side `#on:` method, taking a collection of tests to run as parameter.\x0aTo run the test suite, use `#run`.";
$core.addMethod(
$core.method({
selector: "announcer",
protocol: "accessing",
args: [],
source: "announcer\x0a\x09^ announcer",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.announcer;

}; }),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "contextOf:",
protocol: "private",
args: ["anInteger"],
source: "contextOf: anInteger\x0a\x09^ ReportingTestContext testCase: (suite at: anInteger) result: result finished: [ self resume ]",
referencedClasses: ["ReportingTestContext"],
pragmas: [],
messageSends: ["testCase:result:finished:", "at:", "resume"]
}, function ($methodClass){ return function (anInteger){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($globals.ReportingTestContext)._testCase_result_finished_($recv($self.suite)._at_(anInteger),$self.result,(function(){
return $core.withContext(function($ctx2) {
return $self._resume();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"contextOf:",{anInteger:anInteger})});
}; }),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09announcer := Announcer new.\x0a\x09result := TestResult new.\x0a\x09runNextTest := [ | runs | runs := result runs. runs < result total ifTrue: [ (self contextOf: runs + 1) start ] ].",
referencedClasses: ["Announcer", "TestResult"],
pragmas: [],
messageSends: ["initialize", "new", "runs", "ifTrue:", "<", "total", "start", "contextOf:", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.announcer=[$recv($globals.Announcer)._new()
,$ctx1.sendIdx["new"]=1
][0];
$self.result=$recv($globals.TestResult)._new();
$self.runNextTest=(function(){
var runs;
return $core.withContext(function($ctx2) {
runs=$recv($self.result)._runs();
if($core.assert($recv(runs).__lt($recv($self.result)._total()))){
return $recv($self._contextOf_($recv(runs).__plus((1))))._start();
}
}, function($ctx2) {$ctx2.fillBlock({runs:runs},$ctx1,1)});
});
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "result",
protocol: "accessing",
args: [],
source: "result\x0a\x09^ result",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.result;

}; }),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "resume",
protocol: "actions",
args: [],
source: "resume\x0a\x09runNextTest fork.\x0a\x09announcer announce: (ResultAnnouncement new result: result)",
referencedClasses: ["ResultAnnouncement"],
pragmas: [],
messageSends: ["fork", "announce:", "result:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.runNextTest)._fork();
$recv($self.announcer)._announce_($recv($recv($globals.ResultAnnouncement)._new())._result_($self.result));
return self;
}, function($ctx1) {$ctx1.fill(self,"resume",{})});
}; }),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "run",
protocol: "actions",
args: [],
source: "run\x0a\x09result total: suite size.\x0a\x09self resume",
referencedClasses: [],
pragmas: [],
messageSends: ["total:", "size", "resume"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.result)._total_($recv($self.suite)._size());
$self._resume();
return self;
}, function($ctx1) {$ctx1.fill(self,"run",{})});
}; }),
$globals.TestSuiteRunner);

$core.addMethod(
$core.method({
selector: "suite:",
protocol: "accessing",
args: ["aCollection"],
source: "suite: aCollection\x0a\x09suite := aCollection",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
$self.suite=aCollection;
return self;

}; }),
$globals.TestSuiteRunner);


$core.addMethod(
$core.method({
selector: "new",
protocol: "instance creation",
args: [],
source: "new\x0a\x09self shouldNotImplement",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldNotImplement"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldNotImplement();
return self;
}, function($ctx1) {$ctx1.fill(self,"new",{})});
}; }),
$globals.TestSuiteRunner.a$cls);

$core.addMethod(
$core.method({
selector: "on:",
protocol: "instance creation",
args: ["aCollection"],
source: "on: aCollection\x0a\x09^ super new suite: aCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["suite:", "new"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._new.call($self))
,$ctx1.supercall = false
][0])._suite_(aCollection);
}, function($ctx1) {$ctx1.fill(self,"on:",{aCollection:aCollection})});
}; }),
$globals.TestSuiteRunner.a$cls);

$core.addMethod(
$core.method({
selector: "isTestPackage",
protocol: "*SUnit",
args: [],
source: "isTestPackage\x0a\x09^ self classes anySatisfy: [ :each | each isTestClass ]",
referencedClasses: [],
pragmas: [],
messageSends: ["anySatisfy:", "classes", "isTestClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._classes())._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._isTestClass();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"isTestPackage",{})});
}; }),
$globals.Package);

$core.addMethod(
$core.method({
selector: "isTestClass",
protocol: "*SUnit",
args: [],
source: "isTestClass\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return false;

}; }),
$globals.TBehaviorDefaults);

});

define('amber/core/Kernel-Tests',["amber/boot", "require", "amber/core/Kernel-Objects", "amber/core/SUnit"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Kernel-Tests");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("AnnouncementSubscriptionTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testAddExtensionMethod",
protocol: "tests",
args: [],
source: "testAddExtensionMethod\x0a\x09| method dirty |\x0a\x09dirty := self class package isDirty.\x0a\x09self class package beClean.\x0a\x09method := self class compile: 'doNothing' protocol: '**not-a-package'.\x0a\x09self deny: self class package isDirty.\x0a\x09\x0a\x09self class removeCompiledMethod: method.\x0a\x09dirty ifTrue: [ self class package beDirty ]",
referencedClasses: [],
pragmas: [],
messageSends: ["isDirty", "package", "class", "beClean", "compile:protocol:", "deny:", "removeCompiledMethod:", "ifTrue:", "beDirty"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var method,dirty;
return $core.withContext(function($ctx1) {
dirty=[$recv([$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0])._package()
,$ctx1.sendIdx["package"]=1
][0])._isDirty()
,$ctx1.sendIdx["isDirty"]=1
][0];
$recv([$recv([$self._class()
,$ctx1.sendIdx["class"]=2
][0])._package()
,$ctx1.sendIdx["package"]=2
][0])._beClean();
method=$recv([$self._class()
,$ctx1.sendIdx["class"]=3
][0])._compile_protocol_("doNothing","**not-a-package");
$self._deny_($recv([$recv([$self._class()
,$ctx1.sendIdx["class"]=4
][0])._package()
,$ctx1.sendIdx["package"]=3
][0])._isDirty());
$recv([$self._class()
,$ctx1.sendIdx["class"]=5
][0])._removeCompiledMethod_(method);
if($core.assert(dirty)){
$recv($recv($self._class())._package())._beDirty();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddExtensionMethod",{method:method,dirty:dirty})});
}; }),
$globals.AnnouncementSubscriptionTest);

$core.addMethod(
$core.method({
selector: "testHandlesAnnouncement",
protocol: "tests",
args: [],
source: "testHandlesAnnouncement\x0a\x09| subscription announcementClass1 announcementClass2 classBuilder |\x0a\x09\x0a\x09classBuilder := ClassBuilder new.\x0a\x09announcementClass1 := classBuilder addSubclassOf: SystemAnnouncement named: 'TestAnnouncement1' slots: #() package: 'Kernel-Tests'.\x0a\x09\x0a\x09subscription := AnnouncementSubscription new announcementClass: SystemAnnouncement.\x0a\x09\x22Test whether the same class triggers the announcement\x22\x0a\x09self assert: (subscription handlesAnnouncement: SystemAnnouncement new) equals: true.\x0a\x09\x22Test whether a subclass triggers the announcement\x22\x0a\x09self assert: (subscription handlesAnnouncement: announcementClass1 new) equals: true.\x0a\x09\x22Test whether an unrelated class does not trigger the announcement\x22\x0a\x09self assert: (subscription handlesAnnouncement: Object new) equals: false.\x0a\x09\x0a\x09classBuilder basicRemoveClass: announcementClass1.",
referencedClasses: ["ClassBuilder", "SystemAnnouncement", "AnnouncementSubscription", "Object"],
pragmas: [],
messageSends: ["new", "addSubclassOf:named:slots:package:", "announcementClass:", "assert:equals:", "handlesAnnouncement:", "basicRemoveClass:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var subscription,announcementClass1,announcementClass2,classBuilder;
return $core.withContext(function($ctx1) {
classBuilder=[$recv($globals.ClassBuilder)._new()
,$ctx1.sendIdx["new"]=1
][0];
announcementClass1=$recv(classBuilder)._addSubclassOf_named_slots_package_($globals.SystemAnnouncement,"TestAnnouncement1",[],"Kernel-Tests");
subscription=$recv([$recv($globals.AnnouncementSubscription)._new()
,$ctx1.sendIdx["new"]=2
][0])._announcementClass_($globals.SystemAnnouncement);
[$self._assert_equals_([$recv(subscription)._handlesAnnouncement_([$recv($globals.SystemAnnouncement)._new()
,$ctx1.sendIdx["new"]=3
][0])
,$ctx1.sendIdx["handlesAnnouncement:"]=1
][0],true)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(subscription)._handlesAnnouncement_([$recv(announcementClass1)._new()
,$ctx1.sendIdx["new"]=4
][0])
,$ctx1.sendIdx["handlesAnnouncement:"]=2
][0],true)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv(subscription)._handlesAnnouncement_($recv($globals.Object)._new()),false);
$recv(classBuilder)._basicRemoveClass_(announcementClass1);
return self;
}, function($ctx1) {$ctx1.fill(self,"testHandlesAnnouncement",{subscription:subscription,announcementClass1:announcementClass1,announcementClass2:announcementClass2,classBuilder:classBuilder})});
}; }),
$globals.AnnouncementSubscriptionTest);



$core.addClass("AnnouncerTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testOnDo",
protocol: "tests",
args: [],
source: "testOnDo\x0a\x09| counter announcer |\x0a\x09\x0a\x09counter := 0.\x0a\x09announcer := Announcer new.\x0a\x09announcer on: SystemAnnouncement do: [ counter := counter + 1 ].\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 2.",
referencedClasses: ["Announcer", "SystemAnnouncement"],
pragmas: [],
messageSends: ["new", "on:do:", "+", "announce:", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var counter,announcer;
return $core.withContext(function($ctx1) {
counter=(0);
announcer=[$recv($globals.Announcer)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv(announcer)._on_do_($globals.SystemAnnouncement,(function(){
return $core.withContext(function($ctx2) {
counter=$recv(counter).__plus((1));
return counter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
[$recv(announcer)._announce_([$recv($globals.SystemAnnouncement)._new()
,$ctx1.sendIdx["new"]=2
][0])
,$ctx1.sendIdx["announce:"]=1
][0];
[$self._assert_equals_(counter,(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(announcer)._announce_($recv($globals.SystemAnnouncement)._new());
$self._assert_equals_(counter,(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDo",{counter:counter,announcer:announcer})});
}; }),
$globals.AnnouncerTest);

$core.addMethod(
$core.method({
selector: "testOnDoFor",
protocol: "tests",
args: [],
source: "testOnDoFor\x0a\x09| counter announcer |\x0a\x09\x0a\x09counter := 0.\x0a\x09announcer := Announcer new.\x0a\x09announcer on: SystemAnnouncement do: [ counter := counter + 1 ] for: self.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 2.\x0a\x09\x0a\x09announcer unsubscribe: self.\x0a\x09\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 2.",
referencedClasses: ["Announcer", "SystemAnnouncement"],
pragmas: [],
messageSends: ["new", "on:do:for:", "+", "announce:", "assert:equals:", "unsubscribe:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var counter,announcer;
return $core.withContext(function($ctx1) {
counter=(0);
announcer=[$recv($globals.Announcer)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv(announcer)._on_do_for_($globals.SystemAnnouncement,(function(){
return $core.withContext(function($ctx2) {
counter=$recv(counter).__plus((1));
return counter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),self);
[$recv(announcer)._announce_([$recv($globals.SystemAnnouncement)._new()
,$ctx1.sendIdx["new"]=2
][0])
,$ctx1.sendIdx["announce:"]=1
][0];
[$self._assert_equals_(counter,(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$recv(announcer)._announce_([$recv($globals.SystemAnnouncement)._new()
,$ctx1.sendIdx["new"]=3
][0])
,$ctx1.sendIdx["announce:"]=2
][0];
[$self._assert_equals_(counter,(2))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$recv(announcer)._unsubscribe_(self);
$recv(announcer)._announce_($recv($globals.SystemAnnouncement)._new());
$self._assert_equals_(counter,(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDoFor",{counter:counter,announcer:announcer})});
}; }),
$globals.AnnouncerTest);

$core.addMethod(
$core.method({
selector: "testOnDoOnce",
protocol: "tests",
args: [],
source: "testOnDoOnce\x0a\x09| counter announcer |\x0a\x09\x0a\x09counter := 0.\x0a\x09announcer := Announcer new.\x0a\x09announcer on: SystemAnnouncement doOnce: [ counter := counter + 1 ].\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.\x0a\x0a\x09announcer announce: (SystemAnnouncement new).\x0a\x09self assert: counter equals: 1.",
referencedClasses: ["Announcer", "SystemAnnouncement"],
pragmas: [],
messageSends: ["new", "on:doOnce:", "+", "announce:", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var counter,announcer;
return $core.withContext(function($ctx1) {
counter=(0);
announcer=[$recv($globals.Announcer)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv(announcer)._on_doOnce_($globals.SystemAnnouncement,(function(){
return $core.withContext(function($ctx2) {
counter=$recv(counter).__plus((1));
return counter;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
[$recv(announcer)._announce_([$recv($globals.SystemAnnouncement)._new()
,$ctx1.sendIdx["new"]=2
][0])
,$ctx1.sendIdx["announce:"]=1
][0];
[$self._assert_equals_(counter,(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(announcer)._announce_($recv($globals.SystemAnnouncement)._new());
$self._assert_equals_(counter,(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDoOnce",{counter:counter,announcer:announcer})});
}; }),
$globals.AnnouncerTest);



$core.addClass("BlockClosureTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "localReturnOnDoCatch",
protocol: "fixture",
args: [],
source: "localReturnOnDoCatch\x0a    [ ^ 2 ] on: Error do: [].\x0a    ^ 3",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["on:do:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv((function(){
throw $early=[(2)];

}))._on_do_($globals.Error,(function(){

}));
return (3);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"localReturnOnDoCatch",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "localReturnOnDoMiss",
protocol: "fixture",
args: [],
source: "localReturnOnDoMiss\x0a    [ ^ 2 ] on: Class do: [].\x0a    ^ 3",
referencedClasses: ["Class"],
pragmas: [],
messageSends: ["on:do:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv((function(){
throw $early=[(2)];

}))._on_do_($globals.Class,(function(){

}));
return (3);
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"localReturnOnDoMiss",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCanClearInterval",
protocol: "tests",
args: [],
source: "testCanClearInterval\x0a\x09self shouldnt: [ ([ Error new signal ] valueWithInterval: 0) clearInterval ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["shouldnt:raise:", "clearInterval", "valueWithInterval:", "signal", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._valueWithInterval_((0)))._clearInterval();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCanClearInterval",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCanClearTimeout",
protocol: "tests",
args: [],
source: "testCanClearTimeout\x0a\x09self shouldnt: [ ([ Error new signal ] valueWithTimeout: 0) clearTimeout ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["shouldnt:raise:", "clearTimeout", "valueWithTimeout:", "signal", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._valueWithTimeout_((0)))._clearTimeout();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCanClearTimeout",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCompiledSource",
protocol: "tests",
args: [],
source: "testCompiledSource\x0a\x09self assert: ([ 1+1 ] compiledSource includesSubString: 'function')",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "includesSubString:", "compiledSource", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv((function(){
return $core.withContext(function($ctx2) {
return (1).__plus((1));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._compiledSource())._includesSubString_("function"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCompiledSource",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testCurrySelf",
protocol: "tests",
args: [],
source: "testCurrySelf\x0a\x09| curriedMethod array |\x0a\x09curriedMethod := [ :selfarg :x | selfarg at: x ] currySelf asCompiledMethod: 'foo:'.\x0a\x09curriedMethod protocol: '**test helper'.\x0a\x09array := #(3 1 4).\x0a\x09Array addCompiledMethod: curriedMethod.\x0a\x09[ self assert: (array foo: 2) equals: 1 ]\x0a\x09ensure: [ Array removeCompiledMethod: curriedMethod ]",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["asCompiledMethod:", "currySelf", "at:", "protocol:", "addCompiledMethod:", "ensure:", "assert:equals:", "foo:", "removeCompiledMethod:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var curriedMethod,array;
return $core.withContext(function($ctx1) {
curriedMethod=$recv($recv((function(selfarg,x){
return $core.withContext(function($ctx2) {
return $recv(selfarg)._at_(x);
}, function($ctx2) {$ctx2.fillBlock({selfarg:selfarg,x:x},$ctx1,1)});
}))._currySelf())._asCompiledMethod_("foo:");
$recv(curriedMethod)._protocol_("**test helper");
array=[(3), (1), (4)];
$recv($globals.Array)._addCompiledMethod_(curriedMethod);
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv(array)._foo_((2)),(1));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Array)._removeCompiledMethod_(curriedMethod);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCurrySelf",{curriedMethod:curriedMethod,array:array})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testEnsure",
protocol: "tests",
args: [],
source: "testEnsure\x0a\x09self assert: ([ 3 ] ensure: [ 4 ]) equals: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "ensure:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv((function(){
return (3);

}))._ensure_((function(){
return (4);

})),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEnsure",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testEnsureRaises",
protocol: "tests",
args: [],
source: "testEnsureRaises\x0a\x09self should: [ [Error new signal ] ensure: [ true ]] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "ensure:", "signal", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._ensure_((function(){
return true;

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testEnsureRaises",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testExceptionSemantics",
protocol: "tests",
args: [],
source: "testExceptionSemantics\x0a\x09\x22See https://lolg.it/amber/amber/issues/314\x22\x0a\x09self timeout: 100.\x0a\x09\x0a\x09(self async: [\x0a\x09\x09[\x0a\x09\x09\x09self assert: true.\x0a\x09\x09\x09Error signal.\x0a\x09\x09\x09\x22The following should *not* be run\x22\x0a\x09\x09\x09self deny: true.\x0a\x09\x09\x09self finished.\x0a\x09\x09] on: Error do: [ :ex | self finished ]\x0a\x09]) valueWithTimeout: 0",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "on:do:", "assert:", "signal", "deny:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._timeout_((100));
$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
$self._assert_(true);
$recv($globals.Error)._signal();
$self._deny_(true);
return [$self._finished()
,$ctx3.sendIdx["finished"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._on_do_($globals.Error,(function(ex){
return $core.withContext(function($ctx3) {
return $self._finished();
}, function($ctx3) {$ctx3.fillBlock({ex:ex},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testExceptionSemantics",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testLocalReturnOnDoCatch",
protocol: "tests",
args: [],
source: "testLocalReturnOnDoCatch\x0a\x09self assert: self localReturnOnDoCatch equals: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "localReturnOnDoCatch"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($self._localReturnOnDoCatch(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLocalReturnOnDoCatch",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testLocalReturnOnDoMiss",
protocol: "tests",
args: [],
source: "testLocalReturnOnDoMiss\x0a\x09self assert: self localReturnOnDoMiss equals: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "localReturnOnDoMiss"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($self._localReturnOnDoMiss(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLocalReturnOnDoMiss",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testNewWithValues",
protocol: "tests",
args: [],
source: "testNewWithValues\x0a<inlineJS: '\x0a\x09function TestConstructor(arg1, arg2, arg3) {}\x0a\x09TestConstructor.prototype.name = \x22theTestPrototype\x22;\x0a\x0a\x09var wrappedConstructor = $recv(TestConstructor);\x0a\x09var result = wrappedConstructor._newWithValues_([1, 2, 3]);\x0a\x09$self._assert_(result instanceof TestConstructor);\x0a\x09$self._assert_equals_(result.name, \x22theTestPrototype\x22);\x0a\x0a\x09/* newWithValues: cannot help if the argument list is wrong, and should warn that a mistake was made. */\x0a\x09$self._should_raise_(function () {wrappedConstructor._newWithValues_(\x22single argument\x22);}, $globals.Error);\x0a'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09function TestConstructor(arg1, arg2, arg3) {}\x0a\x09TestConstructor.prototype.name = \x22theTestPrototype\x22;\x0a\x0a\x09var wrappedConstructor = $recv(TestConstructor);\x0a\x09var result = wrappedConstructor._newWithValues_([1, 2, 3]);\x0a\x09$self._assert_(result instanceof TestConstructor);\x0a\x09$self._assert_equals_(result.name, \x22theTestPrototype\x22);\x0a\x0a\x09/* newWithValues: cannot help if the argument list is wrong, and should warn that a mistake was made. */\x0a\x09$self._should_raise_(function () {wrappedConstructor._newWithValues_(\x22single argument\x22);}, $globals.Error);"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

	function TestConstructor(arg1, arg2, arg3) {}
	TestConstructor.prototype.name = "theTestPrototype";

	var wrappedConstructor = $recv(TestConstructor);
	var result = wrappedConstructor._newWithValues_([1, 2, 3]);
	$self._assert_(result instanceof TestConstructor);
	$self._assert_equals_(result.name, "theTestPrototype");

	/* newWithValues: cannot help if the argument list is wrong, and should warn that a mistake was made. */
	$self._should_raise_(function () {wrappedConstructor._newWithValues_("single argument");}, $globals.Error);;
return self;
}, function($ctx1) {$ctx1.fill(self,"testNewWithValues",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testNumArgs",
protocol: "tests",
args: [],
source: "testNumArgs\x0a\x09self assert: [] numArgs equals: 0.\x0a\x09self assert: [ :a :b | ] numArgs equals: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "numArgs"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv((function(){

}))._numArgs()
,$ctx1.sendIdx["numArgs"]=1
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv((function(a,b){

}))._numArgs(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNumArgs",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testOnDo",
protocol: "tests",
args: [],
source: "testOnDo\x0a\x09self assert: ([ Error new signal ] on: Error do: [ :ex | true ])",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["assert:", "on:do:", "signal", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Error)._new())._signal();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(ex){
return true;

})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOnDo",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testValue",
protocol: "tests",
args: [],
source: "testValue\x0a\x09self assert: ([ 1+1 ] value) equals: 2.\x0a\x09self assert: ([ :x | x +1 ] value: 2) equals: 3.\x0a\x09self assert: ([ :x :y | x*y ] value: 2 value: 4) equals: 8.\x0a\x0a\x09\x22Arguments are optional in Amber. This isn't ANSI compliant.\x22\x0a\x0a\x09self assert: ([ :a :b :c | 1 ] value) equals: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "value", "+", "value:", "value:value:", "*"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv((function(){
return $core.withContext(function($ctx2) {
return [(1).__plus((1))
,$ctx2.sendIdx["+"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._value()
,$ctx1.sendIdx["value"]=1
][0],(2))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv((function(x){
return $core.withContext(function($ctx2) {
return $recv(x).__plus((1));
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,2)});
}))._value_((2)),(3))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_($recv((function(x,y){
return $core.withContext(function($ctx2) {
return $recv(x).__star(y);
}, function($ctx2) {$ctx2.fillBlock({x:x,y:y},$ctx1,3)});
}))._value_value_((2),(4)),(8))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv((function(a,b,c){
return (1);

}))._value(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testValueWithPossibleArguments",
protocol: "tests",
args: [],
source: "testValueWithPossibleArguments\x0a\x09self assert: ([ 1 ] valueWithPossibleArguments: #(3 4)) equals: 1.\x0a\x09self assert: ([ :a | a + 4 ] valueWithPossibleArguments: #(3 4)) equals: 7.\x0a\x09self assert: ([ :a :b | a + b ] valueWithPossibleArguments: #(3 4 5)) equals: 7.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "valueWithPossibleArguments:", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv((function(){
return (1);

}))._valueWithPossibleArguments_([(3), (4)])
,$ctx1.sendIdx["valueWithPossibleArguments:"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv((function(a){
return $core.withContext(function($ctx2) {
return [$recv(a).__plus((4))
,$ctx2.sendIdx["+"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({a:a},$ctx1,2)});
}))._valueWithPossibleArguments_([(3), (4)])
,$ctx1.sendIdx["valueWithPossibleArguments:"]=2
][0],(7))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv((function(a,b){
return $core.withContext(function($ctx2) {
return $recv(a).__plus(b);
}, function($ctx2) {$ctx2.fillBlock({a:a,b:b},$ctx1,3)});
}))._valueWithPossibleArguments_([(3), (4), (5)]),(7));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValueWithPossibleArguments",{})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testWhileFalse",
protocol: "tests",
args: [],
source: "testWhileFalse\x0a\x09| i |\x0a\x09i := 0.\x0a\x09[ i > 5 ] whileFalse: [ i := i + 1 ].\x0a\x09self assert: i equals: 6.\x0a\x0a\x09i := 0.\x0a\x09[ i := i + 1. i > 5 ] whileFalse.\x0a\x09self assert: i equals: 6",
referencedClasses: [],
pragmas: [],
messageSends: ["whileFalse:", ">", "+", "assert:equals:", "whileFalse"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var i;
return $core.withContext(function($ctx1) {
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
return [$recv(i).__gt((5))
,$ctx2.sendIdx[">"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
i=[$recv(i).__plus((1))
,$ctx2.sendIdx["+"]=1
][0];
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
[$self._assert_equals_(i,(6))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
return $recv(i).__gt((5));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileFalse();
$self._assert_equals_(i,(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testWhileFalse",{i:i})});
}; }),
$globals.BlockClosureTest);

$core.addMethod(
$core.method({
selector: "testWhileTrue",
protocol: "tests",
args: [],
source: "testWhileTrue\x0a\x09| i |\x0a\x09i := 0.\x0a\x09[ i < 5 ] whileTrue: [ i := i + 1 ].\x0a\x09self assert: i equals: 5.\x0a\x0a\x09i := 0.\x0a\x09[ i := i + 1. i < 5 ] whileTrue.\x0a\x09self assert: i equals: 5",
referencedClasses: [],
pragmas: [],
messageSends: ["whileTrue:", "<", "+", "assert:equals:", "whileTrue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var i;
return $core.withContext(function($ctx1) {
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
return [$recv(i).__lt((5))
,$ctx2.sendIdx["<"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
i=[$recv(i).__plus((1))
,$ctx2.sendIdx["+"]=1
][0];
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
[$self._assert_equals_(i,(5))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
i=(0);
$recv((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
return $recv(i).__lt((5));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._whileTrue();
$self._assert_equals_(i,(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testWhileTrue",{i:i})});
}; }),
$globals.BlockClosureTest);



$core.addClass("BooleanTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testEquality",
protocol: "tests",
args: [],
source: "testEquality\x0a\x09\x22We're on top of JS...just be sure to check the basics!\x22\x0a\x0a\x09self deny: 0 = false.\x0a\x09self deny: false = 0.\x0a\x09self deny: '' = false.\x0a\x09self deny: false = ''.\x0a\x0a\x09self assert: (true = true).\x0a\x09self deny: false = true.\x0a\x09self deny: true = false.\x0a\x09self assert: (false = false).\x0a\x0a\x09\x22JS may do some type coercing after sending a message\x22\x0a\x09self assert: (true yourself = true).\x0a\x09self assert: (true yourself = true yourself)",
referencedClasses: [],
pragmas: [],
messageSends: ["deny:", "=", "assert:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._deny_([(0).__eq(false)
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_([false.__eq((0))
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._deny_(["".__eq(false)
,$ctx1.sendIdx["="]=3
][0])
,$ctx1.sendIdx["deny:"]=3
][0];
[$self._deny_([false.__eq("")
,$ctx1.sendIdx["="]=4
][0])
,$ctx1.sendIdx["deny:"]=4
][0];
[$self._assert_([true.__eq(true)
,$ctx1.sendIdx["="]=5
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_([false.__eq(true)
,$ctx1.sendIdx["="]=6
][0])
,$ctx1.sendIdx["deny:"]=5
][0];
$self._deny_([true.__eq(false)
,$ctx1.sendIdx["="]=7
][0]);
[$self._assert_([false.__eq(false)
,$ctx1.sendIdx["="]=8
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_([$recv([true._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]).__eq(true)
,$ctx1.sendIdx["="]=9
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
$self._assert_($recv([true._yourself()
,$ctx1.sendIdx["yourself"]=2
][0]).__eq(true._yourself()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{})});
}; }),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: "tests",
args: [],
source: "testIdentity\x0a\x09\x22We're on top of JS...just be sure to check the basics!\x22\x0a\x0a\x09self deny: 0 == false.\x0a\x09self deny: false == 0.\x0a\x09self deny: '' == false.\x0a\x09self deny: false == ''.\x0a\x0a\x09self assert: true == true.\x0a\x09self deny: false == true.\x0a\x09self deny: true == false.\x0a\x09self assert: false == false.\x0a\x0a\x09\x22JS may do some type coercing after sending a message\x22\x0a\x09self assert: true yourself == true.\x0a\x09self assert: true yourself == true yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["deny:", "==", "assert:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._deny_([(0).__eq_eq(false)
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_([false.__eq_eq((0))
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._deny_(["".__eq_eq(false)
,$ctx1.sendIdx["=="]=3
][0])
,$ctx1.sendIdx["deny:"]=3
][0];
[$self._deny_([false.__eq_eq("")
,$ctx1.sendIdx["=="]=4
][0])
,$ctx1.sendIdx["deny:"]=4
][0];
[$self._assert_([true.__eq_eq(true)
,$ctx1.sendIdx["=="]=5
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_([false.__eq_eq(true)
,$ctx1.sendIdx["=="]=6
][0])
,$ctx1.sendIdx["deny:"]=5
][0];
$self._deny_([true.__eq_eq(false)
,$ctx1.sendIdx["=="]=7
][0]);
[$self._assert_([false.__eq_eq(false)
,$ctx1.sendIdx["=="]=8
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_([$recv([true._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]).__eq_eq(true)
,$ctx1.sendIdx["=="]=9
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
$self._assert_($recv([true._yourself()
,$ctx1.sendIdx["yourself"]=2
][0]).__eq_eq(true._yourself()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{})});
}; }),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testIfTrueIfFalse",
protocol: "tests",
args: [],
source: "testIfTrueIfFalse\x0a\x0a\x09self assert: (true ifTrue: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x09self assert: (true ifFalse: [ 'alternative block' ]) equals: nil.\x0a\x0a\x09self assert: (false ifTrue: [ 'alternative block' ]) equals: nil.\x0a\x09self assert: (false ifFalse: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (false ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block2'.\x0a\x09self assert: (false ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (true ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x09self assert: (true ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block2'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "ifTrue:", "ifFalse:", "ifTrue:ifFalse:", "ifFalse:ifTrue:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
if($core.assert(true)){
$1="alternative block";
}
[$self._assert_equals_($1,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
if(!$core.assert(true)){
$2="alternative block";
}
[$self._assert_equals_($2,nil)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
if($core.assert(false)){
$3="alternative block";
}
[$self._assert_equals_($3,nil)
,$ctx1.sendIdx["assert:equals:"]=3
][0];
if(!$core.assert(false)){
$4="alternative block";
}
[$self._assert_equals_($4,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=4
][0];
if($core.assert(false)){
$5="alternative block";
} else {
$5="alternative block2";
}
[$self._assert_equals_($5,"alternative block2")
,$ctx1.sendIdx["assert:equals:"]=5
][0];
if($core.assert(false)){
$6="alternative block2";
} else {
$6="alternative block";
}
[$self._assert_equals_($6,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=6
][0];
if($core.assert(true)){
$7="alternative block";
} else {
$7="alternative block2";
}
[$self._assert_equals_($7,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=7
][0];
if($core.assert(true)){
$8="alternative block2";
} else {
$8="alternative block";
}
$self._assert_equals_($8,"alternative block2");
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfTrueIfFalse",{})});
}; }),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testIfTrueIfFalseWithBoxing",
protocol: "tests",
args: [],
source: "testIfTrueIfFalseWithBoxing\x0a\x0a\x09self assert: (true yourself ifTrue: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x09self assert: (true yourself ifFalse: [ 'alternative block' ]) equals: nil.\x0a\x0a\x09self assert: (false yourself ifTrue: [ 'alternative block' ]) equals: nil.\x0a\x09self assert: (false yourself ifFalse: [ 'alternative block' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (false yourself ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block2'.\x0a\x09self assert: (false yourself ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x0a\x09self assert: (true yourself ifTrue: [ 'alternative block' ] ifFalse: [ 'alternative block2' ]) equals: 'alternative block'.\x0a\x09self assert: (true yourself ifFalse: [ 'alternative block' ] ifTrue: [ 'alternative block2' ]) equals: 'alternative block2'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "ifTrue:", "yourself", "ifFalse:", "ifTrue:ifFalse:", "ifFalse:ifTrue:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
if($core.assert([true._yourself()
,$ctx1.sendIdx["yourself"]=1
][0])){
$1="alternative block";
}
[$self._assert_equals_($1,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
if(!$core.assert([true._yourself()
,$ctx1.sendIdx["yourself"]=2
][0])){
$2="alternative block";
}
[$self._assert_equals_($2,nil)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
if($core.assert([false._yourself()
,$ctx1.sendIdx["yourself"]=3
][0])){
$3="alternative block";
}
[$self._assert_equals_($3,nil)
,$ctx1.sendIdx["assert:equals:"]=3
][0];
if(!$core.assert([false._yourself()
,$ctx1.sendIdx["yourself"]=4
][0])){
$4="alternative block";
}
[$self._assert_equals_($4,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=4
][0];
if($core.assert([false._yourself()
,$ctx1.sendIdx["yourself"]=5
][0])){
$5="alternative block";
} else {
$5="alternative block2";
}
[$self._assert_equals_($5,"alternative block2")
,$ctx1.sendIdx["assert:equals:"]=5
][0];
if($core.assert([false._yourself()
,$ctx1.sendIdx["yourself"]=6
][0])){
$6="alternative block2";
} else {
$6="alternative block";
}
[$self._assert_equals_($6,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=6
][0];
if($core.assert([true._yourself()
,$ctx1.sendIdx["yourself"]=7
][0])){
$7="alternative block";
} else {
$7="alternative block2";
}
[$self._assert_equals_($7,"alternative block")
,$ctx1.sendIdx["assert:equals:"]=7
][0];
if($core.assert(true._yourself())){
$8="alternative block2";
} else {
$8="alternative block";
}
$self._assert_equals_($8,"alternative block2");
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfTrueIfFalseWithBoxing",{})});
}; }),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testLogic",
protocol: "tests",
args: [],
source: "testLogic\x0a\x09\x22Trivial logic table\x22\x0a\x09self assert: (true & true);\x0a\x09\x09deny: (true & false);\x0a\x09\x09deny: (false & true);\x0a\x09\x09deny: (false & false).\x0a\x09self assert: (true | true);\x0a\x09\x09assert: (true | false);\x0a\x09\x09assert: (false | true);\x0a\x09\x09deny: (false | false).\x0a\x09\x22Checking that expressions work fine too\x22\x0a\x09self assert: (true & (1 > 0));\x0a\x09\x09deny: ((1 > 0) & false);\x0a\x09\x09deny: ((1 > 0) & (1 > 2)).\x0a\x09self assert: (false | (1 > 0));\x0a\x09\x09assert: ((1 > 0) | false);\x0a\x09\x09assert: ((1 > 0) | (1 > 2))",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "&", "deny:", "|", ">"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([true.__and(true)
,$ctx1.sendIdx["&"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_([true.__and(false)
,$ctx1.sendIdx["&"]=2
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_([false.__and(true)
,$ctx1.sendIdx["&"]=3
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._deny_([false.__and(false)
,$ctx1.sendIdx["&"]=4
][0])
,$ctx1.sendIdx["deny:"]=3
][0];
[$self._assert_([true.__or(true)
,$ctx1.sendIdx["|"]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_([true.__or(false)
,$ctx1.sendIdx["|"]=2
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
[$self._assert_([false.__or(true)
,$ctx1.sendIdx["|"]=3
][0])
,$ctx1.sendIdx["assert:"]=4
][0];
[$self._deny_([false.__or(false)
,$ctx1.sendIdx["|"]=4
][0])
,$ctx1.sendIdx["deny:"]=4
][0];
[$self._assert_([true.__and([(1).__gt((0))
,$ctx1.sendIdx[">"]=1
][0])
,$ctx1.sendIdx["&"]=5
][0])
,$ctx1.sendIdx["assert:"]=5
][0];
[$self._deny_([$recv([(1).__gt((0))
,$ctx1.sendIdx[">"]=2
][0]).__and(false)
,$ctx1.sendIdx["&"]=6
][0])
,$ctx1.sendIdx["deny:"]=5
][0];
$self._deny_($recv([(1).__gt((0))
,$ctx1.sendIdx[">"]=3
][0]).__and([(1).__gt((2))
,$ctx1.sendIdx[">"]=4
][0]));
[$self._assert_([false.__or([(1).__gt((0))
,$ctx1.sendIdx[">"]=5
][0])
,$ctx1.sendIdx["|"]=5
][0])
,$ctx1.sendIdx["assert:"]=6
][0];
[$self._assert_([$recv([(1).__gt((0))
,$ctx1.sendIdx[">"]=6
][0]).__or(false)
,$ctx1.sendIdx["|"]=6
][0])
,$ctx1.sendIdx["assert:"]=7
][0];
$self._assert_($recv([(1).__gt((0))
,$ctx1.sendIdx[">"]=7
][0]).__or((1).__gt((2))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLogic",{})});
}; }),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testLogicKeywords",
protocol: "tests",
args: [],
source: "testLogicKeywords\x0a\x09\x22Trivial logic table\x22\x0a\x09self\x0a\x09\x09assert: (true and: [ true ]);\x0a\x09\x09deny: (true and: [ false ]);\x0a\x09\x09deny: (false and: [ true ]);\x0a\x09\x09deny: (false and: [ false ]).\x0a\x09self\x0a\x09\x09assert: (true or: [ true ]);\x0a\x09\x09assert: (true or: [ false ]);\x0a\x09\x09assert: (false or: [ true ]);\x0a\x09\x09deny: (false or: [ false ]).\x0a\x09\x09\x0a\x09\x22Checking that expressions work fine too\x22\x0a\x09self\x0a\x09\x09assert: (true and: [ 1 > 0 ]);\x0a\x09\x09deny: ((1 > 0) and: [ false ]);\x0a\x09\x09deny: ((1 > 0) and: [ 1 > 2 ]).\x0a\x09self\x0a\x09\x09assert: (false or: [ 1 > 0 ]);\x0a\x09\x09assert: ((1 > 0) or: [ false ]);\x0a\x09\x09assert: ((1 > 0) or: [ 1 > 2 ])",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "and:", "deny:", "or:", ">"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12,$13,$14;
if($core.assert(true)){
$1=true;
} else {
$1=false;
}
[$self._assert_($1)
,$ctx1.sendIdx["assert:"]=1
][0];
if($core.assert(true)){
$2=false;
} else {
$2=false;
}
[$self._deny_($2)
,$ctx1.sendIdx["deny:"]=1
][0];
if($core.assert(false)){
$3=true;
} else {
$3=false;
}
[$self._deny_($3)
,$ctx1.sendIdx["deny:"]=2
][0];
if($core.assert(false)){
$4=false;
} else {
$4=false;
}
[$self._deny_($4)
,$ctx1.sendIdx["deny:"]=3
][0];
if($core.assert(true)){
$5=true;
} else {
$5=true;
}
[$self._assert_($5)
,$ctx1.sendIdx["assert:"]=2
][0];
if($core.assert(true)){
$6=true;
} else {
$6=false;
}
[$self._assert_($6)
,$ctx1.sendIdx["assert:"]=3
][0];
if($core.assert(false)){
$7=true;
} else {
$7=true;
}
[$self._assert_($7)
,$ctx1.sendIdx["assert:"]=4
][0];
if($core.assert(false)){
$8=true;
} else {
$8=false;
}
[$self._deny_($8)
,$ctx1.sendIdx["deny:"]=4
][0];
if($core.assert(true)){
$9=[(1).__gt((0))
,$ctx1.sendIdx[">"]=1
][0];
} else {
$9=false;
}
[$self._assert_($9)
,$ctx1.sendIdx["assert:"]=5
][0];
if($core.assert([(1).__gt((0))
,$ctx1.sendIdx[">"]=2
][0])){
$10=false;
} else {
$10=false;
}
[$self._deny_($10)
,$ctx1.sendIdx["deny:"]=5
][0];
if($core.assert([(1).__gt((0))
,$ctx1.sendIdx[">"]=3
][0])){
$11=[(1).__gt((2))
,$ctx1.sendIdx[">"]=4
][0];
} else {
$11=false;
}
$self._deny_($11);
if($core.assert(false)){
$12=true;
} else {
$12=[(1).__gt((0))
,$ctx1.sendIdx[">"]=5
][0];
}
[$self._assert_($12)
,$ctx1.sendIdx["assert:"]=6
][0];
if($core.assert([(1).__gt((0))
,$ctx1.sendIdx[">"]=6
][0])){
$13=true;
} else {
$13=false;
}
[$self._assert_($13)
,$ctx1.sendIdx["assert:"]=7
][0];
if($core.assert([(1).__gt((0))
,$ctx1.sendIdx[">"]=7
][0])){
$14=true;
} else {
$14=(1).__gt((2));
}
$self._assert_($14);
return self;
}, function($ctx1) {$ctx1.fill(self,"testLogicKeywords",{})});
}; }),
$globals.BooleanTest);

$core.addMethod(
$core.method({
selector: "testNonBooleanError",
protocol: "tests",
args: [],
source: "testNonBooleanError\x0a\x09self should: [ '' ifTrue: [] ifFalse: [] ] raise: NonBooleanReceiver",
referencedClasses: ["NonBooleanReceiver"],
pragmas: [],
messageSends: ["should:raise:", "ifTrue:ifFalse:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
if($core.assert("")){
return nil;
} else {
return nil;
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.NonBooleanReceiver);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonBooleanError",{})});
}; }),
$globals.BooleanTest);



$core.addClass("ClassBuilderTest", $globals.TestCase, "Kernel-Tests");
$core.setSlots($globals.ClassBuilderTest, ["builder", "theClass"]);
$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp\x0a\x09builder := ClassBuilder new",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.builder=$recv($globals.ClassBuilder)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: "running",
args: [],
source: "tearDown\x0a\x09self tearDownTheClass.\x0a\x09theClass ifNotNil: [\x0a\x09\x09self deny: (theClass package classes includes: theClass).\x0a\x09\x09self assert: (Smalltalk globals at: theClass name) equals: nil ]",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["tearDownTheClass", "ifNotNil:", "deny:", "includes:", "classes", "package", "assert:equals:", "at:", "globals", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self._tearDownTheClass();
$1=$self.theClass;
if($1 == null || $1.a$nil){
$1;
} else {
$self._deny_($recv($recv($recv($self.theClass)._package())._classes())._includes_($self.theClass));
$self._assert_equals_($recv($recv($globals.Smalltalk)._globals())._at_($recv($self.theClass)._name()),nil);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testAddTrait",
protocol: "tests",
args: [],
source: "testAddTrait\x0a\x09theClass := builder addTraitNamed: 'ObjectMock2' package: 'Kernel-Tests'.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: (theClass package classes occurrencesOf: theClass) equals: 1.\x0a\x09self assert: theClass package equals: ObjectMock package",
referencedClasses: ["ObjectMock"],
pragmas: [],
messageSends: ["addTraitNamed:package:", "assert:equals:", "name", "occurrencesOf:", "classes", "package"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._addTraitNamed_package_("ObjectMock2","Kernel-Tests");
[$self._assert_equals_($recv($self.theClass)._name(),"ObjectMock2")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($recv([$recv($self.theClass)._package()
,$ctx1.sendIdx["package"]=1
][0])._classes())._occurrencesOf_($self.theClass),(1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([$recv($self.theClass)._package()
,$ctx1.sendIdx["package"]=2
][0],$recv($globals.ObjectMock)._package());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddTrait",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassCopy",
protocol: "tests",
args: [],
source: "testClassCopy\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: theClass isClassCopyOf: ObjectMock",
referencedClasses: ["ObjectMock"],
pragmas: [],
messageSends: ["copyClass:named:", "assert:equals:", "name", "assert:isClassCopyOf:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$self._assert_equals_($recv($self.theClass)._name(),"ObjectMock2");
$self._assert_isClassCopyOf_($self.theClass,$globals.ObjectMock);
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassCopy",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassMigration",
protocol: "tests",
args: [],
source: "testClassMigration\x0a\x09| instance oldClass |\x0a\x09\x0a\x09oldClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09instance := (Smalltalk globals at: 'ObjectMock2') new.\x0a\x09\x0a\x09\x22Change the superclass of ObjectMock2\x22\x0a\x09theClass := ObjectMock subclass: #ObjectMock2\x0a\x09\x09instanceVariableNames: ''\x0a\x09\x09package: 'Kernel-Tests'.\x0a\x09\x0a\x09self deny: oldClass == ObjectMock2.\x0a\x09\x0a\x09self assert: ObjectMock2 superclass == ObjectMock.\x0a\x09self assert: ObjectMock2 slots isEmpty.\x0a\x09self assert: ObjectMock2 selectors equals: oldClass selectors.\x0a\x09self assert: ObjectMock2 comment equals: oldClass comment.\x0a\x09self assert: ObjectMock2 package name equals: 'Kernel-Tests'.\x0a\x09self assert: (ObjectMock2 package classes includes: ObjectMock2).\x0a\x09\x0a\x09self deny: instance class == ObjectMock2.\x0a\x09\x0a\x09self assert: (Smalltalk globals at: instance class name) isNil",
referencedClasses: ["ObjectMock", "Smalltalk", "ObjectMock2"],
pragmas: [],
messageSends: ["copyClass:named:", "new", "at:", "globals", "subclass:instanceVariableNames:package:", "deny:", "==", "assert:", "superclass", "isEmpty", "slots", "assert:equals:", "selectors", "comment", "name", "package", "includes:", "classes", "class", "isNil"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,oldClass;
return $core.withContext(function($ctx1) {
oldClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
instance=$recv([$recv([$recv($globals.Smalltalk)._globals()
,$ctx1.sendIdx["globals"]=1
][0])._at_("ObjectMock2")
,$ctx1.sendIdx["at:"]=1
][0])._new();
$self.theClass=$recv($globals.ObjectMock)._subclass_instanceVariableNames_package_("ObjectMock2","","Kernel-Tests");
[$self._deny_([$recv(oldClass).__eq_eq($globals.ObjectMock2)
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_([$recv($recv($globals.ObjectMock2)._superclass()).__eq_eq($globals.ObjectMock)
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_($recv($recv($globals.ObjectMock2)._slots())._isEmpty())
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_equals_([$recv($globals.ObjectMock2)._selectors()
,$ctx1.sendIdx["selectors"]=1
][0],$recv(oldClass)._selectors())
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($globals.ObjectMock2)._comment()
,$ctx1.sendIdx["comment"]=1
][0],$recv(oldClass)._comment())
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([$recv([$recv($globals.ObjectMock2)._package()
,$ctx1.sendIdx["package"]=1
][0])._name()
,$ctx1.sendIdx["name"]=1
][0],"Kernel-Tests");
[$self._assert_($recv($recv($recv($globals.ObjectMock2)._package())._classes())._includes_($globals.ObjectMock2))
,$ctx1.sendIdx["assert:"]=3
][0];
$self._deny_($recv([$recv(instance)._class()
,$ctx1.sendIdx["class"]=1
][0]).__eq_eq($globals.ObjectMock2));
$self._assert_($recv($recv($recv($globals.Smalltalk)._globals())._at_($recv($recv(instance)._class())._name()))._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassMigration",{instance:instance,oldClass:oldClass})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassMigrationWithClassSlots",
protocol: "tests",
args: [],
source: "testClassMigrationWithClassSlots\x0a\x09\x0a\x09builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09ObjectMock2 class slots: #(foo  bar).\x0a\x09\x0a\x09\x22Change the superclass of ObjectMock2\x22\x0a\x09theClass := ObjectMock subclass: #ObjectMock2\x0a\x09\x09instanceVariableNames: ''\x0a\x09\x09package: 'Kernel-Tests'.\x0a\x09\x0a\x09self assert: ObjectMock2 class slots equals: #('foo' 'bar')",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["copyClass:named:", "slots:", "class", "subclass:instanceVariableNames:package:", "assert:equals:", "slots"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$recv([$recv($globals.ObjectMock2)._class()
,$ctx1.sendIdx["class"]=1
][0])._slots_(["foo", "bar"]);
$self.theClass=$recv($globals.ObjectMock)._subclass_instanceVariableNames_package_("ObjectMock2","","Kernel-Tests");
$self._assert_equals_($recv($recv($globals.ObjectMock2)._class())._slots(),["foo", "bar"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassMigrationWithClassSlots",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testClassMigrationWithSubclasses",
protocol: "tests",
args: [],
source: "testClassMigrationWithSubclasses\x0a\x09\x0a\x09builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09ObjectMock2 subclass: 'ObjectMock3' instanceVariableNames: '' package: 'Kernel-Tests'.\x0a\x09ObjectMock3 subclass: 'ObjectMock4' instanceVariableNames: '' package: 'Kernel-Tests'.\x0a\x09\x0a\x09\x22Change the superclass of ObjectMock2\x22\x0a\x09theClass := ObjectMock subclass: #ObjectMock2\x0a\x09\x09instanceVariableNames: ''\x0a\x09\x09package: 'Kernel-Tests'.\x0a\x09\x0a\x09self assert: ObjectMock subclasses equals: {ObjectMock2}.\x0a\x09self assert: ObjectMock2 subclasses equals: {ObjectMock3}.\x0a\x09self assert: ObjectMock3 subclasses equals: {ObjectMock4}",
referencedClasses: ["ObjectMock", "ObjectMock2", "ObjectMock3", "ObjectMock4"],
pragmas: [],
messageSends: ["copyClass:named:", "subclass:instanceVariableNames:package:", "assert:equals:", "subclasses"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
[$recv($globals.ObjectMock2)._subclass_instanceVariableNames_package_("ObjectMock3","","Kernel-Tests")
,$ctx1.sendIdx["subclass:instanceVariableNames:package:"]=1
][0];
[$recv($globals.ObjectMock3)._subclass_instanceVariableNames_package_("ObjectMock4","","Kernel-Tests")
,$ctx1.sendIdx["subclass:instanceVariableNames:package:"]=2
][0];
$self.theClass=$recv($globals.ObjectMock)._subclass_instanceVariableNames_package_("ObjectMock2","","Kernel-Tests");
[$self._assert_equals_([$recv($globals.ObjectMock)._subclasses()
,$ctx1.sendIdx["subclasses"]=1
][0],[$globals.ObjectMock2])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($globals.ObjectMock2)._subclasses()
,$ctx1.sendIdx["subclasses"]=2
][0],[$globals.ObjectMock3])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv($globals.ObjectMock3)._subclasses(),[$globals.ObjectMock4]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassMigrationWithSubclasses",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "testSubclass",
protocol: "tests",
args: [],
source: "testSubclass\x0a\x09theClass := builder addSubclassOf: ObjectMock named: 'ObjectMock2' slots: #(foo bar) package: 'Kernel-Tests'.\x0a\x09self assert: theClass superclass equals: ObjectMock.\x0a\x09self assert: theClass slots equals: #(foo bar).\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: (theClass package classes occurrencesOf: theClass) equals: 1.\x0a\x09self assert: theClass package equals: ObjectMock package.\x0a\x09self assert: theClass methodDictionary keys size equals: 0",
referencedClasses: ["ObjectMock"],
pragmas: [],
messageSends: ["addSubclassOf:named:slots:package:", "assert:equals:", "superclass", "slots", "name", "occurrencesOf:", "classes", "package", "size", "keys", "methodDictionary"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._addSubclassOf_named_slots_package_($globals.ObjectMock,"ObjectMock2",["foo", "bar"],"Kernel-Tests");
[$self._assert_equals_($recv($self.theClass)._superclass(),$globals.ObjectMock)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.theClass)._slots(),["foo", "bar"])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_($recv($self.theClass)._name(),"ObjectMock2")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_($recv($recv([$recv($self.theClass)._package()
,$ctx1.sendIdx["package"]=1
][0])._classes())._occurrencesOf_($self.theClass),(1))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_([$recv($self.theClass)._package()
,$ctx1.sendIdx["package"]=2
][0],$recv($globals.ObjectMock)._package())
,$ctx1.sendIdx["assert:equals:"]=5
][0];
$self._assert_equals_($recv($recv($recv($self.theClass)._methodDictionary())._keys())._size(),(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSubclass",{})});
}; }),
$globals.ClassBuilderTest);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.ClassBuilderTest);



$core.addClass("ClassTest", $globals.TestCase, "Kernel-Tests");
$core.setSlots($globals.ClassTest, ["builder", "theClass"]);
$core.addMethod(
$core.method({
selector: "augmentMethodInstantiationOf:withAttachments:",
protocol: "running",
args: ["aMethod", "aHashedCollection"],
source: "augmentMethodInstantiationOf: aMethod withAttachments: aHashedCollection\x0a\x09| plain |\x0a\x09plain := aMethod instantiateFn.\x0a\x09aMethod instantiateFn: [ :arg |\x0a\x09\x09(plain value: arg)\x0a\x09\x09\x09basicAt: 'a$atx' put: aHashedCollection;\x0a\x09\x09\x09yourself ]",
referencedClasses: [],
pragmas: [],
messageSends: ["instantiateFn", "instantiateFn:", "basicAt:put:", "value:", "yourself"]
}, function ($methodClass){ return function (aMethod,aHashedCollection){
var self=this,$self=this;
var plain;
return $core.withContext(function($ctx1) {
var $1;
plain=$recv(aMethod)._instantiateFn();
$recv(aMethod)._instantiateFn_((function(arg){
return $core.withContext(function($ctx2) {
$1=$recv(plain)._value_(arg);
$recv($1)._basicAt_put_("a$atx",aHashedCollection);
return $recv($1)._yourself();
}, function($ctx2) {$ctx2.fillBlock({arg:arg},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"augmentMethodInstantiationOf:withAttachments:",{aMethod:aMethod,aHashedCollection:aHashedCollection,plain:plain})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "jsConstructor",
protocol: "running",
args: [],
source: "jsConstructor\x0a\x09<inlineJS: '\x0a\x09\x09function Foo(){}\x0a\x09\x09Foo.prototype.valueOf = function () {return 4;};\x0a\x09\x09return Foo;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09function Foo(){}\x0a\x09\x09Foo.prototype.valueOf = function () {return 4;};\x0a\x09\x09return Foo;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		function Foo(){}
		Foo.prototype.valueOf = function () {return 4;};
		return Foo;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsConstructor",{})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "jsConstructorWithAction",
protocol: "running",
args: [],
source: "jsConstructorWithAction\x0a\x09<inlineJS: '\x0a\x09\x09function Foo(aFoo){this.foo = aFoo;}\x0a\x09\x09return Foo;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09function Foo(aFoo){this.foo = aFoo;}\x0a\x09\x09return Foo;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		function Foo(aFoo){this.foo = aFoo;}
		return Foo;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsConstructorWithAction",{})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp\x0a\x09builder := ClassBuilder new",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.builder=$recv($globals.ClassBuilder)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testAllSubclasses",
protocol: "tests",
args: [],
source: "testAllSubclasses\x0a\x09| subclasses index |\x0a\x0a\x09subclasses := Object subclasses.\x0a\x09index := 1.\x0a\x09[ index > subclasses size ]\x0a\x09\x09whileFalse: [ subclasses addAll: (subclasses at: index) subclasses.\x0a\x09\x09\x09index := index + 1 ].\x0a\x0a\x09self assert: Object allSubclasses equals: subclasses",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["subclasses", "whileFalse:", ">", "size", "addAll:", "at:", "+", "assert:equals:", "allSubclasses"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var subclasses,index;
return $core.withContext(function($ctx1) {
subclasses=[$recv($globals.Object)._subclasses()
,$ctx1.sendIdx["subclasses"]=1
][0];
index=(1);
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(index).__gt($recv(subclasses)._size());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._whileFalse_((function(){
return $core.withContext(function($ctx2) {
$recv(subclasses)._addAll_($recv($recv(subclasses)._at_(index))._subclasses());
index=$recv(index).__plus((1));
return index;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$self._assert_equals_($recv($globals.Object)._allSubclasses(),subclasses);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAllSubclasses",{subclasses:subclasses,index:index})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testAlternateConstructorViaSelector",
protocol: "tests",
args: [],
source: "testAlternateConstructorViaSelector\x0a\x09| instance block |\x0a\x09block := ObjectMock alternateConstructorViaSelector: #foo:.\x0a\x0a\x09instance := block newValue: 4.\x0a\x09self assert: instance class == ObjectMock.\x0a\x09self assert: instance foo equals: 4.\x0a\x09self shouldnt: [ instance foo: 9 ] raise: Error.\x0a\x09self assert: instance foo equals: 9",
referencedClasses: ["ObjectMock", "Error"],
pragmas: [],
messageSends: ["alternateConstructorViaSelector:", "newValue:", "assert:", "==", "class", "assert:equals:", "foo", "shouldnt:raise:", "foo:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,block;
return $core.withContext(function($ctx1) {
block=$recv($globals.ObjectMock)._alternateConstructorViaSelector_("foo:");
instance=$recv(block)._newValue_((4));
$self._assert_($recv($recv(instance)._class()).__eq_eq($globals.ObjectMock));
[$self._assert_equals_([$recv(instance)._foo()
,$ctx1.sendIdx["foo"]=1
][0],(4))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(instance)._foo_((9));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._assert_equals_($recv(instance)._foo(),(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAlternateConstructorViaSelector",{instance:instance,block:block})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testApplySuperConstructor",
protocol: "tests",
args: [],
source: "testApplySuperConstructor\x0a\x09| instance constructor |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09constructor := self jsConstructorWithAction.\x0a\x09theClass beJavaScriptSubclassOf: constructor.\x0a\x09Compiler new\x0a\x09\x09install: 'bar: anObject\x0a\x09\x09\x09ObjectMock2\x0a\x09\x09\x09\x09applySuperConstructorOn: self\x0a\x09\x09\x09\x09withArguments: {anObject}'\x0a\x09\x09forClass: theClass\x0a\x09\x09protocol: 'tests'.\x0a\x09\x22testing specific to late-coupled detached root class\x22\x0a\x09instance := (theClass alternateConstructorViaSelector: #bar:) newValue: 7.\x0a\x09self assert: instance class == theClass.\x0a\x09self assert: instance isJavaScriptInstanceOf: constructor.\x0a\x09self assert: instance foo equals: 7",
referencedClasses: ["ObjectMock", "Compiler"],
pragmas: [],
messageSends: ["copyClass:named:", "jsConstructorWithAction", "beJavaScriptSubclassOf:", "install:forClass:protocol:", "new", "newValue:", "alternateConstructorViaSelector:", "assert:", "==", "class", "assert:isJavaScriptInstanceOf:", "assert:equals:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,constructor;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
constructor=$self._jsConstructorWithAction();
$recv($self.theClass)._beJavaScriptSubclassOf_(constructor);
$recv($recv($globals.Compiler)._new())._install_forClass_protocol_("bar: anObject\x0a\x09\x09\x09ObjectMock2\x0a\x09\x09\x09\x09applySuperConstructorOn: self\x0a\x09\x09\x09\x09withArguments: {anObject}",$self.theClass,"tests");
instance=$recv($recv($self.theClass)._alternateConstructorViaSelector_("bar:"))._newValue_((7));
$self._assert_($recv($recv(instance)._class()).__eq_eq($self.theClass));
$self._assert_isJavaScriptInstanceOf_(instance,constructor);
$self._assert_equals_($recv(instance)._foo(),(7));
return self;
}, function($ctx1) {$ctx1.fill(self,"testApplySuperConstructor",{instance:instance,constructor:constructor})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testBeJavaScriptSubclassOf",
protocol: "tests",
args: [],
source: "testBeJavaScriptSubclassOf\x0a\x09| instance constructor |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09constructor := self jsConstructor.\x0a\x09theClass beJavaScriptSubclassOf: constructor.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: theClass isClassCopyOf: ObjectMock.\x0a\x09\x22testing specific to late-coupled detached root class\x22\x0a\x09instance := theClass new.\x0a\x09self assert: instance class == theClass.\x0a\x09self assert: instance isJavaScriptInstanceOf: constructor.\x0a\x09self assert: instance value equals: 4.\x0a\x09self shouldnt: [ instance foo: 9 ] raise: Error.\x0a\x09self assert: instance foo equals: 9",
referencedClasses: ["ObjectMock", "Error"],
pragmas: [],
messageSends: ["copyClass:named:", "jsConstructor", "beJavaScriptSubclassOf:", "assert:equals:", "name", "assert:isClassCopyOf:", "new", "assert:", "==", "class", "assert:isJavaScriptInstanceOf:", "value", "shouldnt:raise:", "foo:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,constructor;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
constructor=$self._jsConstructor();
$recv($self.theClass)._beJavaScriptSubclassOf_(constructor);
[$self._assert_equals_($recv($self.theClass)._name(),"ObjectMock2")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_isClassCopyOf_($self.theClass,$globals.ObjectMock);
instance=$recv($self.theClass)._new();
$self._assert_($recv($recv(instance)._class()).__eq_eq($self.theClass));
$self._assert_isJavaScriptInstanceOf_(instance,constructor);
[$self._assert_equals_($recv(instance)._value(),(4))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(instance)._foo_((9));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._assert_equals_($recv(instance)._foo(),(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBeJavaScriptSubclassOf",{instance:instance,constructor:constructor})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testMetaclassSubclasses",
protocol: "tests",
args: [],
source: "testMetaclassSubclasses\x0a\x09| subclasses |\x0a\x0a\x09subclasses := (Object class instanceClass subclasses \x0a\x09\x09select: [ :each | each isMetaclass not ])\x0a\x09\x09collect: [ :each | each theMetaClass ].\x0a\x0a\x09self assert: Object class subclasses equals: subclasses",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["collect:", "select:", "subclasses", "instanceClass", "class", "not", "isMetaclass", "theMetaClass", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var subclasses;
return $core.withContext(function($ctx1) {
subclasses=$recv($recv([$recv($recv([$recv($globals.Object)._class()
,$ctx1.sendIdx["class"]=1
][0])._instanceClass())._subclasses()
,$ctx1.sendIdx["subclasses"]=1
][0])._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._isMetaclass())._not();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._theMetaClass();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$self._assert_equals_($recv($recv($globals.Object)._class())._subclasses(),subclasses);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMetaclassSubclasses",{subclasses:subclasses})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testMethodAttachmentsAreAdded",
protocol: "tests",
args: [],
source: "testMethodAttachmentsAreAdded\x0a\x09| instance theMethod anObject |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09anObject := #{#foo -> 'oof'}.\x0a\x09theMethod := Compiler new\x0a\x09\x09compile: 'bar' forClass: ObjectMock2 protocol: '**test'.\x0a\x09self\x0a\x09\x09augmentMethodInstantiationOf: theMethod\x0a\x09\x09withAttachments: #{#a -> 42. #b -> anObject}.\x0a\x09ObjectMock2 addCompiledMethod: theMethod.\x0a\x09self assert: (ObjectMock2 new basicAt: #a) equals: 42.\x0a\x09self assert: (ObjectMock2 new basicAt: #b) equals: anObject",
referencedClasses: ["ObjectMock", "Compiler", "ObjectMock2"],
pragmas: [],
messageSends: ["copyClass:named:", "compile:forClass:protocol:", "new", "augmentMethodInstantiationOf:withAttachments:", "addCompiledMethod:", "assert:equals:", "basicAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,theMethod,anObject;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
anObject=$globals.HashedCollection._newFromPairs_(["foo","oof"]);
theMethod=$recv([$recv($globals.Compiler)._new()
,$ctx1.sendIdx["new"]=1
][0])._compile_forClass_protocol_("bar",$globals.ObjectMock2,"**test");
$self._augmentMethodInstantiationOf_withAttachments_(theMethod,$globals.HashedCollection._newFromPairs_(["a",(42),"b",anObject]));
$recv($globals.ObjectMock2)._addCompiledMethod_(theMethod);
[$self._assert_equals_([$recv([$recv($globals.ObjectMock2)._new()
,$ctx1.sendIdx["new"]=2
][0])._basicAt_("a")
,$ctx1.sendIdx["basicAt:"]=1
][0],(42))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv($recv($globals.ObjectMock2)._new())._basicAt_("b"),anObject);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMethodAttachmentsAreAdded",{instance:instance,theMethod:theMethod,anObject:anObject})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testMethodAttachmentsAreRemoved",
protocol: "tests",
args: [],
source: "testMethodAttachmentsAreRemoved\x0a\x09| instance theMethod anObject |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09anObject := #{#foo -> 'oof'}.\x0a\x09theMethod := Compiler new\x0a\x09\x09compile: 'bar' forClass: ObjectMock2 protocol: '**test'.\x0a\x09self\x0a\x09\x09augmentMethodInstantiationOf: theMethod\x0a\x09\x09withAttachments: #{#a -> 42. #b -> anObject}.\x0a\x09ObjectMock2 addCompiledMethod: theMethod.\x0a\x09theMethod := Compiler new\x0a\x09\x09compile: 'bar' forClass: ObjectMock2 protocol: '**test'.\x0a\x09ObjectMock2 addCompiledMethod: theMethod.\x0a\x09self assert: (ObjectMock2 new basicAt: #a) equals: nil.\x0a\x09self assert: (ObjectMock2 new basicAt: #b) equals: nil",
referencedClasses: ["ObjectMock", "Compiler", "ObjectMock2"],
pragmas: [],
messageSends: ["copyClass:named:", "compile:forClass:protocol:", "new", "augmentMethodInstantiationOf:withAttachments:", "addCompiledMethod:", "assert:equals:", "basicAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,theMethod,anObject;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
anObject=$globals.HashedCollection._newFromPairs_(["foo","oof"]);
theMethod=[$recv([$recv($globals.Compiler)._new()
,$ctx1.sendIdx["new"]=1
][0])._compile_forClass_protocol_("bar",$globals.ObjectMock2,"**test")
,$ctx1.sendIdx["compile:forClass:protocol:"]=1
][0];
$self._augmentMethodInstantiationOf_withAttachments_(theMethod,$globals.HashedCollection._newFromPairs_(["a",(42),"b",anObject]));
[$recv($globals.ObjectMock2)._addCompiledMethod_(theMethod)
,$ctx1.sendIdx["addCompiledMethod:"]=1
][0];
theMethod=$recv([$recv($globals.Compiler)._new()
,$ctx1.sendIdx["new"]=2
][0])._compile_forClass_protocol_("bar",$globals.ObjectMock2,"**test");
$recv($globals.ObjectMock2)._addCompiledMethod_(theMethod);
[$self._assert_equals_([$recv([$recv($globals.ObjectMock2)._new()
,$ctx1.sendIdx["new"]=3
][0])._basicAt_("a")
,$ctx1.sendIdx["basicAt:"]=1
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv($recv($globals.ObjectMock2)._new())._basicAt_("b"),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMethodAttachmentsAreRemoved",{instance:instance,theMethod:theMethod,anObject:anObject})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testMethodAttachmentsAreRemoved2",
protocol: "tests",
args: [],
source: "testMethodAttachmentsAreRemoved2\x0a\x09| instance theMethod anObject |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09anObject := #{#foo -> 'oof'}.\x0a\x09theMethod := Compiler new\x0a\x09\x09compile: 'bar' forClass: ObjectMock2 protocol: '**test'.\x0a\x09self\x0a\x09\x09augmentMethodInstantiationOf: theMethod\x0a\x09\x09withAttachments: #{#a -> 42. #b -> anObject}.\x0a\x09ObjectMock2 addCompiledMethod: theMethod.\x0a\x09ObjectMock2 new bar.\x0a\x09ObjectMock2 removeCompiledMethod: theMethod.\x0a\x09self assert: (ObjectMock2 new basicAt: #a) equals: nil.\x0a\x09self assert: (ObjectMock2 new basicAt: #b) equals: nil",
referencedClasses: ["ObjectMock", "Compiler", "ObjectMock2"],
pragmas: [],
messageSends: ["copyClass:named:", "compile:forClass:protocol:", "new", "augmentMethodInstantiationOf:withAttachments:", "addCompiledMethod:", "bar", "removeCompiledMethod:", "assert:equals:", "basicAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,theMethod,anObject;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
anObject=$globals.HashedCollection._newFromPairs_(["foo","oof"]);
theMethod=$recv([$recv($globals.Compiler)._new()
,$ctx1.sendIdx["new"]=1
][0])._compile_forClass_protocol_("bar",$globals.ObjectMock2,"**test");
$self._augmentMethodInstantiationOf_withAttachments_(theMethod,$globals.HashedCollection._newFromPairs_(["a",(42),"b",anObject]));
$recv($globals.ObjectMock2)._addCompiledMethod_(theMethod);
$recv([$recv($globals.ObjectMock2)._new()
,$ctx1.sendIdx["new"]=2
][0])._bar();
$recv($globals.ObjectMock2)._removeCompiledMethod_(theMethod);
[$self._assert_equals_([$recv([$recv($globals.ObjectMock2)._new()
,$ctx1.sendIdx["new"]=3
][0])._basicAt_("a")
,$ctx1.sendIdx["basicAt:"]=1
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv($recv($globals.ObjectMock2)._new())._basicAt_("b"),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMethodAttachmentsAreRemoved2",{instance:instance,theMethod:theMethod,anObject:anObject})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testMethodAttachmentsAreReplaced",
protocol: "tests",
args: [],
source: "testMethodAttachmentsAreReplaced\x0a\x09| instance theMethod anObject |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09anObject := #{#foo -> 'oof'}.\x0a\x09theMethod := Compiler new\x0a\x09\x09compile: 'bar' forClass: ObjectMock2 protocol: '**test'.\x0a\x09self\x0a\x09\x09augmentMethodInstantiationOf: theMethod\x0a\x09\x09withAttachments: #{#a -> 42. #b -> anObject}.\x0a\x09ObjectMock2 addCompiledMethod: theMethod.\x0a\x09theMethod := Compiler new\x0a\x09\x09compile: 'bar' forClass: ObjectMock2 protocol: '**test'.\x0a\x09self\x0a\x09\x09augmentMethodInstantiationOf: theMethod\x0a\x09\x09withAttachments: #{#a -> 6. #c -> [^9]}.\x0a\x09ObjectMock2 addCompiledMethod: theMethod.\x0a\x09self assert: (ObjectMock2 new basicAt: #a) equals: 6.\x0a\x09self assert: (ObjectMock2 new basicAt: #b) equals: nil.\x0a\x09self assert: (ObjectMock2 new basicPerform: #c) equals: 9",
referencedClasses: ["ObjectMock", "Compiler", "ObjectMock2"],
pragmas: [],
messageSends: ["copyClass:named:", "compile:forClass:protocol:", "new", "augmentMethodInstantiationOf:withAttachments:", "addCompiledMethod:", "assert:equals:", "basicAt:", "basicPerform:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance,theMethod,anObject;
return $core.withContext(function($ctx1) {
var $early={};
try {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
anObject=$globals.HashedCollection._newFromPairs_(["foo","oof"]);
theMethod=[$recv([$recv($globals.Compiler)._new()
,$ctx1.sendIdx["new"]=1
][0])._compile_forClass_protocol_("bar",$globals.ObjectMock2,"**test")
,$ctx1.sendIdx["compile:forClass:protocol:"]=1
][0];
[$self._augmentMethodInstantiationOf_withAttachments_(theMethod,$globals.HashedCollection._newFromPairs_(["a",(42),"b",anObject]))
,$ctx1.sendIdx["augmentMethodInstantiationOf:withAttachments:"]=1
][0];
[$recv($globals.ObjectMock2)._addCompiledMethod_(theMethod)
,$ctx1.sendIdx["addCompiledMethod:"]=1
][0];
theMethod=$recv([$recv($globals.Compiler)._new()
,$ctx1.sendIdx["new"]=2
][0])._compile_forClass_protocol_("bar",$globals.ObjectMock2,"**test");
$self._augmentMethodInstantiationOf_withAttachments_(theMethod,$globals.HashedCollection._newFromPairs_(["a",(6),"c",(function(){
throw $early=[(9)];

})]));
$recv($globals.ObjectMock2)._addCompiledMethod_(theMethod);
[$self._assert_equals_([$recv([$recv($globals.ObjectMock2)._new()
,$ctx1.sendIdx["new"]=3
][0])._basicAt_("a")
,$ctx1.sendIdx["basicAt:"]=1
][0],(6))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv([$recv($globals.ObjectMock2)._new()
,$ctx1.sendIdx["new"]=4
][0])._basicAt_("b"),nil)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv($recv($globals.ObjectMock2)._new())._basicPerform_("c"),(9));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"testMethodAttachmentsAreReplaced",{instance:instance,theMethod:theMethod,anObject:anObject})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testRespondsTo",
protocol: "tests",
args: [],
source: "testRespondsTo\x0a\x09self assert: (Object new respondsTo: #class).\x0a\x09self deny: (Object new respondsTo: #foo).\x0a\x09self assert: (Object respondsTo: #new)",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["assert:", "respondsTo:", "new", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=1
][0])._respondsTo_("class")
,$ctx1.sendIdx["respondsTo:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$self._deny_([$recv($recv($globals.Object)._new())._respondsTo_("foo")
,$ctx1.sendIdx["respondsTo:"]=2
][0]);
$self._assert_($recv($globals.Object)._respondsTo_("new"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRespondsTo",{})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testSetJavaScriptConstructor",
protocol: "tests",
args: [],
source: "testSetJavaScriptConstructor\x0a\x09| instance |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09theClass javaScriptConstructor: self jsConstructor.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: theClass isClassCopyOf: ObjectMock.\x0a\x09\x22testing specific to late-coupled detached root class\x22\x0a\x09instance := theClass new.\x0a\x09self assert: instance class == theClass.\x0a\x09self assert: instance value equals: 4.\x0a\x09self shouldnt: [ instance foo: 9 ] raise: Error.\x0a\x09self assert: instance foo equals: 9",
referencedClasses: ["ObjectMock", "Error"],
pragmas: [],
messageSends: ["copyClass:named:", "javaScriptConstructor:", "jsConstructor", "assert:equals:", "name", "assert:isClassCopyOf:", "new", "assert:", "==", "class", "value", "shouldnt:raise:", "foo:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$recv($self.theClass)._javaScriptConstructor_($self._jsConstructor());
[$self._assert_equals_($recv($self.theClass)._name(),"ObjectMock2")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_isClassCopyOf_($self.theClass,$globals.ObjectMock);
instance=$recv($self.theClass)._new();
$self._assert_($recv($recv(instance)._class()).__eq_eq($self.theClass));
[$self._assert_equals_($recv(instance)._value(),(4))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(instance)._foo_((9));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._assert_equals_($recv(instance)._foo(),(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSetJavaScriptConstructor",{instance:instance})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "testTrickySetJavaScriptConstructor",
protocol: "tests",
args: [],
source: "testTrickySetJavaScriptConstructor\x0a\x09| instance |\x0a\x09theClass := builder copyClass: ObjectMock named: 'ObjectMock2'.\x0a\x09theClass javaScriptConstructor: self trickyJsConstructor.\x0a\x09self assert: theClass name equals: 'ObjectMock2'.\x0a\x09self assert: theClass isClassCopyOf: ObjectMock.\x0a\x09\x22testing specific to late-coupled detached root class\x22\x0a\x09instance := theClass new.\x0a\x09self assert: instance class == theClass.\x0a\x09self assert: instance value equals: 4.\x0a\x09self shouldnt: [ instance foo: 9 ] raise: Error.\x0a\x09self assert: instance foo equals: 9",
referencedClasses: ["ObjectMock", "Error"],
pragmas: [],
messageSends: ["copyClass:named:", "javaScriptConstructor:", "trickyJsConstructor", "assert:equals:", "name", "assert:isClassCopyOf:", "new", "assert:", "==", "class", "value", "shouldnt:raise:", "foo:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var instance;
return $core.withContext(function($ctx1) {
$self.theClass=$recv($self.builder)._copyClass_named_($globals.ObjectMock,"ObjectMock2");
$recv($self.theClass)._javaScriptConstructor_($self._trickyJsConstructor());
[$self._assert_equals_($recv($self.theClass)._name(),"ObjectMock2")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_isClassCopyOf_($self.theClass,$globals.ObjectMock);
instance=$recv($self.theClass)._new();
$self._assert_($recv($recv(instance)._class()).__eq_eq($self.theClass));
[$self._assert_equals_($recv(instance)._value(),(4))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(instance)._foo_((9));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._assert_equals_($recv(instance)._foo(),(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTrickySetJavaScriptConstructor",{instance:instance})});
}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.ClassTest);

$core.addMethod(
$core.method({
selector: "trickyJsConstructor",
protocol: "running",
args: [],
source: "trickyJsConstructor\x0a\x09<inlineJS: '\x0a\x09\x09function Foo(){}\x0a\x09\x09Foo.prototype.valueOf = function () {return 4;};\x0a\x09\x09Foo.prototype._foo = function () {return \x22bar\x22;};\x0a\x09\x09return Foo;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09function Foo(){}\x0a\x09\x09Foo.prototype.valueOf = function () {return 4;};\x0a\x09\x09Foo.prototype._foo = function () {return \x22bar\x22;};\x0a\x09\x09return Foo;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		function Foo(){}
		Foo.prototype.valueOf = function () {return 4;};
		Foo.prototype._foo = function () {return "bar";};
		return Foo;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"trickyJsConstructor",{})});
}; }),
$globals.ClassTest);



$core.addClass("CollectionTest", $globals.TestCase, "Kernel-Tests");
$core.setSlots($globals.CollectionTest, ["sampleBlock"]);
$core.addMethod(
$core.method({
selector: "assertSameContents:as:",
protocol: "convenience",
args: ["aCollection", "anotherCollection"],
source: "assertSameContents: aCollection as: anotherCollection\x0a\x09self assert: (aCollection size = anotherCollection size).\x0a\x09aCollection do: [ :each |\x0a\x09\x09self assert: ((aCollection occurrencesOf: each) = (anotherCollection occurrencesOf: each)) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "=", "size", "do:", "occurrencesOf:"]
}, function ($methodClass){ return function (aCollection,anotherCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([$recv(aCollection)._size()
,$ctx1.sendIdx["size"]=1
][0]).__eq($recv(anotherCollection)._size())
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$recv(aCollection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._assert_($recv([$recv(aCollection)._occurrencesOf_(each)
,$ctx2.sendIdx["occurrencesOf:"]=1
][0]).__eq($recv(anotherCollection)._occurrencesOf_(each)));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"assertSameContents:as:",{aCollection:aCollection,anotherCollection:anotherCollection})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collection",
protocol: "fixture",
args: [],
source: "collection\x0a\x09\x22Answers pre-filled collection of type tested.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collection",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09\x22Answers class of collection type tested\x22\x0a\x0a\x09^ self class collectionClass",
referencedClasses: [],
pragmas: [],
messageSends: ["collectionClass", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._collectionClass();
}, function($ctx1) {$ctx1.fill(self,"collectionClass",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: "fixture",
args: [],
source: "collectionOfPrintStrings\x0a\x09\x22Answers self collection but with values\x0a\x09changed to their printStrings\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionOfPrintStrings",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: "fixture",
args: [],
source: "collectionSize\x0a\x09\x22Answers size of self collection.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionSize",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: "fixture",
args: [],
source: "collectionWithDuplicates\x0a\x09\x22Answers pre-filled collection of type tested,\x0a\x09with exactly six distinct elements,\x0a\x09some of them appearing multiple times, if possible.\x22\x0a\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionWithDuplicates",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: "fixture",
args: [],
source: "collectionWithNewValue\x0a\x09\x22Answers a collection which shows how\x0a\x09self collection would look after adding\x0a\x09self sampleNewValue\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x0a\x09sampleBlock := []",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.sampleBlock=(function(){

});
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewValue",
protocol: "fixture",
args: [],
source: "sampleNewValue\x0a\x09\x22Answers a value that is not yet there\x0a\x09and can be put into a tested collection\x22\x0a\x09\x0a\x09^ 'N'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "N";

}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: "fixture",
args: [],
source: "sampleNewValueAsCollection\x0a\x09\x22Answers self sampleNewValue\x0a\x09wrapped in single element collection\x0a\x09of tested type\x22\x0a\x09\x0a\x09^ self collectionClass with: self sampleNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["with:", "collectionClass", "sampleNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._collectionClass())._with_($self._sampleNewValue());
}, function($ctx1) {$ctx1.fill(self,"sampleNewValueAsCollection",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: "tests",
args: [],
source: "testAddAll\x0a\x09self assert: (self collection addAll: self collectionClass new; yourself) equals: self collection.\x0a\x09self assert: (self collectionClass new addAll: self collection; yourself) equals: self collection.\x0a\x09self assert: (self collectionClass new addAll: self collectionClass new; yourself) equals: self collectionClass new.\x0a\x09self assert: (self collection addAll: self sampleNewValueAsCollection; yourself) equals: self collectionWithNewValue.\x0a\x09self assertSameContents: (self sampleNewValueAsCollection addAll: self collection; yourself) as: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "addAll:", "collection", "new", "collectionClass", "yourself", "sampleNewValueAsCollection", "collectionWithNewValue", "assertSameContents:as:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5;
$1=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
[$recv($1)._addAll_([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])
,$ctx1.sendIdx["addAll:"]=1
][0];
[$self._assert_equals_([$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$2=[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=2
][0])._new()
,$ctx1.sendIdx["new"]=2
][0];
[$recv($2)._addAll_([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["addAll:"]=2
][0];
[$self._assert_equals_([$recv($2)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$3=[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=3
][0])._new()
,$ctx1.sendIdx["new"]=3
][0];
[$recv($3)._addAll_([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=4
][0])._new()
,$ctx1.sendIdx["new"]=4
][0])
,$ctx1.sendIdx["addAll:"]=3
][0];
[$self._assert_equals_([$recv($3)._yourself()
,$ctx1.sendIdx["yourself"]=3
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$4=[$self._collection()
,$ctx1.sendIdx["collection"]=5
][0];
[$recv($4)._addAll_([$self._sampleNewValueAsCollection()
,$ctx1.sendIdx["sampleNewValueAsCollection"]=1
][0])
,$ctx1.sendIdx["addAll:"]=4
][0];
$self._assert_equals_([$recv($4)._yourself()
,$ctx1.sendIdx["yourself"]=4
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0]);
$5=$self._sampleNewValueAsCollection();
$recv($5)._addAll_($self._collection());
$self._assertSameContents_as_($recv($5)._yourself(),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAllSatisfy",
protocol: "tests",
args: [],
source: "testAllSatisfy\x0a\x09| collection anyOne |\x0a\x09collection := self collection.\x0a\x09anyOne := collection anyOne.\x0a\x09self assert: (collection allSatisfy: [ :each | collection includes: each ]).\x0a\x09self deny: (collection allSatisfy: [ :each | each ~= anyOne ])",
referencedClasses: [],
pragmas: [],
messageSends: ["collection", "anyOne", "assert:", "allSatisfy:", "includes:", "deny:", "~="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var collection,anyOne;
return $core.withContext(function($ctx1) {
collection=$self._collection();
anyOne=$recv(collection)._anyOne();
$self._assert_([$recv(collection)._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(collection)._includes_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["allSatisfy:"]=1
][0]);
$self._deny_($recv(collection)._allSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__tild_eq(anyOne);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAllSatisfy",{collection:collection,anyOne:anyOne})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAnyOne",
protocol: "tests",
args: [],
source: "testAnyOne\x0a\x09self should: [ self collectionClass new anyOne ] raise: Error.\x0a\x09self assert: (self collection includes: self collection anyOne)",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "anyOne", "new", "collectionClass", "assert:", "includes:", "collection"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv($recv($self._collectionClass())._new())._anyOne()
,$ctx2.sendIdx["anyOne"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._assert_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._includes_($recv($self._collection())._anyOne()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAnyOne",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAnySatisfy",
protocol: "tests",
args: [],
source: "testAnySatisfy\x0a\x09| anyOne |\x0a\x09anyOne := self collection anyOne.\x0a\x09self assert: (self collection anySatisfy: [ :each | each = anyOne ]).\x0a\x09self deny: (self collection anySatisfy: [ :each | each = Object new ])",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["anyOne", "collection", "assert:", "anySatisfy:", "=", "deny:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var anyOne;
return $core.withContext(function($ctx1) {
anyOne=$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._anyOne();
$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each).__eq(anyOne)
,$ctx2.sendIdx["="]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["anySatisfy:"]=1
][0]);
$self._deny_($recv($self._collection())._anySatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq($recv($globals.Object)._new());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAnySatisfy",{anyOne:anyOne})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAsArray",
protocol: "tests",
args: [],
source: "testAsArray\x0a\x09self\x0a\x09\x09assertSameContents: self collection\x0a\x09\x09as: self collection asArray",
referencedClasses: [],
pragmas: [],
messageSends: ["assertSameContents:as:", "collection", "asArray"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assertSameContents_as_([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0],$recv($self._collection())._asArray());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsArray",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAsOrderedCollection",
protocol: "tests",
args: [],
source: "testAsOrderedCollection\x0a\x09self\x0a\x09\x09assertSameContents: self collection\x0a\x09\x09as: self collection asOrderedCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["assertSameContents:as:", "collection", "asOrderedCollection"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assertSameContents_as_([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0],$recv($self._collection())._asOrderedCollection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsOrderedCollection",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testAsSet",
protocol: "tests",
args: [],
source: "testAsSet\x0a\x09| c set |\x0a\x09c := self collectionWithDuplicates.\x0a\x09set := c asSet.\x0a\x09self assert: set size equals: 6.\x0a\x09c do: [ :each |\x0a\x09\x09self assert: (set includes: each) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collectionWithDuplicates", "asSet", "assert:equals:", "size", "do:", "assert:", "includes:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var c,set;
return $core.withContext(function($ctx1) {
c=$self._collectionWithDuplicates();
set=$recv(c)._asSet();
$self._assert_equals_($recv(set)._size(),(6));
$recv(c)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._assert_($recv(set)._includes_(each));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsSet",{c:c,set:set})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCollect",
protocol: "tests",
args: [],
source: "testCollect\x0a\x09self assert: (self collection collect: [ :each | each ]) equals: self collection.\x0a\x09self assert: (self collectionWithNewValue collect: [ :each | each ]) equals: self collectionWithNewValue.\x0a\x09self assert: (self collectionClass new collect: [ :each | each printString ]) equals: self collectionClass new.\x0a\x09self assert: ((self collection collect: [ self sampleNewValue ]) detect: [ true ]) equals: self sampleNewValue.\x0a\x09self assert: (self collection collect: [ :each | each printString ]) equals: self collectionOfPrintStrings",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "collect:", "collection", "collectionWithNewValue", "new", "collectionClass", "printString", "detect:", "sampleNewValue", "collectionOfPrintStrings"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._collect_((function(each){
return each;

}))
,$ctx1.sendIdx["collect:"]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])._collect_((function(each){
return each;

}))
,$ctx1.sendIdx["collect:"]=2
][0],$self._collectionWithNewValue())
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])._collect_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each)._printString()
,$ctx2.sendIdx["printString"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}))
,$ctx1.sendIdx["collect:"]=3
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_($recv([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])._collect_((function(){
return $core.withContext(function($ctx2) {
return [$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}))
,$ctx1.sendIdx["collect:"]=4
][0])._detect_((function(){
return true;

})),$self._sampleNewValue())
,$ctx1.sendIdx["assert:equals:"]=4
][0];
$self._assert_equals_($recv($self._collection())._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._printString();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
})),$self._collectionOfPrintStrings());
return self;
}, function($ctx1) {$ctx1.fill(self,"testCollect",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testComma",
protocol: "tests",
args: [],
source: "testComma\x0a\x09self assert: self collection, self collectionClass new equals: self collection.\x0a\x09self assert: self collectionClass new, self collection equals: self collection.\x0a\x09self assert: self collectionClass new, self collectionClass new equals: self collectionClass new.\x0a\x09self assert: self collection, self sampleNewValueAsCollection equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", ",", "collection", "new", "collectionClass", "sampleNewValueAsCollection", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0]).__comma([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])
,$ctx1.sendIdx[","]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=2
][0])._new()
,$ctx1.sendIdx["new"]=2
][0]).__comma([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx[","]=2
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=3
][0])._new()
,$ctx1.sendIdx["new"]=3
][0]).__comma([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=4
][0])._new()
,$ctx1.sendIdx["new"]=4
][0])
,$ctx1.sendIdx[","]=3
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv($self._collection()).__comma($self._sampleNewValueAsCollection()),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testComma",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCopy",
protocol: "tests",
args: [],
source: "testCopy\x0a\x09self assert: self collectionClass new copy equals: self collectionClass new.\x0a\x09self assert: self collection copy equals: self collection.\x0a\x09self assert: self collectionWithNewValue copy equals: self collectionWithNewValue.\x0a\x09\x0a\x09self deny: self collectionClass new copy = self collection.\x0a\x09self deny: self collection copy = self collectionClass new.\x0a\x09self deny: self collection copy = self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "copy", "new", "collectionClass", "collection", "collectionWithNewValue", "deny:", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])._copy()
,$ctx1.sendIdx["copy"]=1
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=2
][0])._new()
,$ctx1.sendIdx["new"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._copy()
,$ctx1.sendIdx["copy"]=2
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([$recv([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])._copy()
,$ctx1.sendIdx["copy"]=3
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0]);
[$self._deny_([$recv([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=3
][0])._new()
,$ctx1.sendIdx["new"]=3
][0])._copy()
,$ctx1.sendIdx["copy"]=4
][0]).__eq([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_([$recv([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])._copy()
,$ctx1.sendIdx["copy"]=5
][0]).__eq($recv($self._collectionClass())._new())
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
$self._deny_($recv($recv($self._collection())._copy()).__eq($self._collectionWithNewValue()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopy",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCopyEmpty",
protocol: "tests",
args: [],
source: "testCopyEmpty\x0a\x09self assert: self collectionClass new copyEmpty equals: self collectionClass new.\x0a\x09self assert: self collection copyEmpty equals: self collectionClass new.\x0a\x09self assert: self collectionWithNewValue copyEmpty equals: self collectionClass new",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "copyEmpty", "new", "collectionClass", "collection", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])._copyEmpty()
,$ctx1.sendIdx["copyEmpty"]=1
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=2
][0])._new()
,$ctx1.sendIdx["new"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($self._collection())._copyEmpty()
,$ctx1.sendIdx["copyEmpty"]=2
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=3
][0])._new()
,$ctx1.sendIdx["new"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv($self._collectionWithNewValue())._copyEmpty(),$recv($self._collectionClass())._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopyEmpty",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testCopySeparates",
protocol: "tests",
args: [],
source: "testCopySeparates\x0a\x09| original copy |\x0a\x09original := self collection.\x0a\x09copy := original copy.\x0a\x09copy addAll: self sampleNewValueAsCollection.\x0a\x09self assert: original = self collection",
referencedClasses: [],
pragmas: [],
messageSends: ["collection", "copy", "addAll:", "sampleNewValueAsCollection", "assert:", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var original,copy;
return $core.withContext(function($ctx1) {
original=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
copy=$recv(original)._copy();
$recv(copy)._addAll_($self._sampleNewValueAsCollection());
$self._assert_($recv(original).__eq($self._collection()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopySeparates",{original:original,copy:copy})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testDetect",
protocol: "tests",
args: [],
source: "testDetect\x0a\x09self\x0a\x09\x09shouldnt: [ self collection detect: [ true ] ]\x0a\x09\x09raise: Error.\x0a\x09self\x0a\x09\x09should: [ self collection detect: [ false ] ]\x0a\x09\x09raise: Error.\x0a\x09self assert: (self sampleNewValueAsCollection detect: [ true ]) equals: self sampleNewValue.\x0a\x09self assert: (self collectionWithNewValue detect: [ :each | each = self sampleNewValue ]) equals: self sampleNewValue.\x0a\x09self\x0a\x09\x09should: [ self collection detect: [ :each | each = self sampleNewValue ] ]\x0a\x09\x09raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["shouldnt:raise:", "detect:", "collection", "should:raise:", "assert:equals:", "sampleNewValueAsCollection", "sampleNewValue", "collectionWithNewValue", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._detect_((function(){
return true;

}))
,$ctx2.sendIdx["detect:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv([$self._collection()
,$ctx2.sendIdx["collection"]=2
][0])._detect_((function(){
return false;

}))
,$ctx2.sendIdx["detect:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}),$globals.Error)
,$ctx1.sendIdx["should:raise:"]=1
][0];
[$self._assert_equals_([$recv($self._sampleNewValueAsCollection())._detect_((function(){
return true;

}))
,$ctx1.sendIdx["detect:"]=3
][0],[$self._sampleNewValue()
,$ctx1.sendIdx["sampleNewValue"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_([$recv($self._collectionWithNewValue())._detect_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each).__eq([$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0])
,$ctx2.sendIdx["="]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
}))
,$ctx1.sendIdx["detect:"]=4
][0],[$self._sampleNewValue()
,$ctx1.sendIdx["sampleNewValue"]=3
][0]);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self._collection())._detect_((function(each){
return $core.withContext(function($ctx3) {
return $recv(each).__eq($self._sampleNewValue());
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,8)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDetect",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testDetectIfNone",
protocol: "tests",
args: [],
source: "testDetectIfNone\x0a\x09| sentinel |\x0a\x09sentinel := Object new.\x0a\x09self assert: (self collection detect: [ true ] ifNone: [ sentinel ]) ~= sentinel.\x0a\x09self assert: (self collection detect: [ false ] ifNone: [ sentinel ]) equals: sentinel.\x0a\x09self assert: (self sampleNewValueAsCollection detect: [ true ] ifNone: [ sentinel ]) equals: self sampleNewValue.\x0a\x09self assert: (self collectionWithNewValue detect: [ :each | each = self sampleNewValue ] ifNone: [ sentinel ]) equals: self sampleNewValue.\x0a\x09self assert: (self collection detect: [ :each | each = self sampleNewValue ] ifNone: [ sentinel ]) equals: sentinel",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "assert:", "~=", "detect:ifNone:", "collection", "assert:equals:", "sampleNewValueAsCollection", "sampleNewValue", "collectionWithNewValue", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var sentinel;
return $core.withContext(function($ctx1) {
sentinel=$recv($globals.Object)._new();
$self._assert_($recv([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._detect_ifNone_((function(){
return true;

}),(function(){
return sentinel;

}))
,$ctx1.sendIdx["detect:ifNone:"]=1
][0]).__tild_eq(sentinel));
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._detect_ifNone_((function(){
return false;

}),(function(){
return sentinel;

}))
,$ctx1.sendIdx["detect:ifNone:"]=2
][0],sentinel)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($self._sampleNewValueAsCollection())._detect_ifNone_((function(){
return true;

}),(function(){
return sentinel;

}))
,$ctx1.sendIdx["detect:ifNone:"]=3
][0],[$self._sampleNewValue()
,$ctx1.sendIdx["sampleNewValue"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv($self._collectionWithNewValue())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each).__eq([$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0])
,$ctx2.sendIdx["="]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,7)});
}),(function(){
return sentinel;

}))
,$ctx1.sendIdx["detect:ifNone:"]=4
][0],[$self._sampleNewValue()
,$ctx1.sendIdx["sampleNewValue"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv($self._collection())._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq($self._sampleNewValue());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,9)});
}),(function(){
return sentinel;

})),sentinel);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDetectIfNone",{sentinel:sentinel})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testDo",
protocol: "tests",
args: [],
source: "testDo\x0a\x09| newCollection |\x0a\x09newCollection := OrderedCollection new.\x0a\x09self collection do: [ :each |\x0a\x09\x09newCollection add: each ].\x0a\x09self\x0a\x09\x09assertSameContents: self collection\x0a\x09\x09as: newCollection.\x0a\x09newCollection := OrderedCollection new.\x0a\x09self collectionWithDuplicates do: [ :each |\x0a\x09\x09newCollection add: each ].\x0a\x09self\x0a\x09\x09assertSameContents: self collectionWithDuplicates\x0a\x09\x09as: newCollection",
referencedClasses: ["OrderedCollection"],
pragmas: [],
messageSends: ["new", "do:", "collection", "add:", "assertSameContents:as:", "collectionWithDuplicates"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var newCollection;
return $core.withContext(function($ctx1) {
newCollection=[$recv($globals.OrderedCollection)._new()
,$ctx1.sendIdx["new"]=1
][0];
[$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._do_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(newCollection)._add_(each)
,$ctx2.sendIdx["add:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["do:"]=1
][0];
[$self._assertSameContents_as_($self._collection(),newCollection)
,$ctx1.sendIdx["assertSameContents:as:"]=1
][0];
newCollection=$recv($globals.OrderedCollection)._new();
$recv([$self._collectionWithDuplicates()
,$ctx1.sendIdx["collectionWithDuplicates"]=1
][0])._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newCollection)._add_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
$self._assertSameContents_as_($self._collectionWithDuplicates(),newCollection);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDo",{newCollection:newCollection})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: "tests",
args: [],
source: "testEquality\x0a\x09self assert: self collectionClass new equals: self collectionClass new.\x0a\x09self assert: self collection equals: self collection.\x0a\x09self assert: self collectionWithNewValue equals: self collectionWithNewValue.\x0a\x09\x0a\x09self deny: self collectionClass new = self collection.\x0a\x09self deny: self collection = self collectionClass new.\x0a\x09self deny: self collection = self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "new", "collectionClass", "collection", "collectionWithNewValue", "deny:", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=2
][0])._new()
,$ctx1.sendIdx["new"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0]);
[$self._deny_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=3
][0])._new()
,$ctx1.sendIdx["new"]=3
][0]).__eq([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0]).__eq($recv($self._collectionClass())._new())
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
$self._deny_($recv($self._collection()).__eq($self._collectionWithNewValue()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testIfEmptyFamily",
protocol: "tests",
args: [],
source: "testIfEmptyFamily\x0a\x09self assert: (self collectionClass new ifEmpty: [ 42 ]) equals: 42.\x0a\x09self assert: (self collection ifEmpty: [ 42 ]) equals: self collection.\x0a\x0a\x09self assert: (self collectionClass new ifNotEmpty: [ 42 ]) equals: self collectionClass new.\x0a\x09self assert: (self collection ifNotEmpty: [ 42 ]) equals: 42.\x0a\x09self assert: (self collection ifNotEmpty: [ :col | col ]) equals: self collection.\x0a\x09\x0a\x09self assert: (self collectionClass new ifEmpty: [ 42 ] ifNotEmpty: [ 999 ]) equals: 42.\x0a\x09self assert: (self collection ifEmpty: [ 42 ] ifNotEmpty: [ 999 ]) equals: 999.\x0a\x09self assert: (self collection ifEmpty: [ 42 ] ifNotEmpty: [ :col | col ]) equals: self collection.\x0a\x0a\x09self assert: (self collectionClass new ifNotEmpty: [ 42 ] ifEmpty: [ 999 ]) equals: 999.\x0a\x09self assert: (self collection ifNotEmpty: [ 42 ] ifEmpty: [ 999 ]) equals: 42.\x0a\x09self assert: (self collection ifNotEmpty: [ :col | col ] ifEmpty: [ 999 ]) equals: self collection.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "ifEmpty:", "new", "collectionClass", "collection", "ifNotEmpty:", "ifEmpty:ifNotEmpty:", "ifNotEmpty:ifEmpty:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])._ifEmpty_((function(){
return (42);

}))
,$ctx1.sendIdx["ifEmpty:"]=1
][0],(42))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._ifEmpty_((function(){
return (42);

})),[$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=2
][0])._new()
,$ctx1.sendIdx["new"]=2
][0])._ifNotEmpty_((function(){
return (42);

}))
,$ctx1.sendIdx["ifNotEmpty:"]=1
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=3
][0])._new()
,$ctx1.sendIdx["new"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])._ifNotEmpty_((function(){
return (42);

}))
,$ctx1.sendIdx["ifNotEmpty:"]=2
][0],(42))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])._ifNotEmpty_((function(col){
return col;

})),[$self._collection()
,$ctx1.sendIdx["collection"]=5
][0])
,$ctx1.sendIdx["assert:equals:"]=5
][0];
[$self._assert_equals_([$recv([$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=4
][0])._new()
,$ctx1.sendIdx["new"]=4
][0])._ifEmpty_ifNotEmpty_((function(){
return (42);

}),(function(){
return (999);

}))
,$ctx1.sendIdx["ifEmpty:ifNotEmpty:"]=1
][0],(42))
,$ctx1.sendIdx["assert:equals:"]=6
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=6
][0])._ifEmpty_ifNotEmpty_((function(){
return (42);

}),(function(){
return (999);

}))
,$ctx1.sendIdx["ifEmpty:ifNotEmpty:"]=2
][0],(999))
,$ctx1.sendIdx["assert:equals:"]=7
][0];
[$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=7
][0])._ifEmpty_ifNotEmpty_((function(){
return (42);

}),(function(col){
return col;

})),[$self._collection()
,$ctx1.sendIdx["collection"]=8
][0])
,$ctx1.sendIdx["assert:equals:"]=8
][0];
[$self._assert_equals_([$recv($recv($self._collectionClass())._new())._ifNotEmpty_ifEmpty_((function(){
return (42);

}),(function(){
return (999);

}))
,$ctx1.sendIdx["ifNotEmpty:ifEmpty:"]=1
][0],(999))
,$ctx1.sendIdx["assert:equals:"]=9
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=9
][0])._ifNotEmpty_ifEmpty_((function(){
return (42);

}),(function(){
return (999);

}))
,$ctx1.sendIdx["ifNotEmpty:ifEmpty:"]=2
][0],(42))
,$ctx1.sendIdx["assert:equals:"]=10
][0];
$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=10
][0])._ifNotEmpty_ifEmpty_((function(col){
return col;

}),(function(){
return (999);

})),$self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfEmptyFamily",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testIsEmpty",
protocol: "tests",
args: [],
source: "testIsEmpty\x0a\x09self assert: self collectionClass new isEmpty.\x0a\x09self deny: self collection isEmpty",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "isEmpty", "new", "collectionClass", "deny:", "collection"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_([$recv($recv($self._collectionClass())._new())._isEmpty()
,$ctx1.sendIdx["isEmpty"]=1
][0]);
$self._deny_($recv($self._collection())._isEmpty());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsEmpty",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testNoneSatisfy",
protocol: "tests",
args: [],
source: "testNoneSatisfy\x0a\x09| anyOne |\x0a\x09anyOne := self collection anyOne.\x0a\x09self deny: (self collection noneSatisfy: [ :each | each = anyOne ]).\x0a\x09self assert: (self collection noneSatisfy: [ :each | each = Object new ])",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["anyOne", "collection", "deny:", "noneSatisfy:", "=", "assert:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var anyOne;
return $core.withContext(function($ctx1) {
anyOne=$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._anyOne();
$self._deny_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._noneSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each).__eq(anyOne)
,$ctx2.sendIdx["="]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["noneSatisfy:"]=1
][0]);
$self._assert_($recv($self._collection())._noneSatisfy_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq($recv($globals.Object)._new());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
})));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNoneSatisfy",{anyOne:anyOne})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testRegression1224",
protocol: "tests",
args: [],
source: "testRegression1224\x0a\x09self assert: (self collectionClass new\x0a\x09\x09remove: self sampleNewValue ifAbsent: [];\x0a\x09\x09yourself) size equals: 0",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "size", "remove:ifAbsent:", "new", "collectionClass", "sampleNewValue", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($self._collectionClass())._new();
$recv($1)._remove_ifAbsent_($self._sampleNewValue(),(function(){

}));
$self._assert_equals_($recv($recv($1)._yourself())._size(),(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1224",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testRemoveAll",
protocol: "tests",
args: [],
source: "testRemoveAll\x0a\x09self assert: (self collection removeAll; yourself) equals: self collectionClass new",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "removeAll", "collection", "yourself", "new", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._collection();
$recv($1)._removeAll();
$self._assert_equals_($recv($1)._yourself(),$recv($self._collectionClass())._new());
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveAll",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testSelect",
protocol: "tests",
args: [],
source: "testSelect\x0a\x09self assert: (self collection select: [ false ]) equals: self collectionClass new.\x0a\x09self assert: (self collection select: [ true ]) equals: self collection.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each = self sampleNewValue ]) equals: self sampleNewValueAsCollection.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each ~= self sampleNewValue ]) equals: self collection.\x0a\x09self assert: (self collection select: [ :each | each = self sampleNewValue ]) equals: self collectionClass new.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each ~= self sampleNewValue ]) equals: self collection",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "select:", "collection", "new", "collectionClass", "collectionWithNewValue", "=", "sampleNewValue", "sampleNewValueAsCollection", "~="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._select_((function(){
return false;

}))
,$ctx1.sendIdx["select:"]=1
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._select_((function(){
return true;

}))
,$ctx1.sendIdx["select:"]=2
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])._select_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each).__eq([$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=1
][0])
,$ctx2.sendIdx["="]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}))
,$ctx1.sendIdx["select:"]=3
][0],$self._sampleNewValueAsCollection())
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_([$recv([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0])._select_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(each).__tild_eq([$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0])
,$ctx2.sendIdx["~="]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}))
,$ctx1.sendIdx["select:"]=4
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=5
][0])._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq([$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=3
][0]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,5)});
}))
,$ctx1.sendIdx["select:"]=5
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=5
][0];
$self._assert_equals_($recv($self._collectionWithNewValue())._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__tild_eq($self._sampleNewValue());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
})),$self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testSelect",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testSelectThenCollect",
protocol: "tests",
args: [],
source: "testSelectThenCollect\x0a\x09self assert: (self collection select: [ false ] thenCollect: #isString) equals: self collectionClass new.\x0a\x09self assert: (self collection select: [ true ] thenCollect: [:x|x]) equals: self collection.\x0a\x09self assert: (self collection select: [ :each | each = self sampleNewValue ] thenCollect: [:x|x]) equals: self collectionClass new.\x0a\x09self assert: (self collectionWithNewValue select: [ :each | each ~= self sampleNewValue ] thenCollect: #printString) equals: self collectionOfPrintStrings",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "select:thenCollect:", "collection", "new", "collectionClass", "=", "sampleNewValue", "collectionWithNewValue", "~=", "collectionOfPrintStrings"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._select_thenCollect_((function(){
return false;

}),"isString")
,$ctx1.sendIdx["select:thenCollect:"]=1
][0],[$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new()
,$ctx1.sendIdx["new"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._select_thenCollect_((function(){
return true;

}),(function(x){
return x;

}))
,$ctx1.sendIdx["select:thenCollect:"]=2
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv($self._collection())._select_thenCollect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__eq([$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=1
][0]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}),(function(x){
return x;

}))
,$ctx1.sendIdx["select:thenCollect:"]=3
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv($self._collectionWithNewValue())._select_thenCollect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each).__tild_eq($self._sampleNewValue());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,6)});
}),"printString"),$self._collectionOfPrintStrings());
return self;
}, function($ctx1) {$ctx1.fill(self,"testSelectThenCollect",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testSingle",
protocol: "tests",
args: [],
source: "testSingle\x0a\x09self should: [ self collectionClass new single ] raise: Error.\x0a\x09self should: [ self collection single ] raise: Error.\x0a\x09self assert: self sampleNewValueAsCollection single equals: self sampleNewValue",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "single", "new", "collectionClass", "collection", "assert:equals:", "sampleNewValueAsCollection", "sampleNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv($recv($self._collectionClass())._new())._single()
,$ctx2.sendIdx["single"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error)
,$ctx1.sendIdx["should:raise:"]=1
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv($self._collection())._single()
,$ctx2.sendIdx["single"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
$self._assert_equals_($recv($self._sampleNewValueAsCollection())._single(),$self._sampleNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testSingle",{})});
}; }),
$globals.CollectionTest);

$core.addMethod(
$core.method({
selector: "testSize",
protocol: "tests",
args: [],
source: "testSize\x0a\x09self assert: self collectionClass new size equals: 0.\x0a\x09self assert: self sampleNewValueAsCollection size equals: 1.\x0a\x09self assert: self collection size equals: self collectionSize",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "size", "new", "collectionClass", "sampleNewValueAsCollection", "collection", "collectionSize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv($recv($self._collectionClass())._new())._size()
,$ctx1.sendIdx["size"]=1
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($self._sampleNewValueAsCollection())._size()
,$ctx1.sendIdx["size"]=2
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv($self._collection())._size(),$self._collectionSize());
return self;
}, function($ctx1) {$ctx1.fill(self,"testSize",{})});
}; }),
$globals.CollectionTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09\x22Answers class of collection type tested,\x0a\x09or nil if test is abstract\x22\x0a\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.CollectionTest.a$cls);

$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: "testing",
args: [],
source: "isAbstract\x0a\x09^ self collectionClass isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["isNil", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._collectionClass())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{})});
}; }),
$globals.CollectionTest.a$cls);


$core.addClass("AssociativeCollectionTest", $globals.CollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collectionKeys",
protocol: "fixture",
args: [],
source: "collectionKeys\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionKeys",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionValues",
protocol: "fixture",
args: [],
source: "collectionValues\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionValues",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "nonIndexesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "nonIndexesDo: aBlock\x0a\x09aBlock value: 5.\x0a\x09aBlock value: [].\x0a\x09aBlock value: Object new.\x0a\x09aBlock value: 'z'",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["value:", "new"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aBlock)._value_((5))
,$ctx1.sendIdx["value:"]=1
][0];
[$recv(aBlock)._value_((function(){

}))
,$ctx1.sendIdx["value:"]=2
][0];
[$recv(aBlock)._value_($recv($globals.Object)._new())
,$ctx1.sendIdx["value:"]=3
][0];
$recv(aBlock)._value_("z");
return self;
}, function($ctx1) {$ctx1.fill(self,"nonIndexesDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewIndex",
protocol: "fixture",
args: [],
source: "sampleNewIndex\x0a\x09^ 'new'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "new";

}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09aBlock value: 'a' value: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["value:value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aBlock)._value_value_("a",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: "tests",
args: [],
source: "testAddAll\x0a\x09super testAddAll.\x0a\x09self assert: (self collection addAll: self collection; yourself) equals: self collection.\x0a\x09self assert: (self collection addAll: self collectionWithNewValue; yourself) equals: self collectionWithNewValue.\x0a\x09self assert: (self collectionWithNewValue addAll: self collection; yourself) equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["testAddAll", "assert:equals:", "addAll:", "collection", "yourself", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._testAddAll.call($self))
,$ctx1.supercall = false
][0];
$1=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
[$recv($1)._addAll_([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["addAll:"]=1
][0];
[$self._assert_equals_([$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$2=[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0];
[$recv($2)._addAll_([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])
,$ctx1.sendIdx["addAll:"]=2
][0];
[$self._assert_equals_([$recv($2)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$3=[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=3
][0];
$recv($3)._addAll_($self._collection());
$self._assert_equals_($recv($3)._yourself(),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testAsDictionary",
protocol: "tests",
args: [],
source: "testAsDictionary\x0aself assert: ( self collectionClass new asDictionary isMemberOf: Dictionary ).",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["assert:", "isMemberOf:", "asDictionary", "new", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv($recv($self._collectionClass())._new())._asDictionary())._isMemberOf_($globals.Dictionary));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsDictionary",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testAsHashedCollection",
protocol: "tests",
args: [],
source: "testAsHashedCollection\x0aself assert: ( self collectionClass new asHashedCollection isMemberOf: HashedCollection ).",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["assert:", "isMemberOf:", "asHashedCollection", "new", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv($recv($self._collectionClass())._new())._asHashedCollection())._isMemberOf_($globals.HashedCollection));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsHashedCollection",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testFrom",
protocol: "tests",
args: [],
source: "testFrom\x0a\x22Accept a collection of associations.\x22\x0a| associations |\x0aassociations := { 'a' -> 1. 'b' -> 2 }.\x0aself assertSameContents: ( self class collectionClass from: associations ) as: #{ 'a' -> 1. 'b' -> 2 }.",
referencedClasses: [],
pragmas: [],
messageSends: ["->", "assertSameContents:as:", "from:", "collectionClass", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var associations;
return $core.withContext(function($ctx1) {
associations=[["a".__minus_gt((1))
,$ctx1.sendIdx["->"]=1
][0],"b".__minus_gt((2))];
$self._assertSameContents_as_($recv($recv($self._class())._collectionClass())._from_(associations),$globals.HashedCollection._newFromPairs_(["a",(1),"b",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testFrom",{associations:associations})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testKeys",
protocol: "tests",
args: [],
source: "testKeys\x0a\x09self assert:self collectionClass new keys isEmpty.\x0a\x09self assertSameContents:self collection keys as: self collectionKeys.\x0a\x09self assertSameContents:self collectionWithNewValue keys as: self collectionKeys, { self sampleNewIndex }",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "isEmpty", "keys", "new", "collectionClass", "assertSameContents:as:", "collection", "collectionKeys", "collectionWithNewValue", ",", "sampleNewIndex"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv([$recv($recv($self._collectionClass())._new())._keys()
,$ctx1.sendIdx["keys"]=1
][0])._isEmpty());
[$self._assertSameContents_as_([$recv($self._collection())._keys()
,$ctx1.sendIdx["keys"]=2
][0],[$self._collectionKeys()
,$ctx1.sendIdx["collectionKeys"]=1
][0])
,$ctx1.sendIdx["assertSameContents:as:"]=1
][0];
$self._assertSameContents_as_($recv($self._collectionWithNewValue())._keys(),$recv($self._collectionKeys()).__comma([$self._sampleNewIndex()]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testKeys",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testNewFromPairs",
protocol: "tests",
args: [],
source: "testNewFromPairs\x0a\x22Accept an array in which all odd indexes are keys and evens are values.\x22\x0a| flattenedAssociations |\x0aflattenedAssociations := { 'a'. 1. 'b'. 2 }.\x0aself assertSameContents: ( self class collectionClass newFromPairs: flattenedAssociations ) as: #{ 'a' -> 1. 'b' -> 2 }.",
referencedClasses: [],
pragmas: [],
messageSends: ["assertSameContents:as:", "newFromPairs:", "collectionClass", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var flattenedAssociations;
return $core.withContext(function($ctx1) {
flattenedAssociations=["a",(1),"b",(2)];
$self._assertSameContents_as_($recv($recv($self._class())._collectionClass())._newFromPairs_(flattenedAssociations),$globals.HashedCollection._newFromPairs_(["a",(1),"b",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNewFromPairs",{flattenedAssociations:flattenedAssociations})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testPrintString",
protocol: "tests",
args: [],
source: "testPrintString\x0a\x09self\x0a\x09\x09assert: (self collectionClass new\x0a\x09\x09\x09\x09\x09\x09\x09at:'firstname' put: 'James';\x0a\x09\x09\x09\x09\x09\x09\x09at:'lastname' put: 'Bond';\x0a\x09\x09\x09\x09\x09\x09\x09printString)\x0a\x09\x09equals: 'a ', self collectionClass name, ' (''firstname'' -> ''James'' , ''lastname'' -> ''Bond'')'",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "at:put:", "new", "collectionClass", "printString", ",", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv([$self._collectionClass()
,$ctx1.sendIdx["collectionClass"]=1
][0])._new();
[$recv($1)._at_put_("firstname","James")
,$ctx1.sendIdx["at:put:"]=1
][0];
$recv($1)._at_put_("lastname","Bond");
$self._assert_equals_($recv($1)._printString(),[$recv("a ".__comma($recv($self._collectionClass())._name())).__comma(" ('firstname' -> 'James' , 'lastname' -> 'Bond')")
,$ctx1.sendIdx[","]=1
][0]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintString",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testRemoveKey",
protocol: "tests",
args: [],
source: "testRemoveKey\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self should: [ collection removeKey: each ] raise: Error.\x0a\x09\x09self assert: collection equals: self collection ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self assert: (collection removeKey: index) equals: value.\x0a\x09\x09self deny: collection = self collection ].\x0a\x09self\x0a\x09\x09assert: (self collectionWithNewValue removeKey: self sampleNewIndex; yourself)\x0a\x09\x09equals: self collection",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["nonIndexesDo:", "collection", "should:raise:", "removeKey:", "assert:equals:", "samplesDo:", "deny:", "=", "collectionWithNewValue", "sampleNewIndex", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self._nonIndexesDo_((function(each){
var collection;
return $core.withContext(function($ctx2) {
collection=[$self._collection()
,$ctx2.sendIdx["collection"]=1
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return [$recv(collection)._removeKey_(each)
,$ctx3.sendIdx["removeKey:"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.Error);
return [$self._assert_equals_(collection,[$self._collection()
,$ctx2.sendIdx["collection"]=2
][0])
,$ctx2.sendIdx["assert:equals:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each,collection:collection},$ctx1,1)});
}));
$self._samplesDo_((function(index,value){
var collection;
return $core.withContext(function($ctx2) {
collection=[$self._collection()
,$ctx2.sendIdx["collection"]=3
][0];
[$self._assert_equals_([$recv(collection)._removeKey_(index)
,$ctx2.sendIdx["removeKey:"]=2
][0],value)
,$ctx2.sendIdx["assert:equals:"]=2
][0];
return $self._deny_($recv(collection).__eq([$self._collection()
,$ctx2.sendIdx["collection"]=4
][0]));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value,collection:collection},$ctx1,3)});
}));
$1=$self._collectionWithNewValue();
$recv($1)._removeKey_($self._sampleNewIndex());
$self._assert_equals_($recv($1)._yourself(),$self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveKey",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testRemoveKeyIfAbsent",
protocol: "tests",
args: [],
source: "testRemoveKeyIfAbsent\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self assert: (collection removeKey: each ifAbsent: [ self sampleNewValue ]) equals: self sampleNewValue.\x0a\x09\x09self assert: collection equals: self collection ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09| collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09self assert: (collection removeKey: index ifAbsent: [ self sampleNewValue ]) equals: value.\x0a\x09\x09self deny: collection = self collection ].\x0a\x09self\x0a\x09\x09assert: (self collectionWithNewValue removeKey: self sampleNewIndex ifAbsent: [ self assert: false ]; yourself)\x0a\x09\x09equals: self collection",
referencedClasses: [],
pragmas: [],
messageSends: ["nonIndexesDo:", "collection", "assert:equals:", "removeKey:ifAbsent:", "sampleNewValue", "samplesDo:", "deny:", "=", "collectionWithNewValue", "sampleNewIndex", "assert:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self._nonIndexesDo_((function(each){
var collection;
return $core.withContext(function($ctx2) {
collection=[$self._collection()
,$ctx2.sendIdx["collection"]=1
][0];
[$self._assert_equals_([$recv(collection)._removeKey_ifAbsent_(each,(function(){
return $core.withContext(function($ctx3) {
return [$self._sampleNewValue()
,$ctx3.sendIdx["sampleNewValue"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))
,$ctx2.sendIdx["removeKey:ifAbsent:"]=1
][0],[$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0])
,$ctx2.sendIdx["assert:equals:"]=1
][0];
return [$self._assert_equals_(collection,[$self._collection()
,$ctx2.sendIdx["collection"]=2
][0])
,$ctx2.sendIdx["assert:equals:"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each,collection:collection},$ctx1,1)});
}));
$self._samplesDo_((function(index,value){
var collection;
return $core.withContext(function($ctx2) {
collection=[$self._collection()
,$ctx2.sendIdx["collection"]=3
][0];
[$self._assert_equals_([$recv(collection)._removeKey_ifAbsent_(index,(function(){
return $core.withContext(function($ctx3) {
return $self._sampleNewValue();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}))
,$ctx2.sendIdx["removeKey:ifAbsent:"]=2
][0],value)
,$ctx2.sendIdx["assert:equals:"]=3
][0];
return $self._deny_($recv(collection).__eq([$self._collection()
,$ctx2.sendIdx["collection"]=4
][0]));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value,collection:collection},$ctx1,3)});
}));
$1=$self._collectionWithNewValue();
$recv($1)._removeKey_ifAbsent_($self._sampleNewIndex(),(function(){
return $core.withContext(function($ctx2) {
return $self._assert_(false);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
$self._assert_equals_($recv($1)._yourself(),$self._collection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveKeyIfAbsent",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testUnorderedComma",
protocol: "tests",
args: [],
source: "testUnorderedComma\x0a\x09self assert: self collection, self collection equals: self collection.\x0a\x09self assert: self sampleNewValueAsCollection, self collection equals: self collectionWithNewValue.\x0a\x09self assert: self collection, self collectionWithNewValue equals: self collectionWithNewValue.\x0a\x09self assert: self collectionWithNewValue, self collection equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", ",", "collection", "sampleNewValueAsCollection", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0]).__comma([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx[","]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($self._sampleNewValueAsCollection()).__comma([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])
,$ctx1.sendIdx[","]=2
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=5
][0]).__comma([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0])
,$ctx1.sendIdx[","]=3
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=4
][0]).__comma($self._collection()),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnorderedComma",{})});
}; }),
$globals.AssociativeCollectionTest);

$core.addMethod(
$core.method({
selector: "testValues",
protocol: "tests",
args: [],
source: "testValues\x0a\x09self assert:self collectionClass new values isEmpty.\x0a\x09self assertSameContents:self collection values as: self collectionValues.\x0a\x09self assertSameContents:self collectionWithNewValue values as: self collectionValues, { self sampleNewValue }",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "isEmpty", "values", "new", "collectionClass", "assertSameContents:as:", "collection", "collectionValues", "collectionWithNewValue", ",", "sampleNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv([$recv($recv($self._collectionClass())._new())._values()
,$ctx1.sendIdx["values"]=1
][0])._isEmpty());
[$self._assertSameContents_as_([$recv($self._collection())._values()
,$ctx1.sendIdx["values"]=2
][0],[$self._collectionValues()
,$ctx1.sendIdx["collectionValues"]=1
][0])
,$ctx1.sendIdx["assertSameContents:as:"]=1
][0];
$self._assertSameContents_as_($recv($self._collectionWithNewValue())._values(),$recv($self._collectionValues()).__comma([$self._sampleNewValue()]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValues",{})});
}; }),
$globals.AssociativeCollectionTest);



$core.addClass("DictionaryTest", $globals.AssociativeCollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collection",
protocol: "fixture",
args: [],
source: "collection\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: 1;\x0a\x09\x09at: 'a' put: 2;\x0a\x09\x09at: true put: 3;\x0a\x09\x09at: 1@3 put: -4;\x0a\x09\x09at: sampleBlock put: 9;\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["at:put:", "new", "@", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
[$recv($1)._at_put_((1),(1))
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($1)._at_put_("a",(2))
,$ctx1.sendIdx["at:put:"]=2
][0];
[$recv($1)._at_put_(true,(3))
,$ctx1.sendIdx["at:put:"]=3
][0];
[$recv($1)._at_put_((1).__at((3)),(-4))
,$ctx1.sendIdx["at:put:"]=4
][0];
$recv($1)._at_put_($self.sampleBlock,(9));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collection",{})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionKeys",
protocol: "fixture",
args: [],
source: "collectionKeys\x0a\x09^ {1. 'a'. true. 1@3. sampleBlock}",
referencedClasses: [],
pragmas: [],
messageSends: ["@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [(1),"a",true,(1).__at((3)),$self.sampleBlock];
}, function($ctx1) {$ctx1.fill(self,"collectionKeys",{})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: "fixture",
args: [],
source: "collectionOfPrintStrings\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: '1';\x0a\x09\x09at: 'a' put: '2';\x0a\x09\x09at: true put: '3';\x0a\x09\x09at: 1@3 put: '-4';\x0a\x09\x09at: sampleBlock put: '9';\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["at:put:", "new", "@", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
[$recv($1)._at_put_((1),"1")
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($1)._at_put_("a","2")
,$ctx1.sendIdx["at:put:"]=2
][0];
[$recv($1)._at_put_(true,"3")
,$ctx1.sendIdx["at:put:"]=3
][0];
[$recv($1)._at_put_((1).__at((3)),"-4")
,$ctx1.sendIdx["at:put:"]=4
][0];
$recv($1)._at_put_($self.sampleBlock,"9");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionOfPrintStrings",{})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: "fixture",
args: [],
source: "collectionSize\x0a\x09^ 5",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (5);

}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionValues",
protocol: "fixture",
args: [],
source: "collectionValues\x0a\x09^ {1. 2. 3. -4. 9}",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [(1),(2),(3),(-4),(9)];

}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: "fixture",
args: [],
source: "collectionWithDuplicates\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: 1;\x0a\x09\x09at: 'a' put: 2;\x0a\x09\x09at: true put: 3;\x0a\x09\x09at: 4 put: -4;\x0a\x09\x09at: sampleBlock put: 9;\x0a\x09\x09at: 'b' put: 1;\x0a\x09\x09at: 3 put: 3;\x0a\x09\x09at: false put: 12;\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["at:put:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
[$recv($1)._at_put_((1),(1))
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($1)._at_put_("a",(2))
,$ctx1.sendIdx["at:put:"]=2
][0];
[$recv($1)._at_put_(true,(3))
,$ctx1.sendIdx["at:put:"]=3
][0];
[$recv($1)._at_put_((4),(-4))
,$ctx1.sendIdx["at:put:"]=4
][0];
[$recv($1)._at_put_($self.sampleBlock,(9))
,$ctx1.sendIdx["at:put:"]=5
][0];
[$recv($1)._at_put_("b",(1))
,$ctx1.sendIdx["at:put:"]=6
][0];
[$recv($1)._at_put_((3),(3))
,$ctx1.sendIdx["at:put:"]=7
][0];
$recv($1)._at_put_(false,(12));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithDuplicates",{})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: "fixture",
args: [],
source: "collectionWithNewValue\x0a\x09^ Dictionary new\x0a\x09\x09at: 1 put: 1;\x0a\x09\x09at: 'a' put: 2;\x0a\x09\x09at: true put: 3;\x0a\x09\x09at: 1@3 put: -4;\x0a\x09\x09at: sampleBlock put: 9;\x0a\x09\x09at: 'new' put: 'N';\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["at:put:", "new", "@", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
[$recv($1)._at_put_((1),(1))
,$ctx1.sendIdx["at:put:"]=1
][0];
[$recv($1)._at_put_("a",(2))
,$ctx1.sendIdx["at:put:"]=2
][0];
[$recv($1)._at_put_(true,(3))
,$ctx1.sendIdx["at:put:"]=3
][0];
[$recv($1)._at_put_((1).__at((3)),(-4))
,$ctx1.sendIdx["at:put:"]=4
][0];
[$recv($1)._at_put_($self.sampleBlock,(9))
,$ctx1.sendIdx["at:put:"]=5
][0];
$recv($1)._at_put_("new","N");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: "fixture",
args: [],
source: "sampleNewValueAsCollection\x0a\x09^ Dictionary new\x0a\x09\x09at: 'new' put: 'N';\x0a\x09\x09yourself",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["at:put:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Dictionary)._new();
$recv($1)._at_put_("new","N");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"sampleNewValueAsCollection",{})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09super samplesDo: aBlock.\x0a\x09aBlock value: true value: 3.\x0a\x09aBlock value: 1@3 value: -4.\x0a\x09aBlock value: sampleBlock value: 9",
referencedClasses: [],
pragmas: [],
messageSends: ["samplesDo:", "value:value:", "@"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._samplesDo_.call($self,aBlock))
,$ctx1.supercall = false
][0];
[$recv(aBlock)._value_value_(true,(3))
,$ctx1.sendIdx["value:value:"]=1
][0];
[$recv(aBlock)._value_value_((1).__at((3)),(-4))
,$ctx1.sendIdx["value:value:"]=2
][0];
$recv(aBlock)._value_value_($self.sampleBlock,(9));
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "testAccessing",
protocol: "tests",
args: [],
source: "testAccessing\x0a\x09| d |\x0a\x0a\x09d := Dictionary new.\x0a\x0a\x09d at: 'hello' put: 'world'.\x0a\x09self assert: (d at: 'hello') equals: 'world'.\x0a\x09self assert: (d at: 'hello' ifAbsent: [ nil ]) equals: 'world'.\x0a\x09self deny: (d at: 'foo' ifAbsent: [ nil ]) = 'world'.\x0a\x0a\x09self assert: (d includesKey: 'hello').\x0a\x09self deny: (d includesKey: 'foo').\x0a\x0a\x09d at: 1 put: 2.\x0a\x09self assert: (d at: 1) equals: 2.\x0a\x0a\x09d at: 1@3 put: 3.\x0a\x09self assert: (d at: 1@3) equals: 3.\x0a\x0a\x09self assert: (d includesKey: 1@3).\x0a\x09self deny: (d includesKey: 3@1)",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["new", "at:put:", "assert:equals:", "at:", "at:ifAbsent:", "deny:", "=", "assert:", "includesKey:", "@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var d;
return $core.withContext(function($ctx1) {
d=$recv($globals.Dictionary)._new();
[$recv(d)._at_put_("hello","world")
,$ctx1.sendIdx["at:put:"]=1
][0];
[$self._assert_equals_([$recv(d)._at_("hello")
,$ctx1.sendIdx["at:"]=1
][0],"world")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(d)._at_ifAbsent_("hello",(function(){
return nil;

}))
,$ctx1.sendIdx["at:ifAbsent:"]=1
][0],"world")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._deny_($recv($recv(d)._at_ifAbsent_("foo",(function(){
return nil;

}))).__eq("world"))
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_([$recv(d)._includesKey_("hello")
,$ctx1.sendIdx["includesKey:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_([$recv(d)._includesKey_("foo")
,$ctx1.sendIdx["includesKey:"]=2
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$recv(d)._at_put_((1),(2))
,$ctx1.sendIdx["at:put:"]=2
][0];
[$self._assert_equals_([$recv(d)._at_((1))
,$ctx1.sendIdx["at:"]=2
][0],(2))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$recv(d)._at_put_([(1).__at((3))
,$ctx1.sendIdx["@"]=1
][0],(3));
$self._assert_equals_($recv(d)._at_([(1).__at((3))
,$ctx1.sendIdx["@"]=2
][0]),(3));
$self._assert_([$recv(d)._includesKey_([(1).__at((3))
,$ctx1.sendIdx["@"]=3
][0])
,$ctx1.sendIdx["includesKey:"]=3
][0]);
$self._deny_($recv(d)._includesKey_((3).__at((1))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAccessing",{d:d})});
}; }),
$globals.DictionaryTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaries",
protocol: "tests",
args: [],
source: "testDynamicDictionaries\x0a\x09self assert: #{'hello' -> 1} asDictionary equals: (Dictionary with: 'hello' -> 1)",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["assert:equals:", "asDictionary", "with:", "->"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($globals.HashedCollection._newFromPairs_(["hello",(1)]))._asDictionary(),$recv($globals.Dictionary)._with_("hello".__minus_gt((1))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaries",{})});
}; }),
$globals.DictionaryTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09^ Dictionary",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Dictionary;

}; }),
$globals.DictionaryTest.a$cls);


$core.addClass("HashedCollectionTest", $globals.AssociativeCollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collection",
protocol: "fixture",
args: [],
source: "collection\x0a\x09^ #{ 'b' -> 1. 'a' -> 2. 'c' -> 3. 'd' -> -4 }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection._newFromPairs_(["b",(1),"a",(2),"c",(3),"d",(-4)]);

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionKeys",
protocol: "fixture",
args: [],
source: "collectionKeys\x0a\x09^ { 'b'. 'a'. 'c'. 'd' }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return ["b","a","c","d"];

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: "fixture",
args: [],
source: "collectionOfPrintStrings\x0a\x09^ #{ 'b' -> '1'. 'a' -> '2'. 'c' -> '3'. 'd' -> '-4' }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection._newFromPairs_(["b","1","a","2","c","3","d","-4"]);

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: "fixture",
args: [],
source: "collectionSize\x0a\x09^ 4",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (4);

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionValues",
protocol: "fixture",
args: [],
source: "collectionValues\x0a\x09^ { 1. 2. 3. -4 }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [(1),(2),(3),(-4)];

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: "fixture",
args: [],
source: "collectionWithDuplicates\x0a\x09^ #{ 'b' -> 1. 'a' -> 2. 'c' -> 3. 'd' -> -4. 'e' -> 1. 'f' -> 2. 'g' -> 10. 'h' -> 0 }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection._newFromPairs_(["b",(1),"a",(2),"c",(3),"d",(-4),"e",(1),"f",(2),"g",(10),"h",(0)]);

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: "fixture",
args: [],
source: "collectionWithNewValue\x0a\x09^ #{ 'b' -> 1. 'a' -> 2. 'c' -> 3. 'd' -> -4. 'new' -> 'N' }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection._newFromPairs_(["b",(1),"a",(2),"c",(3),"d",(-4),"new","N"]);

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: "fixture",
args: [],
source: "sampleNewValueAsCollection\x0a\x09^ #{ 'new' -> 'N' }",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection._newFromPairs_(["new","N"]);

}; }),
$globals.HashedCollectionTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaries",
protocol: "tests",
args: [],
source: "testDynamicDictionaries\x0a\x09self assert: #{'hello' -> 1} asHashedCollection equals: (HashedCollection with: 'hello' -> 1)",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["assert:equals:", "asHashedCollection", "with:", "->"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($globals.HashedCollection._newFromPairs_(["hello",(1)]))._asHashedCollection(),$recv($globals.HashedCollection)._with_("hello".__minus_gt((1))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaries",{})});
}; }),
$globals.HashedCollectionTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09^ HashedCollection",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection;

}; }),
$globals.HashedCollectionTest.a$cls);


$core.addClass("SequenceableCollectionTest", $globals.CollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collectionFirst",
protocol: "fixture",
args: [],
source: "collectionFirst\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionFirst",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionFirstTwo",
protocol: "fixture",
args: [],
source: "collectionFirstTwo\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionFirstTwo",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionLast",
protocol: "fixture",
args: [],
source: "collectionLast\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionLast",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "collectionLastTwo",
protocol: "fixture",
args: [],
source: "collectionLastTwo\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"collectionLastTwo",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "nonIndexesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "nonIndexesDo: aBlock\x0a\x09aBlock value: 0.\x0a\x09aBlock value: self collectionSize + 1.\x0a\x09aBlock value: 'z'",
referencedClasses: [],
pragmas: [],
messageSends: ["value:", "+", "collectionSize"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aBlock)._value_((0))
,$ctx1.sendIdx["value:"]=1
][0];
[$recv(aBlock)._value_($recv($self._collectionSize()).__plus((1)))
,$ctx1.sendIdx["value:"]=2
][0];
$recv(aBlock)._value_("z");
return self;
}, function($ctx1) {$ctx1.fill(self,"nonIndexesDo:",{aBlock:aBlock})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09aBlock value: 1 value: self collectionFirst.\x0a\x09aBlock value: self collectionSize value: self collectionLast",
referencedClasses: [],
pragmas: [],
messageSends: ["value:value:", "collectionFirst", "collectionSize", "collectionLast"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(aBlock)._value_value_((1),$self._collectionFirst())
,$ctx1.sendIdx["value:value:"]=1
][0];
$recv(aBlock)._value_value_($self._collectionSize(),$self._collectionLast());
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testBeginsWith",
protocol: "tests",
args: [],
source: "testBeginsWith\x0a\x09self assert: (self collection beginsWith: self collectionClass new).\x0a\x09self assert: (self collection beginsWith: self collection).\x0a\x09self assert: (self collection beginsWith: self collectionFirstTwo).\x0a\x09self deny: (self collection beginsWith: self collectionLastTwo)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "beginsWith:", "collection", "new", "collectionClass", "collectionFirstTwo", "deny:", "collectionLastTwo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._beginsWith_($recv($self._collectionClass())._new())
,$ctx1.sendIdx["beginsWith:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._beginsWith_([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["beginsWith:"]=2
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])._beginsWith_($self._collectionFirstTwo())
,$ctx1.sendIdx["beginsWith:"]=3
][0]);
$self._deny_($recv($self._collection())._beginsWith_($self._collectionLastTwo()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBeginsWith",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testEndsWith",
protocol: "tests",
args: [],
source: "testEndsWith\x0a\x09self assert: (self collection endsWith: self collectionClass new).\x0a\x09self assert: (self collection endsWith: self collection).\x0a\x09self assert: (self collection endsWith: self collectionLastTwo).\x0a\x09self deny: (self collection endsWith: self collectionFirstTwo)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "endsWith:", "collection", "new", "collectionClass", "collectionLastTwo", "deny:", "collectionFirstTwo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._endsWith_($recv($self._collectionClass())._new())
,$ctx1.sendIdx["endsWith:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._endsWith_([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["endsWith:"]=2
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])._endsWith_($self._collectionLastTwo())
,$ctx1.sendIdx["endsWith:"]=3
][0]);
$self._deny_($recv($self._collection())._endsWith_($self._collectionFirstTwo()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEndsWith",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testFirst",
protocol: "tests",
args: [],
source: "testFirst\x0a\x09self assert: self collection first equals: self collectionFirst",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "first", "collection", "collectionFirst"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($self._collection())._first(),$self._collectionFirst());
return self;
}, function($ctx1) {$ctx1.fill(self,"testFirst",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testFirstN",
protocol: "tests",
args: [],
source: "testFirstN\x0a\x09self \x0a\x09\x09assert: (self collection first: 2)\x0a\x09\x09equals: self collectionFirstTwo.\x0a\x09\x09\x0a\x09self\x0a\x09\x09assert: (self collection first: 0)\x0a\x09\x09equals: self collectionClass new.\x0a\x09\x09\x0a\x09self\x0a\x09\x09assert: (self collection first: self collectionSize)\x0a\x09\x09equals: self collection.\x0a\x09\x09\x0a\x09self should: [ self collection first: 33 ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["assert:equals:", "first:", "collection", "collectionFirstTwo", "new", "collectionClass", "collectionSize", "should:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._first_((2))
,$ctx1.sendIdx["first:"]=1
][0],$self._collectionFirstTwo())
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._first_((0))
,$ctx1.sendIdx["first:"]=2
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])._first_($self._collectionSize())
,$ctx1.sendIdx["first:"]=3
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0]);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self._collection())._first_((33));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testFirstN",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testFourth",
protocol: "tests",
args: [],
source: "testFourth\x0a\x09self assert: (self collection fourth) equals: (self collection at: 4)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "fourth", "collection", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._fourth(),$recv($self._collection())._at_((4)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testFourth",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOfStartingAt",
protocol: "tests",
args: [],
source: "testIndexOfStartingAt\x0a\x09| jsNull |\x0a\x09jsNull := JSON parse: 'null'.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection indexOf: value startingAt: 1) equals: index.\x0a\x09\x09self assert: (self collection indexOf: value startingAt: index) equals: index.\x0a\x09\x09self assert: (self collection indexOf: value startingAt: index+1) equals: 0 ]",
referencedClasses: ["JSON"],
pragmas: [],
messageSends: ["parse:", "samplesDo:", "assert:equals:", "indexOf:startingAt:", "collection", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var jsNull;
return $core.withContext(function($ctx1) {
jsNull=$recv($globals.JSON)._parse_("null");
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._indexOf_startingAt_(value,(1))
,$ctx2.sendIdx["indexOf:startingAt:"]=1
][0],index)
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx2.sendIdx["collection"]=2
][0])._indexOf_startingAt_(value,index)
,$ctx2.sendIdx["indexOf:startingAt:"]=2
][0],index)
,$ctx2.sendIdx["assert:equals:"]=2
][0];
return $self._assert_equals_($recv($self._collection())._indexOf_startingAt_(value,$recv(index).__plus((1))),(0));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOfStartingAt",{jsNull:jsNull})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOfStartingAtWithNull",
protocol: "tests",
args: [],
source: "testIndexOfStartingAtWithNull\x0a\x09| jsNull |\x0a\x09jsNull := JSON parse: 'null'.\x0a\x09self samplesDo: [ :index :value | | collection |\x0a\x09\x09collection := self collection.\x0a\x09\x09collection at: index put: jsNull.\x0a\x09\x09self assert: (collection indexOf: jsNull startingAt: 1) equals: index.\x0a\x09\x09self assert: (collection indexOf: jsNull startingAt: index) equals: index.\x0a\x09\x09self assert: (collection indexOf: jsNull startingAt: index+1) equals: 0 ]",
referencedClasses: ["JSON"],
pragmas: [],
messageSends: ["parse:", "samplesDo:", "collection", "at:put:", "assert:equals:", "indexOf:startingAt:", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var jsNull;
return $core.withContext(function($ctx1) {
jsNull=$recv($globals.JSON)._parse_("null");
$self._samplesDo_((function(index,value){
var collection;
return $core.withContext(function($ctx2) {
collection=$self._collection();
$recv(collection)._at_put_(index,jsNull);
[$self._assert_equals_([$recv(collection)._indexOf_startingAt_(jsNull,(1))
,$ctx2.sendIdx["indexOf:startingAt:"]=1
][0],index)
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(collection)._indexOf_startingAt_(jsNull,index)
,$ctx2.sendIdx["indexOf:startingAt:"]=2
][0],index)
,$ctx2.sendIdx["assert:equals:"]=2
][0];
return $self._assert_equals_($recv(collection)._indexOf_startingAt_(jsNull,$recv(index).__plus((1))),(0));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value,collection:collection},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOfStartingAtWithNull",{jsNull:jsNull})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testLast",
protocol: "tests",
args: [],
source: "testLast\x0a\x09self assert: self collection last equals: self collectionLast",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "last", "collection", "collectionLast"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($self._collection())._last(),$self._collectionLast());
return self;
}, function($ctx1) {$ctx1.fill(self,"testLast",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testLastN",
protocol: "tests",
args: [],
source: "testLastN\x0a\x09self \x0a\x09\x09assert: (self collection last: 2) \x0a\x09\x09equals: self collectionLastTwo.\x0a\x09\x09\x0a\x09self\x0a\x09\x09assert: (self collection last: 0)\x0a\x09\x09equals: self collectionClass new.\x0a\x0a\x09self\x0a\x09\x09assert: (self collection last: self collectionSize)\x0a\x09\x09equals: self collection.\x0a\x0a\x09self should: [ self collection last: 33 ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["assert:equals:", "last:", "collection", "collectionLastTwo", "new", "collectionClass", "collectionSize", "should:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._last_((2))
,$ctx1.sendIdx["last:"]=1
][0],$self._collectionLastTwo())
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])._last_((0))
,$ctx1.sendIdx["last:"]=2
][0],$recv($self._collectionClass())._new())
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])._last_($self._collectionSize())
,$ctx1.sendIdx["last:"]=3
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0]);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self._collection())._last_((33));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testLastN",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testOrderedComma",
protocol: "tests",
args: [],
source: "testOrderedComma\x0a\x09self assertSameContents: self sampleNewValueAsCollection, self collection as: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assertSameContents:as:", ",", "sampleNewValueAsCollection", "collection", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assertSameContents_as_($recv($self._sampleNewValueAsCollection()).__comma($self._collection()),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testOrderedComma",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testSecond",
protocol: "tests",
args: [],
source: "testSecond\x0a\x09self assert: (self collection second) equals: (self collection at: 2)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "second", "collection", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._second(),$recv($self._collection())._at_((2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSecond",{})});
}; }),
$globals.SequenceableCollectionTest);

$core.addMethod(
$core.method({
selector: "testThird",
protocol: "tests",
args: [],
source: "testThird\x0a\x09self assert: (self collection third) equals: (self collection at: 3)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "third", "collection", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._third(),$recv($self._collection())._at_((3)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testThird",{})});
}; }),
$globals.SequenceableCollectionTest);



$core.addClass("ArrayTest", $globals.SequenceableCollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collection",
protocol: "fixture",
args: [],
source: "collection\x0a\x09^ #(1 2 3 -4)",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [(1), (2), (3), (-4)];

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionFirst",
protocol: "fixture",
args: [],
source: "collectionFirst\x0a\x09^ 1",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (1);

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionFirstTwo",
protocol: "fixture",
args: [],
source: "collectionFirstTwo\x0a\x09^ #(1 2)",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [(1), (2)];

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionLast",
protocol: "fixture",
args: [],
source: "collectionLast\x0a\x09^ -4",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (-4);

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionLastTwo",
protocol: "fixture",
args: [],
source: "collectionLastTwo\x0a\x09^ #(3 -4)",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [(3), (-4)];

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: "fixture",
args: [],
source: "collectionOfPrintStrings\x0a\x09^ #('1' '2' '3' '-4')",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return ["1", "2", "3", "-4"];

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: "fixture",
args: [],
source: "collectionSize\x0a\x09^ 4",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (4);

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: "fixture",
args: [],
source: "collectionWithDuplicates\x0a\x09^ #('a' 'b' 'c' 1 2 1 'a' ())",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return ["a", "b", "c", (1), (2), (1), "a", []];

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: "fixture",
args: [],
source: "collectionWithNewValue\x0a\x09^ #(1 2 3 -4 'N')",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return [(1), (2), (3), (-4), "N"];

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "sampleNewIndex",
protocol: "fixture",
args: [],
source: "sampleNewIndex\x0a\x09^ 5",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (5);

}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09super samplesDo: aBlock.\x0a\x09aBlock value: 3 value: 3.",
referencedClasses: [],
pragmas: [],
messageSends: ["samplesDo:", "value:value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._samplesDo_.call($self,aBlock))
,$ctx1.supercall = false
][0];
$recv(aBlock)._value_value_((3),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testAdd",
protocol: "tests",
args: [],
source: "testAdd \x0a\x09| array | \x0a\x09array := self collection. \x0a\x09array add: 6.\x0a\x09\x0a\x09self assert: array last equals: 6",
referencedClasses: [],
pragmas: [],
messageSends: ["collection", "add:", "assert:equals:", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=$self._collection();
$recv(array)._add_((6));
$self._assert_equals_($recv(array)._last(),(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAdd",{array:array})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testAddFirst",
protocol: "tests",
args: [],
source: "testAddFirst\x0a\x09self assert: (self collection addFirst: 0; yourself) first equals: 0",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "first", "addFirst:", "collection", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._collection();
$recv($1)._addFirst_((0));
$self._assert_equals_($recv($recv($1)._yourself())._first(),(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddFirst",{})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testPrintString",
protocol: "tests",
args: [],
source: "testPrintString\x0a\x09| array |\x0a\x09array := Array new.\x0a\x09self assert: array printString equals: 'an Array ()'.\x0a\x09array add: 1; add: 3.\x0a\x09self assert: array printString equals: 'an Array (1 3)'.\x0a\x09array add: 'foo'.\x0a\x09self assert: array printString equals: 'an Array (1 3 ''foo'')'.\x0a\x09array remove: 1; remove: 3.\x0a\x09self assert: array printString equals: 'an Array (''foo'')'.\x0a\x09array addLast: 3.\x0a\x09self assert: array printString equals: 'an Array (''foo'' 3)'.\x0a\x09array addLast: 3.\x0a\x09self assert: array printString equals: 'an Array (''foo'' 3 3)'.",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["new", "assert:equals:", "printString", "add:", "remove:", "addLast:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
var $1,$2;
array=$recv($globals.Array)._new();
[$self._assert_equals_([$recv(array)._printString()
,$ctx1.sendIdx["printString"]=1
][0],"an Array ()")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$1=array;
[$recv($1)._add_((1))
,$ctx1.sendIdx["add:"]=1
][0];
[$recv($1)._add_((3))
,$ctx1.sendIdx["add:"]=2
][0];
[$self._assert_equals_([$recv(array)._printString()
,$ctx1.sendIdx["printString"]=2
][0],"an Array (1 3)")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$recv(array)._add_("foo");
[$self._assert_equals_([$recv(array)._printString()
,$ctx1.sendIdx["printString"]=3
][0],"an Array (1 3 'foo')")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$2=array;
[$recv($2)._remove_((1))
,$ctx1.sendIdx["remove:"]=1
][0];
$recv($2)._remove_((3));
[$self._assert_equals_([$recv(array)._printString()
,$ctx1.sendIdx["printString"]=4
][0],"an Array ('foo')")
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$recv(array)._addLast_((3))
,$ctx1.sendIdx["addLast:"]=1
][0];
[$self._assert_equals_([$recv(array)._printString()
,$ctx1.sendIdx["printString"]=5
][0],"an Array ('foo' 3)")
,$ctx1.sendIdx["assert:equals:"]=5
][0];
$recv(array)._addLast_((3));
$self._assert_equals_($recv(array)._printString(),"an Array ('foo' 3 3)");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintString",{array:array})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemove",
protocol: "tests",
args: [],
source: "testRemove \x0a\x09| array |\x0a\x09array := #(1 2 3 4 5). \x0a\x09array remove: 3.\x0a\x0a\x09self assert: array equals: #(1 2 4 5).\x0a\x09self should: [ array remove: 3 ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["remove:", "assert:equals:", "should:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(1), (2), (3), (4), (5)];
[$recv(array)._remove_((3))
,$ctx1.sendIdx["remove:"]=1
][0];
$self._assert_equals_(array,[(1), (2), (4), (5)]);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(array)._remove_((3));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemove",{array:array})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemoveFromTo",
protocol: "tests",
args: [],
source: "testRemoveFromTo\x0a\x09\x0a\x09self assert: (#(1 2 3 4) removeFrom: 1 to: 3) equals: #(4).\x0a\x09self assert: (#(1 2 3 4) removeFrom: 2 to: 3) equals: #(1 4).\x0a\x09self assert: (#(1 2 3 4) removeFrom: 2 to: 4) equals: #(1)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "removeFrom:to:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([[(1), (2), (3), (4)]._removeFrom_to_((1),(3))
,$ctx1.sendIdx["removeFrom:to:"]=1
][0],[(4)])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([[(1), (2), (3), (4)]._removeFrom_to_((2),(3))
,$ctx1.sendIdx["removeFrom:to:"]=2
][0],[(1), (4)])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_([(1), (2), (3), (4)]._removeFrom_to_((2),(4)),[(1)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveFromTo",{})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemoveIndex",
protocol: "tests",
args: [],
source: "testRemoveIndex\x0a\x09\x0a\x09self assert: (#(1 2 3 4) removeIndex: 2) equals: #(1 3 4).\x0a\x09self assert: (#(1 2 3 4) removeIndex: 1) equals: #(2 3 4).\x0a\x09self assert: (#('hello') removeIndex: 1) equals: #()",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "removeIndex:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([[(1), (2), (3), (4)]._removeIndex_((2))
,$ctx1.sendIdx["removeIndex:"]=1
][0],[(1), (3), (4)])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([[(1), (2), (3), (4)]._removeIndex_((1))
,$ctx1.sendIdx["removeIndex:"]=2
][0],[(2), (3), (4)])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_(["hello"]._removeIndex_((1)),[]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveIndex",{})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testRemoveLast",
protocol: "tests",
args: [],
source: "testRemoveLast \x0a\x09| array |\x0a\x09array := #(1 2). \x0a\x09array removeLast.\x0a\x09\x0a\x09self assert: array last equals: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["removeLast", "assert:equals:", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(1), (2)];
$recv(array)._removeLast();
$self._assert_equals_($recv(array)._last(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveLast",{array:array})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testReversed",
protocol: "tests",
args: [],
source: "testReversed\x0a\x09|array|\x0a\x09array := #(5 4 3 2 1). \x0a\x09self assert: (array reversed) equals: #(1 2 3 4 5)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "reversed"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(5), (4), (3), (2), (1)];
$self._assert_equals_($recv(array)._reversed(),[(1), (2), (3), (4), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testReversed",{array:array})});
}; }),
$globals.ArrayTest);

$core.addMethod(
$core.method({
selector: "testSort",
protocol: "tests",
args: [],
source: "testSort\x0a\x09| array |\x0a\x09array := #(10 1 5). \x0a\x09array sort.\x0a\x09self assert: array equals: #(1 5 10)",
referencedClasses: [],
pragmas: [],
messageSends: ["sort", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var array;
return $core.withContext(function($ctx1) {
array=[(10), (1), (5)];
$recv(array)._sort();
$self._assert_equals_(array,[(1), (5), (10)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSort",{array:array})});
}; }),
$globals.ArrayTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09^ Array",
referencedClasses: ["Array"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Array;

}; }),
$globals.ArrayTest.a$cls);


$core.addClass("StringTest", $globals.SequenceableCollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collection",
protocol: "fixture",
args: [],
source: "collection\x0a\x09^ 'helLo'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "helLo";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionFirst",
protocol: "fixture",
args: [],
source: "collectionFirst\x0a\x09^ 'h'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "h";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionFirstTwo",
protocol: "fixture",
args: [],
source: "collectionFirstTwo\x0a\x09^ 'he'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "he";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionLast",
protocol: "fixture",
args: [],
source: "collectionLast\x0a\x09^ 'o'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "o";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionLastTwo",
protocol: "fixture",
args: [],
source: "collectionLastTwo\x0a\x09^ 'Lo'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "Lo";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: "fixture",
args: [],
source: "collectionOfPrintStrings\x0a\x09^ '''h''''e''''l''''L''''o'''",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "'h''e''l''L''o'";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: "fixture",
args: [],
source: "collectionSize\x0a\x09^ 5",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (5);

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: "fixture",
args: [],
source: "collectionWithDuplicates\x0a\x09^ 'abbaerten'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "abbaerten";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: "fixture",
args: [],
source: "collectionWithNewValue\x0a\x09^ 'helLoN'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "helLoN";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "sampleNewValueAsCollection",
protocol: "fixture",
args: [],
source: "sampleNewValueAsCollection\x0a\x09^ 'N'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "N";

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09super samplesDo: aBlock.\x0a\x09aBlock value: 3 value: 'l'",
referencedClasses: [],
pragmas: [],
messageSends: ["samplesDo:", "value:value:"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._samplesDo_.call($self,aBlock))
,$ctx1.supercall = false
][0];
$recv(aBlock)._value_value_((3),"l");
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: "tests",
args: [],
source: "testAddAll\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ self collection addAll: self collection ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "addAll:", "collection"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._addAll_($self._collection());
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAddRemove",
protocol: "tests",
args: [],
source: "testAddRemove\x0a\x09self should: [ 'hello' add: 'a' ] raise: Error.\x0a\x09self should: [ 'hello' remove: 'h' ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "add:", "remove:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._add_("a");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error)
,$ctx1.sendIdx["should:raise:"]=1
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._remove_("h");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddRemove",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsArray",
protocol: "tests",
args: [],
source: "testAsArray\x0a\x09self assert: 'hello' asArray equals: #('h' 'e' 'l' 'l' 'o').",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asArray"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("hello"._asArray(),["h", "e", "l", "l", "o"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsArray",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsLowerCase",
protocol: "tests",
args: [],
source: "testAsLowerCase\x0a\x09self assert: 'JACKIE' asLowercase equals: 'jackie'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asLowercase"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("JACKIE"._asLowercase(),"jackie");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsLowerCase",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsNumber",
protocol: "tests",
args: [],
source: "testAsNumber\x0a\x09self assert: '3' asNumber equals: 3.\x0a\x09self assert: '-3' asNumber equals: -3.\x0a\x09self assert: '-1.5' asNumber equals: -1.5.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asNumber"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_(["3"._asNumber()
,$ctx1.sendIdx["asNumber"]=1
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_(["-3"._asNumber()
,$ctx1.sendIdx["asNumber"]=2
][0],(-3))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_("-1.5"._asNumber(),(-1.5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsNumber",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsUpperCase",
protocol: "tests",
args: [],
source: "testAsUpperCase\x0a\x09self assert: 'jackie' asUppercase equals: 'JACKIE'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asUppercase"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("jackie"._asUppercase(),"JACKIE");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsUpperCase",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAsciiValue",
protocol: "tests",
args: [],
source: "testAsciiValue\x0a    | characterA characterU |\x0a    characterA := 'A'.\x0a    characterU := 'U'.\x0a    self assert: (characterA asciiValue) equals:65.\x0a    self assert: (characterU asciiValue) equals:85",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asciiValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var characterA,characterU;
return $core.withContext(function($ctx1) {
characterA="A";
characterU="U";
[$self._assert_equals_([$recv(characterA)._asciiValue()
,$ctx1.sendIdx["asciiValue"]=1
][0],(65))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(characterU)._asciiValue(),(85));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsciiValue",{characterA:characterA,characterU:characterU})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsentPut",
protocol: "tests",
args: [],
source: "testAtIfAbsentPut\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ 'hello' at: 6 ifAbsentPut: [ 'a' ] ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "at:ifAbsentPut:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._at_ifAbsentPut_((6),(function(){
return "a";

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsentPut",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testAtPut",
protocol: "tests",
args: [],
source: "testAtPut\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ 'hello' at: 1 put: 'a' ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "at:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return "hello"._at_put_((1),"a");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtPut",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCapitalized",
protocol: "tests",
args: [],
source: "testCapitalized\x0a\x09self assert: 'test' capitalized equals: 'Test'.\x0a\x09self assert: 'Test' capitalized equals: 'Test'.\x0a\x09self assert: '' capitalized equals: ''.\x0a\x09self assert: 'Test' isCapitalized equals: true.\x0a\x09self assert: 'test' isCapitalized equals: false.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "capitalized", "isCapitalized"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_(["test"._capitalized()
,$ctx1.sendIdx["capitalized"]=1
][0],"Test")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_(["Test"._capitalized()
,$ctx1.sendIdx["capitalized"]=2
][0],"Test")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_(""._capitalized(),"")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_(["Test"._isCapitalized()
,$ctx1.sendIdx["isCapitalized"]=1
][0],true)
,$ctx1.sendIdx["assert:equals:"]=4
][0];
$self._assert_equals_("test"._isCapitalized(),false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCapitalized",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCharCodeAt",
protocol: "tests",
args: [],
source: "testCharCodeAt\x0a\x09self assert: ('jackie' charCodeAt:1) equals: 106.\x0a\x09self assert: ('jackie' charCodeAt:2) equals: 97.\x0a\x09self assert: ('jackie' charCodeAt:3) equals: 99.\x0a\x09self assert: ('jackie' charCodeAt:4) equals: 107.\x0a\x09self assert: ('jackie' charCodeAt:5) equals: 105.\x0a\x09self assert: ('jackie' charCodeAt:6) equals: 101",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "charCodeAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_(["jackie"._charCodeAt_((1))
,$ctx1.sendIdx["charCodeAt:"]=1
][0],(106))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_(["jackie"._charCodeAt_((2))
,$ctx1.sendIdx["charCodeAt:"]=2
][0],(97))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_(["jackie"._charCodeAt_((3))
,$ctx1.sendIdx["charCodeAt:"]=3
][0],(99))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_(["jackie"._charCodeAt_((4))
,$ctx1.sendIdx["charCodeAt:"]=4
][0],(107))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_(["jackie"._charCodeAt_((5))
,$ctx1.sendIdx["charCodeAt:"]=5
][0],(105))
,$ctx1.sendIdx["assert:equals:"]=5
][0];
$self._assert_equals_("jackie"._charCodeAt_((6)),(101));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCharCodeAt",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCopyFromTo",
protocol: "tests",
args: [],
source: "testCopyFromTo\x0a\x09self assert: ('jackie' copyFrom: 1 to: 3) equals: 'jac'.\x0a\x09self assert: ('jackie' copyFrom: 4 to: 6) equals: 'kie'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "copyFrom:to:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_(["jackie"._copyFrom_to_((1),(3))
,$ctx1.sendIdx["copyFrom:to:"]=1
][0],"jac")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_("jackie"._copyFrom_to_((4),(6)),"kie");
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopyFromTo",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCopySeparates",
protocol: "tests",
args: [],
source: "testCopySeparates\x0a\x09\x22String instances are immutable\x22\x0a\x09self assert: self collection copy == self collection",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "==", "copy", "collection"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0])._copy()).__eq_eq($self._collection()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopySeparates",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testCopyWithoutAll",
protocol: "tests",
args: [],
source: "testCopyWithoutAll\x0a\x09self\x0a\x09\x09assert: ('*hello* *world*' copyWithoutAll: '*')\x0a\x09\x09equals: 'hello world'",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "copyWithoutAll:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("*hello* *world*"._copyWithoutAll_("*"),"hello world");
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopyWithoutAll",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: "tests",
args: [],
source: "testEquality\x0a\x09self assert: 'hello' equals: 'hello'.\x0a\x09self deny: 'hello' = 'world'.\x0a\x09\x0a\x09\x22Test for issue 459\x22\x0a\x09self deny: 'hello' = (#() at: 1 ifAbsent: [ ]).\x0a\x0a\x09self assert: 'hello' equals: 'hello' yourself.\x0a\x09self assert: 'hello' yourself equals: 'hello'.\x0a\x0a\x09\x22test JS falsy value\x22\x0a\x09self deny: '' = 0",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "deny:", "=", "at:ifAbsent:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_("hello","hello")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._deny_(["hello".__eq("world")
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_(["hello".__eq([]._at_ifAbsent_((1),(function(){

})))
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._assert_equals_("hello",["hello"._yourself()
,$ctx1.sendIdx["yourself"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_("hello"._yourself(),"hello");
$self._deny_("".__eq((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: "tests",
args: [],
source: "testIdentity\x0a\x09self assert: 'hello' == 'hello'.\x0a\x09self deny: 'hello' == 'world'.\x0a\x0a\x09self assert: 'hello' == 'hello' yourself.\x0a\x09self assert: 'hello' yourself == 'hello'.\x0a\x0a\x09\x22test JS falsy value\x22\x0a\x09self deny: '' == 0",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "==", "deny:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_(["hello".__eq_eq("hello")
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_(["hello".__eq_eq("world")
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_(["hello".__eq_eq(["hello"._yourself()
,$ctx1.sendIdx["yourself"]=1
][0])
,$ctx1.sendIdx["=="]=3
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_([$recv("hello"._yourself()).__eq_eq("hello")
,$ctx1.sendIdx["=="]=4
][0]);
$self._deny_("".__eq_eq((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIncludesSubString",
protocol: "tests",
args: [],
source: "testIncludesSubString\x0a\x09self assert: ('amber' includesSubString: 'ber').\x0a\x09self deny: ('amber' includesSubString: 'zork').",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "includesSubString:", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_(["amber"._includesSubString_("ber")
,$ctx1.sendIdx["includesSubString:"]=1
][0]);
$self._deny_("amber"._includesSubString_("zork"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIncludesSubString",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIndexOfStartingAtWithNull",
protocol: "tests",
args: [],
source: "testIndexOfStartingAtWithNull\x0a\x09\x22String cannot hold JS null\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIndexOfWithNull",
protocol: "tests",
args: [],
source: "testIndexOfWithNull\x0a\x09\x22String cannot hold JS null\x22",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testIsVowel",
protocol: "tests",
args: [],
source: "testIsVowel\x0a    |vowel consonant|\x0a    vowel := 'u'.\x0a    consonant := 'z'.\x0a    self assert: vowel isVowel equals: true.\x0a    self assert: consonant isVowel equals: false",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "isVowel"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var vowel,consonant;
return $core.withContext(function($ctx1) {
vowel="u";
consonant="z";
[$self._assert_equals_([$recv(vowel)._isVowel()
,$ctx1.sendIdx["isVowel"]=1
][0],true)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(consonant)._isVowel(),false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsVowel",{vowel:vowel,consonant:consonant})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testJoin",
protocol: "tests",
args: [],
source: "testJoin\x0a\x09self assert: (',' join: #('hello' 'world')) equals: 'hello,world'",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "join:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_(","._join_(["hello", "world"]),"hello,world");
return self;
}, function($ctx1) {$ctx1.fill(self,"testJoin",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testRegression1224",
protocol: "tests",
args: [],
source: "testRegression1224\x0a\x09\x22String instances are read-only\x22\x0a\x09self should: [ (self collectionClass new\x0a\x09\x09remove: self sampleNewValue ifAbsent: [];\x0a\x09\x09yourself) size ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "size", "remove:ifAbsent:", "new", "collectionClass", "sampleNewValue", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
$1=$recv($self._collectionClass())._new();
$recv($1)._remove_ifAbsent_($self._sampleNewValue(),(function(){

}));
return $recv($recv($1)._yourself())._size();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1224",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testRemoveAll",
protocol: "tests",
args: [],
source: "testRemoveAll\x0a\x09self should: [ self collection removeAll ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "removeAll", "collection"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self._collection())._removeAll();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemoveAll",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testReversed",
protocol: "tests",
args: [],
source: "testReversed\x0a\x09self assert: 'jackiechan' reversed equals: 'nahceikcaj'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "reversed"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("jackiechan"._reversed(),"nahceikcaj");
return self;
}, function($ctx1) {$ctx1.fill(self,"testReversed",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testStreamContents",
protocol: "tests",
args: [],
source: "testStreamContents\x0a\x09self\x0a\x09\x09assert: (String streamContents: [ :aStream |\x0a\x09\x09\x09aStream\x0a\x09\x09\x09\x09nextPutAll: 'hello'; space;\x0a\x09\x09\x09\x09nextPutAll: 'world' ])\x0a\x09\x09equals: 'hello world'",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["assert:equals:", "streamContents:", "nextPutAll:", "space"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($globals.String)._streamContents_((function(aStream){
return $core.withContext(function($ctx2) {
[$recv(aStream)._nextPutAll_("hello")
,$ctx2.sendIdx["nextPutAll:"]=1
][0];
$recv(aStream)._space();
return $recv(aStream)._nextPutAll_("world");
}, function($ctx2) {$ctx2.fillBlock({aStream:aStream},$ctx1,1)});
})),"hello world");
return self;
}, function($ctx1) {$ctx1.fill(self,"testStreamContents",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testSubStrings",
protocol: "tests",
args: [],
source: "testSubStrings\x0a\x09self assert: ('jackiechan' subStrings: 'ie') equals: #( 'jack' 'chan' ).",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "subStrings:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("jackiechan"._subStrings_("ie"),["jack", "chan"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSubStrings",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testTrim",
protocol: "tests",
args: [],
source: "testTrim\x0a\x09self assert: '       jackie' trimLeft equals: 'jackie'.\x0a\x09self assert: 'jackie               ' trimRight equals: 'jackie'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "trimLeft", "trimRight"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_("       jackie"._trimLeft(),"jackie")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_("jackie               "._trimRight(),"jackie");
return self;
}, function($ctx1) {$ctx1.fill(self,"testTrim",{})});
}; }),
$globals.StringTest);

$core.addMethod(
$core.method({
selector: "testValue",
protocol: "tests",
args: [],
source: "testValue\x0a\x0a\x09self assert: (#asString value: 1) equals: '1'.\x0a\x0a\x09\x22Which (since String and BlockClosure are now polymorphic) enables the nice idiom...\x22\x0a\x09self assert: (#(1 2 3) collect: #asString) equals: #('1' '2' '3')",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "value:", "collect:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_("asString"._value_((1)),"1")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_([(1), (2), (3)]._collect_("asString"),["1", "2", "3"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{})});
}; }),
$globals.StringTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09^ String",
referencedClasses: ["String"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.String;

}; }),
$globals.StringTest.a$cls);


$core.addClass("SetTest", $globals.CollectionTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collection",
protocol: "fixture",
args: [],
source: "collection\x0a\x09^ Set new\x0a\x09\x09add: Smalltalk;\x0a\x09\x09add: nil;\x0a\x09\x09add: 3@3;\x0a\x09\x09add: false;\x0a\x09\x09add: sampleBlock;\x0a\x09\x09yourself",
referencedClasses: ["Set", "Smalltalk"],
pragmas: [],
messageSends: ["add:", "new", "@", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Set)._new();
[$recv($1)._add_($globals.Smalltalk)
,$ctx1.sendIdx["add:"]=1
][0];
[$recv($1)._add_(nil)
,$ctx1.sendIdx["add:"]=2
][0];
[$recv($1)._add_((3).__at((3)))
,$ctx1.sendIdx["add:"]=3
][0];
[$recv($1)._add_(false)
,$ctx1.sendIdx["add:"]=4
][0];
$recv($1)._add_($self.sampleBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collection",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionOfPrintStrings",
protocol: "fixture",
args: [],
source: "collectionOfPrintStrings\x0a\x09^ Set new\x0a\x09\x09add: 'a SmalltalkImage';\x0a\x09\x09add: 'nil';\x0a\x09\x09add: '3@3';\x0a\x09\x09add: 'false';\x0a\x09\x09add: 'a BlockClosure';\x0a\x09\x09yourself",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["add:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Set)._new();
[$recv($1)._add_("a SmalltalkImage")
,$ctx1.sendIdx["add:"]=1
][0];
[$recv($1)._add_("nil")
,$ctx1.sendIdx["add:"]=2
][0];
[$recv($1)._add_("3@3")
,$ctx1.sendIdx["add:"]=3
][0];
[$recv($1)._add_("false")
,$ctx1.sendIdx["add:"]=4
][0];
$recv($1)._add_("a BlockClosure");
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionOfPrintStrings",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionSize",
protocol: "fixture",
args: [],
source: "collectionSize\x0a\x09^ 5",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (5);

}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionWithDuplicates",
protocol: "fixture",
args: [],
source: "collectionWithDuplicates\x0a\x09\x22Set has no duplicates\x22\x0a\x09^ self collection add: 0; yourself",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "collection", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._collection();
$recv($1)._add_((0));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithDuplicates",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "collectionWithNewValue",
protocol: "fixture",
args: [],
source: "collectionWithNewValue\x0a\x09^ Set new\x0a\x09\x09add: Smalltalk;\x0a\x09\x09add: nil;\x0a\x09\x09add: 3@3;\x0a\x09\x09add: 'N';\x0a\x09\x09add: false;\x0a\x09\x09add: sampleBlock;\x0a\x09\x09yourself",
referencedClasses: ["Set", "Smalltalk"],
pragmas: [],
messageSends: ["add:", "new", "@", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Set)._new();
[$recv($1)._add_($globals.Smalltalk)
,$ctx1.sendIdx["add:"]=1
][0];
[$recv($1)._add_(nil)
,$ctx1.sendIdx["add:"]=2
][0];
[$recv($1)._add_((3).__at((3)))
,$ctx1.sendIdx["add:"]=3
][0];
[$recv($1)._add_("N")
,$ctx1.sendIdx["add:"]=4
][0];
[$recv($1)._add_(false)
,$ctx1.sendIdx["add:"]=5
][0];
$recv($1)._add_($self.sampleBlock);
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"collectionWithNewValue",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testAddAll",
protocol: "tests",
args: [],
source: "testAddAll\x0a\x09super testAddAll.\x0a\x09self assert: (self collection addAll: self collection; yourself) equals: self collection.\x0a\x09self assert: (self collection addAll: self collectionWithNewValue; yourself) equals: self collectionWithNewValue.\x0a\x09self assert: (self collectionWithNewValue addAll: self collection; yourself) equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["testAddAll", "assert:equals:", "addAll:", "collection", "yourself", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._testAddAll.call($self))
,$ctx1.supercall = false
][0];
$1=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
[$recv($1)._addAll_([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx["addAll:"]=1
][0];
[$self._assert_equals_([$recv($1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$2=[$self._collection()
,$ctx1.sendIdx["collection"]=4
][0];
[$recv($2)._addAll_([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])
,$ctx1.sendIdx["addAll:"]=2
][0];
[$self._assert_equals_([$recv($2)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$3=[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=3
][0];
$recv($3)._addAll_($self._collection());
$self._assert_equals_($recv($3)._yourself(),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddAll",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testAddRemove",
protocol: "tests",
args: [],
source: "testAddRemove\x0a\x09| set |\x0a\x09set := Set new.\x0a\x09\x0a\x09self assert: set isEmpty.\x0a\x0a\x09set add: 3.\x0a\x09self assert: (set includes: 3).\x0a\x0a\x09set add: 5.\x0a\x09self assert: (set includes: 5).\x0a\x0a\x09set remove: 3.\x0a\x09self deny: (set includes: 3)",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["new", "assert:", "isEmpty", "add:", "includes:", "remove:", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var set;
return $core.withContext(function($ctx1) {
set=$recv($globals.Set)._new();
[$self._assert_($recv(set)._isEmpty())
,$ctx1.sendIdx["assert:"]=1
][0];
[$recv(set)._add_((3))
,$ctx1.sendIdx["add:"]=1
][0];
[$self._assert_([$recv(set)._includes_((3))
,$ctx1.sendIdx["includes:"]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$recv(set)._add_((5));
$self._assert_([$recv(set)._includes_((5))
,$ctx1.sendIdx["includes:"]=2
][0]);
$recv(set)._remove_((3));
$self._deny_($recv(set)._includes_((3)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAddRemove",{set:set})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testAt",
protocol: "tests",
args: [],
source: "testAt\x0a\x09self should: [ Set new at: 1 put: 2 ] raise: Error",
referencedClasses: ["Set", "Error"],
pragmas: [],
messageSends: ["should:raise:", "at:put:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Set)._new())._at_put_((1),(2));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAt",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testCollect",
protocol: "tests",
args: [],
source: "testCollect\x0a\x09super testCollect.\x0a\x09self assert: (#(5 6 8) asSet collect: [ :x | x \x5c\x5c 3 ]) equals: #(0 2) asSet",
referencedClasses: [],
pragmas: [],
messageSends: ["testCollect", "assert:equals:", "collect:", "asSet", "\x5c\x5c"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._testCollect.call($self))
,$ctx1.supercall = false
][0];
$self._assert_equals_($recv([[(5), (6), (8)]._asSet()
,$ctx1.sendIdx["asSet"]=1
][0])._collect_((function(x){
return $core.withContext(function($ctx2) {
return $recv(x).__backslash_backslash((3));
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
})),[(0), (2)]._asSet());
return self;
}, function($ctx1) {$ctx1.fill(self,"testCollect",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testComparing",
protocol: "tests",
args: [],
source: "testComparing\x0a\x09self assert: #(0 2) asSet equals: #(0 2) asSet.\x0a\x09self assert: #(2 0) asSet equals: #(0 2) asSet.\x0a\x09self deny: #(0 2 3) asSet = #(0 2) asSet.\x0a\x09self deny: #(1 2) asSet = #(0 2) asSet",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asSet", "deny:", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([[(0), (2)]._asSet()
,$ctx1.sendIdx["asSet"]=1
][0],[[(0), (2)]._asSet()
,$ctx1.sendIdx["asSet"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_([[(2), (0)]._asSet()
,$ctx1.sendIdx["asSet"]=3
][0],[[(0), (2)]._asSet()
,$ctx1.sendIdx["asSet"]=4
][0]);
[$self._deny_([$recv([[(0), (2), (3)]._asSet()
,$ctx1.sendIdx["asSet"]=5
][0]).__eq([[(0), (2)]._asSet()
,$ctx1.sendIdx["asSet"]=6
][0])
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
$self._deny_($recv([[(1), (2)]._asSet()
,$ctx1.sendIdx["asSet"]=7
][0]).__eq([(0), (2)]._asSet()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparing",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testPrintString",
protocol: "tests",
args: [],
source: "testPrintString\x0a\x09| set |\x0a\x09set := Set new.\x0a\x09self assert: set printString equals: 'a Set ()'.\x0a\x09set add: 1; add: 3.\x0a\x09self assert: set printString equals: 'a Set (1 3)'.\x0a\x09set add: 'foo'.\x0a\x09self assert: set printString equals: 'a Set (1 3 ''foo'')'.\x0a\x09set remove: 1; remove: 3.\x0a\x09self assert: set printString equals: 'a Set (''foo'')'.\x0a\x09set add: 3.\x0a\x09self assert: set printString equals: 'a Set (3 ''foo'')'.\x0a\x09set add: 3.\x0a\x09self assert: set printString equals: 'a Set (3 ''foo'')'",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["new", "assert:equals:", "printString", "add:", "remove:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var set;
return $core.withContext(function($ctx1) {
var $1,$2;
set=$recv($globals.Set)._new();
[$self._assert_equals_([$recv(set)._printString()
,$ctx1.sendIdx["printString"]=1
][0],"a Set ()")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$1=set;
[$recv($1)._add_((1))
,$ctx1.sendIdx["add:"]=1
][0];
[$recv($1)._add_((3))
,$ctx1.sendIdx["add:"]=2
][0];
[$self._assert_equals_([$recv(set)._printString()
,$ctx1.sendIdx["printString"]=2
][0],"a Set (1 3)")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$recv(set)._add_("foo")
,$ctx1.sendIdx["add:"]=3
][0];
[$self._assert_equals_([$recv(set)._printString()
,$ctx1.sendIdx["printString"]=3
][0],"a Set (1 3 'foo')")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$2=set;
[$recv($2)._remove_((1))
,$ctx1.sendIdx["remove:"]=1
][0];
$recv($2)._remove_((3));
[$self._assert_equals_([$recv(set)._printString()
,$ctx1.sendIdx["printString"]=4
][0],"a Set ('foo')")
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$recv(set)._add_((3))
,$ctx1.sendIdx["add:"]=4
][0];
[$self._assert_equals_([$recv(set)._printString()
,$ctx1.sendIdx["printString"]=5
][0],"a Set (3 'foo')")
,$ctx1.sendIdx["assert:equals:"]=5
][0];
$recv(set)._add_((3));
$self._assert_equals_($recv(set)._printString(),"a Set (3 'foo')");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintString",{set:set})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testRegression1225",
protocol: "tests",
args: [],
source: "testRegression1225\x0a\x09self assert: (#(1 2 3) asSet add: 3) equals: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "add:", "asSet"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([(1), (2), (3)]._asSet())._add_((3)),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1225",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testRegression1226",
protocol: "tests",
args: [],
source: "testRegression1226\x0a\x09self assert: (#(1 2 3) asSet remove: 3) equals: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "remove:", "asSet"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([(1), (2), (3)]._asSet())._remove_((3)),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1226",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testRegression1227",
protocol: "tests",
args: [],
source: "testRegression1227\x0a\x09self assert: (#(1 2 3) asSet remove: 4 ifAbsent: [5]) equals: 5",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "remove:ifAbsent:", "asSet"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([(1), (2), (3)]._asSet())._remove_ifAbsent_((4),(function(){
return (5);

})),(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1227",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testRegression1228",
protocol: "tests",
args: [],
source: "testRegression1228\x0a\x09self should: [#(1 2 3) asSet remove: 4] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "remove:", "asSet"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv([(1), (2), (3)]._asSet())._remove_((4));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1228",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testRegression1245",
protocol: "tests",
args: [],
source: "testRegression1245\x0a\x09self assert: ({Object. String} asSet remove: String) equals: String",
referencedClasses: ["Object", "String"],
pragmas: [],
messageSends: ["assert:equals:", "remove:", "asSet"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($recv([$globals.Object,$globals.String])._asSet())._remove_($globals.String),$globals.String);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1245",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testUnboxedObjects",
protocol: "tests",
args: [],
source: "testUnboxedObjects\x0a\x09self assert: {'foo' yourself. 'foo' yourself} asSet asArray equals: #('foo')",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asArray", "asSet", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($recv([["foo"._yourself()
,$ctx1.sendIdx["yourself"]=1
][0],"foo"._yourself()])._asSet())._asArray(),["foo"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnboxedObjects",{})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testUnicity",
protocol: "tests",
args: [],
source: "testUnicity\x0a\x09| set |\x0a\x09set := Set new.\x0a\x09set add: 21.\x0a\x09set add: 'hello'.\x0a\x0a\x09set add: 21.\x0a\x09self assert: set size equals: 2.\x0a\x09\x0a\x09set add: 'hello'.\x0a\x09self assert: set size equals: 2.\x0a\x0a\x09self assert: set asArray equals: #(21 'hello')",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["new", "add:", "assert:equals:", "size", "asArray"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var set;
return $core.withContext(function($ctx1) {
set=$recv($globals.Set)._new();
[$recv(set)._add_((21))
,$ctx1.sendIdx["add:"]=1
][0];
[$recv(set)._add_("hello")
,$ctx1.sendIdx["add:"]=2
][0];
[$recv(set)._add_((21))
,$ctx1.sendIdx["add:"]=3
][0];
[$self._assert_equals_([$recv(set)._size()
,$ctx1.sendIdx["size"]=1
][0],(2))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(set)._add_("hello");
[$self._assert_equals_($recv(set)._size(),(2))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv(set)._asArray(),[(21), "hello"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnicity",{set:set})});
}; }),
$globals.SetTest);

$core.addMethod(
$core.method({
selector: "testUnorderedComma",
protocol: "tests",
args: [],
source: "testUnorderedComma\x0a\x09self assert: self collection, self collection equals: self collection.\x0a\x09self assert: self sampleNewValueAsCollection, self collection equals: self collectionWithNewValue.\x0a\x09self assert: self collection, self collectionWithNewValue equals: self collectionWithNewValue.\x0a\x09self assert: self collectionWithNewValue, self collection equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", ",", "collection", "sampleNewValueAsCollection", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=1
][0]).__comma([$self._collection()
,$ctx1.sendIdx["collection"]=2
][0])
,$ctx1.sendIdx[","]=1
][0],[$self._collection()
,$ctx1.sendIdx["collection"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($self._sampleNewValueAsCollection()).__comma([$self._collection()
,$ctx1.sendIdx["collection"]=4
][0])
,$ctx1.sendIdx[","]=2
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([$self._collection()
,$ctx1.sendIdx["collection"]=5
][0]).__comma([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=2
][0])
,$ctx1.sendIdx[","]=3
][0],[$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv([$self._collectionWithNewValue()
,$ctx1.sendIdx["collectionWithNewValue"]=4
][0]).__comma($self._collection()),$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnorderedComma",{})});
}; }),
$globals.SetTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "fixture",
args: [],
source: "collectionClass\x0a\x09^ Set",
referencedClasses: ["Set"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Set;

}; }),
$globals.SetTest.a$cls);


$core.addClass("ConsoleTranscriptTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testShow",
protocol: "tests",
args: [],
source: "testShow\x0a| originalTranscript |\x0aoriginalTranscript := Transcript current.\x0aTranscript register: ConsoleTranscript new.\x0a\x0aself shouldnt: [ Transcript show: 'Hello console!' ] raise: Error.\x0aself shouldnt: [ Transcript show: console ] raise: Error.\x0a\x0aTranscript register: originalTranscript.",
referencedClasses: ["Transcript", "ConsoleTranscript", "Error"],
pragmas: [],
messageSends: ["current", "register:", "new", "shouldnt:raise:", "show:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var originalTranscript;
return $core.withContext(function($ctx1) {
originalTranscript=$recv($globals.Transcript)._current();
[$recv($globals.Transcript)._register_($recv($globals.ConsoleTranscript)._new())
,$ctx1.sendIdx["register:"]=1
][0];
[$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv($globals.Transcript)._show_("Hello console!")
,$ctx2.sendIdx["show:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error)
,$ctx1.sendIdx["shouldnt:raise:"]=1
][0];
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Transcript)._show_(console);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
$recv($globals.Transcript)._register_(originalTranscript);
return self;
}, function($ctx1) {$ctx1.fill(self,"testShow",{originalTranscript:originalTranscript})});
}; }),
$globals.ConsoleTranscriptTest);



$core.addClass("DateTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testEquality",
protocol: "tests",
args: [],
source: "testEquality\x0a\x09| now |\x0a\x09now := Date new.\x0a\x0a\x09self assert: now = now.\x0a\x0a\x09self deny: now = (Date fromMilliseconds: 0).\x0a\x0a\x09self assert: (Date fromMilliseconds: 12345678) = (Date fromMilliseconds: 12345678).\x0a\x09self assert: now = (Date fromMilliseconds: now asMilliseconds).\x0a\x09self assert: (Date fromMilliseconds: now asMilliseconds) = now",
referencedClasses: ["Date"],
pragmas: [],
messageSends: ["new", "assert:", "=", "deny:", "fromMilliseconds:", "asMilliseconds"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var now;
return $core.withContext(function($ctx1) {
now=$recv($globals.Date)._new();
[$self._assert_([$recv(now).__eq(now)
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$self._deny_([$recv(now).__eq([$recv($globals.Date)._fromMilliseconds_((0))
,$ctx1.sendIdx["fromMilliseconds:"]=1
][0])
,$ctx1.sendIdx["="]=2
][0]);
[$self._assert_([$recv([$recv($globals.Date)._fromMilliseconds_((12345678))
,$ctx1.sendIdx["fromMilliseconds:"]=2
][0]).__eq([$recv($globals.Date)._fromMilliseconds_((12345678))
,$ctx1.sendIdx["fromMilliseconds:"]=3
][0])
,$ctx1.sendIdx["="]=3
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_([$recv(now).__eq([$recv($globals.Date)._fromMilliseconds_([$recv(now)._asMilliseconds()
,$ctx1.sendIdx["asMilliseconds"]=1
][0])
,$ctx1.sendIdx["fromMilliseconds:"]=4
][0])
,$ctx1.sendIdx["="]=4
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
$self._assert_($recv($recv($globals.Date)._fromMilliseconds_($recv(now)._asMilliseconds())).__eq(now));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{now:now})});
}; }),
$globals.DateTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: "tests",
args: [],
source: "testIdentity\x0a\x09| now |\x0a\x09now := Date new.\x0a\x0a\x09self assert: now == now.\x0a\x0a\x09self deny: now == (Date fromMilliseconds: 0).\x0a\x0a\x09self deny: (Date fromMilliseconds: 12345678) == (Date fromMilliseconds: 12345678).\x0a\x09self deny: now == (Date fromMilliseconds: now asMilliseconds).\x0a\x09self deny: (Date fromMilliseconds: now asMilliseconds) == now",
referencedClasses: ["Date"],
pragmas: [],
messageSends: ["new", "assert:", "==", "deny:", "fromMilliseconds:", "asMilliseconds"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var now;
return $core.withContext(function($ctx1) {
now=$recv($globals.Date)._new();
$self._assert_([$recv(now).__eq_eq(now)
,$ctx1.sendIdx["=="]=1
][0]);
[$self._deny_([$recv(now).__eq_eq([$recv($globals.Date)._fromMilliseconds_((0))
,$ctx1.sendIdx["fromMilliseconds:"]=1
][0])
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._deny_([$recv([$recv($globals.Date)._fromMilliseconds_((12345678))
,$ctx1.sendIdx["fromMilliseconds:"]=2
][0]).__eq_eq([$recv($globals.Date)._fromMilliseconds_((12345678))
,$ctx1.sendIdx["fromMilliseconds:"]=3
][0])
,$ctx1.sendIdx["=="]=3
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._deny_([$recv(now).__eq_eq([$recv($globals.Date)._fromMilliseconds_([$recv(now)._asMilliseconds()
,$ctx1.sendIdx["asMilliseconds"]=1
][0])
,$ctx1.sendIdx["fromMilliseconds:"]=4
][0])
,$ctx1.sendIdx["=="]=4
][0])
,$ctx1.sendIdx["deny:"]=3
][0];
$self._deny_($recv($recv($globals.Date)._fromMilliseconds_($recv(now)._asMilliseconds())).__eq_eq(now));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{now:now})});
}; }),
$globals.DateTest);

$core.addMethod(
$core.method({
selector: "testPlusAndMinus",
protocol: "tests",
args: [],
source: "testPlusAndMinus\x0a\x09| a b now zeroDuration |\x0a\x09a := Date fromString: '1974-07-12 14:30'.\x0a\x09now := Date now.\x0a\x09b := Date fromString: '2616-03-06'.\x0a\x09zeroDuration := 0.\x0a\x0a\x09self assert: {a-a. now-now. b-b} asSet equals: (Set with: zeroDuration).\x0a\x09self assert: now + (b - now) equals: b.\x0a\x09self assert: a + (b - a) equals: b.\x0a\x09self assert: now + (a - now) equals: a.\x0a\x09self assert: a + ((now - a) + (b - now)) equals: b",
referencedClasses: ["Date", "Set"],
pragmas: [],
messageSends: ["fromString:", "now", "assert:equals:", "asSet", "-", "with:", "+"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var a,b,now,zeroDuration;
return $core.withContext(function($ctx1) {
a=[$recv($globals.Date)._fromString_("1974-07-12 14:30")
,$ctx1.sendIdx["fromString:"]=1
][0];
now=$recv($globals.Date)._now();
b=$recv($globals.Date)._fromString_("2616-03-06");
zeroDuration=(0);
[$self._assert_equals_($recv([[$recv(a).__minus(a)
,$ctx1.sendIdx["-"]=1
][0],[$recv(now).__minus(now)
,$ctx1.sendIdx["-"]=2
][0],[$recv(b).__minus(b)
,$ctx1.sendIdx["-"]=3
][0]])._asSet(),$recv($globals.Set)._with_(zeroDuration))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(now).__plus([$recv(b).__minus(now)
,$ctx1.sendIdx["-"]=4
][0])
,$ctx1.sendIdx["+"]=1
][0],b)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv(a).__plus([$recv(b).__minus(a)
,$ctx1.sendIdx["-"]=5
][0])
,$ctx1.sendIdx["+"]=2
][0],b)
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_([$recv(now).__plus([$recv(a).__minus(now)
,$ctx1.sendIdx["-"]=6
][0])
,$ctx1.sendIdx["+"]=3
][0],a)
,$ctx1.sendIdx["assert:equals:"]=4
][0];
$self._assert_equals_([$recv(a).__plus($recv([$recv(now).__minus(a)
,$ctx1.sendIdx["-"]=7
][0]).__plus($recv(b).__minus(now)))
,$ctx1.sendIdx["+"]=4
][0],b);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPlusAndMinus",{a:a,b:b,now:now,zeroDuration:zeroDuration})});
}; }),
$globals.DateTest);



$core.addClass("JSObjectProxyTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "jsObject",
protocol: "accessing",
args: [],
source: "jsObject\x0a\x09<inlineJS: \x0a\x09\x09'return {a: 1, b: function() {return 2;}, c: function(object) {return object;}, d: \x22\x22, \x22e\x22: null, \x22f\x22: void 0}'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return {a: 1, b: function() {return 2;}, c: function(object) {return object;}, d: \x22\x22, \x22e\x22: null, \x22f\x22: void 0}"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return {a: 1, b: function() {return 2;}, c: function(object) {return object;}, d: "", "e": null, "f": void 0};
return self;
}, function($ctx1) {$ctx1.fill(self,"jsObject",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "jsUndefined",
protocol: "accessing",
args: [],
source: "jsUndefined\x0a\x09<inlineJS: 'return'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsUndefined",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsent",
protocol: "tests",
args: [],
source: "testAtIfAbsent\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09self assert: (testObject at: 'abc' ifAbsent: [ 'Property does not exist' ]) equals: 'Property does not exist'.\x0a\x09self assert: (testObject at: 'e' ifAbsent: [ 'Property does not exist' ]) equals: nil.\x0a\x09self assert: (testObject at: 'a' ifAbsent: [ 'Property does not exist' ]) equals: 1.\x0a\x09self assert: (testObject at: 'f' ifAbsent: [ 'Property does not exist' ]) equals: nil.",
referencedClasses: [],
pragmas: [],
messageSends: ["jsObject", "assert:equals:", "at:ifAbsent:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var testObject;
return $core.withContext(function($ctx1) {
testObject=$self._jsObject();
[$self._assert_equals_([$recv(testObject)._at_ifAbsent_("abc",(function(){
return "Property does not exist";

}))
,$ctx1.sendIdx["at:ifAbsent:"]=1
][0],"Property does not exist")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(testObject)._at_ifAbsent_("e",(function(){
return "Property does not exist";

}))
,$ctx1.sendIdx["at:ifAbsent:"]=2
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv(testObject)._at_ifAbsent_("a",(function(){
return "Property does not exist";

}))
,$ctx1.sendIdx["at:ifAbsent:"]=3
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv(testObject)._at_ifAbsent_("f",(function(){
return "Property does not exist";

})),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsent",{testObject:testObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresent",
protocol: "tests",
args: [],
source: "testAtIfPresent\x0a\x09| testObject |\x0a\x09\x0a\x09testObject := self jsObject.\x0a\x09\x0a\x09self assert: (testObject at: 'abc' ifPresent: [ :x | 'hello ',x asString ]) equals: nil.\x0a\x09self assert: (testObject at: 'e' ifPresent: [ :x | 'hello ',x asString ]) equals: 'hello nil'.\x0a\x09self assert: (testObject at: 'a' ifPresent: [ :x | 'hello ',x asString ]) equals: 'hello 1'.\x0a\x09self assert: (testObject at: 'f' ifPresent: [ :x | 'hello ',x asString ]) equals: 'hello nil'.",
referencedClasses: [],
pragmas: [],
messageSends: ["jsObject", "assert:equals:", "at:ifPresent:", ",", "asString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var testObject;
return $core.withContext(function($ctx1) {
testObject=$self._jsObject();
[$self._assert_equals_([$recv(testObject)._at_ifPresent_("abc",(function(x){
return $core.withContext(function($ctx2) {
return ["hello ".__comma([$recv(x)._asString()
,$ctx2.sendIdx["asString"]=1
][0])
,$ctx2.sendIdx[","]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}))
,$ctx1.sendIdx["at:ifPresent:"]=1
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(testObject)._at_ifPresent_("e",(function(x){
return $core.withContext(function($ctx2) {
return ["hello ".__comma([$recv(x)._asString()
,$ctx2.sendIdx["asString"]=2
][0])
,$ctx2.sendIdx[","]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,2)});
}))
,$ctx1.sendIdx["at:ifPresent:"]=2
][0],"hello nil")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv(testObject)._at_ifPresent_("a",(function(x){
return $core.withContext(function($ctx2) {
return ["hello ".__comma([$recv(x)._asString()
,$ctx2.sendIdx["asString"]=3
][0])
,$ctx2.sendIdx[","]=3
][0];
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,3)});
}))
,$ctx1.sendIdx["at:ifPresent:"]=3
][0],"hello 1")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv(testObject)._at_ifPresent_("f",(function(x){
return $core.withContext(function($ctx2) {
return "hello ".__comma($recv(x)._asString());
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,4)});
})),"hello nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresent",{testObject:testObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresentIfAbsent",
protocol: "tests",
args: [],
source: "testAtIfPresentIfAbsent\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09self assert: (testObject at: 'abc' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'not present'.\x0a\x09self assert: (testObject at: 'e' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'hello nil'.\x0a\x09self assert: (testObject at: 'a' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'hello 1'.\x0a\x09self assert: (testObject at: 'f' ifPresent: [ :x|'hello ',x asString ] ifAbsent: [ 'not present' ]) equals: 'hello nil'.",
referencedClasses: [],
pragmas: [],
messageSends: ["jsObject", "assert:equals:", "at:ifPresent:ifAbsent:", ",", "asString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var testObject;
return $core.withContext(function($ctx1) {
testObject=$self._jsObject();
[$self._assert_equals_([$recv(testObject)._at_ifPresent_ifAbsent_("abc",(function(x){
return $core.withContext(function($ctx2) {
return ["hello ".__comma([$recv(x)._asString()
,$ctx2.sendIdx["asString"]=1
][0])
,$ctx2.sendIdx[","]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
}),(function(){
return "not present";

}))
,$ctx1.sendIdx["at:ifPresent:ifAbsent:"]=1
][0],"not present")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv(testObject)._at_ifPresent_ifAbsent_("e",(function(x){
return $core.withContext(function($ctx2) {
return ["hello ".__comma([$recv(x)._asString()
,$ctx2.sendIdx["asString"]=2
][0])
,$ctx2.sendIdx[","]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,3)});
}),(function(){
return "not present";

}))
,$ctx1.sendIdx["at:ifPresent:ifAbsent:"]=2
][0],"hello nil")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv(testObject)._at_ifPresent_ifAbsent_("a",(function(x){
return $core.withContext(function($ctx2) {
return ["hello ".__comma([$recv(x)._asString()
,$ctx2.sendIdx["asString"]=3
][0])
,$ctx2.sendIdx[","]=3
][0];
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,5)});
}),(function(){
return "not present";

}))
,$ctx1.sendIdx["at:ifPresent:ifAbsent:"]=3
][0],"hello 1")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv(testObject)._at_ifPresent_ifAbsent_("f",(function(x){
return $core.withContext(function($ctx2) {
return "hello ".__comma($recv(x)._asString());
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,7)});
}),(function(){
return "not present";

})),"hello nil");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresentIfAbsent",{testObject:testObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testAtPut",
protocol: "tests",
args: [],
source: "testAtPut\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09\x0a\x09self assert: (testObject at: 'abc') ~= 'xyz'.\x0a\x09self assert: (testObject at: 'abc' put: 'xyz') equals: 'xyz'.\x0a\x09self assert: (testObject at: 'abc') equals: 'xyz'",
referencedClasses: [],
pragmas: [],
messageSends: ["jsObject", "assert:", "~=", "at:", "assert:equals:", "at:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var testObject;
return $core.withContext(function($ctx1) {
testObject=$self._jsObject();
$self._assert_($recv([$recv(testObject)._at_("abc")
,$ctx1.sendIdx["at:"]=1
][0]).__tild_eq("xyz"));
[$self._assert_equals_($recv(testObject)._at_put_("abc","xyz"),"xyz")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(testObject)._at_("abc"),"xyz");
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtPut",{testObject:testObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testComparison",
protocol: "tests",
args: [],
source: "testComparison\x0a\x09self assert: ({ console. 2 } indexOf: console) equals: 1.\x0a\x09self assert: console = console.\x0a\x09self deny: console = Object new.\x0a\x09self deny: console = self jsObject",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["assert:equals:", "indexOf:", "assert:", "=", "deny:", "new", "jsObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([console,(2)])._indexOf_(console),(1));
$self._assert_([$recv(console).__eq(console)
,$ctx1.sendIdx["="]=1
][0]);
[$self._deny_([$recv(console).__eq($recv($globals.Object)._new())
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
$self._deny_($recv(console).__eq($self._jsObject()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparison",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNU",
protocol: "tests",
args: [],
source: "testDNU\x0a\x09self should: [ self jsObject foo ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:raise:", "foo", "jsObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self._jsObject())._foo();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNU",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testDNUWithAllowJavaScriptCalls",
protocol: "tests",
args: [],
source: "testDNUWithAllowJavaScriptCalls\x0a\x09| jsObject |\x0a\x09jsObject := #().\x0a\x09jsObject basicAt: 'allowJavaScriptCalls' put: true.\x0a\x09self should: [ jsObject foo ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["basicAt:put:", "should:raise:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var jsObject;
return $core.withContext(function($ctx1) {
jsObject=[];
$recv(jsObject)._basicAt_put_("allowJavaScriptCalls",true);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(jsObject)._foo();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNUWithAllowJavaScriptCalls",{jsObject:jsObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testMessageSend",
protocol: "tests",
args: [],
source: "testMessageSend\x0a\x0a\x09self assert: self jsObject a equals: 1.\x0a\x09self assert: self jsObject b equals: 2.\x0a\x09self assert: (self jsObject c: 3) equals: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "a", "jsObject", "b", "c:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_($recv([$self._jsObject()
,$ctx1.sendIdx["jsObject"]=1
][0])._a(),(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv([$self._jsObject()
,$ctx1.sendIdx["jsObject"]=2
][0])._b(),(2))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv($self._jsObject())._c_((3)),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSend",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testMethodWithArguments",
protocol: "tests",
args: [],
source: "testMethodWithArguments\x0a\x09self assert: (self jsObject c: 1) equals: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "c:", "jsObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($self._jsObject())._c_((1)),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMethodWithArguments",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testNull",
protocol: "tests",
args: [],
source: "testNull\x0a\x09self assert: JSObjectProxy null isNil.\x0a\x09self\x0a\x09\x09assert: (JSON stringify: #{#foo -> JSObjectProxy null})\x0a\x09\x09equals: '{\x22foo\x22:null}'",
referencedClasses: ["JSObjectProxy", "JSON"],
pragmas: [],
messageSends: ["assert:", "isNil", "null", "assert:equals:", "stringify:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv([$recv($globals.JSObjectProxy)._null()
,$ctx1.sendIdx["null"]=1
][0])._isNil());
$self._assert_equals_($recv($globals.JSON)._stringify_($globals.HashedCollection._newFromPairs_(["foo",$recv($globals.JSObjectProxy)._null()])),"{\x22foo\x22:null}");
return self;
}, function($ctx1) {$ctx1.fill(self,"testNull",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testPrinting",
protocol: "tests",
args: [],
source: "testPrinting\x0a\x09self assert: self jsObject printString equals: '[object Object]'",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "printString", "jsObject"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv($self._jsObject())._printString(),"[object Object]");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrinting",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testPropertyThatReturnsEmptyString",
protocol: "tests",
args: [],
source: "testPropertyThatReturnsEmptyString\x0a\x09| object |\x0a\x0a\x09object := self jsObject.\x0a\x09self assert: object d equals: ''.\x0a\x0a\x09object d: 'hello'.\x0a\x09self assert: object d equals: 'hello'",
referencedClasses: [],
pragmas: [],
messageSends: ["jsObject", "assert:equals:", "d", "d:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var object;
return $core.withContext(function($ctx1) {
object=$self._jsObject();
[$self._assert_equals_([$recv(object)._d()
,$ctx1.sendIdx["d"]=1
][0],"")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(object)._d_("hello");
$self._assert_equals_($recv(object)._d(),"hello");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPropertyThatReturnsEmptyString",{object:object})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testPropertyThatReturnsUndefined",
protocol: "tests",
args: [],
source: "testPropertyThatReturnsUndefined\x0a\x09| object |\x0a\x0a\x09object := self jsObject.\x0a\x09self shouldnt: [ object e ] raise: MessageNotUnderstood.\x0a\x09self assert: object e isNil",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["jsObject", "shouldnt:raise:", "e", "assert:", "isNil"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var object;
return $core.withContext(function($ctx1) {
object=$self._jsObject();
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv(object)._e()
,$ctx2.sendIdx["e"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
$self._assert_($recv($recv(object)._e())._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testPropertyThatReturnsUndefined",{object:object})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testSetPropertyWithFalsyValue",
protocol: "tests",
args: [],
source: "testSetPropertyWithFalsyValue\x0a\x09| jsObject |\x0a\x09jsObject := self jsObject.\x0a\x09self assert: (jsObject a) equals: 1.\x0a\x0a\x09jsObject a: JSObjectProxy null.\x0a\x09self assert: (jsObject a) equals: nil.\x0a\x09jsObject a: 0.\x0a\x09self assert: (jsObject a) equals: 0.\x0a\x09jsObject a: self jsUndefined.\x0a\x09self assert: (jsObject a) equals: nil.\x0a\x09jsObject a: ''.\x0a\x09self assert: (jsObject a) equals: ''.\x0a\x09jsObject a: false.\x0a\x09self assert: (jsObject a) equals: false",
referencedClasses: ["JSObjectProxy"],
pragmas: [],
messageSends: ["jsObject", "assert:equals:", "a", "a:", "null", "jsUndefined"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var jsObject;
return $core.withContext(function($ctx1) {
jsObject=$self._jsObject();
[$self._assert_equals_([$recv(jsObject)._a()
,$ctx1.sendIdx["a"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$recv(jsObject)._a_($recv($globals.JSObjectProxy)._null())
,$ctx1.sendIdx["a:"]=1
][0];
[$self._assert_equals_([$recv(jsObject)._a()
,$ctx1.sendIdx["a"]=2
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$recv(jsObject)._a_((0))
,$ctx1.sendIdx["a:"]=2
][0];
[$self._assert_equals_([$recv(jsObject)._a()
,$ctx1.sendIdx["a"]=3
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$recv(jsObject)._a_($self._jsUndefined())
,$ctx1.sendIdx["a:"]=3
][0];
[$self._assert_equals_([$recv(jsObject)._a()
,$ctx1.sendIdx["a"]=4
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$recv(jsObject)._a_("")
,$ctx1.sendIdx["a:"]=4
][0];
[$self._assert_equals_([$recv(jsObject)._a()
,$ctx1.sendIdx["a"]=5
][0],"")
,$ctx1.sendIdx["assert:equals:"]=5
][0];
$recv(jsObject)._a_(false);
$self._assert_equals_($recv(jsObject)._a(),false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSetPropertyWithFalsyValue",{jsObject:jsObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testUndefined",
protocol: "tests",
args: [],
source: "testUndefined\x0a\x09self assert: JSObjectProxy undefined isNil.\x0a\x09self\x0a\x09\x09assert: (JSON stringify: #{#foo -> JSObjectProxy undefined})\x0a\x09\x09equals: '{}'",
referencedClasses: ["JSObjectProxy", "JSON"],
pragmas: [],
messageSends: ["assert:", "isNil", "undefined", "assert:equals:", "stringify:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv([$recv($globals.JSObjectProxy)._undefined()
,$ctx1.sendIdx["undefined"]=1
][0])._isNil());
$self._assert_equals_($recv($globals.JSON)._stringify_($globals.HashedCollection._newFromPairs_(["foo",$recv($globals.JSObjectProxy)._undefined()])),"{}");
return self;
}, function($ctx1) {$ctx1.fill(self,"testUndefined",{})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testValue",
protocol: "tests",
args: [],
source: "testValue\x0a\x09| testObject |\x0a\x09testObject := self jsObject.\x0a\x09testObject at: 'value' put: 'aValue'.\x0a\x09self assert: testObject value equals: 'aValue'",
referencedClasses: [],
pragmas: [],
messageSends: ["jsObject", "at:put:", "assert:equals:", "value"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var testObject;
return $core.withContext(function($ctx1) {
testObject=$self._jsObject();
$recv(testObject)._at_put_("value","aValue");
$self._assert_equals_($recv(testObject)._value(),"aValue");
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{testObject:testObject})});
}; }),
$globals.JSObjectProxyTest);

$core.addMethod(
$core.method({
selector: "testYourself",
protocol: "tests",
args: [],
source: "testYourself\x0a\x09| object |\x0a\x09object := self jsObject\x0a\x09\x09d: 'test';\x0a\x09\x09yourself.\x0a\x0a\x09self assert: object d equals: 'test'",
referencedClasses: [],
pragmas: [],
messageSends: ["d:", "jsObject", "yourself", "assert:equals:", "d"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var object;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._jsObject();
$recv($1)._d_("test");
object=$recv($1)._yourself();
$self._assert_equals_($recv(object)._d(),"test");
return self;
}, function($ctx1) {$ctx1.fill(self,"testYourself",{object:object})});
}; }),
$globals.JSObjectProxyTest);



$core.addClass("JavaScriptExceptionTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testCatchingException",
protocol: "tests",
args: [],
source: "testCatchingException\x0a\x09[ self throwException ]\x0a\x09\x09on: Error\x0a\x09\x09do: [ :error |\x0a\x09\x09\x09self assert: error exception = 'test' ]",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["on:do:", "throwException", "assert:", "=", "exception"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._throwException();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(error){
return $core.withContext(function($ctx2) {
return $self._assert_($recv($recv(error)._exception()).__eq("test"));
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCatchingException",{})});
}; }),
$globals.JavaScriptExceptionTest);

$core.addMethod(
$core.method({
selector: "testRaisingException",
protocol: "tests",
args: [],
source: "testRaisingException\x0a\x09self should: [ self throwException ] raise: JavaScriptException",
referencedClasses: ["JavaScriptException"],
pragmas: [],
messageSends: ["should:raise:", "throwException"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $self._throwException();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.JavaScriptException);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRaisingException",{})});
}; }),
$globals.JavaScriptExceptionTest);

$core.addMethod(
$core.method({
selector: "throwException",
protocol: "helpers",
args: [],
source: "throwException\x0a\x09<inlineJS: 'throw \x22test\x22'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["throw \x22test\x22"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
throw "test";
return self;
}, function($ctx1) {$ctx1.fill(self,"throwException",{})});
}; }),
$globals.JavaScriptExceptionTest);



$core.addClass("MessageSendTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testValue",
protocol: "tests",
args: [],
source: "testValue\x0a\x09| messageSend |\x0a\x09\x0a\x09messageSend := MessageSend new\x0a\x09\x09receiver: Object new;\x0a\x09\x09selector: #asString;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09self assert: messageSend value equals: 'an Object'",
referencedClasses: ["MessageSend", "Object"],
pragmas: [],
messageSends: ["receiver:", "new", "selector:", "yourself", "assert:equals:", "value"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var messageSend;
return $core.withContext(function($ctx1) {
var $1;
$1=[$recv($globals.MessageSend)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._receiver_($recv($globals.Object)._new());
$recv($1)._selector_("asString");
messageSend=$recv($1)._yourself();
$self._assert_equals_($recv(messageSend)._value(),"an Object");
return self;
}, function($ctx1) {$ctx1.fill(self,"testValue",{messageSend:messageSend})});
}; }),
$globals.MessageSendTest);

$core.addMethod(
$core.method({
selector: "testValueWithArguments",
protocol: "tests",
args: [],
source: "testValueWithArguments\x0a\x09| messageSend |\x0a\x09\x0a\x09messageSend := MessageSend new\x0a\x09\x09receiver: 2;\x0a\x09\x09selector: '+';\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09self assert: (messageSend value: 3) equals: 5.\x0a\x09\x0a\x09self assert: (messageSend valueWithPossibleArguments: #(4)) equals: 6",
referencedClasses: ["MessageSend"],
pragmas: [],
messageSends: ["receiver:", "new", "selector:", "yourself", "assert:equals:", "value:", "valueWithPossibleArguments:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var messageSend;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MessageSend)._new();
$recv($1)._receiver_((2));
$recv($1)._selector_("+");
messageSend=$recv($1)._yourself();
[$self._assert_equals_($recv(messageSend)._value_((3)),(5))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(messageSend)._valueWithPossibleArguments_([(4)]),(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testValueWithArguments",{messageSend:messageSend})});
}; }),
$globals.MessageSendTest);



$core.addClass("MethodInheritanceTest", $globals.TestCase, "Kernel-Tests");
$core.setSlots($globals.MethodInheritanceTest, ["receiverTop", "receiverMiddle", "receiverBottom", "method", "performBlock"]);
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: "accessing",
args: [],
source: "codeGeneratorClass\x0a\x09^ CodeGenerator",
referencedClasses: ["CodeGenerator"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.CodeGenerator;

}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "compiler",
protocol: "factory",
args: [],
source: "compiler\x0a\x09^ Compiler new\x0a\x09\x09codeGeneratorClass: self codeGeneratorClass;\x0a\x09\x09yourself",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["codeGeneratorClass:", "new", "codeGeneratorClass", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Compiler)._new();
$recv($1)._codeGeneratorClass_($self._codeGeneratorClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"compiler",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "deinstallBottom",
protocol: "testing",
args: [],
source: "deinstallBottom\x0a\x09self targetClassBottom removeCompiledMethod: method",
referencedClasses: [],
pragmas: [],
messageSends: ["removeCompiledMethod:", "targetClassBottom"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._targetClassBottom())._removeCompiledMethod_($self.method);
return self;
}, function($ctx1) {$ctx1.fill(self,"deinstallBottom",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "deinstallMiddle",
protocol: "testing",
args: [],
source: "deinstallMiddle\x0a\x09self targetClassMiddle removeCompiledMethod: method",
referencedClasses: [],
pragmas: [],
messageSends: ["removeCompiledMethod:", "targetClassMiddle"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._targetClassMiddle())._removeCompiledMethod_($self.method);
return self;
}, function($ctx1) {$ctx1.fill(self,"deinstallMiddle",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "deinstallTop",
protocol: "testing",
args: [],
source: "deinstallTop\x0a\x09self targetClassTop removeCompiledMethod: method",
referencedClasses: [],
pragmas: [],
messageSends: ["removeCompiledMethod:", "targetClassTop"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._targetClassTop())._removeCompiledMethod_($self.method);
return self;
}, function($ctx1) {$ctx1.fill(self,"deinstallTop",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "installBottom:",
protocol: "testing",
args: ["aString"],
source: "installBottom: aString\x0a\x09method := self compiler install: aString forClass: self targetClassBottom protocol: 'tests'",
referencedClasses: [],
pragmas: [],
messageSends: ["install:forClass:protocol:", "compiler", "targetClassBottom"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.method=$recv($self._compiler())._install_forClass_protocol_(aString,$self._targetClassBottom(),"tests");
return self;
}, function($ctx1) {$ctx1.fill(self,"installBottom:",{aString:aString})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "installMiddle:",
protocol: "testing",
args: ["aString"],
source: "installMiddle: aString\x0a\x09method := self compiler install: aString forClass: self targetClassMiddle protocol: 'tests'",
referencedClasses: [],
pragmas: [],
messageSends: ["install:forClass:protocol:", "compiler", "targetClassMiddle"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.method=$recv($self._compiler())._install_forClass_protocol_(aString,$self._targetClassMiddle(),"tests");
return self;
}, function($ctx1) {$ctx1.fill(self,"installMiddle:",{aString:aString})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "installTop:",
protocol: "testing",
args: ["aString"],
source: "installTop: aString\x0a\x09method := self compiler install: aString forClass: self targetClassTop protocol: 'tests'",
referencedClasses: [],
pragmas: [],
messageSends: ["install:forClass:protocol:", "compiler", "targetClassTop"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.method=$recv($self._compiler())._install_forClass_protocol_(aString,$self._targetClassTop(),"tests");
return self;
}, function($ctx1) {$ctx1.fill(self,"installTop:",{aString:aString})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: "initialization",
args: [],
source: "setUp\x0a\x09receiverTop := self targetClassTop new.\x0a\x09receiverMiddle := self targetClassMiddle new.\x0a\x09receiverBottom := self targetClassBottom new.\x0a\x09method := nil.\x0a\x09performBlock := [ self error: 'performBlock not initialized' ]",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "targetClassTop", "targetClassMiddle", "targetClassBottom", "error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiverTop=[$recv($self._targetClassTop())._new()
,$ctx1.sendIdx["new"]=1
][0];
$self.receiverMiddle=[$recv($self._targetClassMiddle())._new()
,$ctx1.sendIdx["new"]=2
][0];
$self.receiverBottom=$recv($self._targetClassBottom())._new();
$self.method=nil;
$self.performBlock=(function(){
return $core.withContext(function($ctx2) {
return $self._error_("performBlock not initialized");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
});
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNU",
protocol: "testing",
args: [],
source: "shouldMNU\x0a\x09self shouldMNUTop.\x0a\x09self shouldMNUMiddle.\x0a\x09self shouldMNUBottom",
referencedClasses: [],
pragmas: [],
messageSends: ["shouldMNUTop", "shouldMNUMiddle", "shouldMNUBottom"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldMNUTop();
$self._shouldMNUMiddle();
$self._shouldMNUBottom();
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNU",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNUBottom",
protocol: "testing",
args: [],
source: "shouldMNUBottom\x0a\x09self should: [ performBlock value: receiverBottom ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:raise:", "value:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.performBlock)._value_($self.receiverBottom);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNUBottom",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNUMiddle",
protocol: "testing",
args: [],
source: "shouldMNUMiddle\x0a\x09self should: [ performBlock value: receiverMiddle ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:raise:", "value:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.performBlock)._value_($self.receiverMiddle);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNUMiddle",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldMNUTop",
protocol: "testing",
args: [],
source: "shouldMNUTop\x0a\x09self should: [ performBlock value: receiverTop ] raise: MessageNotUnderstood",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:raise:", "value:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.performBlock)._value_($self.receiverTop);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldMNUTop",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldReturn:",
protocol: "testing",
args: ["anObject"],
source: "shouldReturn: anObject\x0a\x09| result |\x0a\x0a\x09result := performBlock value: receiverTop.\x0a\x09self assert: { 'top'. anObject } equals: { 'top'. result }.\x0a\x09result := performBlock value: receiverMiddle.\x0a\x09self assert: { 'middle'. anObject } equals: { 'middle'. result }.\x0a\x09result := performBlock value: receiverBottom.\x0a\x09self assert: { 'bottom'. anObject } equals: { 'bottom'. result }",
referencedClasses: [],
pragmas: [],
messageSends: ["value:", "assert:equals:"]
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
result=[$recv($self.performBlock)._value_($self.receiverTop)
,$ctx1.sendIdx["value:"]=1
][0];
[$self._assert_equals_(["top",anObject],["top",result])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
result=[$recv($self.performBlock)._value_($self.receiverMiddle)
,$ctx1.sendIdx["value:"]=2
][0];
[$self._assert_equals_(["middle",anObject],["middle",result])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
result=$recv($self.performBlock)._value_($self.receiverBottom);
$self._assert_equals_(["bottom",anObject],["bottom",result]);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldReturn:",{anObject:anObject,result:result})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "shouldReturn:and:and:",
protocol: "testing",
args: ["anObject", "anObject2", "anObject3"],
source: "shouldReturn: anObject and: anObject2 and: anObject3\x0a\x09| result |\x0a\x0a\x09result := performBlock value: receiverTop.\x0a\x09self assert: { 'top'. anObject } equals: { 'top'. result }.\x0a\x09result := performBlock value: receiverMiddle.\x0a\x09self assert: { 'middle'. anObject2 } equals: { 'middle'. result }.\x0a\x09result := performBlock value: receiverBottom.\x0a\x09self assert: { 'bottom'. anObject3 } equals: { 'bottom'. result }",
referencedClasses: [],
pragmas: [],
messageSends: ["value:", "assert:equals:"]
}, function ($methodClass){ return function (anObject,anObject2,anObject3){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
result=[$recv($self.performBlock)._value_($self.receiverTop)
,$ctx1.sendIdx["value:"]=1
][0];
[$self._assert_equals_(["top",anObject],["top",result])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
result=[$recv($self.performBlock)._value_($self.receiverMiddle)
,$ctx1.sendIdx["value:"]=2
][0];
[$self._assert_equals_(["middle",anObject2],["middle",result])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
result=$recv($self.performBlock)._value_($self.receiverBottom);
$self._assert_equals_(["bottom",anObject3],["bottom",result]);
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldReturn:and:and:",{anObject:anObject,anObject2:anObject2,anObject3:anObject3,result:result})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "targetClassBottom",
protocol: "accessing",
args: [],
source: "targetClassBottom\x0a\x09^ JavaScriptException",
referencedClasses: ["JavaScriptException"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.JavaScriptException;

}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "targetClassMiddle",
protocol: "accessing",
args: [],
source: "targetClassMiddle\x0a\x09^ Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Error;

}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "targetClassTop",
protocol: "accessing",
args: [],
source: "targetClassTop\x0a\x09^ Object",
referencedClasses: ["Object"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Object;

}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: "initialization",
args: [],
source: "tearDown\x0a\x09[ self deinstallTop ] on: Error do: [ ].\x0a\x09[ self deinstallMiddle ] on: Error do: [ ].\x0a\x09[ self deinstallBottom ] on: Error do: [ ]",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["on:do:", "deinstallTop", "deinstallMiddle", "deinstallBottom"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv((function(){
return $core.withContext(function($ctx2) {
return $self._deinstallTop();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._on_do_($globals.Error,(function(){

}))
,$ctx1.sendIdx["on:do:"]=1
][0];
[$recv((function(){
return $core.withContext(function($ctx2) {
return $self._deinstallMiddle();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))._on_do_($globals.Error,(function(){

}))
,$ctx1.sendIdx["on:do:"]=2
][0];
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._deinstallBottom();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}))._on_do_($globals.Error,(function(){

}));
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "testMNU11",
protocol: "tests",
args: [],
source: "testMNU11\x0a\x09performBlock := [ :x | x foo ].\x0a\x09self shouldMNU.\x0a\x09self installTop: 'foo ^ false'.\x0a\x09self installTop: 'foo ^ true'.\x0a\x09self deinstallTop.\x0a\x09self shouldMNU",
referencedClasses: [],
pragmas: [],
messageSends: ["foo", "shouldMNU", "installTop:", "deinstallTop"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.performBlock=(function(x){
return $core.withContext(function($ctx2) {
return $recv(x)._foo();
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
});
[$self._shouldMNU()
,$ctx1.sendIdx["shouldMNU"]=1
][0];
[$self._installTop_("foo ^ false")
,$ctx1.sendIdx["installTop:"]=1
][0];
$self._installTop_("foo ^ true");
$self._deinstallTop();
$self._shouldMNU();
return self;
}, function($ctx1) {$ctx1.fill(self,"testMNU11",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "testMNU22",
protocol: "tests",
args: [],
source: "testMNU22\x0a\x09performBlock := [ :x | x foo ].\x0a\x09self shouldMNU.\x0a\x09self installMiddle: 'foo ^ false'.\x0a\x09self installMiddle: 'foo ^ true'.\x0a\x09self deinstallMiddle.\x0a\x09self shouldMNU",
referencedClasses: [],
pragmas: [],
messageSends: ["foo", "shouldMNU", "installMiddle:", "deinstallMiddle"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.performBlock=(function(x){
return $core.withContext(function($ctx2) {
return $recv(x)._foo();
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
});
[$self._shouldMNU()
,$ctx1.sendIdx["shouldMNU"]=1
][0];
[$self._installMiddle_("foo ^ false")
,$ctx1.sendIdx["installMiddle:"]=1
][0];
$self._installMiddle_("foo ^ true");
$self._deinstallMiddle();
$self._shouldMNU();
return self;
}, function($ctx1) {$ctx1.fill(self,"testMNU22",{})});
}; }),
$globals.MethodInheritanceTest);

$core.addMethod(
$core.method({
selector: "testReturns1",
protocol: "tests",
args: [],
source: "testReturns1\x0a\x09performBlock := [ :x | x foo ].\x0a\x09self installTop: 'foo ^ false'.\x0a\x09self shouldReturn: false.\x0a\x09self installTop: 'foo ^ true'.\x0a\x09self shouldReturn: true",
referencedClasses: [],
pragmas: [],
messageSends: ["foo", "installTop:", "shouldReturn:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.performBlock=(function(x){
return $core.withContext(function($ctx2) {
return $recv(x)._foo();
}, function($ctx2) {$ctx2.fillBlock({x:x},$ctx1,1)});
});
[$self._installTop_("foo ^ false")
,$ctx1.sendIdx["installTop:"]=1
][0];
[$self._shouldReturn_(false)
,$ctx1.sendIdx["shouldReturn:"]=1
][0];
$self._installTop_("foo ^ true");
$self._shouldReturn_(true);
return self;
}, function($ctx1) {$ctx1.fill(self,"testReturns1",{})});
}; }),
$globals.MethodInheritanceTest);



$core.addClass("NumberTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testAbs",
protocol: "tests",
args: [],
source: "testAbs\x0a\x09self assert: 4 abs equals: 4.\x0a\x09self assert: -4 abs equals: 4",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "abs"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(4)._abs()
,$ctx1.sendIdx["abs"]=1
][0],(4))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_((-4)._abs(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAbs",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testArithmetic",
protocol: "tests",
args: [],
source: "testArithmetic\x0a\x09\x0a\x09\x22We rely on JS here, so we won't test complex behavior, just check if\x0a\x09message sends are corrects\x22\x0a\x0a\x09self assert: 1.5 + 1 equals: 2.5.\x0a\x09self assert: 2 - 1 equals: 1.\x0a\x09self assert: -2 - 1 equals: -3.\x0a\x09self assert: 12 / 2 equals: 6.\x0a\x09self assert: 3 * 4 equals: 12.\x0a\x09self assert: 7 // 2 equals: 3.\x0a\x09self assert: 7 \x5c\x5c 2 equals: 1.\x0a\x0a\x09\x22Simple parenthesis and execution order\x22\x0a\x09self assert: 1 + 2 * 3 equals: 9.\x0a\x09self assert: 1 + (2 * 3) equals: 7",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "+", "-", "/", "*", "//", "\x5c\x5c"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(1.5).__plus((1))
,$ctx1.sendIdx["+"]=1
][0],(2.5))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(2).__minus((1))
,$ctx1.sendIdx["-"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_((-2).__minus((1)),(-3))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_((12).__slash((2)),(6))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_([(3).__star((4))
,$ctx1.sendIdx["*"]=1
][0],(12))
,$ctx1.sendIdx["assert:equals:"]=5
][0];
[$self._assert_equals_((7).__slash_slash((2)),(3))
,$ctx1.sendIdx["assert:equals:"]=6
][0];
[$self._assert_equals_((7).__backslash_backslash((2)),(1))
,$ctx1.sendIdx["assert:equals:"]=7
][0];
[$self._assert_equals_([$recv([(1).__plus((2))
,$ctx1.sendIdx["+"]=2
][0]).__star((3))
,$ctx1.sendIdx["*"]=2
][0],(9))
,$ctx1.sendIdx["assert:equals:"]=8
][0];
$self._assert_equals_((1).__plus((2).__star((3))),(7));
return self;
}, function($ctx1) {$ctx1.fill(self,"testArithmetic",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testAsNumber",
protocol: "tests",
args: [],
source: "testAsNumber\x0a\x09self assert: 3 asNumber equals: 3.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "asNumber"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_((3)._asNumber(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsNumber",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testBetweenAnd",
protocol: "tests",
args: [],
source: "testBetweenAnd\x0a\x09self assert: (4 between: 3 and: 5).\x0a\x09self assert: (1 between: 5 and: 6) not.\x0a\x09self assert: (90 between: 67 and: 87) not.\x0a\x09self assert: (1 between: 1 and: 1).",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "between:and:", "not"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([(4)._between_and_((3),(5))
,$ctx1.sendIdx["between:and:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([$recv([(1)._between_and_((5),(6))
,$ctx1.sendIdx["between:and:"]=2
][0])._not()
,$ctx1.sendIdx["not"]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_($recv([(90)._between_and_((67),(87))
,$ctx1.sendIdx["between:and:"]=3
][0])._not())
,$ctx1.sendIdx["assert:"]=3
][0];
$self._assert_((1)._between_and_((1),(1)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBetweenAnd",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testBitAnd",
protocol: "tests",
args: [],
source: "testBitAnd\x0a\x09self assert: (15 bitAnd: 2) equals: 2.\x0a\x09self assert: (15 bitAnd: 15) equals: 15.\x0a\x09self assert: (-1 bitAnd: 1021) equals: 1021",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "bitAnd:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(15)._bitAnd_((2))
,$ctx1.sendIdx["bitAnd:"]=1
][0],(2))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(15)._bitAnd_((15))
,$ctx1.sendIdx["bitAnd:"]=2
][0],(15))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((-1)._bitAnd_((1021)),(1021));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBitAnd",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testBitNot",
protocol: "tests",
args: [],
source: "testBitNot\x0a\x09self assert: 2 bitNot equals: -3.\x0a\x09self assert: -1 bitNot equals: 0.\x0a\x09self assert: -1022 bitNot equals: 1021",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "bitNot"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(2)._bitNot()
,$ctx1.sendIdx["bitNot"]=1
][0],(-3))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(-1)._bitNot()
,$ctx1.sendIdx["bitNot"]=2
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((-1022)._bitNot(),(1021));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBitNot",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testBitOr",
protocol: "tests",
args: [],
source: "testBitOr\x0a\x09self assert: (2 bitOr: 4) equals: 6.\x0a\x09self assert: (7 bitOr: 2) equals: 7.\x0a\x09self assert: (-1 bitOr: 1021) equals: -1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "bitOr:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(2)._bitOr_((4))
,$ctx1.sendIdx["bitOr:"]=1
][0],(6))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(7)._bitOr_((2))
,$ctx1.sendIdx["bitOr:"]=2
][0],(7))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((-1)._bitOr_((1021)),(-1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBitOr",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testBitXor",
protocol: "tests",
args: [],
source: "testBitXor\x0a\x09self assert: (2 bitXor: 4) equals: 6.\x0a\x09self assert: (7 bitXor: 2) equals: 5.\x0a\x09self assert: (-1 bitXor: 1021) equals: -1022.\x0a\x09self assert: (91 bitXor: 91) equals: 0",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "bitXor:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(2)._bitXor_((4))
,$ctx1.sendIdx["bitXor:"]=1
][0],(6))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(7)._bitXor_((2))
,$ctx1.sendIdx["bitXor:"]=2
][0],(5))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([(-1)._bitXor_((1021))
,$ctx1.sendIdx["bitXor:"]=3
][0],(-1022))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_((91)._bitXor_((91)),(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBitXor",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testCeiling",
protocol: "tests",
args: [],
source: "testCeiling\x0a\x09self assert: 1.2 ceiling equals: 2.\x0a\x09self assert: -1.2 ceiling equals: -1.\x0a\x09self assert: 1.0 ceiling equals: 1.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "ceiling"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(1.2)._ceiling()
,$ctx1.sendIdx["ceiling"]=1
][0],(2))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(-1.2)._ceiling()
,$ctx1.sendIdx["ceiling"]=2
][0],(-1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((1)._ceiling(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCeiling",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testComparison",
protocol: "tests",
args: [],
source: "testComparison\x0a\x0a\x09self assert: 3 > 2.\x0a\x09self assert: 2 < 3.\x0a\x09\x0a\x09self deny: 3 < 2.\x0a\x09self deny: 2 > 3.\x0a\x0a\x09self assert: 3 >= 3.\x0a\x09self assert: 3.1 >= 3.\x0a\x09self assert: 3 <= 3.\x0a\x09self assert: 3 <= 3.1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", ">", "<", "deny:", ">=", "<="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([(3).__gt((2))
,$ctx1.sendIdx[">"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([(2).__lt((3))
,$ctx1.sendIdx["<"]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._deny_((3).__lt((2)))
,$ctx1.sendIdx["deny:"]=1
][0];
$self._deny_((2).__gt((3)));
[$self._assert_([(3).__gt_eq((3))
,$ctx1.sendIdx[">="]=1
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
[$self._assert_((3.1).__gt_eq((3)))
,$ctx1.sendIdx["assert:"]=4
][0];
[$self._assert_([(3).__lt_eq((3))
,$ctx1.sendIdx["<="]=1
][0])
,$ctx1.sendIdx["assert:"]=5
][0];
$self._assert_((3).__lt_eq((3.1)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparison",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testCopying",
protocol: "tests",
args: [],
source: "testCopying\x0a\x09self assert: 1 copy == 1.\x0a\x09self assert: 1 deepCopy == 1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "==", "copy", "deepCopy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv((1)._copy()).__eq_eq((1))
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$self._assert_($recv((1)._deepCopy()).__eq_eq((1)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopying",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testDegreesToRadians",
protocol: "tests",
args: [],
source: "testDegreesToRadians\x0a\x09self assert: (180 degreesToRadians - Number pi) abs <= 0.01.",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["assert:", "<=", "abs", "-", "degreesToRadians", "pi"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv($recv((180)._degreesToRadians()).__minus($recv($globals.Number)._pi()))._abs()).__lt_eq((0.01)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDegreesToRadians",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: "tests",
args: [],
source: "testEquality\x0a\x09self assert: (1 = 1).\x0a\x09self assert: (0 = 0).\x0a\x09self deny: (1 = 0).\x0a\x0a\x09self assert: (1 yourself = 1).\x0a\x09self assert: (1 = 1 yourself).\x0a\x09self assert: (1 yourself = 1 yourself).\x0a\x09\x0a\x09self deny: 0 = false.\x0a\x09self deny: false = 0.\x0a\x09self deny: '' = 0.\x0a\x09self deny: 0 = ''",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "=", "deny:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([(1).__eq((1))
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([(0).__eq((0))
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._deny_([(1).__eq((0))
,$ctx1.sendIdx["="]=3
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_([$recv([(1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]).__eq((1))
,$ctx1.sendIdx["="]=4
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
[$self._assert_([(1).__eq([(1)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0])
,$ctx1.sendIdx["="]=5
][0])
,$ctx1.sendIdx["assert:"]=4
][0];
$self._assert_([$recv([(1)._yourself()
,$ctx1.sendIdx["yourself"]=3
][0]).__eq((1)._yourself())
,$ctx1.sendIdx["="]=6
][0]);
[$self._deny_([(0).__eq(false)
,$ctx1.sendIdx["="]=7
][0])
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._deny_([false.__eq((0))
,$ctx1.sendIdx["="]=8
][0])
,$ctx1.sendIdx["deny:"]=3
][0];
[$self._deny_(["".__eq((0))
,$ctx1.sendIdx["="]=9
][0])
,$ctx1.sendIdx["deny:"]=4
][0];
$self._deny_((0).__eq(""));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testFloor",
protocol: "tests",
args: [],
source: "testFloor\x0a\x09self assert: 1.2 floor equals: 1.\x0a\x09self assert: -1.2 floor equals: -2.\x0a\x09self assert: 1.0 floor equals: 1.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "floor"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(1.2)._floor()
,$ctx1.sendIdx["floor"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(-1.2)._floor()
,$ctx1.sendIdx["floor"]=2
][0],(-2))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((1)._floor(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testFloor",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testHexNumbers",
protocol: "tests",
args: [],
source: "testHexNumbers\x0a\x0a\x09self assert: 16r9 equals: 9.\x0a\x09self assert: 16rA truncated equals: 10.\x0a\x09self assert: 16rB truncated equals: 11.\x0a\x09self assert: 16rC truncated equals: 12.\x0a\x09self assert: 16rD truncated equals: 13.\x0a\x09self assert: 16rE truncated equals: 14.\x0a\x09self assert: 16rF truncated equals: 15",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "truncated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_((9),(9))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(10)._truncated()
,$ctx1.sendIdx["truncated"]=1
][0],(10))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([(11)._truncated()
,$ctx1.sendIdx["truncated"]=2
][0],(11))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_([(12)._truncated()
,$ctx1.sendIdx["truncated"]=3
][0],(12))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_([(13)._truncated()
,$ctx1.sendIdx["truncated"]=4
][0],(13))
,$ctx1.sendIdx["assert:equals:"]=5
][0];
[$self._assert_equals_([(14)._truncated()
,$ctx1.sendIdx["truncated"]=5
][0],(14))
,$ctx1.sendIdx["assert:equals:"]=6
][0];
$self._assert_equals_((15)._truncated(),(15));
return self;
}, function($ctx1) {$ctx1.fill(self,"testHexNumbers",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: "tests",
args: [],
source: "testIdentity\x0a\x09self assert: 1 == 1.\x0a\x09self assert: 0 == 0.\x0a\x09self deny: 1 == 0.\x0a\x0a\x09self assert: 1 yourself == 1.\x0a\x09self assert: 1 == 1 yourself.\x0a\x09self assert: 1 yourself == 1 yourself.\x0a\x09\x0a\x09self deny: 1 == 2",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "==", "deny:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([(1).__eq_eq((1))
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([(0).__eq_eq((0))
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._deny_([(1).__eq_eq((0))
,$ctx1.sendIdx["=="]=3
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_([$recv([(1)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]).__eq_eq((1))
,$ctx1.sendIdx["=="]=4
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
[$self._assert_([(1).__eq_eq([(1)._yourself()
,$ctx1.sendIdx["yourself"]=2
][0])
,$ctx1.sendIdx["=="]=5
][0])
,$ctx1.sendIdx["assert:"]=4
][0];
$self._assert_([$recv([(1)._yourself()
,$ctx1.sendIdx["yourself"]=3
][0]).__eq_eq((1)._yourself())
,$ctx1.sendIdx["=="]=6
][0]);
$self._deny_((1).__eq_eq((2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testInvalidHexNumbers",
protocol: "tests",
args: [],
source: "testInvalidHexNumbers\x0a\x0a\x09self should: [ 16rG ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rg ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rH ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rh ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rI ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ri ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rJ ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rj ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rK ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rk ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rL ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rl ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rM ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rm ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rN ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rn ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rO ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ro ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rP ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rp ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rQ ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rq ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rR ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rr ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rS ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rs ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rT ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rt ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rU ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ru ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rV ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rv ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rW ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rw ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rX ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rx ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rY ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16ry ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rZ ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rz ] raise: MessageNotUnderstood.\x0a\x09self should: [ 16rABcdEfZ ] raise: MessageNotUnderstood.",
referencedClasses: ["MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:raise:", "rG", "rg", "rH", "rh", "rI", "ri", "rJ", "rj", "rK", "rk", "rL", "rl", "rM", "rm", "rN", "rn", "rO", "ro", "rP", "rp", "rQ", "rq", "rR", "rr", "rS", "rs", "rT", "rt", "rU", "ru", "rV", "rv", "rW", "rw", "rX", "rx", "rY", "ry", "rZ", "rz", "Z"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rG();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=1
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rg();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=2
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rH();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=3
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rh();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=4
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rI();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=5
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ri();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,6)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=6
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rJ();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,7)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=7
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rj();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,8)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=8
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rK();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,9)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=9
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rk();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,10)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=10
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rL();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,11)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=11
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rl();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,12)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=12
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rM();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,13)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=13
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rm();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,14)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=14
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rN();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,15)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=15
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rn();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,16)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=16
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rO();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,17)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=17
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ro();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,18)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=18
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rP();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,19)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=19
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rp();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,20)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=20
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rQ();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,21)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=21
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rq();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,22)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=22
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rR();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,23)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=23
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rr();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,24)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=24
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rS();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,25)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=25
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rs();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,26)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=26
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rT();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,27)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=27
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rt();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,28)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=28
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rU();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,29)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=29
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ru();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,30)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=30
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rV();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,31)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=31
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rv();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,32)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=32
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rW();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,33)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=33
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rw();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,34)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=34
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rX();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,35)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=35
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rx();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,36)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=36
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rY();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,37)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=37
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._ry();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,38)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=38
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rZ();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,39)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=39
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (16)._rz();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,40)});
}),$globals.MessageNotUnderstood)
,$ctx1.sendIdx["should:raise:"]=40
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (11259375)._Z();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,41)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testInvalidHexNumbers",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testLog",
protocol: "tests",
args: [],
source: "testLog\x0a\x09self assert: 10000 log equals: 4.\x0a\x09self assert: (512 log: 2) equals: 9.\x0a\x09self assert: Number e ln equals: 1.",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["assert:equals:", "log", "log:", "ln", "e"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_((10000)._log(),(4))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_((512)._log_((2)),(9))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv($recv($globals.Number)._e())._ln(),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLog",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testMinMax",
protocol: "tests",
args: [],
source: "testMinMax\x0a\x09\x0a\x09self assert: (2 max: 5) equals: 5.\x0a\x09self assert: (2 min: 5) equals: 2.\x0a\x09self assert: (2 min: 5 max: 3) equals: 3.\x0a\x09self assert: (7 min: 5 max: 3) equals: 5.\x0a\x09self assert: (4 min: 5 max: 3) equals: 4.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "max:", "min:", "min:max:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_((2)._max_((5)),(5))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_((2)._min_((5)),(2))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([(2)._min_max_((5),(3))
,$ctx1.sendIdx["min:max:"]=1
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_([(7)._min_max_((5),(3))
,$ctx1.sendIdx["min:max:"]=2
][0],(5))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
$self._assert_equals_((4)._min_max_((5),(3)),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMinMax",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testNegated",
protocol: "tests",
args: [],
source: "testNegated\x0a\x09self assert: 3 negated equals: -3.\x0a\x09self assert: -3 negated equals: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "negated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(3)._negated()
,$ctx1.sendIdx["negated"]=1
][0],(-3))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_((-3)._negated(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNegated",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testPrintShowingDecimalPlaces",
protocol: "tests",
args: [],
source: "testPrintShowingDecimalPlaces\x0a\x09self assert: (23 printShowingDecimalPlaces: 2) equals: '23.00'.\x0a\x09self assert: (23.5698 printShowingDecimalPlaces: 2) equals: '23.57'.\x0a\x09self assert: (234.567 negated printShowingDecimalPlaces: 5) equals: '-234.56700'.\x0a\x09self assert: (23.4567 printShowingDecimalPlaces: 0) equals: '23'.\x0a\x09self assert: (23.5567 printShowingDecimalPlaces: 0) equals: '24'.\x0a\x09self assert: (23.4567 negated printShowingDecimalPlaces: 0) equals: '-23'.\x0a\x09self assert: (23.5567 negated printShowingDecimalPlaces: 0) equals: '-24'.\x0a\x09self assert: (100000000 printShowingDecimalPlaces: 1) equals: '100000000.0'.\x0a\x09self assert: (0.98 printShowingDecimalPlaces: 5) equals: '0.98000'.\x0a\x09self assert: (0.98 negated printShowingDecimalPlaces: 2) equals: '-0.98'.\x0a\x09self assert: (2.567 printShowingDecimalPlaces: 2) equals: '2.57'.\x0a\x09self assert: (-2.567 printShowingDecimalPlaces: 2) equals: '-2.57'.\x0a\x09self assert: (0 printShowingDecimalPlaces: 2) equals: '0.00'.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "printShowingDecimalPlaces:", "negated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(23)._printShowingDecimalPlaces_((2))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=1
][0],"23.00")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(23.5698)._printShowingDecimalPlaces_((2))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=2
][0],"23.57")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([(234.567)._negated()
,$ctx1.sendIdx["negated"]=1
][0])._printShowingDecimalPlaces_((5))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=3
][0],"-234.56700")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_([(23.4567)._printShowingDecimalPlaces_((0))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=4
][0],"23")
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_([(23.5567)._printShowingDecimalPlaces_((0))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=5
][0],"24")
,$ctx1.sendIdx["assert:equals:"]=5
][0];
[$self._assert_equals_([$recv([(23.4567)._negated()
,$ctx1.sendIdx["negated"]=2
][0])._printShowingDecimalPlaces_((0))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=6
][0],"-23")
,$ctx1.sendIdx["assert:equals:"]=6
][0];
[$self._assert_equals_([$recv([(23.5567)._negated()
,$ctx1.sendIdx["negated"]=3
][0])._printShowingDecimalPlaces_((0))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=7
][0],"-24")
,$ctx1.sendIdx["assert:equals:"]=7
][0];
[$self._assert_equals_([(100000000)._printShowingDecimalPlaces_((1))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=8
][0],"100000000.0")
,$ctx1.sendIdx["assert:equals:"]=8
][0];
[$self._assert_equals_([(0.98)._printShowingDecimalPlaces_((5))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=9
][0],"0.98000")
,$ctx1.sendIdx["assert:equals:"]=9
][0];
[$self._assert_equals_([$recv((0.98)._negated())._printShowingDecimalPlaces_((2))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=10
][0],"-0.98")
,$ctx1.sendIdx["assert:equals:"]=10
][0];
[$self._assert_equals_([(2.567)._printShowingDecimalPlaces_((2))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=11
][0],"2.57")
,$ctx1.sendIdx["assert:equals:"]=11
][0];
[$self._assert_equals_([(-2.567)._printShowingDecimalPlaces_((2))
,$ctx1.sendIdx["printShowingDecimalPlaces:"]=12
][0],"-2.57")
,$ctx1.sendIdx["assert:equals:"]=12
][0];
$self._assert_equals_((0)._printShowingDecimalPlaces_((2)),"0.00");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintShowingDecimalPlaces",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testPrintStringBase",
protocol: "tests",
args: [],
source: "testPrintStringBase\x0a\x09self assert: (15 printStringBase: 2) equals: '1111'.\x0a\x09self assert: (15 printStringBase: 16) equals: 'f'.\x0a\x09self assert: (256 printStringBase: 16) equals: '100'.\x0a\x09self assert: (256 printStringBase: 2) equals: '100000000'",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "printStringBase:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(15)._printStringBase_((2))
,$ctx1.sendIdx["printStringBase:"]=1
][0],"1111")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(15)._printStringBase_((16))
,$ctx1.sendIdx["printStringBase:"]=2
][0],"f")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([(256)._printStringBase_((16))
,$ctx1.sendIdx["printStringBase:"]=3
][0],"100")
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_((256)._printStringBase_((2)),"100000000");
return self;
}, function($ctx1) {$ctx1.fill(self,"testPrintStringBase",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testRadiansToDegrees",
protocol: "tests",
args: [],
source: "testRadiansToDegrees\x0a\x09self assert: (Number pi radiansToDegrees - 180) abs <= 0.01.",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["assert:", "<=", "abs", "-", "radiansToDegrees", "pi"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv($recv($recv($recv($globals.Number)._pi())._radiansToDegrees()).__minus((180)))._abs()).__lt_eq((0.01)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRadiansToDegrees",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testRaisedTo",
protocol: "tests",
args: [],
source: "testRaisedTo\x0a\x09self assert: (2 raisedTo: 4) equals: 16.\x0a\x09self assert: (2 raisedTo: 0) equals: 1.\x0a\x09self assert: (2 raisedTo: -3) equals: 0.125.\x0a\x09self assert: (4 raisedTo: 0.5) equals: 2.\x0a\x09\x0a\x09self assert: 2 ** 4 equals: 16.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "raisedTo:", "**"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(2)._raisedTo_((4))
,$ctx1.sendIdx["raisedTo:"]=1
][0],(16))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(2)._raisedTo_((0))
,$ctx1.sendIdx["raisedTo:"]=2
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([(2)._raisedTo_((-3))
,$ctx1.sendIdx["raisedTo:"]=3
][0],(0.125))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_((4)._raisedTo_((0.5)),(2))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
$self._assert_equals_((2).__star_star((4)),(16));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRaisedTo",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testRounded",
protocol: "tests",
args: [],
source: "testRounded\x0a\x09\x0a\x09self assert: 3 rounded equals: 3.\x0a\x09self assert: 3.212 rounded equals: 3.\x0a\x09self assert: 3.51 rounded equals: 4",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "rounded"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(3)._rounded()
,$ctx1.sendIdx["rounded"]=1
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(3.212)._rounded()
,$ctx1.sendIdx["rounded"]=2
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((3.51)._rounded(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRounded",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testSign",
protocol: "tests",
args: [],
source: "testSign\x0a\x09self assert: 5 sign equals: 1.\x0a\x09self assert: 0 sign equals: 0.\x0a\x09self assert: -1.4 sign equals: -1.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "sign"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(5)._sign()
,$ctx1.sendIdx["sign"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(0)._sign()
,$ctx1.sendIdx["sign"]=2
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((-1.4)._sign(),(-1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSign",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testSqrt",
protocol: "tests",
args: [],
source: "testSqrt\x0a\x09\x0a\x09self assert: 4 sqrt equals: 2.\x0a\x09self assert: 16 sqrt equals: 4",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "sqrt"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(4)._sqrt()
,$ctx1.sendIdx["sqrt"]=1
][0],(2))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_((16)._sqrt(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSqrt",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testSquared",
protocol: "tests",
args: [],
source: "testSquared\x0a\x09\x0a\x09self assert: 4 squared equals: 16",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "squared"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_((4)._squared(),(16));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSquared",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTimesRepeat",
protocol: "tests",
args: [],
source: "testTimesRepeat\x0a\x09| i |\x0a\x0a\x09i := 0.\x0a\x090 timesRepeat: [ i := i + 1 ].\x0a\x09self assert: i equals: 0.\x0a\x0a\x095 timesRepeat: [ i := i + 1 ].\x0a\x09self assert: i equals: 5",
referencedClasses: [],
pragmas: [],
messageSends: ["timesRepeat:", "+", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var i;
return $core.withContext(function($ctx1) {
i=(0);
[(0)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
i=[$recv(i).__plus((1))
,$ctx2.sendIdx["+"]=1
][0];
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["timesRepeat:"]=1
][0];
[$self._assert_equals_(i,(0))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
(5)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
i=$recv(i).__plus((1));
return i;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$self._assert_equals_(i,(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTimesRepeat",{i:i})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTo",
protocol: "tests",
args: [],
source: "testTo\x0a\x09self assert: (1 to: 5) equals: #(1 2 3 4 5)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "to:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_((1)._to_((5)),[(1), (2), (3), (4), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testTo",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testToBy",
protocol: "tests",
args: [],
source: "testToBy\x0a\x09self assert: (0 to: 6 by: 2) equals: #(0 2 4 6).\x0a\x0a\x09self should: [ 1 to: 4 by: 0 ] raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["assert:equals:", "to:by:", "should:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_([(0)._to_by_((6),(2))
,$ctx1.sendIdx["to:by:"]=1
][0],[(0), (2), (4), (6)]);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return (1)._to_by_((4),(0));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testToBy",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTrigonometry",
protocol: "tests",
args: [],
source: "testTrigonometry\x0a\x09self assert: 0 cos equals: 1.\x0a\x09self assert: 0 sin equals: 0.\x0a\x09self assert: 0 tan equals: 0.\x0a\x09self assert: 1 arcCos equals: 0.\x0a\x09self assert: 0 arcSin equals: 0.\x0a\x09self assert: 0 arcTan equals: 0.\x0a\x09\x0a\x09self assert: (0 arcTan: 1) equals: 0.\x0a\x09self assert: (1 arcTan: 0) equals: (Number pi / 2)",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["assert:equals:", "cos", "sin", "tan", "arcCos", "arcSin", "arcTan", "arcTan:", "/", "pi"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_((0)._cos(),(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_((0)._sin(),(0))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_((0)._tan(),(0))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
[$self._assert_equals_((1)._arcCos(),(0))
,$ctx1.sendIdx["assert:equals:"]=4
][0];
[$self._assert_equals_((0)._arcSin(),(0))
,$ctx1.sendIdx["assert:equals:"]=5
][0];
[$self._assert_equals_((0)._arcTan(),(0))
,$ctx1.sendIdx["assert:equals:"]=6
][0];
[$self._assert_equals_([(0)._arcTan_((1))
,$ctx1.sendIdx["arcTan:"]=1
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=7
][0];
$self._assert_equals_((1)._arcTan_((0)),$recv($recv($globals.Number)._pi()).__slash((2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTrigonometry",{})});
}; }),
$globals.NumberTest);

$core.addMethod(
$core.method({
selector: "testTruncated",
protocol: "tests",
args: [],
source: "testTruncated\x0a\x09\x0a\x09self assert: 3 truncated equals: 3.\x0a\x09self assert: 3.212 truncated equals: 3.\x0a\x09self assert: 3.51 truncated equals: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "truncated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([(3)._truncated()
,$ctx1.sendIdx["truncated"]=1
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([(3.212)._truncated()
,$ctx1.sendIdx["truncated"]=2
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_((3.51)._truncated(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTruncated",{})});
}; }),
$globals.NumberTest);



$core.addClass("ObjectMock", $globals.Object, "Kernel-Tests");
$core.setSlots($globals.ObjectMock, ["foo", "bar"]);
$globals.ObjectMock.comment="ObjectMock is there only to perform tests on classes.";
$core.addMethod(
$core.method({
selector: "foo",
protocol: "not yet classified",
args: [],
source: "foo\x0a\x09^ foo",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.foo;

}; }),
$globals.ObjectMock);

$core.addMethod(
$core.method({
selector: "foo:",
protocol: "not yet classified",
args: ["anObject"],
source: "foo: anObject\x0a\x09foo := anObject",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (anObject){
var self=this,$self=this;
$self.foo=anObject;
return self;

}; }),
$globals.ObjectMock);



$core.addClass("ObjectTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "notDefined",
protocol: "tests",
args: [],
source: "notDefined\x0a\x09<inlineJS: 'return void 0;'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return void 0;"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return void 0;;
return self;
}, function($ctx1) {$ctx1.fill(self,"notDefined",{})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testBasicAccess",
protocol: "tests",
args: [],
source: "testBasicAccess\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09o basicAt: 'a' put: 1.\x0a\x09self assert: (o basicAt: 'a') equals: 1.\x0a\x09self assert: (o basicAt: 'b') equals: nil",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "basicAt:put:", "assert:equals:", "basicAt:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var o;
return $core.withContext(function($ctx1) {
o=$recv($globals.Object)._new();
$recv(o)._basicAt_put_("a",(1));
[$self._assert_equals_([$recv(o)._basicAt_("a")
,$ctx1.sendIdx["basicAt:"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(o)._basicAt_("b"),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testBasicAccess",{o:o})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testBasicPerform",
protocol: "tests",
args: [],
source: "testBasicPerform\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09o basicAt: 'func' put: [ 'hello' ].\x0a\x09o basicAt: 'func2' put: [ :a | a + 1 ].\x0a\x0a\x09self assert: (o basicPerform: 'func') equals: 'hello'.\x0a\x09self assert: (o basicPerform: 'func2' withArguments: #(3)) equals: 4",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "basicAt:put:", "+", "assert:equals:", "basicPerform:", "basicPerform:withArguments:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var o;
return $core.withContext(function($ctx1) {
o=$recv($globals.Object)._new();
[$recv(o)._basicAt_put_("func",(function(){
return "hello";

}))
,$ctx1.sendIdx["basicAt:put:"]=1
][0];
$recv(o)._basicAt_put_("func2",(function(a){
return $core.withContext(function($ctx2) {
return $recv(a).__plus((1));
}, function($ctx2) {$ctx2.fillBlock({a:a},$ctx1,2)});
}));
[$self._assert_equals_($recv(o)._basicPerform_("func"),"hello")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(o)._basicPerform_withArguments_("func2",[(3)]),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBasicPerform",{o:o})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testDNU",
protocol: "tests",
args: [],
source: "testDNU\x0a\x09self should: [ Object new foo ] raise: MessageNotUnderstood",
referencedClasses: ["Object", "MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:raise:", "foo", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Object)._new())._foo();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDNU",{})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testEquality",
protocol: "tests",
args: [],
source: "testEquality\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09self deny: o = Object new.\x0a\x09self assert: (o = o).\x0a\x09self assert: (o yourself = o).\x0a\x09self assert: (o = o yourself)",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "deny:", "=", "assert:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var o;
return $core.withContext(function($ctx1) {
o=[$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=1
][0];
$self._deny_([$recv(o).__eq($recv($globals.Object)._new())
,$ctx1.sendIdx["="]=1
][0]);
[$self._assert_([$recv(o).__eq(o)
,$ctx1.sendIdx["="]=2
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([$recv([$recv(o)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]).__eq(o)
,$ctx1.sendIdx["="]=3
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_($recv(o).__eq($recv(o)._yourself()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEquality",{o:o})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testHalt",
protocol: "tests",
args: [],
source: "testHalt\x0a\x09self should: [ Object new halt ] raise: Error",
referencedClasses: ["Object", "Error"],
pragmas: [],
messageSends: ["should:raise:", "halt", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($recv($globals.Object)._new())._halt();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testHalt",{})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testIdentity",
protocol: "tests",
args: [],
source: "testIdentity\x0a\x09| o |\x0a\x09o := Object new.\x0a\x09self deny: o == Object new.\x0a\x09self assert: o == o.\x0a\x09self assert: o yourself == o.\x0a\x09self assert: o == o yourself",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "deny:", "==", "assert:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var o;
return $core.withContext(function($ctx1) {
o=[$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=1
][0];
$self._deny_([$recv(o).__eq_eq($recv($globals.Object)._new())
,$ctx1.sendIdx["=="]=1
][0]);
[$self._assert_([$recv(o).__eq_eq(o)
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([$recv([$recv(o)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]).__eq_eq(o)
,$ctx1.sendIdx["=="]=3
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_($recv(o).__eq_eq($recv(o)._yourself()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIdentity",{o:o})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testIfNil",
protocol: "tests",
args: [],
source: "testIfNil\x0a\x09self deny: Object new isNil.\x0a\x09self deny: (Object new ifNil: [ true ]) = true.\x0a\x09self assert: (Object new ifNotNil: [ true ]) equals: true.\x0a\x0a\x09self assert: (Object new ifNil: [ false ] ifNotNil: [ true ]) equals: true.\x0a\x09self assert: (Object new ifNotNil: [ true ] ifNil: [ false ]) equals: true",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["deny:", "isNil", "new", "=", "ifNil:", "assert:equals:", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4,$5,$6,$7,$8;
[$self._deny_($recv([$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=1
][0])._isNil())
,$ctx1.sendIdx["deny:"]=1
][0];
$1=[$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=2
][0];
if($1 == null || $1.a$nil){
$2=true;
} else {
$2=$1;
}
$self._deny_($recv($2).__eq(true));
$3=[$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=3
][0];
if($3 == null || $3.a$nil){
$4=$3;
} else {
$4=true;
}
[$self._assert_equals_($4,true)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$5=[$recv($globals.Object)._new()
,$ctx1.sendIdx["new"]=4
][0];
if($5 == null || $5.a$nil){
$6=false;
} else {
$6=true;
}
[$self._assert_equals_($6,true)
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$7=$recv($globals.Object)._new();
if($7 == null || $7.a$nil){
$8=false;
} else {
$8=true;
}
$self._assert_equals_($8,true);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfNil",{})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testInstVars",
protocol: "tests",
args: [],
source: "testInstVars\x0a\x09| o |\x0a\x09o := ObjectMock new.\x0a\x09self assert: (o instVarNamed: #foo) equals: nil.\x0a\x0a\x09o instVarNamed: #foo put: 1.\x0a\x09self assert: (o instVarNamed: #foo) equals: 1.\x0a\x09self assert: (o instVarNamed: 'foo') equals: 1",
referencedClasses: ["ObjectMock"],
pragmas: [],
messageSends: ["new", "assert:equals:", "instVarNamed:", "instVarNamed:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var o;
return $core.withContext(function($ctx1) {
o=$recv($globals.ObjectMock)._new();
[$self._assert_equals_([$recv(o)._instVarNamed_("foo")
,$ctx1.sendIdx["instVarNamed:"]=1
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(o)._instVarNamed_put_("foo",(1));
[$self._assert_equals_([$recv(o)._instVarNamed_("foo")
,$ctx1.sendIdx["instVarNamed:"]=2
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv(o)._instVarNamed_("foo"),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testInstVars",{o:o})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testNilUndefined",
protocol: "tests",
args: [],
source: "testNilUndefined\x0a\x09\x22nil in Smalltalk is the undefined object in JS\x22\x0a\x0a\x09self assert: self notDefined equals: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "notDefined"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($self._notDefined(),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNilUndefined",{})});
}; }),
$globals.ObjectTest);

$core.addMethod(
$core.method({
selector: "testYourself",
protocol: "tests",
args: [],
source: "testYourself\x0a\x09| o |\x0a\x09o := ObjectMock new.\x0a\x09self assert: o yourself == o",
referencedClasses: ["ObjectMock"],
pragmas: [],
messageSends: ["new", "assert:", "==", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var o;
return $core.withContext(function($ctx1) {
o=$recv($globals.ObjectMock)._new();
$self._assert_($recv($recv(o)._yourself()).__eq_eq(o));
return self;
}, function($ctx1) {$ctx1.fill(self,"testYourself",{o:o})});
}; }),
$globals.ObjectTest);



$core.addClass("PointTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testAccessing",
protocol: "tests",
args: [],
source: "testAccessing\x0a\x09self assert: (Point x: 3 y: 4) x equals: 3.\x0a\x09self assert: (Point x: 3 y: 4) y equals: 4.\x0a\x09self assert: (Point new x: 3) x equals: 3.\x0a\x09self assert: (Point new y: 4) y equals: 4",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["assert:equals:", "x", "x:y:", "y", "x:", "new", "y:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$recv($globals.Point)._x_y_((3),(4))
,$ctx1.sendIdx["x:y:"]=1
][0])._x()
,$ctx1.sendIdx["x"]=1
][0],(3))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($recv($globals.Point)._x_y_((3),(4)))._y()
,$ctx1.sendIdx["y"]=1
][0],(4))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_($recv($recv([$recv($globals.Point)._new()
,$ctx1.sendIdx["new"]=1
][0])._x_((3)))._x(),(3))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv($recv($recv($globals.Point)._new())._y_((4)))._y(),(4));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAccessing",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testAngle",
protocol: "tests",
args: [],
source: "testAngle\x0a\x09self assert: (-1@0) angle equals: Number pi",
referencedClasses: ["Number"],
pragmas: [],
messageSends: ["assert:equals:", "angle", "@", "pi"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv((-1).__at((0)))._angle(),$recv($globals.Number)._pi());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAngle",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testArithmetic",
protocol: "tests",
args: [],
source: "testArithmetic\x0a\x09self assert: 3@4 * (3@4 ) equals: (Point x: 9 y: 16).\x0a\x09self assert: 3@4 + (3@4 ) equals: (Point x: 6 y: 8).\x0a\x09self assert: 3@4 - (3@4 ) equals: (Point x: 0 y: 0).\x0a\x09self assert: 6@8 / (3@4 ) equals: (Point x: 2 y: 2)",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["assert:equals:", "*", "@", "x:y:", "+", "-", "/"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_($recv([(3).__at((4))
,$ctx1.sendIdx["@"]=1
][0]).__star([(3).__at((4))
,$ctx1.sendIdx["@"]=2
][0]),[$recv($globals.Point)._x_y_((9),(16))
,$ctx1.sendIdx["x:y:"]=1
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv([(3).__at((4))
,$ctx1.sendIdx["@"]=3
][0]).__plus([(3).__at((4))
,$ctx1.sendIdx["@"]=4
][0]),[$recv($globals.Point)._x_y_((6),(8))
,$ctx1.sendIdx["x:y:"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_($recv([(3).__at((4))
,$ctx1.sendIdx["@"]=5
][0]).__minus([(3).__at((4))
,$ctx1.sendIdx["@"]=6
][0]),[$recv($globals.Point)._x_y_((0),(0))
,$ctx1.sendIdx["x:y:"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv([(6).__at((8))
,$ctx1.sendIdx["@"]=7
][0]).__slash((3).__at((4))),$recv($globals.Point)._x_y_((2),(2)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testArithmetic",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testAt",
protocol: "tests",
args: [],
source: "testAt\x0a\x09self assert: 3@4 equals: (Point x: 3 y: 4)",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["assert:equals:", "@", "x:y:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_((3).__at((4)),$recv($globals.Point)._x_y_((3),(4)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAt",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testComparison",
protocol: "tests",
args: [],
source: "testComparison\x0a\x09self assert: 3@4 < (4@5).\x0a\x09self deny: 3@4 < (4@4).\x0a\x09\x0a\x09self assert: 4@5 <= (4@5).\x0a\x09self deny: 4@5 <= (3@5).\x0a\x09\x0a\x09self assert: 5@6 > (4@5).\x0a\x09self deny: 5@6 > (6@6).\x0a\x09\x0a\x09self assert: 4@5 >= (4@5).\x0a\x09self deny: 4@5 >= (5@5)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "<", "@", "deny:", "<=", ">", ">="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([(3).__at((4))
,$ctx1.sendIdx["@"]=1
][0]).__lt([(4).__at((5))
,$ctx1.sendIdx["@"]=2
][0])
,$ctx1.sendIdx["<"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_($recv([(3).__at((4))
,$ctx1.sendIdx["@"]=3
][0]).__lt([(4).__at((4))
,$ctx1.sendIdx["@"]=4
][0]))
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_([$recv([(4).__at((5))
,$ctx1.sendIdx["@"]=5
][0]).__lt_eq([(4).__at((5))
,$ctx1.sendIdx["@"]=6
][0])
,$ctx1.sendIdx["<="]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._deny_($recv([(4).__at((5))
,$ctx1.sendIdx["@"]=7
][0]).__lt_eq([(3).__at((5))
,$ctx1.sendIdx["@"]=8
][0]))
,$ctx1.sendIdx["deny:"]=2
][0];
[$self._assert_([$recv([(5).__at((6))
,$ctx1.sendIdx["@"]=9
][0]).__gt([(4).__at((5))
,$ctx1.sendIdx["@"]=10
][0])
,$ctx1.sendIdx[">"]=1
][0])
,$ctx1.sendIdx["assert:"]=3
][0];
[$self._deny_($recv([(5).__at((6))
,$ctx1.sendIdx["@"]=11
][0]).__gt([(6).__at((6))
,$ctx1.sendIdx["@"]=12
][0]))
,$ctx1.sendIdx["deny:"]=3
][0];
$self._assert_([$recv([(4).__at((5))
,$ctx1.sendIdx["@"]=13
][0]).__gt_eq([(4).__at((5))
,$ctx1.sendIdx["@"]=14
][0])
,$ctx1.sendIdx[">="]=1
][0]);
$self._deny_($recv([(4).__at((5))
,$ctx1.sendIdx["@"]=15
][0]).__gt_eq((5).__at((5))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testComparison",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testDotProduct",
protocol: "tests",
args: [],
source: "testDotProduct\x0a\x09self assert: (2@3 dotProduct: 3@7) equals: 27",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "dotProduct:", "@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([(2).__at((3))
,$ctx1.sendIdx["@"]=1
][0])._dotProduct_((3).__at((7))),(27));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDotProduct",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testEgality",
protocol: "tests",
args: [],
source: "testEgality\x0a\x09self assert: (3@4 = (3@4)).\x0a\x09self deny: 3@5 = (3@6)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "=", "@", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_([$recv([(3).__at((4))
,$ctx1.sendIdx["@"]=1
][0]).__eq([(3).__at((4))
,$ctx1.sendIdx["@"]=2
][0])
,$ctx1.sendIdx["="]=1
][0]);
$self._deny_($recv([(3).__at((5))
,$ctx1.sendIdx["@"]=3
][0]).__eq((3).__at((6))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testEgality",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testNew",
protocol: "tests",
args: [],
source: "testNew\x0a\x0a\x09self assert: (Point new x: 3) y equals: nil.\x0a\x09self deny: (Point new x: 3) x = 0.\x0a\x09self assert: (Point new y: 4) x equals: nil.\x0a\x09self deny: (Point new y: 4) y = 0",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["assert:equals:", "y", "x:", "new", "deny:", "=", "x", "y:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([$recv([$recv($globals.Point)._new()
,$ctx1.sendIdx["new"]=1
][0])._x_((3))
,$ctx1.sendIdx["x:"]=1
][0])._y()
,$ctx1.sendIdx["y"]=1
][0],nil)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._deny_([$recv([$recv($recv([$recv($globals.Point)._new()
,$ctx1.sendIdx["new"]=2
][0])._x_((3)))._x()
,$ctx1.sendIdx["x"]=1
][0]).__eq((0))
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
$self._assert_equals_($recv([$recv([$recv($globals.Point)._new()
,$ctx1.sendIdx["new"]=3
][0])._y_((4))
,$ctx1.sendIdx["y:"]=1
][0])._x(),nil);
$self._deny_($recv($recv($recv($recv($globals.Point)._new())._y_((4)))._y()).__eq((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNew",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testNormal",
protocol: "tests",
args: [],
source: "testNormal\x0a\x09self assert: (1@0) normal equals: 0@1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "normal", "@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($recv([(1).__at((0))
,$ctx1.sendIdx["@"]=1
][0])._normal(),(0).__at((1)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNormal",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testNormalized",
protocol: "tests",
args: [],
source: "testNormalized\x0a\x09self assert: (0@2) normalized equals: 0@1.\x0a\x09self assert: (0@0) normalized equals: 0@0.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "normalized", "@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([(0).__at((2))
,$ctx1.sendIdx["@"]=1
][0])._normalized()
,$ctx1.sendIdx["normalized"]=1
][0],[(0).__at((1))
,$ctx1.sendIdx["@"]=2
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv([(0).__at((0))
,$ctx1.sendIdx["@"]=3
][0])._normalized(),(0).__at((0)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNormalized",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testPolarCoordinates",
protocol: "tests",
args: [],
source: "testPolarCoordinates\x0a\x09self assert: (1@0) r equals: 1.\x0a\x09self assert: (0@0) r equals: 0.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "r", "@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([(1).__at((0))
,$ctx1.sendIdx["@"]=1
][0])._r()
,$ctx1.sendIdx["r"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv((0).__at((0)))._r(),(0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPolarCoordinates",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testRectangleCreation",
protocol: "tests",
args: [],
source: "testRectangleCreation\x0a\x09self assert: (1@1 corner: 2@2) equals: (Rectangle origin: 1@1 corner: 2@2).\x0a\x09self assert: (1@1 rectangle: 2@2) equals: (Rectangle point: 1@1 point: 2@2).\x0a\x09self assert: (1@1 extent: 2@2) equals: (Rectangle origin: 1@1 extent: 2@2)",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["assert:equals:", "corner:", "@", "origin:corner:", "rectangle:", "point:point:", "extent:", "origin:extent:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_($recv([(1).__at((1))
,$ctx1.sendIdx["@"]=1
][0])._corner_([(2).__at((2))
,$ctx1.sendIdx["@"]=2
][0]),$recv($globals.Rectangle)._origin_corner_([(1).__at((1))
,$ctx1.sendIdx["@"]=3
][0],[(2).__at((2))
,$ctx1.sendIdx["@"]=4
][0]))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv([(1).__at((1))
,$ctx1.sendIdx["@"]=5
][0])._rectangle_([(2).__at((2))
,$ctx1.sendIdx["@"]=6
][0]),$recv($globals.Rectangle)._point_point_([(1).__at((1))
,$ctx1.sendIdx["@"]=7
][0],[(2).__at((2))
,$ctx1.sendIdx["@"]=8
][0]))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$self._assert_equals_($recv([(1).__at((1))
,$ctx1.sendIdx["@"]=9
][0])._extent_([(2).__at((2))
,$ctx1.sendIdx["@"]=10
][0]),$recv($globals.Rectangle)._origin_extent_([(1).__at((1))
,$ctx1.sendIdx["@"]=11
][0],(2).__at((2))));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRectangleCreation",{})});
}; }),
$globals.PointTest);

$core.addMethod(
$core.method({
selector: "testTranslateBy",
protocol: "tests",
args: [],
source: "testTranslateBy\x0a\x09self assert: (3@3 translateBy: 0@1) equals: 3@4.\x0a\x09self assert: (3@3 translateBy: 0@1 negated) equals: 3@2.\x0a\x09self assert: (3@3 translateBy: 2@3) equals: 5@6.\x0a\x09self assert: (3@3 translateBy: 3 negated @0) equals: 0@3.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "translateBy:", "@", "negated"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv([(3).__at((3))
,$ctx1.sendIdx["@"]=1
][0])._translateBy_([(0).__at((1))
,$ctx1.sendIdx["@"]=2
][0])
,$ctx1.sendIdx["translateBy:"]=1
][0],[(3).__at((4))
,$ctx1.sendIdx["@"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv([(3).__at((3))
,$ctx1.sendIdx["@"]=4
][0])._translateBy_([(0).__at([(1)._negated()
,$ctx1.sendIdx["negated"]=1
][0])
,$ctx1.sendIdx["@"]=5
][0])
,$ctx1.sendIdx["translateBy:"]=2
][0],[(3).__at((2))
,$ctx1.sendIdx["@"]=6
][0])
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_([$recv([(3).__at((3))
,$ctx1.sendIdx["@"]=7
][0])._translateBy_([(2).__at((3))
,$ctx1.sendIdx["@"]=8
][0])
,$ctx1.sendIdx["translateBy:"]=3
][0],[(5).__at((6))
,$ctx1.sendIdx["@"]=9
][0])
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_($recv([(3).__at((3))
,$ctx1.sendIdx["@"]=10
][0])._translateBy_([$recv((3)._negated()).__at((0))
,$ctx1.sendIdx["@"]=11
][0]),(0).__at((3)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTranslateBy",{})});
}; }),
$globals.PointTest);



$core.addClass("QueueTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testNextIfAbsent",
protocol: "tests",
args: [],
source: "testNextIfAbsent\x0a\x09| queue |\x0a\x09queue := Queue new.\x0a\x09queue nextPut: 'index1'. \x0a\x0a\x09self assert: (queue  nextIfAbsent: 'empty') = 'index1'.\x0a\x09self deny: (queue  nextIfAbsent: 'empty') = 'index1'",
referencedClasses: ["Queue"],
pragmas: [],
messageSends: ["new", "nextPut:", "assert:", "=", "nextIfAbsent:", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var queue;
return $core.withContext(function($ctx1) {
queue=$recv($globals.Queue)._new();
$recv(queue)._nextPut_("index1");
$self._assert_([$recv([$recv(queue)._nextIfAbsent_("empty")
,$ctx1.sendIdx["nextIfAbsent:"]=1
][0]).__eq("index1")
,$ctx1.sendIdx["="]=1
][0]);
$self._deny_($recv($recv(queue)._nextIfAbsent_("empty")).__eq("index1"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNextIfAbsent",{queue:queue})});
}; }),
$globals.QueueTest);

$core.addMethod(
$core.method({
selector: "testQueueNext",
protocol: "tests",
args: [],
source: "testQueueNext\x0a\x09| queue |               \x0a\x09queue := Queue new.\x0a\x09queue \x0a\x09\x09nextPut: 'index1';\x0a\x09\x09nextPut: 'index2'.\x0a\x0a\x09self assert: queue next = 'index1'.\x0a\x09self deny: queue next = 'index'.\x0a\x09self should: [ queue next ] raise: Error",
referencedClasses: ["Queue", "Error"],
pragmas: [],
messageSends: ["new", "nextPut:", "assert:", "=", "next", "deny:", "should:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var queue;
return $core.withContext(function($ctx1) {
var $1;
queue=$recv($globals.Queue)._new();
$1=queue;
[$recv($1)._nextPut_("index1")
,$ctx1.sendIdx["nextPut:"]=1
][0];
$recv($1)._nextPut_("index2");
$self._assert_([$recv([$recv(queue)._next()
,$ctx1.sendIdx["next"]=1
][0]).__eq("index1")
,$ctx1.sendIdx["="]=1
][0]);
$self._deny_($recv([$recv(queue)._next()
,$ctx1.sendIdx["next"]=2
][0]).__eq("index"));
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv(queue)._next();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testQueueNext",{queue:queue})});
}; }),
$globals.QueueTest);



$core.addClass("RandomTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testAtRandomNumber",
protocol: "tests",
args: [],
source: "testAtRandomNumber\x0a\x09|val|\x09\x0a\x0a\x09100 timesRepeat: [\x0a\x09\x09val := 10 atRandom.\x09\x0a\x09\x09self assert: (val > 0).\x0a\x09\x09self assert: (val <11)\x0a\x09]",
referencedClasses: [],
pragmas: [],
messageSends: ["timesRepeat:", "atRandom", "assert:", ">", "<"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var val;
return $core.withContext(function($ctx1) {
(100)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
val=(10)._atRandom();
[$self._assert_($recv(val).__gt((0)))
,$ctx2.sendIdx["assert:"]=1
][0];
return $self._assert_($recv(val).__lt((11)));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtRandomNumber",{val:val})});
}; }),
$globals.RandomTest);

$core.addMethod(
$core.method({
selector: "testAtRandomSequenceableCollection",
protocol: "tests",
args: [],
source: "testAtRandomSequenceableCollection\x0a\x09|val|\x0a\x09\x0a\x09100 timesRepeat: [\x0a\x09\x09val := 'abc' atRandom.\x0a\x09\x09self assert: ((val = 'a') | (val = 'b') | (val = 'c' )).\x0a\x09].",
referencedClasses: [],
pragmas: [],
messageSends: ["timesRepeat:", "atRandom", "assert:", "|", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var val;
return $core.withContext(function($ctx1) {
(100)._timesRepeat_((function(){
return $core.withContext(function($ctx2) {
val="abc"._atRandom();
return $self._assert_([$recv($recv([$recv(val).__eq("a")
,$ctx2.sendIdx["="]=1
][0]).__or([$recv(val).__eq("b")
,$ctx2.sendIdx["="]=2
][0])).__or($recv(val).__eq("c"))
,$ctx2.sendIdx["|"]=1
][0]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtRandomSequenceableCollection",{val:val})});
}; }),
$globals.RandomTest);

$core.addMethod(
$core.method({
selector: "textNext",
protocol: "tests",
args: [],
source: "textNext\x0a\x0a\x0910000 timesRepeat: [\x0a\x09\x09\x09| current next |\x0a\x09\x09\x09next := Random new next.\x0a\x09\x09\x09self assert: (next >= 0).\x0a\x09\x09\x09self assert: (next < 1).\x0a\x09\x09\x09self deny: current = next.\x0a\x09\x09\x09next = current ]",
referencedClasses: ["Random"],
pragmas: [],
messageSends: ["timesRepeat:", "next", "new", "assert:", ">=", "<", "deny:", "="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
(10000)._timesRepeat_((function(){
var current,next;
return $core.withContext(function($ctx2) {
next=$recv($recv($globals.Random)._new())._next();
[$self._assert_($recv(next).__gt_eq((0)))
,$ctx2.sendIdx["assert:"]=1
][0];
$self._assert_($recv(next).__lt((1)));
$self._deny_([$recv(current).__eq(next)
,$ctx2.sendIdx["="]=1
][0]);
return $recv(next).__eq(current);
}, function($ctx2) {$ctx2.fillBlock({current:current,next:next},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"textNext",{})});
}; }),
$globals.RandomTest);



$core.addClass("RectangleTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testContainsPoint",
protocol: "tests",
args: [],
source: "testContainsPoint\x0a\x09| rect |\x0a\x09rect := Rectangle origin: 0@0 corner: 4@4.\x0a\x09\x0a\x09self assert: (rect containsPoint: 1@2).\x0a\x09self assert: (rect containsPoint: 5@4) not.",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["origin:corner:", "@", "assert:", "containsPoint:", "not"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var rect;
return $core.withContext(function($ctx1) {
rect=$recv($globals.Rectangle)._origin_corner_([(0).__at((0))
,$ctx1.sendIdx["@"]=1
][0],[(4).__at((4))
,$ctx1.sendIdx["@"]=2
][0]);
[$self._assert_([$recv(rect)._containsPoint_([(1).__at((2))
,$ctx1.sendIdx["@"]=3
][0])
,$ctx1.sendIdx["containsPoint:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$self._assert_($recv($recv(rect)._containsPoint_((5).__at((4))))._not());
return self;
}, function($ctx1) {$ctx1.fill(self,"testContainsPoint",{rect:rect})});
}; }),
$globals.RectangleTest);

$core.addMethod(
$core.method({
selector: "testContainsRect",
protocol: "tests",
args: [],
source: "testContainsRect\x0a\x09self assert: ((Rectangle origin: 0@0 corner: 6@6) containsRect: (Rectangle origin: 1@1 corner: 5@5)).\x0a\x09self assert: ((Rectangle origin: 0@0 corner: 6@6) containsRect: (Rectangle origin: 1@(-1) corner: 5@5)) not.",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["assert:", "containsRect:", "origin:corner:", "@", "not"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([$recv($globals.Rectangle)._origin_corner_([(0).__at((0))
,$ctx1.sendIdx["@"]=1
][0],[(6).__at((6))
,$ctx1.sendIdx["@"]=2
][0])
,$ctx1.sendIdx["origin:corner:"]=1
][0])._containsRect_([$recv($globals.Rectangle)._origin_corner_([(1).__at((1))
,$ctx1.sendIdx["@"]=3
][0],[(5).__at((5))
,$ctx1.sendIdx["@"]=4
][0])
,$ctx1.sendIdx["origin:corner:"]=2
][0])
,$ctx1.sendIdx["containsRect:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$self._assert_($recv($recv([$recv($globals.Rectangle)._origin_corner_([(0).__at((0))
,$ctx1.sendIdx["@"]=5
][0],[(6).__at((6))
,$ctx1.sendIdx["@"]=6
][0])
,$ctx1.sendIdx["origin:corner:"]=3
][0])._containsRect_($recv($globals.Rectangle)._origin_corner_([(1).__at((-1))
,$ctx1.sendIdx["@"]=7
][0],(5).__at((5)))))._not());
return self;
}, function($ctx1) {$ctx1.fill(self,"testContainsRect",{})});
}; }),
$globals.RectangleTest);

$core.addMethod(
$core.method({
selector: "testOriginExtent",
protocol: "tests",
args: [],
source: "testOriginExtent\x0a\x09| rectangle |\x0a\x09rectangle := Rectangle origin: 3@4 extent: 7@8.\x0a\x09\x0a\x09self assert: rectangle origin equals: 3@4.\x0a\x09self assert: rectangle corner equals: 10@12.",
referencedClasses: ["Rectangle"],
pragmas: [],
messageSends: ["origin:extent:", "@", "assert:equals:", "origin", "corner"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var rectangle;
return $core.withContext(function($ctx1) {
rectangle=$recv($globals.Rectangle)._origin_extent_([(3).__at((4))
,$ctx1.sendIdx["@"]=1
][0],[(7).__at((8))
,$ctx1.sendIdx["@"]=2
][0]);
[$self._assert_equals_($recv(rectangle)._origin(),[(3).__at((4))
,$ctx1.sendIdx["@"]=3
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv(rectangle)._corner(),(10).__at((12)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOriginExtent",{rectangle:rectangle})});
}; }),
$globals.RectangleTest);



$core.addClass("StreamTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "accessing",
args: [],
source: "collectionClass\x0a\x09^ self class collectionClass",
referencedClasses: [],
pragmas: [],
messageSends: ["collectionClass", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._class())._collectionClass();
}, function($ctx1) {$ctx1.fill(self,"collectionClass",{})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "newCollection",
protocol: "accessing",
args: [],
source: "newCollection\x0a\x09^ self collectionClass new",
referencedClasses: [],
pragmas: [],
messageSends: ["new", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._collectionClass())._new();
}, function($ctx1) {$ctx1.fill(self,"newCollection",{})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "newStream",
protocol: "accessing",
args: [],
source: "newStream\x0a\x09^ self collectionClass new stream",
referencedClasses: [],
pragmas: [],
messageSends: ["stream", "new", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($self._collectionClass())._new())._stream();
}, function($ctx1) {$ctx1.fill(self,"newStream",{})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testAtStartAtEnd",
protocol: "tests",
args: [],
source: "testAtStartAtEnd\x0a\x09| stream |\x0a\x09\x0a\x09stream := self newStream.\x0a\x09self assert: stream atStart.\x0a\x09self assert: stream atEnd.\x0a\x09\x0a\x09stream nextPutAll: self newCollection.\x0a\x09self assert: stream atEnd.\x0a\x09self deny: stream atStart.\x0a\x09\x0a\x09stream position: 1.\x0a\x09self deny: stream atEnd.\x0a\x09self deny: stream atStart",
referencedClasses: [],
pragmas: [],
messageSends: ["newStream", "assert:", "atStart", "atEnd", "nextPutAll:", "newCollection", "deny:", "position:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$self._newStream();
[$self._assert_([$recv(stream)._atStart()
,$ctx1.sendIdx["atStart"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_([$recv(stream)._atEnd()
,$ctx1.sendIdx["atEnd"]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
$recv(stream)._nextPutAll_($self._newCollection());
$self._assert_([$recv(stream)._atEnd()
,$ctx1.sendIdx["atEnd"]=2
][0]);
[$self._deny_([$recv(stream)._atStart()
,$ctx1.sendIdx["atStart"]=2
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
$recv(stream)._position_((1));
[$self._deny_($recv(stream)._atEnd())
,$ctx1.sendIdx["deny:"]=2
][0];
$self._deny_($recv(stream)._atStart());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtStartAtEnd",{stream:stream})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testContents",
protocol: "tests",
args: [],
source: "testContents\x0a\x09| stream |\x0a\x09\x0a\x09stream := self newStream.\x0a\x09stream nextPutAll: self newCollection.\x0a\x09\x0a\x09self assert: stream contents equals: self newCollection",
referencedClasses: [],
pragmas: [],
messageSends: ["newStream", "nextPutAll:", "newCollection", "assert:equals:", "contents"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$self._newStream();
$recv(stream)._nextPutAll_([$self._newCollection()
,$ctx1.sendIdx["newCollection"]=1
][0]);
$self._assert_equals_($recv(stream)._contents(),$self._newCollection());
return self;
}, function($ctx1) {$ctx1.fill(self,"testContents",{stream:stream})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testIsEmpty",
protocol: "tests",
args: [],
source: "testIsEmpty\x0a\x09| stream |\x0a\x09\x0a\x09stream := self newStream.\x0a\x09self assert: stream isEmpty.\x0a\x09\x0a\x09stream nextPutAll: self newCollection.\x0a\x09self deny: stream isEmpty",
referencedClasses: [],
pragmas: [],
messageSends: ["newStream", "assert:", "isEmpty", "nextPutAll:", "newCollection", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var stream;
return $core.withContext(function($ctx1) {
stream=$self._newStream();
$self._assert_([$recv(stream)._isEmpty()
,$ctx1.sendIdx["isEmpty"]=1
][0]);
$recv(stream)._nextPutAll_($self._newCollection());
$self._deny_($recv(stream)._isEmpty());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsEmpty",{stream:stream})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testPosition",
protocol: "tests",
args: [],
source: "testPosition\x0a\x09| collection stream |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09stream nextPutAll: collection.\x0a\x09self assert: stream position equals: collection size.\x0a\x09\x0a\x09stream position: 0.\x0a\x09self assert: stream position equals: 0.\x0a\x09\x0a\x09stream next.\x0a\x09self assert: stream position equals: 1.\x0a\x09\x0a\x09stream next.\x0a\x09self assert: stream position equals: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["newCollection", "newStream", "nextPutAll:", "assert:equals:", "position", "size", "position:", "next"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var collection,stream;
return $core.withContext(function($ctx1) {
collection=$self._newCollection();
stream=$self._newStream();
$recv(stream)._nextPutAll_(collection);
[$self._assert_equals_([$recv(stream)._position()
,$ctx1.sendIdx["position"]=1
][0],$recv(collection)._size())
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(stream)._position_((0));
[$self._assert_equals_([$recv(stream)._position()
,$ctx1.sendIdx["position"]=2
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$recv(stream)._next()
,$ctx1.sendIdx["next"]=1
][0];
[$self._assert_equals_([$recv(stream)._position()
,$ctx1.sendIdx["position"]=3
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$recv(stream)._next();
$self._assert_equals_($recv(stream)._position(),(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPosition",{collection:collection,stream:stream})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testReading",
protocol: "tests",
args: [],
source: "testReading\x0a\x09| stream collection |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09stream \x0a\x09\x09nextPutAll: collection;\x0a\x09\x09position: 0.\x0a\x09\x0a\x09collection do: [ :each |\x0a\x09\x09self assert: stream next equals: each ].\x0a\x09\x09\x0a\x09self assert: stream next isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["newCollection", "newStream", "nextPutAll:", "position:", "do:", "assert:equals:", "next", "assert:", "isNil"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var stream,collection;
return $core.withContext(function($ctx1) {
var $1;
collection=$self._newCollection();
stream=$self._newStream();
$1=stream;
$recv($1)._nextPutAll_(collection);
$recv($1)._position_((0));
$recv(collection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $self._assert_equals_([$recv(stream)._next()
,$ctx2.sendIdx["next"]=1
][0],each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._assert_($recv($recv(stream)._next())._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testReading",{stream:stream,collection:collection})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testStreamContents",
protocol: "tests",
args: [],
source: "testStreamContents",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return self;

}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testWrite",
protocol: "tests",
args: [],
source: "testWrite\x0a\x09| stream collection |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09collection do: [ :each | stream << each ].\x0a\x09self assert: stream contents equals: collection",
referencedClasses: [],
pragmas: [],
messageSends: ["newCollection", "newStream", "do:", "<<", "assert:equals:", "contents"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var stream,collection;
return $core.withContext(function($ctx1) {
collection=$self._newCollection();
stream=$self._newStream();
$recv(collection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(stream).__lt_lt(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._assert_equals_($recv(stream)._contents(),collection);
return self;
}, function($ctx1) {$ctx1.fill(self,"testWrite",{stream:stream,collection:collection})});
}; }),
$globals.StreamTest);

$core.addMethod(
$core.method({
selector: "testWriting",
protocol: "tests",
args: [],
source: "testWriting\x0a\x09| stream collection |\x0a\x09\x0a\x09collection := self newCollection.\x0a\x09stream := self newStream.\x0a\x09\x0a\x09collection do: [ :each | stream nextPut: each ].\x0a\x09self assert: stream contents equals: collection.\x0a\x09\x0a\x09stream := self newStream.\x0a\x09stream nextPutAll: collection.\x0a\x09self assert: stream contents equals: collection",
referencedClasses: [],
pragmas: [],
messageSends: ["newCollection", "newStream", "do:", "nextPut:", "assert:equals:", "contents", "nextPutAll:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var stream,collection;
return $core.withContext(function($ctx1) {
collection=$self._newCollection();
stream=[$self._newStream()
,$ctx1.sendIdx["newStream"]=1
][0];
$recv(collection)._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(stream)._nextPut_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
[$self._assert_equals_([$recv(stream)._contents()
,$ctx1.sendIdx["contents"]=1
][0],collection)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
stream=$self._newStream();
$recv(stream)._nextPutAll_(collection);
$self._assert_equals_($recv(stream)._contents(),collection);
return self;
}, function($ctx1) {$ctx1.fill(self,"testWriting",{stream:stream,collection:collection})});
}; }),
$globals.StreamTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "accessing",
args: [],
source: "collectionClass\x0a\x09^ nil",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return nil;

}; }),
$globals.StreamTest.a$cls);

$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: "testing",
args: [],
source: "isAbstract\x0a\x09^ self collectionClass isNil",
referencedClasses: [],
pragmas: [],
messageSends: ["isNil", "collectionClass"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._collectionClass())._isNil();
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{})});
}; }),
$globals.StreamTest.a$cls);


$core.addClass("ArrayStreamTest", $globals.StreamTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "newCollection",
protocol: "accessing",
args: [],
source: "newCollection\x0a\x09^ { true. 1. 3@4. 'foo' }",
referencedClasses: [],
pragmas: [],
messageSends: ["@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return [true,(1),(3).__at((4)),"foo"];
}, function($ctx1) {$ctx1.fill(self,"newCollection",{})});
}; }),
$globals.ArrayStreamTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "accessing",
args: [],
source: "collectionClass\x0a\x09^ Array",
referencedClasses: ["Array"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.Array;

}; }),
$globals.ArrayStreamTest.a$cls);


$core.addClass("StringStreamTest", $globals.StreamTest, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "newCollection",
protocol: "accessing",
args: [],
source: "newCollection\x0a\x09^ 'hello world'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "hello world";

}; }),
$globals.StringStreamTest);


$core.addMethod(
$core.method({
selector: "collectionClass",
protocol: "accessing",
args: [],
source: "collectionClass\x0a\x09^ String",
referencedClasses: ["String"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.String;

}; }),
$globals.StringStreamTest.a$cls);


$core.addTrait("TClassBuildingTest", "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "assert:isClassCopyOf:",
protocol: "running",
args: ["aClass", "anotherClass"],
source: "assert: aClass isClassCopyOf: anotherClass\x0a\x09self assert: aClass superclass == anotherClass superclass.\x0a\x09self deny: aClass slots == anotherClass slots.\x0a\x09self assert: aClass slots equals: anotherClass slots.\x0a\x09self deny: aClass class slots == anotherClass class slots.\x0a\x09self assert: aClass class slots equals: anotherClass class slots.\x0a\x09self assert: aClass package == anotherClass package.\x0a\x09self assert: (aClass package classes includes: aClass).\x0a\x09self assert: aClass methodDictionary keys equals: anotherClass methodDictionary keys",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "==", "superclass", "deny:", "slots", "assert:equals:", "class", "package", "includes:", "classes", "keys", "methodDictionary"]
}, function ($methodClass){ return function (aClass,anotherClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv([$recv(aClass)._superclass()
,$ctx1.sendIdx["superclass"]=1
][0]).__eq_eq($recv(anotherClass)._superclass())
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._deny_([$recv([$recv(aClass)._slots()
,$ctx1.sendIdx["slots"]=1
][0]).__eq_eq([$recv(anotherClass)._slots()
,$ctx1.sendIdx["slots"]=2
][0])
,$ctx1.sendIdx["=="]=2
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
[$self._assert_equals_([$recv(aClass)._slots()
,$ctx1.sendIdx["slots"]=3
][0],[$recv(anotherClass)._slots()
,$ctx1.sendIdx["slots"]=4
][0])
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._deny_([$recv([$recv([$recv(aClass)._class()
,$ctx1.sendIdx["class"]=1
][0])._slots()
,$ctx1.sendIdx["slots"]=5
][0]).__eq_eq([$recv([$recv(anotherClass)._class()
,$ctx1.sendIdx["class"]=2
][0])._slots()
,$ctx1.sendIdx["slots"]=6
][0])
,$ctx1.sendIdx["=="]=3
][0]);
[$self._assert_equals_([$recv([$recv(aClass)._class()
,$ctx1.sendIdx["class"]=3
][0])._slots()
,$ctx1.sendIdx["slots"]=7
][0],$recv($recv(anotherClass)._class())._slots())
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_($recv([$recv(aClass)._package()
,$ctx1.sendIdx["package"]=1
][0]).__eq_eq([$recv(anotherClass)._package()
,$ctx1.sendIdx["package"]=2
][0]))
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_($recv($recv($recv(aClass)._package())._classes())._includes_(aClass));
$self._assert_equals_([$recv([$recv(aClass)._methodDictionary()
,$ctx1.sendIdx["methodDictionary"]=1
][0])._keys()
,$ctx1.sendIdx["keys"]=1
][0],$recv($recv(anotherClass)._methodDictionary())._keys());
return self;
}, function($ctx1) {$ctx1.fill(self,"assert:isClassCopyOf:",{aClass:aClass,anotherClass:anotherClass})});
}; }),
$globals.TClassBuildingTest);

$core.addMethod(
$core.method({
selector: "assert:isJavaScriptInstanceOf:",
protocol: "running",
args: ["anObject", "aJavaScriptClass"],
source: "assert: anObject isJavaScriptInstanceOf: aJavaScriptClass\x0a\x09self assert: (self is: anObject javaScriptInstanceOf: aJavaScriptClass)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "is:javaScriptInstanceOf:"]
}, function ($methodClass){ return function (anObject,aJavaScriptClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($self._is_javaScriptInstanceOf_(anObject,aJavaScriptClass));
return self;
}, function($ctx1) {$ctx1.fill(self,"assert:isJavaScriptInstanceOf:",{anObject:anObject,aJavaScriptClass:aJavaScriptClass})});
}; }),
$globals.TClassBuildingTest);

$core.addMethod(
$core.method({
selector: "is:javaScriptInstanceOf:",
protocol: "private",
args: ["anObject", "aJavaScriptClass"],
source: "is: anObject javaScriptInstanceOf: aJavaScriptClass\x0a\x09<inlineJS: 'return anObject instanceof aJavaScriptClass'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return anObject instanceof aJavaScriptClass"]]],
messageSends: []
}, function ($methodClass){ return function (anObject,aJavaScriptClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return anObject instanceof aJavaScriptClass;
return self;
}, function($ctx1) {$ctx1.fill(self,"is:javaScriptInstanceOf:",{anObject:anObject,aJavaScriptClass:aJavaScriptClass})});
}; }),
$globals.TClassBuildingTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: "running",
args: [],
source: "tearDown\x0a\x09self theClass ifNotNil: [ :theClass |\x0a\x09\x09(Array streamContents: [ :s | theClass allSubclassesDo: [ :each | s nextPut: each ] ])\x0a\x09\x09\x09reverseDo: [ :each | Smalltalk removeClass: each ].\x0a\x09\x09Smalltalk removeClass: theClass ]",
referencedClasses: ["Array", "Smalltalk"],
pragmas: [],
messageSends: ["ifNotNil:", "theClass", "reverseDo:", "streamContents:", "allSubclassesDo:", "nextPut:", "removeClass:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self._theClass();
if($1 == null || $1.a$nil){
$1;
} else {
var theClass;
theClass=$1;
$recv($recv($globals.Array)._streamContents_((function(s){
return $core.withContext(function($ctx2) {
return $recv(theClass)._allSubclassesDo_((function(each){
return $core.withContext(function($ctx3) {
return $recv(s)._nextPut_(each);
}, function($ctx3) {$ctx3.fillBlock({each:each},$ctx2,3)});
}));
}, function($ctx2) {$ctx2.fillBlock({s:s},$ctx1,2)});
})))._reverseDo_((function(each){
return $core.withContext(function($ctx2) {
return [$recv($globals.Smalltalk)._removeClass_(each)
,$ctx2.sendIdx["removeClass:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,4)});
}));
$recv($globals.Smalltalk)._removeClass_(theClass);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{})});
}; }),
$globals.TClassBuildingTest);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"theClass",{})});
}; }),
$globals.TClassBuildingTest);


$core.addTrait("TKeyValueCollectionTest", "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "nonIndexesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "nonIndexesDo: aBlock\x0a\x09\x22Executes block a few times,\x0a\x09each time passing value that is known\x0a\x09not to be an index, as the first parameter\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"nonIndexesDo:",{aBlock:aBlock})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "sampleNewIndex",
protocol: "fixture",
args: [],
source: "sampleNewIndex\x0a\x09\x22Answers a value that can be used as index in at:put: or at:ifAbsentPut:\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"sampleNewIndex",{})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "samplesDo:",
protocol: "fixture",
args: ["aBlock"],
source: "samplesDo: aBlock\x0a\x09\x22Executes block a few times,\x0a\x09each time passing known index and value stored\x0a\x09under that index as the parameters\x22\x0a\x09\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"samplesDo:",{aBlock:aBlock})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testAt",
protocol: "tests",
args: [],
source: "testAt\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09self should: [ self collection at: each ] raise: Error ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection at: index) equals: value ]",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["nonIndexesDo:", "should:raise:", "at:", "collection", "samplesDo:", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
return $self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return [$recv([$self._collection()
,$ctx3.sendIdx["collection"]=1
][0])._at_(each)
,$ctx3.sendIdx["at:"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.Error);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv($self._collection())._at_(index),value);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAt",{})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsent",
protocol: "tests",
args: [],
source: "testAtIfAbsent\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09self assert: (self collection at: each ifAbsent: [ self sampleNewValue ]) equals: self sampleNewValue ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection at: index ifAbsent: [ self sampleNewValue ]) equals: value ].",
referencedClasses: [],
pragmas: [],
messageSends: ["nonIndexesDo:", "assert:equals:", "at:ifAbsent:", "collection", "sampleNewValue", "samplesDo:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
return [$self._assert_equals_([$recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._at_ifAbsent_(each,(function(){
return $core.withContext(function($ctx3) {
return [$self._sampleNewValue()
,$ctx3.sendIdx["sampleNewValue"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))
,$ctx2.sendIdx["at:ifAbsent:"]=1
][0],[$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0])
,$ctx2.sendIdx["assert:equals:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv($self._collection())._at_ifAbsent_(index,(function(){
return $core.withContext(function($ctx3) {
return $self._sampleNewValue();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
})),value);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsent",{})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfAbsentPut",
protocol: "tests",
args: [],
source: "testAtIfAbsentPut\x0a\x09| newCollection |\x0a\x09newCollection := self collection.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (newCollection at: index ifAbsentPut: [ self sampleNewValue ]) equals: value ].\x0a\x09self assert: newCollection equals: self collection.\x0a\x09self assert: (newCollection at: self sampleNewIndex ifAbsentPut: [ self sampleNewValue ]) equals: self sampleNewValue.\x0a\x09self assert: newCollection equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["collection", "samplesDo:", "assert:equals:", "at:ifAbsentPut:", "sampleNewValue", "sampleNewIndex", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var newCollection;
return $core.withContext(function($ctx1) {
newCollection=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return [$self._assert_equals_([$recv(newCollection)._at_ifAbsentPut_(index,(function(){
return $core.withContext(function($ctx3) {
return [$self._sampleNewValue()
,$ctx3.sendIdx["sampleNewValue"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))
,$ctx2.sendIdx["at:ifAbsentPut:"]=1
][0],value)
,$ctx2.sendIdx["assert:equals:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
[$self._assert_equals_(newCollection,$self._collection())
,$ctx1.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_($recv(newCollection)._at_ifAbsentPut_($self._sampleNewIndex(),(function(){
return $core.withContext(function($ctx2) {
return [$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
})),$self._sampleNewValue())
,$ctx1.sendIdx["assert:equals:"]=3
][0];
$self._assert_equals_(newCollection,$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfAbsentPut",{newCollection:newCollection})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresent",
protocol: "tests",
args: [],
source: "testAtIfPresent\x0a\x09| visited sentinel |\x0a\x09sentinel := Object new.\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: each ifPresent: [ :value1 | visited := value1. sentinel ]) equals: nil.\x0a\x09\x09self assert: visited isNil ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: index ifPresent: [ :value2 | visited := value2. sentinel ]) equals: sentinel.\x0a\x09\x09self assert: visited equals: (self collection at: index) ]",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "nonIndexesDo:", "assert:equals:", "at:ifPresent:", "collection", "assert:", "isNil", "samplesDo:", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var visited,sentinel;
return $core.withContext(function($ctx1) {
sentinel=$recv($globals.Object)._new();
$self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
visited=nil;
[$self._assert_equals_([$recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._at_ifPresent_(each,(function(value1){
visited=value1;
return sentinel;

}))
,$ctx2.sendIdx["at:ifPresent:"]=1
][0],nil)
,$ctx2.sendIdx["assert:equals:"]=1
][0];
return $self._assert_($recv(visited)._isNil());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
visited=nil;
[$self._assert_equals_($recv([$self._collection()
,$ctx2.sendIdx["collection"]=2
][0])._at_ifPresent_(index,(function(value2){
visited=value2;
return sentinel;

})),sentinel)
,$ctx2.sendIdx["assert:equals:"]=2
][0];
return $self._assert_equals_(visited,$recv($self._collection())._at_(index));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresent",{visited:visited,sentinel:sentinel})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtIfPresentIfAbsent",
protocol: "tests",
args: [],
source: "testAtIfPresentIfAbsent\x0a\x09| visited sentinel |\x0a\x09sentinel := Object new.\x0a\x09self nonIndexesDo: [ :each |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: each ifPresent: [ :value1 | visited := value1. sentinel ] ifAbsent: [ self sampleNewValue ] ) equals: self sampleNewValue.\x0a\x09\x09self assert: visited isNil ].\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09visited := nil.\x0a\x09\x09self assert: (self collection at: index ifPresent: [ :value2 | visited := value2. sentinel ] ifAbsent: [ self sampleNewValue ]) equals: sentinel.\x0a\x09\x09self assert: visited equals: (self collection at: index) ]",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["new", "nonIndexesDo:", "assert:equals:", "at:ifPresent:ifAbsent:", "collection", "sampleNewValue", "assert:", "isNil", "samplesDo:", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var visited,sentinel;
return $core.withContext(function($ctx1) {
sentinel=$recv($globals.Object)._new();
$self._nonIndexesDo_((function(each){
return $core.withContext(function($ctx2) {
visited=nil;
[$self._assert_equals_([$recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._at_ifPresent_ifAbsent_(each,(function(value1){
visited=value1;
return sentinel;

}),(function(){
return $core.withContext(function($ctx3) {
return [$self._sampleNewValue()
,$ctx3.sendIdx["sampleNewValue"]=1
][0];
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}))
,$ctx2.sendIdx["at:ifPresent:ifAbsent:"]=1
][0],[$self._sampleNewValue()
,$ctx2.sendIdx["sampleNewValue"]=2
][0])
,$ctx2.sendIdx["assert:equals:"]=1
][0];
return $self._assert_($recv(visited)._isNil());
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
visited=nil;
[$self._assert_equals_($recv([$self._collection()
,$ctx2.sendIdx["collection"]=2
][0])._at_ifPresent_ifAbsent_(index,(function(value2){
visited=value2;
return sentinel;

}),(function(){
return $core.withContext(function($ctx3) {
return $self._sampleNewValue();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,6)});
})),sentinel)
,$ctx2.sendIdx["assert:equals:"]=2
][0];
return $self._assert_equals_(visited,$recv($self._collection())._at_(index));
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,4)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtIfPresentIfAbsent",{visited:visited,sentinel:sentinel})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testAtPut",
protocol: "tests",
args: [],
source: "testAtPut\x0a\x09| newCollection |\x0a\x09newCollection := self collection.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09newCollection at: index put: value ].\x0a\x09self assert: newCollection equals: self collection.\x0a\x09newCollection at: self sampleNewIndex put: self sampleNewValue.\x0a\x09self assert: newCollection equals: self collectionWithNewValue",
referencedClasses: [],
pragmas: [],
messageSends: ["collection", "samplesDo:", "at:put:", "assert:equals:", "sampleNewIndex", "sampleNewValue", "collectionWithNewValue"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var newCollection;
return $core.withContext(function($ctx1) {
newCollection=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return [$recv(newCollection)._at_put_(index,value)
,$ctx2.sendIdx["at:put:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
[$self._assert_equals_(newCollection,$self._collection())
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$recv(newCollection)._at_put_($self._sampleNewIndex(),$self._sampleNewValue());
$self._assert_equals_(newCollection,$self._collectionWithNewValue());
return self;
}, function($ctx1) {$ctx1.fill(self,"testAtPut",{newCollection:newCollection})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOf",
protocol: "tests",
args: [],
source: "testIndexOf\x0a\x09self should: [ self collection indexOf: self sampleNewValue ] raise: Error.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection indexOf: value) equals: index ]",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "indexOf:", "collection", "sampleNewValue", "samplesDo:", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$recv([$self._collection()
,$ctx2.sendIdx["collection"]=1
][0])._indexOf_($self._sampleNewValue())
,$ctx2.sendIdx["indexOf:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv($self._collection())._indexOf_(value),index);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOf",{})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testIndexOfWithNull",
protocol: "tests",
args: [],
source: "testIndexOfWithNull\x0a\x09| jsNull |\x0a\x09jsNull := JSON parse: 'null'.\x0a\x09self samplesDo: [ :index :value |\x0a\x09\x09self assert: (self collection at: index put: jsNull; indexOf: jsNull) equals: index ]",
referencedClasses: ["JSON"],
pragmas: [],
messageSends: ["parse:", "samplesDo:", "assert:equals:", "at:put:", "collection", "indexOf:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var jsNull;
return $core.withContext(function($ctx1) {
var $1;
jsNull=$recv($globals.JSON)._parse_("null");
$self._samplesDo_((function(index,value){
return $core.withContext(function($ctx2) {
$1=$self._collection();
$recv($1)._at_put_(index,jsNull);
return $self._assert_equals_($recv($1)._indexOf_(jsNull),index);
}, function($ctx2) {$ctx2.fillBlock({index:index,value:value},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIndexOfWithNull",{jsNull:jsNull})});
}; }),
$globals.TKeyValueCollectionTest);

$core.addMethod(
$core.method({
selector: "testWithIndexDo",
protocol: "tests",
args: [],
source: "testWithIndexDo\x0a\x09| collection |\x0a\x09collection := self collection.\x0a\x09\x0a\x09self collection withIndexDo: [ :each :index |\x0a\x09\x09self assert: (collection at: index) equals: each ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collection", "withIndexDo:", "assert:equals:", "at:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var collection;
return $core.withContext(function($ctx1) {
collection=[$self._collection()
,$ctx1.sendIdx["collection"]=1
][0];
$recv($self._collection())._withIndexDo_((function(each,index){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv(collection)._at_(index),each);
}, function($ctx2) {$ctx2.fillBlock({each:each,index:index},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testWithIndexDo",{collection:collection})});
}; }),
$globals.TKeyValueCollectionTest);


$core.addClass("UndefinedTest", $globals.TestCase, "Kernel-Tests");
$core.addMethod(
$core.method({
selector: "testCopying",
protocol: "tests",
args: [],
source: "testCopying\x0a\x09self assert: nil copy equals: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "copy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_($nil._copy(),nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCopying",{})});
}; }),
$globals.UndefinedTest);

$core.addMethod(
$core.method({
selector: "testDeepCopy",
protocol: "tests",
args: [],
source: "testDeepCopy\x0a\x09self assert: nil deepCopy = nil",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "=", "deepCopy"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($nil._deepCopy()).__eq(nil));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDeepCopy",{})});
}; }),
$globals.UndefinedTest);

$core.addMethod(
$core.method({
selector: "testIfNil",
protocol: "tests",
args: [],
source: "testIfNil\x0a\x09self assert: (nil ifNil: [ true ]) equals: true.\x0a\x09self deny: (nil ifNotNil: [ true ]) = true.\x0a\x09self assert: (nil ifNil: [ true ] ifNotNil: [ false ]) equals: true.\x0a\x09self deny: (nil ifNotNil: [ true ] ifNil: [ false ]) = true",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "ifNil:", "deny:", "=", "ifNotNil:", "ifNil:ifNotNil:", "ifNotNil:ifNil:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
if(nil == null || nil.a$nil){
$1=true;
} else {
$1=nil;
}
[$self._assert_equals_($1,true)
,$ctx1.sendIdx["assert:equals:"]=1
][0];
if(nil == null || nil.a$nil){
$2=nil;
} else {
$2=true;
}
[$self._deny_([$recv($2).__eq(true)
,$ctx1.sendIdx["="]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
if(nil == null || nil.a$nil){
$3=true;
} else {
$3=false;
}
$self._assert_equals_($3,true);
if(nil == null || nil.a$nil){
$4=false;
} else {
$4=true;
}
$self._deny_($recv($4).__eq(true));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIfNil",{})});
}; }),
$globals.UndefinedTest);

$core.addMethod(
$core.method({
selector: "testIsNil",
protocol: "tests",
args: [],
source: "testIsNil\x0a\x09self assert: nil isNil.\x0a\x09self deny: nil notNil.",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "isNil", "deny:", "notNil"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($nil._isNil());
$self._deny_($nil._notNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsNil",{})});
}; }),
$globals.UndefinedTest);


$core.setTraitComposition([{trait: $globals.TClassBuildingTest, aliases: {"tearDownTheClass":"tearDown"}}], $globals.ClassBuilderTest);
$core.setTraitComposition([{trait: $globals.TClassBuildingTest}], $globals.ClassTest);
$core.setTraitComposition([{trait: $globals.TKeyValueCollectionTest}], $globals.AssociativeCollectionTest);
$core.setTraitComposition([{trait: $globals.TKeyValueCollectionTest}], $globals.SequenceableCollectionTest);

});

define('amber/core/Compiler-Tests',["amber/boot", "require", "amber/core/Kernel-Tests", "amber/core/SUnit"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Compiler-Tests");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ASTMethodRunningTest", $globals.TestCase, "Compiler-Tests");
$core.setSlots($globals.ASTMethodRunningTest, ["receiver", "arguments"]);
$core.addMethod(
$core.method({
selector: "arguments",
protocol: "accessing",
args: [],
source: "arguments\x0a\x09^ arguments",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.arguments;

}; }),
$globals.ASTMethodRunningTest);

$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.ASTMethodRunningTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: "initialization",
args: [],
source: "setUp\x0a\x09arguments := #().\x0a\x09receiver := DoIt new",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.arguments=[];
$self.receiver=$recv($globals.DoIt)._new();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.ASTMethodRunningTest);

$core.addMethod(
$core.method({
selector: "should:class:receiver:return:",
protocol: "testing",
args: ["aString", "aClass", "anObject", "aResult"],
source: "should: aString class: aClass receiver: anObject return: aResult\x0a\x09receiver := anObject.\x0a\x09self while: aString inClass: aClass should: [ :runBlock |\x0a\x09\x09self assert: runBlock value equals: aResult ]",
referencedClasses: [],
pragmas: [],
messageSends: ["while:inClass:should:", "assert:equals:", "value"]
}, function ($methodClass){ return function (aString,aClass,anObject,aResult){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=anObject;
$self._while_inClass_should_(aString,aClass,(function(runBlock){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv(runBlock)._value(),aResult);
}, function($ctx2) {$ctx2.fillBlock({runBlock:runBlock},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"should:class:receiver:return:",{aString:aString,aClass:aClass,anObject:anObject,aResult:aResult})});
}; }),
$globals.ASTMethodRunningTest);

$core.addMethod(
$core.method({
selector: "should:receiver:raise:",
protocol: "testing",
args: ["aString", "anObject", "anErrorClass"],
source: "should: aString receiver: anObject raise: anErrorClass\x0a\x09receiver := anObject.\x0a\x09self while: aString should: [ :runBlock |\x0a\x09\x09self should: runBlock raise: anErrorClass ]",
referencedClasses: [],
pragmas: [],
messageSends: ["while:should:", "should:raise:"]
}, function ($methodClass){ return function (aString,anObject,anErrorClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=anObject;
$self._while_should_(aString,(function(runBlock){
return $core.withContext(function($ctx2) {
return $self._should_raise_(runBlock,anErrorClass);
}, function($ctx2) {$ctx2.fillBlock({runBlock:runBlock},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"should:receiver:raise:",{aString:aString,anObject:anObject,anErrorClass:anErrorClass})});
}; }),
$globals.ASTMethodRunningTest);

$core.addMethod(
$core.method({
selector: "should:receiver:return:",
protocol: "testing",
args: ["aString", "anObject", "aResult"],
source: "should: aString receiver: anObject return: aResult\x0a\x09receiver := anObject.\x0a\x09self should: aString return: aResult",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (aString,anObject,aResult){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=anObject;
$self._should_return_(aString,aResult);
return self;
}, function($ctx1) {$ctx1.fill(self,"should:receiver:return:",{aString:aString,anObject:anObject,aResult:aResult})});
}; }),
$globals.ASTMethodRunningTest);

$core.addMethod(
$core.method({
selector: "should:return:",
protocol: "testing",
args: ["aString", "anObject"],
source: "should: aString return: anObject\x0a\x09self while: aString should: [ :runBlock |\x0a\x09\x09self assert: runBlock value equals: anObject ]",
referencedClasses: [],
pragmas: [],
messageSends: ["while:should:", "assert:equals:", "value"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._while_should_(aString,(function(runBlock){
return $core.withContext(function($ctx2) {
return $self._assert_equals_($recv(runBlock)._value(),anObject);
}, function($ctx2) {$ctx2.fillBlock({runBlock:runBlock},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"should:return:",{aString:aString,anObject:anObject})});
}; }),
$globals.ASTMethodRunningTest);



$core.addClass("AbstractCompilerTest", $globals.ASTMethodRunningTest, "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "testAfterInliningNonLocalBlockReturnIndexSend",
protocol: "tests",
args: [],
source: "testAfterInliningNonLocalBlockReturnIndexSend\x0a\x09self should: 'foo [ ^ true ifTrue: [ self class ] ] value. self class' return: DoIt.",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo [ ^ true ifTrue: [ self class ] ] value. self class",$globals.DoIt);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAfterInliningNonLocalBlockReturnIndexSend",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testAfterInliningNonLocalBlockReturnSuperSend",
protocol: "tests",
args: [],
source: "testAfterInliningNonLocalBlockReturnSuperSend\x0a\x09self should: 'foo [ ^ true ifTrue: [ super class ] ] value' return: DoIt.",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo [ ^ true ifTrue: [ super class ] ] value",$globals.DoIt);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAfterInliningNonLocalBlockReturnSuperSend",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testAssignment",
protocol: "tests",
args: [],
source: "testAssignment\x0a\x09self should: 'foo | a | a := true ifTrue: [ 1 ]. ^ a' return: 1.\x0a\x09self should: 'foo | a | a := false ifTrue: [ 1 ]. ^ a' return: nil.\x0a\x0a\x09self should: 'foo | a | ^ a := true ifTrue: [ 1 ]' return: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo | a | a := true ifTrue: [ 1 ]. ^ a",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo | a | a := false ifTrue: [ 1 ]. ^ a",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
$self._should_return_("foo | a | ^ a := true ifTrue: [ 1 ]",(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAssignment",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testBackslashSelectors",
protocol: "tests",
args: [],
source: "testBackslashSelectors\x0a\x09\x0a\x09self should: '\x5c arg ^ 4' return: 4.\x0a\x09self should: '\x5c\x5c arg ^ 42' return: 42",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("\x5c arg ^ 4",(4))
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("\x5c\x5c arg ^ 42",(42));
return self;
}, function($ctx1) {$ctx1.fill(self,"testBackslashSelectors",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testBlockReturn",
protocol: "tests",
args: [],
source: "testBlockReturn\x0a\x09self should: 'foo ^ #(1 2 3) collect: [ :each | true ifTrue: [ each + 1 ] ]' return: #(2 3 4).\x0a\x09self should: 'foo ^ #(1 2 3) collect: [ :each | false ifFalse: [ each + 1 ] ]' return: #(2 3 4).\x0a\x09self should: 'foo ^ #(1 2 3) collect: [ :each | each odd ifTrue: [ each + 1 ] ifFalse: [ each - 1 ] ]' return: #(2 1 4).",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ #(1 2 3) collect: [ :each | true ifTrue: [ each + 1 ] ]",[(2), (3), (4)])
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ #(1 2 3) collect: [ :each | false ifFalse: [ each + 1 ] ]",[(2), (3), (4)])
,$ctx1.sendIdx["should:return:"]=2
][0];
$self._should_return_("foo ^ #(1 2 3) collect: [ :each | each odd ifTrue: [ each + 1 ] ifFalse: [ each - 1 ] ]",[(2), (1), (4)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testBlockReturn",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testCascades",
protocol: "tests",
args: [],
source: "testCascades\x0a\x09\x0a\x09self should: 'foo ^ Array new add: 3; add: 4; yourself' return: #(3 4)",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo ^ Array new add: 3; add: 4; yourself",[(3), (4)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascades",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testCascadesInDynamicArray",
protocol: "tests",
args: [],
source: "testCascadesInDynamicArray\x0a\x09self should: 'foo | x | x := 1. ^ {x. [x:=2] value; in: [x]}' return: #(1 2)",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo | x | x := 1. ^ {x. [x:=2] value; in: [x]}",[(1), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesInDynamicArray",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testCascadesInDynamicDictioary",
protocol: "tests",
args: [],
source: "testCascadesInDynamicDictioary\x0a\x09self should: 'foo | x | x := 1. ^ #{''one'' -> x. ''two'' -> ([x:=2] value; in: [x])}' return: #{'one' -> 1. 'two' -> 2}",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo | x | x := 1. ^ #{'one' -> x. 'two' -> ([x:=2] value; in: [x])}",$globals.HashedCollection._newFromPairs_(["one",(1),"two",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesInDynamicDictioary",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testCascadesInSend",
protocol: "tests",
args: [],
source: "testCascadesInSend\x0a\x09self should: 'foo | x | x := 1. ^ Array with: x with: ([x:=2] value; in: [x])' return: #(1 2)",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo | x | x := 1. ^ Array with: x with: ([x:=2] value; in: [x])",[(1), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesInSend",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testCascadesWithInlining",
protocol: "tests",
args: [],
source: "testCascadesWithInlining\x0a\x09\x0a\x09self should: 'foo ^ true class; ifTrue: [ 1 ] ifFalse: [ 2 ]' return: 1.\x0a\x09self should: 'foo ^ false class; ifTrue: [ 1 ] ifFalse: [ 2 ]' return: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ true class; ifTrue: [ 1 ] ifFalse: [ 2 ]",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("foo ^ false class; ifTrue: [ 1 ] ifFalse: [ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testCascadesWithInlining",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testDynamicArrayElementsOrdered",
protocol: "tests",
args: [],
source: "testDynamicArrayElementsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. x := 2 }\x0a' return: #(1 2).\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. true ifTrue: [ x := 2 ] }\x0a' return: #(1 2).",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. x := 2 }\x0a",[(1), (2)])
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { x. true ifTrue: [ x := 2 ] }\x0a",[(1), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicArrayElementsOrdered",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaryElementsOrdered",
protocol: "tests",
args: [],
source: "testDynamicDictionaryElementsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := ''foo''.\x0a\x09^ #{ x->1. ''bar''->(true ifTrue: [ 2 ]) }\x0a' return: #{'foo'->1. 'bar'->2}.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 'foo'.\x0a\x09^ #{ x->1. 'bar'->(true ifTrue: [ 2 ]) }\x0a",$globals.HashedCollection._newFromPairs_(["foo",(1),"bar",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaryElementsOrdered",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testDynamicDictionaryWithMoreArrows",
protocol: "tests",
args: [],
source: "testDynamicDictionaryWithMoreArrows\x0a\x09self should: 'foo ^ #{1->2->3}' return: (HashedCollection with: 1->2->3)",
referencedClasses: ["HashedCollection"],
pragmas: [],
messageSends: ["should:return:", "with:", "->"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo ^ #{1->2->3}",$recv($globals.HashedCollection)._with_([$recv((1).__minus_gt((2))).__minus_gt((3))
,$ctx1.sendIdx["->"]=1
][0]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDynamicDictionaryWithMoreArrows",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testGlobalVar",
protocol: "tests",
args: [],
source: "testGlobalVar\x0a\x09self should: 'foo ^ eval class' return: BlockClosure.\x0a\x09self should: 'foo ^ Math cos: 0' return: 1.\x0a\x09self should: 'foo ^ NonExistingVar' return: nil",
referencedClasses: ["BlockClosure"],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ eval class",$globals.BlockClosure)
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ Math cos: 0",(1))
,$ctx1.sendIdx["should:return:"]=2
][0];
$self._should_return_("foo ^ NonExistingVar",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testGlobalVar",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testInnerTemporalDependentElementsOrdered",
protocol: "tests",
args: [],
source: "testInnerTemporalDependentElementsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: ''foo''->x with: ''bar''->(x := 2)\x0a' return: {'foo'->Array. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: ''foo''->x with: ''bar''->(true ifTrue: [ x := 2 ])\x0a' return: {'foo'->Array. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: ''foo''->x with: ''bar''->(true ifTrue: [ x := 2 ])\x0a' return: {'foo'->1. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { ''foo''->x. ''bar''->(true ifTrue: [ x := 2 ]) }\x0a' return: {'foo'->1. 'bar'->2}.\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ #{ ''foo''->x. ''bar''->(true ifTrue: [ x := 2 ]) }\x0a' return: #{'foo'->1. 'bar'->2}.",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["should:return:", "->"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: 'foo'->x with: 'bar'->(x := 2)\x0a",[["foo".__minus_gt($globals.Array)
,$ctx1.sendIdx["->"]=1
][0],["bar".__minus_gt((2))
,$ctx1.sendIdx["->"]=2
][0]])
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: 'foo'->x with: 'bar'->(true ifTrue: [ x := 2 ])\x0a",[["foo".__minus_gt($globals.Array)
,$ctx1.sendIdx["->"]=3
][0],["bar".__minus_gt((2))
,$ctx1.sendIdx["->"]=4
][0]])
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: 'foo'->x with: 'bar'->(true ifTrue: [ x := 2 ])\x0a",[["foo".__minus_gt((1))
,$ctx1.sendIdx["->"]=5
][0],["bar".__minus_gt((2))
,$ctx1.sendIdx["->"]=6
][0]])
,$ctx1.sendIdx["should:return:"]=3
][0];
[$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ { 'foo'->x. 'bar'->(true ifTrue: [ x := 2 ]) }\x0a",[["foo".__minus_gt((1))
,$ctx1.sendIdx["->"]=7
][0],"bar".__minus_gt((2))])
,$ctx1.sendIdx["should:return:"]=4
][0];
$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ #{ 'foo'->x. 'bar'->(true ifTrue: [ x := 2 ]) }\x0a",$globals.HashedCollection._newFromPairs_(["foo",(1),"bar",(2)]));
return self;
}, function($ctx1) {$ctx1.fill(self,"testInnerTemporalDependentElementsOrdered",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testLexicalScope",
protocol: "tests",
args: [],
source: "testLexicalScope\x0a\x09self should: 'foo | a | a := 1. [ a := 2 ] value. ^ a' return: 2",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo | a | a := 1. [ a := 2 ] value. ^ a",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLexicalScope",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testLiterals",
protocol: "tests",
args: [],
source: "testLiterals\x0a\x09self should: 'foo ^ 1' return: 1.\x0a\x09self should: 'foo ^ ''hello''' return: 'hello'.\x0a\x09self should: 'foo ^ #(1 2 3 4)' return: #(1 2 3 4).\x0a\x09self should: 'foo ^ {1. [:x | x ] value: 2. 3. [4] value}' return: #(1 2 3 4).\x0a\x09self should: 'foo ^ true' return: true.\x0a\x09self should: 'foo ^ false' return: false.\x0a\x09self should: 'foo ^ #{1->2. 3->4}' return: #{1->2. 3->4}.\x0a\x09self should: 'foo ^ #hello' return: #hello.\x0a\x09self should: 'foo ^ $h' return: 'h'.\x0a\x09self should: 'foo ^ -123.456' return: -123.456.\x0a\x09self should: 'foo ^ -2.5e4' return: -25000.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ 'hello'","hello")
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ #(1 2 3 4)",[(1), (2), (3), (4)])
,$ctx1.sendIdx["should:return:"]=3
][0];
[$self._should_return_("foo ^ {1. [:x | x ] value: 2. 3. [4] value}",[(1), (2), (3), (4)])
,$ctx1.sendIdx["should:return:"]=4
][0];
[$self._should_return_("foo ^ true",true)
,$ctx1.sendIdx["should:return:"]=5
][0];
[$self._should_return_("foo ^ false",false)
,$ctx1.sendIdx["should:return:"]=6
][0];
[$self._should_return_("foo ^ #{1->2. 3->4}",$globals.HashedCollection._newFromPairs_([(1),(2),(3),(4)]))
,$ctx1.sendIdx["should:return:"]=7
][0];
[$self._should_return_("foo ^ #hello","hello")
,$ctx1.sendIdx["should:return:"]=8
][0];
[$self._should_return_("foo ^ $h","h")
,$ctx1.sendIdx["should:return:"]=9
][0];
[$self._should_return_("foo ^ -123.456",(-123.456))
,$ctx1.sendIdx["should:return:"]=10
][0];
$self._should_return_("foo ^ -2.5e4",(-25000));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLiterals",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testLocalReturn",
protocol: "tests",
args: [],
source: "testLocalReturn\x0a\x09self should: 'foo ^ 1' return: 1.\x0a\x09self should: 'foo ^ 1 + 1' return: 2.\x0a\x09self should: 'foo ' return: receiver.\x0a\x09self should: 'foo self asString' return: receiver.\x0a\x09self should: 'foo | a b | a := 1. b := 2. ^ a + b' return: 3",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ 1 + 1",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ",$self.receiver)
,$ctx1.sendIdx["should:return:"]=3
][0];
[$self._should_return_("foo self asString",$self.receiver)
,$ctx1.sendIdx["should:return:"]=4
][0];
$self._should_return_("foo | a b | a := 1. b := 2. ^ a + b",(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testLocalReturn",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testMessageSends",
protocol: "tests",
args: [],
source: "testMessageSends\x0a\x09self should: 'foo ^ 1 asString' return: '1'.\x0a\x0a\x09self should: 'foo ^ 1 + 1' return: 2.\x0a\x09self should: 'foo ^ 1 + 2 * 3' return: 9.\x0a\x0a\x09self should: 'foo ^ 1 to: 3' return: #(1 2 3).\x0a\x09self should: 'foo ^ 1 to: 5 by: 2' return: #(1 3 5)",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1 asString","1")
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ 1 + 1",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ 1 + 2 * 3",(9))
,$ctx1.sendIdx["should:return:"]=3
][0];
[$self._should_return_("foo ^ 1 to: 3",[(1), (2), (3)])
,$ctx1.sendIdx["should:return:"]=4
][0];
$self._should_return_("foo ^ 1 to: 5 by: 2",[(1), (3), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSends",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testMultipleSequences",
protocol: "tests",
args: [],
source: "testMultipleSequences\x0a\x09self should: 'foo | a b c | a := 2. b := 3. c := a + b. ^ c * 6' return: 30",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo | a b c | a := 2. b := 3. c := a + b. ^ c * 6",(30));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMultipleSequences",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testMutableLiterals",
protocol: "tests",
args: [],
source: "testMutableLiterals\x0a\x09\x22Mutable literals must be aliased in cascades.\x0a\x09See https://lolg.it/amber/amber/issues/428\x22\x0a\x09\x0a\x09self \x0a\x09\x09should: 'foo ^ #( 1 2 ) at: 1 put: 3; yourself' \x0a\x09\x09return: #(3 2)",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo ^ #( 1 2 ) at: 1 put: 3; yourself",[(3), (2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMutableLiterals",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testNestedIfTrue",
protocol: "tests",
args: [],
source: "testNestedIfTrue\x0a\x09self should: 'foo ^ true ifTrue: [ false ifFalse: [ 1 ] ]' return: 1.\x0a\x09self should: 'foo ^ true ifTrue: [ false ifTrue: [ 1 ] ]' return: nil.\x0a\x0a\x09self should: 'foo true ifTrue: [ false ifFalse: [ ^ 1 ] ]' return: 1.\x0a\x09self should: 'foo true ifTrue: [ false ifTrue: [ ^ 1 ] ]' return: receiver.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ true ifTrue: [ false ifFalse: [ 1 ] ]",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ true ifTrue: [ false ifTrue: [ 1 ] ]",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo true ifTrue: [ false ifFalse: [ ^ 1 ] ]",(1))
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo true ifTrue: [ false ifTrue: [ ^ 1 ] ]",$self.receiver);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNestedIfTrue",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testNestedSends",
protocol: "tests",
args: [],
source: "testNestedSends\x0a\x09self should: 'foo ^ (Point x: (Point x: 2 y: 3) y: 4) asString' return: (Point x: (2@3) y: 4) asString",
referencedClasses: ["Point"],
pragmas: [],
messageSends: ["should:return:", "asString", "x:y:", "@"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo ^ (Point x: (Point x: 2 y: 3) y: 4) asString",$recv($recv($globals.Point)._x_y_((2).__at((3)),(4)))._asString());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNestedSends",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testNilPerform",
protocol: "tests",
args: [],
source: "testNilPerform\x0a\x09self should: 'foo ^ nil perform: #yourself' return: nil",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo ^ nil perform: #yourself",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNilPerform",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testNonLocalReturn",
protocol: "tests",
args: [],
source: "testNonLocalReturn\x0a\x09self should: 'foo [ ^ 1 ] value' return: 1.\x0a\x09self should: 'foo [ ^ 1 + 1 ] value' return: 2.\x0a\x09self should: 'foo | a b | a := 1. b := 2. [ ^ a + b ] value. self halt' return: 3.\x0a\x09self should: 'foo [ :x | ^ x + x ] value: 4. ^ 2' return: 8",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo [ ^ 1 ] value",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo [ ^ 1 + 1 ] value",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo | a b | a := 1. b := 2. [ ^ a + b ] value. self halt",(3))
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo [ :x | ^ x + x ] value: 4. ^ 2",(8));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonLocalReturn",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testPascalCaseGlobal",
protocol: "tests",
args: [],
source: "testPascalCaseGlobal\x0a\x09self should: 'foo ^Object' return: (Smalltalk globals at: 'Object').\x0a\x09self should: 'foo ^NonExistent' return: nil",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["should:return:", "at:", "globals"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^Object",$recv($recv($globals.Smalltalk)._globals())._at_("Object"))
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("foo ^NonExistent",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPascalCaseGlobal",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testPragmaJSStatement",
protocol: "tests",
args: [],
source: "testPragmaJSStatement\x0a\x09self should: 'foo < inlineJS: ''return 2+3'' >' return: 5",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo < inlineJS: 'return 2+3' >",(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPragmaJSStatement",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testReceiverEvaluatedOnceInSpecials",
protocol: "tests",
args: [],
source: "testReceiverEvaluatedOnceInSpecials\x0a\x09self should: 'foo |x| x := 1. ^ {[ x := x+1 ] value ifNil: []. x}' return: {2. 2}.\x0a\x09self should: 'foo |xs| xs := {nil. nil}. ^ {[ xs removeLast ] value ifNotNil: []. xs}' return: {nil. {nil}}.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo |x| x := 1. ^ {[ x := x+1 ] value ifNil: []. x}",[(2),(2)])
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("foo |xs| xs := {nil. nil}. ^ {[ xs removeLast ] value ifNotNil: []. xs}",[nil,[nil]]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testReceiverEvaluatedOnceInSpecials",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testRegression1242",
protocol: "tests",
args: [],
source: "testRegression1242\x0a\x09self should: '\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := nil ifNil: [].\x0a\x09\x09\x09^ x\x0a\x09' return: nil.\x0a\x09\x0a\x09self should: '\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := 1 ifNotNil: [].\x0a\x09\x09\x09^ x\x0a\x09' return: nil.\x0a\x09\x0a\x09self should: '\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := false ifFalse: [].\x0a\x09\x09\x09^ x\x0a\x09' return: nil.\x0a\x09\x0a\x09self should: '\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := true ifTrue: [].\x0a\x09\x09\x09^ x\x0a\x09' return: nil.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := nil ifNil: [].\x0a\x09\x09\x09^ x\x0a\x09",nil)
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := 1 ifNotNil: [].\x0a\x09\x09\x09^ x\x0a\x09",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := false ifFalse: [].\x0a\x09\x09\x09^ x\x0a\x09",nil)
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("\x0a\x09\x09foo\x0a\x09\x09\x09|x|\x0a\x09\x09\x09x := 2.\x0a\x09\x09\x09x := true ifTrue: [].\x0a\x09\x09\x09^ x\x0a\x09",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1242",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testRegression1242ForReturn",
protocol: "tests",
args: [],
source: "testRegression1242ForReturn\x0a\x09self should: 'foo [ ^ nil ifNil: [] ] value' return: nil.\x0a\x09self should: 'foo [ ^ 1 ifNotNil: [] ] value' return: nil.\x0a\x09self should: 'foo [ ^ false ifFalse: [] ] value' return: nil.\x0a\x09self should: 'foo [ ^ true ifTrue: [] ] value' return: nil.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo [ ^ nil ifNil: [] ] value",nil)
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo [ ^ 1 ifNotNil: [] ] value",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo [ ^ false ifFalse: [] ] value",nil)
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo [ ^ true ifTrue: [] ] value",nil);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1242ForReturn",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testRegression1244",
protocol: "tests",
args: [],
source: "testRegression1244\x0a\x09self should: 'foo [ ^ true ifTrue: [1] ifFalse: [2] ] value' return: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo [ ^ true ifTrue: [1] ifFalse: [2] ] value",(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRegression1244",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testRootSuperSend",
protocol: "tests",
args: [],
source: "testRootSuperSend\x0a\x09self \x0a\x09\x09should: 'foo ^ super class' \x0a\x09\x09receiver: ProtoObject new\x0a\x09\x09raise: MessageNotUnderstood",
referencedClasses: ["ProtoObject", "MessageNotUnderstood"],
pragmas: [],
messageSends: ["should:receiver:raise:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_receiver_raise_("foo ^ super class",$recv($globals.ProtoObject)._new(),$globals.MessageNotUnderstood);
return self;
}, function($ctx1) {$ctx1.fill(self,"testRootSuperSend",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSendReceiverAndArgumentsOrdered",
protocol: "tests",
args: [],
source: "testSendReceiverAndArgumentsOrdered\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: x with: (true ifTrue: [ x := 2 ])\x0a' return: #(1 2).\x0a\x0a\x09self should: 'foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: x with: (true ifTrue: [ x := 2 ])\x0a' return: {Array. 2}.",
referencedClasses: ["Array"],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo\x0a\x09| x |\x0a\x09x := 1.\x0a\x09^ Array with: x with: (true ifTrue: [ x := 2 ])\x0a",[(1), (2)])
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("foo\x0a\x09| x |\x0a\x09x := Array.\x0a\x09^ x with: x with: (true ifTrue: [ x := 2 ])\x0a",[$globals.Array,(2)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSendReceiverAndArgumentsOrdered",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSuperSend",
protocol: "tests",
args: [],
source: "testSuperSend\x0a\x09self \x0a\x09\x09should: 'foo ^ super isBoolean' \x0a\x09\x09receiver: true\x0a\x09\x09return: false",
referencedClasses: [],
pragmas: [],
messageSends: ["should:receiver:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_receiver_return_("foo ^ super isBoolean",true,false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSuperSend2",
protocol: "tests",
args: [],
source: "testSuperSend2\x0a\x09self \x0a\x09\x09should: 'foo ^ super isNil'\x0a\x09\x09receiver: nil\x0a\x09\x09return: false",
referencedClasses: [],
pragmas: [],
messageSends: ["should:receiver:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_receiver_return_("foo ^ super isNil",nil,false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend2",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSuperSend3",
protocol: "tests",
args: [],
source: "testSuperSend3\x0a\x09self \x0a\x09\x09should: 'doo ^ super isNil'\x0a\x09\x09class: Object\x0a\x09\x09receiver: nil\x0a\x09\x09return: false",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["should:class:receiver:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_class_receiver_return_("doo ^ super isNil",$globals.Object,nil,false);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend3",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSuperSend4",
protocol: "tests",
args: [],
source: "testSuperSend4\x0a\x09self \x0a\x09\x09should: 'foo ^ super asJavaScriptObject'\x0a\x09\x09receiver: 'me'\x0a\x09\x09return: #('m' 'e')",
referencedClasses: [],
pragmas: [],
messageSends: ["should:receiver:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_receiver_return_("foo ^ super asJavaScriptObject","me",["m", "e"]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend4",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSuperSend5",
protocol: "tests",
args: [],
source: "testSuperSend5\x0a\x09self \x0a\x09\x09should: 'foo [super addLast: 4] on: Error do: [ self add: 5 ]. ^ self'\x0a\x09\x09class: SequenceableCollection\x0a\x09\x09receiver: #(1 2 3)\x0a\x09\x09return: #(1 2 3 5)",
referencedClasses: ["SequenceableCollection"],
pragmas: [],
messageSends: ["should:class:receiver:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_class_receiver_return_("foo [super addLast: 4] on: Error do: [ self add: 5 ]. ^ self",$globals.SequenceableCollection,[(1), (2), (3)],[(1), (2), (3), (5)]);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend5",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testSuperSend6",
protocol: "tests",
args: [],
source: "testSuperSend6\x0a\x09self \x0a\x09\x09should: 'foo ^ super ifTrue: [ true ] ifFalse: [ false ]' \x0a\x09\x09receiver: true\x0a\x09\x09raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:receiver:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_receiver_raise_("foo ^ super ifTrue: [ true ] ifFalse: [ false ]",true,$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testSuperSend6",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testTempVariables",
protocol: "tests",
args: [],
source: "testTempVariables\x0a\x09self should: 'foo | a | ^ a' return: nil.\x0a\x09self should: 'foo | AVariable | ^ AVariable' return: nil.\x0a\x09self should: 'foo | a b c | ^ c' return: nil.\x0a\x09self should: 'foo | a | [ | d | ^ d ] value' return: nil.\x0a\x09\x0a\x09self should: 'foo | a | a:= 1. ^ a' return: 1.\x0a\x09self should: 'foo | AVariable | AVariable := 1. ^ AVariable' return: 1.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo | a | ^ a",nil)
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo | AVariable | ^ AVariable",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo | a b c | ^ c",nil)
,$ctx1.sendIdx["should:return:"]=3
][0];
[$self._should_return_("foo | a | [ | d | ^ d ] value",nil)
,$ctx1.sendIdx["should:return:"]=4
][0];
[$self._should_return_("foo | a | a:= 1. ^ a",(1))
,$ctx1.sendIdx["should:return:"]=5
][0];
$self._should_return_("foo | AVariable | AVariable := 1. ^ AVariable",(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTempVariables",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testThisContext",
protocol: "tests",
args: [],
source: "testThisContext\x0a\x09self should: 'foo ^ [ thisContext ] value outerContext == thisContext' return: true",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_return_("foo ^ [ thisContext ] value outerContext == thisContext",true);
return self;
}, function($ctx1) {$ctx1.fill(self,"testThisContext",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testUnknownPragma",
protocol: "tests",
args: [],
source: "testUnknownPragma\x0a\x09self should: 'foo < fooBar: ''return 2+3'' > | x | ^ x := 6' return: 6.\x0a\x09self should: 'foo | x | < fooBar: ''return 2+3'' > ^ x := 6' return: 6",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo < fooBar: 'return 2+3' > | x | ^ x := 6",(6))
,$ctx1.sendIdx["should:return:"]=1
][0];
$self._should_return_("foo | x | < fooBar: 'return 2+3' > ^ x := 6",(6));
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownPragma",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifFalse",
protocol: "tests",
args: [],
source: "testifFalse\x0a\x09self should: 'foo true ifFalse: [ ^ 1 ]' return: receiver.\x0a\x09self should: 'foo false ifFalse: [ ^ 2 ]' return: 2.\x0a\x09\x0a\x09self should: 'foo ^ true ifFalse: [ 1 ]' return: nil.\x0a\x09self should: 'foo ^ false ifFalse: [ 2 ]' return: 2.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo true ifFalse: [ ^ 1 ]",$self.receiver)
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo false ifFalse: [ ^ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ true ifFalse: [ 1 ]",nil)
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo ^ false ifFalse: [ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifFalse",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifFalseIfTrue",
protocol: "tests",
args: [],
source: "testifFalseIfTrue\x0a\x09self should: 'foo true ifFalse: [ ^ 1 ] ifTrue: [ ^ 2 ]' return: 2.\x0a\x09self should: 'foo false ifFalse: [ ^ 2 ] ifTrue: [ ^1 ]' return: 2.\x0a\x09\x0a\x09self should: 'foo ^ true ifFalse: [ 1 ] ifTrue: [ 2 ]' return: 2.\x0a\x09self should: 'foo ^ false ifFalse: [ 2 ] ifTrue: [ 1 ]' return: 2.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo true ifFalse: [ ^ 1 ] ifTrue: [ ^ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo false ifFalse: [ ^ 2 ] ifTrue: [ ^1 ]",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ true ifFalse: [ 1 ] ifTrue: [ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo ^ false ifFalse: [ 2 ] ifTrue: [ 1 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifFalseIfTrue",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifNil",
protocol: "tests",
args: [],
source: "testifNil\x0a\x09self should: 'foo ^ 1 ifNil: [ 2 ]' return: 1.\x0a\x09self should: 'foo ^ nil ifNil: [ 2 ]' return: 2.\x0a\x0a\x09self should: 'foo 1 ifNil: [ ^ 2 ]' return: receiver.\x0a\x09self should: 'foo nil ifNil: [ ^ 2 ]' return: 2.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1 ifNil: [ 2 ]",(1))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ nil ifNil: [ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo 1 ifNil: [ ^ 2 ]",$self.receiver)
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo nil ifNil: [ ^ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNil",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifNilIfNotNil",
protocol: "tests",
args: [],
source: "testifNilIfNotNil\x0a\x09self should: 'foo ^ 1 ifNil: [ 2 ] ifNotNil: [ 3 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNil: [ 2 ] ifNotNil: [ 3 ]' return: 2.\x0a\x0a\x09self should: 'foo 1 ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]' return: 3.\x0a\x09self should: 'foo nil ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]' return: 2.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1 ifNil: [ 2 ] ifNotNil: [ 3 ]",(3))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ nil ifNil: [ 2 ] ifNotNil: [ 3 ]",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo 1 ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]",(3))
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo nil ifNil: [ ^ 2 ] ifNotNil: [ ^3 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNilIfNotNil",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifNotNil",
protocol: "tests",
args: [],
source: "testifNotNil\x0a\x09self should: 'foo ^ 1 ifNotNil: [ 2 ]' return: 2.\x0a\x09self should: 'foo ^ nil ifNotNil: [ 2 ]' return: nil.\x0a\x0a\x09self should: 'foo 1 ifNotNil: [ ^ 2 ]' return: 2.\x0a\x09self should: 'foo nil ifNotNil: [ ^ 2 ]' return: receiver.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1 ifNotNil: [ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ nil ifNotNil: [ 2 ]",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo 1 ifNotNil: [ ^ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo nil ifNotNil: [ ^ 2 ]",$self.receiver);
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNotNil",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifNotNilWithArgument",
protocol: "tests",
args: [],
source: "testifNotNilWithArgument\x0a\x09self should: 'foo ^ 1 ifNotNil: [ :val | val + 2 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNotNil: [ :val | val + 2 ]' return: nil.\x0a\x09\x0a\x09self should: 'foo ^ 1 ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]' return: 5.\x0a\x09\x0a\x09self should: 'foo ^ 1 ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]' return: 3.\x0a\x09self should: 'foo ^ nil ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]' return: 5",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo ^ 1 ifNotNil: [ :val | val + 2 ]",(3))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo ^ nil ifNotNil: [ :val | val + 2 ]",nil)
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ 1 ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]",(3))
,$ctx1.sendIdx["should:return:"]=3
][0];
[$self._should_return_("foo ^ nil ifNil: [ 5 ] ifNotNil: [ :val | val + 2 ]",(5))
,$ctx1.sendIdx["should:return:"]=4
][0];
[$self._should_return_("foo ^ 1 ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]",(3))
,$ctx1.sendIdx["should:return:"]=5
][0];
$self._should_return_("foo ^ nil ifNotNil: [ :val | val + 2 ] ifNil: [ 5 ]",(5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifNotNilWithArgument",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifTrue",
protocol: "tests",
args: [],
source: "testifTrue\x0a\x09self should: 'foo false ifTrue: [ ^ 1 ]' return: receiver.\x0a\x09self should: 'foo true ifTrue: [ ^ 2 ]' return: 2.\x0a\x09\x0a\x09self should: 'foo ^ false ifTrue: [ 1 ]' return: nil.\x0a\x09self should: 'foo ^ true ifTrue: [ 2 ]' return: 2.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo false ifTrue: [ ^ 1 ]",$self.receiver)
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo true ifTrue: [ ^ 2 ]",(2))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ false ifTrue: [ 1 ]",nil)
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo ^ true ifTrue: [ 2 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifTrue",{})});
}; }),
$globals.AbstractCompilerTest);

$core.addMethod(
$core.method({
selector: "testifTrueIfFalse",
protocol: "tests",
args: [],
source: "testifTrueIfFalse\x0a\x09self should: 'foo false ifTrue: [ ^ 1 ] ifFalse: [ ^2 ]' return: 2.\x0a\x09self should: 'foo true ifTrue: [ ^ 1 ] ifFalse: [ ^ 2 ]' return: 1.\x0a\x09\x0a\x09self should: 'foo ^ false ifTrue: [ 2 ] ifFalse: [ 1 ]' return: 1.\x0a\x09self should: 'foo ^ true ifTrue: [ 2 ] ifFalse: [ 1 ]' return: 2.",
referencedClasses: [],
pragmas: [],
messageSends: ["should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_return_("foo false ifTrue: [ ^ 1 ] ifFalse: [ ^2 ]",(2))
,$ctx1.sendIdx["should:return:"]=1
][0];
[$self._should_return_("foo true ifTrue: [ ^ 1 ] ifFalse: [ ^ 2 ]",(1))
,$ctx1.sendIdx["should:return:"]=2
][0];
[$self._should_return_("foo ^ false ifTrue: [ 2 ] ifFalse: [ 1 ]",(1))
,$ctx1.sendIdx["should:return:"]=3
][0];
$self._should_return_("foo ^ true ifTrue: [ 2 ] ifFalse: [ 1 ]",(2));
return self;
}, function($ctx1) {$ctx1.fill(self,"testifTrueIfFalse",{})});
}; }),
$globals.AbstractCompilerTest);


$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: "testing",
args: [],
source: "isAbstract\x0a\x09^ self name = AbstractCompilerTest name",
referencedClasses: ["AbstractCompilerTest"],
pragmas: [],
messageSends: ["=", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$self._name()
,$ctx1.sendIdx["name"]=1
][0]).__eq($recv($globals.AbstractCompilerTest)._name());
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{})});
}; }),
$globals.AbstractCompilerTest.a$cls);


$core.addClass("ASTDebuggerTest", $globals.AbstractCompilerTest, "Compiler-Tests");


$core.addClass("ASTInterpreterTest", $globals.AbstractCompilerTest, "Compiler-Tests");


$core.addClass("CodeGeneratorTest", $globals.AbstractCompilerTest, "Compiler-Tests");


$core.addClass("InliningCodeGeneratorTest", $globals.AbstractCompilerTest, "Compiler-Tests");


$core.addClass("AbstractJavaScriptGatewayTest", $globals.ASTMethodRunningTest, "Compiler-Tests");
$core.setSlots($globals.AbstractJavaScriptGatewayTest, ["theClass"]);
$core.addMethod(
$core.method({
selector: "jsConstructor",
protocol: "running",
args: [],
source: "jsConstructor\x0a\x09<inlineJS: '\x0a\x09\x09var ctr = function () {};\x0a\x09\x09ctr.prototype.foo = function (a,b) {return a+\x22,\x22+b};\x0a\x09\x09return ctr;\x0a\x09'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["\x0a\x09\x09var ctr = function () {};\x0a\x09\x09ctr.prototype.foo = function (a,b) {return a+\x22,\x22+b};\x0a\x09\x09return ctr;\x0a\x09"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {

		var ctr = function () {};
		ctr.prototype.foo = function (a,b) {return a+","+b};
		return ctr;
	;
return self;
}, function($ctx1) {$ctx1.fill(self,"jsConstructor",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testDyadicSuperDifferentNames",
protocol: "tests",
args: [],
source: "testDyadicSuperDifferentNames\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09receiver := ObjectMock2 new foo: 'should be shadowed'; yourself.\x0a\x09arguments := #(4 true).\x0a\x09self\x0a\x09\x09should: 'bar: anObject baz: anotherObject\x0a\x09\x09\x09<jsOverride: #foo args: #(anObject anotherObject)>\x0a\x09\x09\x09^ super bar: anObject baz: anotherObject'\x0a\x09\x09return: '4,true'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "foo:", "new", "yourself", "should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self.receiver=$recv($1)._yourself();
$self.arguments=[(4), true];
$self._should_return_("bar: anObject baz: anotherObject\x0a\x09\x09\x09<jsOverride: #foo args: #(anObject anotherObject)>\x0a\x09\x09\x09^ super bar: anObject baz: anotherObject","4,true");
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicSuperDifferentNames",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testDyadicSuperDifferentNamesNested",
protocol: "tests",
args: [],
source: "testDyadicSuperDifferentNamesNested\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09receiver := ObjectMock2 new foo: 'should be shadowed'; yourself.\x0a\x09arguments := #(4 true).\x0a\x09self\x0a\x09\x09should: 'bar: anObject baz: anotherObject\x0a\x09\x09\x09<jsOverride: #foo args: #(anObject anotherObject)>\x0a\x09\x09\x09^ [ super bar: anObject baz: anotherObject ] value'\x0a\x09\x09return: '4,true'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "foo:", "new", "yourself", "should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self.receiver=$recv($1)._yourself();
$self.arguments=[(4), true];
$self._should_return_("bar: anObject baz: anotherObject\x0a\x09\x09\x09<jsOverride: #foo args: #(anObject anotherObject)>\x0a\x09\x09\x09^ [ super bar: anObject baz: anotherObject ] value","4,true");
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicSuperDifferentNamesNested",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testDyadicSuperDifferentNamesPermutated",
protocol: "tests",
args: [],
source: "testDyadicSuperDifferentNamesPermutated\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09receiver := ObjectMock2 new foo: 'should be shadowed'; yourself.\x0a\x09arguments := #(4 true).\x0a\x09self\x0a\x09\x09should: 'bar: anObject baz: anotherObject\x0a\x09\x09\x09<jsOverride: #foo args: #(anotherObject anObject)>\x0a\x09\x09\x09^ super bar: anObject baz: anotherObject'\x0a\x09\x09return: 'true,4'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "foo:", "new", "yourself", "should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self.receiver=$recv($1)._yourself();
$self.arguments=[(4), true];
$self._should_return_("bar: anObject baz: anotherObject\x0a\x09\x09\x09<jsOverride: #foo args: #(anotherObject anObject)>\x0a\x09\x09\x09^ super bar: anObject baz: anotherObject","true,4");
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicSuperDifferentNamesPermutated",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testMonadicSuperDifferentNames",
protocol: "tests",
args: [],
source: "testMonadicSuperDifferentNames\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09receiver := ObjectMock2 new foo: 'should be shadowed'; yourself.\x0a\x09arguments := #(4).\x0a\x09self\x0a\x09\x09should: 'bar: anObject <jsOverride: #foo args: #(anObject)> ^ super bar: anObject'\x0a\x09\x09return: '4,undefined'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "foo:", "new", "yourself", "should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self.receiver=$recv($1)._yourself();
$self.arguments=[(4)];
$self._should_return_("bar: anObject <jsOverride: #foo args: #(anObject)> ^ super bar: anObject","4,undefined");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMonadicSuperDifferentNames",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testNiladicSuper",
protocol: "tests",
args: [],
source: "testNiladicSuper\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09self\x0a\x09\x09should: 'foo <jsOverride: #foo> ^ super foo'\x0a\x09\x09receiver: (ObjectMock2 new foo: 'should be shadowed'; yourself)\x0a\x09\x09return: 'undefined,undefined'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "should:receiver:return:", "foo:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self._should_receiver_return_("foo <jsOverride: #foo> ^ super foo",$recv($1)._yourself(),"undefined,undefined");
return self;
}, function($ctx1) {$ctx1.fill(self,"testNiladicSuper",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testNiladicSuperDifferentNames",
protocol: "tests",
args: [],
source: "testNiladicSuperDifferentNames\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09self\x0a\x09\x09should: 'bar <jsOverride: #foo> ^ super bar'\x0a\x09\x09receiver: (ObjectMock2 new foo: 'should be shadowed'; yourself)\x0a\x09\x09return: 'undefined,undefined'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "should:receiver:return:", "foo:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self._should_receiver_return_("bar <jsOverride: #foo> ^ super bar",$recv($1)._yourself(),"undefined,undefined");
return self;
}, function($ctx1) {$ctx1.fill(self,"testNiladicSuperDifferentNames",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testNiladicSuperNested",
protocol: "tests",
args: [],
source: "testNiladicSuperNested\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09self\x0a\x09\x09should: 'foo <jsOverride: #foo> ^ [ super foo ] value'\x0a\x09\x09receiver: (ObjectMock2 new foo: 'should be shadowed'; yourself)\x0a\x09\x09return: 'undefined,undefined'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "should:receiver:return:", "foo:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self._should_receiver_return_("foo <jsOverride: #foo> ^ [ super foo ] value",$recv($1)._yourself(),"undefined,undefined");
return self;
}, function($ctx1) {$ctx1.fill(self,"testNiladicSuperNested",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "testTriadicSuperDifferentNamesPermutated",
protocol: "tests",
args: [],
source: "testTriadicSuperDifferentNamesPermutated\x0a\x09theClass := ObjectMock subclass: #ObjectMock2 slots: #() package: 'Compiler-Tests'.\x0a\x09theClass beJavaScriptSubclassOf: self jsConstructor.\x0a\x09receiver := ObjectMock2 new foo: 'should be shadowed'; yourself.\x0a\x09arguments := #(4 true 'hello').\x0a\x09self\x0a\x09\x09should: 'bar: anObject baz: anotherObject moo: yao\x0a\x09\x09\x09<jsOverride: #foo args: #(yao anObject anotherObject)>\x0a\x09\x09\x09^ super bar: anObject baz: anotherObject moo: yao'\x0a\x09\x09return: 'hello,4'",
referencedClasses: ["ObjectMock", "ObjectMock2"],
pragmas: [],
messageSends: ["subclass:slots:package:", "beJavaScriptSubclassOf:", "jsConstructor", "foo:", "new", "yourself", "should:return:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self.theClass=$recv($globals.ObjectMock)._subclass_slots_package_("ObjectMock2",[],"Compiler-Tests");
$recv($self.theClass)._beJavaScriptSubclassOf_($self._jsConstructor());
$1=$recv($globals.ObjectMock2)._new();
$recv($1)._foo_("should be shadowed");
$self.receiver=$recv($1)._yourself();
$self.arguments=[(4), true, "hello"];
$self._should_return_("bar: anObject baz: anotherObject moo: yao\x0a\x09\x09\x09<jsOverride: #foo args: #(yao anObject anotherObject)>\x0a\x09\x09\x09^ super bar: anObject baz: anotherObject moo: yao","hello,4");
return self;
}, function($ctx1) {$ctx1.fill(self,"testTriadicSuperDifferentNamesPermutated",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest);

$core.addMethod(
$core.method({
selector: "theClass",
protocol: "accessing",
args: [],
source: "theClass\x0a\x09^ theClass",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.theClass;

}; }),
$globals.AbstractJavaScriptGatewayTest);


$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: "testing",
args: [],
source: "isAbstract\x0a\x09^ self name = AbstractJavaScriptGatewayTest name",
referencedClasses: ["AbstractJavaScriptGatewayTest"],
pragmas: [],
messageSends: ["=", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$self._name()
,$ctx1.sendIdx["name"]=1
][0]).__eq($recv($globals.AbstractJavaScriptGatewayTest)._name());
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{})});
}; }),
$globals.AbstractJavaScriptGatewayTest.a$cls);


$core.addClass("DebuggedJSGTest", $globals.AbstractJavaScriptGatewayTest, "Compiler-Tests");


$core.addClass("InlinedJSGTest", $globals.AbstractJavaScriptGatewayTest, "Compiler-Tests");


$core.addClass("InterpretedJSGTest", $globals.AbstractJavaScriptGatewayTest, "Compiler-Tests");


$core.addClass("PlainJSGTest", $globals.AbstractJavaScriptGatewayTest, "Compiler-Tests");


$core.addClass("ASTPCNodeVisitorTest", $globals.TestCase, "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "astPCNodeVisitor",
protocol: "factory",
args: [],
source: "astPCNodeVisitor\x0a\x09^ ASTPCNodeVisitor new\x0a\x09\x09index: 0;\x0a\x09\x09yourself",
referencedClasses: ["ASTPCNodeVisitor"],
pragmas: [],
messageSends: ["index:", "new", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ASTPCNodeVisitor)._new();
$recv($1)._index_((0));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"astPCNodeVisitor",{})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "astPCNodeVisitorForSelector:",
protocol: "factory",
args: ["aString"],
source: "astPCNodeVisitorForSelector: aString\x0a\x09^ ASTPCNodeVisitor new\x0a\x09\x09selector: aString;\x0a\x09\x09index: 0;\x0a\x09\x09yourself",
referencedClasses: ["ASTPCNodeVisitor"],
pragmas: [],
messageSends: ["selector:", "new", "index:", "yourself"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.ASTPCNodeVisitor)._new();
$recv($1)._selector_(aString);
$recv($1)._index_((0));
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"astPCNodeVisitorForSelector:",{aString:aString})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "newTeachableVisitor",
protocol: "factory",
args: [],
source: "newTeachableVisitor\x0a\x09| result |\x0a\x09result := Teachable new\x0a\x09\x09whenSend: #visit: evaluate: [ :one | one acceptDagVisitor: result ];\x0a\x09\x09acceptSend: #visitDagNode:.\x0a\x09^ result",
referencedClasses: ["Teachable"],
pragmas: [],
messageSends: ["whenSend:evaluate:", "new", "acceptDagVisitor:", "acceptSend:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Teachable)._new();
$recv($1)._whenSend_evaluate_("visit:",(function(one){
return $core.withContext(function($ctx2) {
return $recv(one)._acceptDagVisitor_(result);
}, function($ctx2) {$ctx2.fillBlock({one:one},$ctx1,1)});
}));
result=$recv($1)._acceptSend_("visitDagNode:");
return result;
}, function($ctx1) {$ctx1.fill(self,"newTeachableVisitor",{result:result})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testJSStatementNode",
protocol: "tests",
args: [],
source: "testJSStatementNode\x0a\x09| ast result |\x0a\x09\x0a\x09ast := self parse: 'foo <inlineJS: ''consolee.log(1)''>' forClass: Object.\x0a\x09result := self astPCNodeVisitor visit: ast; currentNode.\x0a\x09self\x0a\x09\x09assert: ((self newTeachableVisitor whenSend: #visitJSStatementNode: return: 'JS'; yourself) visit: result)\x0a\x09\x09equals: 'JS'",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["parse:forClass:", "visit:", "astPCNodeVisitor", "currentNode", "assert:equals:", "whenSend:return:", "newTeachableVisitor", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var ast,result;
return $core.withContext(function($ctx1) {
var $1,$2;
ast=$self._parse_forClass_("foo <inlineJS: 'consolee.log(1)'>",$globals.Object);
$1=$self._astPCNodeVisitor();
[$recv($1)._visit_(ast)
,$ctx1.sendIdx["visit:"]=1
][0];
result=$recv($1)._currentNode();
$2=$self._newTeachableVisitor();
$recv($2)._whenSend_return_("visitJSStatementNode:","JS");
$self._assert_equals_($recv($recv($2)._yourself())._visit_(result),"JS");
return self;
}, function($ctx1) {$ctx1.fill(self,"testJSStatementNode",{ast:ast,result:result})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testMessageSend",
protocol: "tests",
args: [],
source: "testMessageSend\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo self asString yourself. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'yourself')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'yourself'",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["parse:forClass:", "assert:equals:", "selector", "visit:", "astPCNodeVisitorForSelector:", "currentNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var ast;
return $core.withContext(function($ctx1) {
var $1;
ast=$self._parse_forClass_("foo self asString yourself. ^ self asBoolean",$globals.Object);
$1=$self._astPCNodeVisitorForSelector_("yourself");
$recv($1)._visit_(ast);
$self._assert_equals_($recv($recv($1)._currentNode())._selector(),"yourself");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSend",{ast:ast})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testMessageSendWithBlocks",
protocol: "tests",
args: [],
source: "testMessageSendWithBlocks\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo true ifTrue: [ [ self asString yourself ] value.  ]. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'yourself')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'yourself'",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["parse:forClass:", "assert:equals:", "selector", "visit:", "astPCNodeVisitorForSelector:", "currentNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var ast;
return $core.withContext(function($ctx1) {
var $1;
ast=$self._parse_forClass_("foo true ifTrue: [ [ self asString yourself ] value.  ]. ^ self asBoolean",$globals.Object);
$1=$self._astPCNodeVisitorForSelector_("yourself");
$recv($1)._visit_(ast);
$self._assert_equals_($recv($recv($1)._currentNode())._selector(),"yourself");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSendWithBlocks",{ast:ast})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testMessageSendWithInlining",
protocol: "tests",
args: [],
source: "testMessageSendWithInlining\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo true ifTrue: [ self asString yourself ]. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'yourself')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'yourself'.\x0a\x09\x09\x0a\x09ast := self parse: 'foo true ifTrue: [ self asString yourself ]. ^ self asBoolean' forClass: Object.\x0a\x09self assert: ((self astPCNodeVisitorForSelector: 'asBoolean')\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) selector equals: 'asBoolean'",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["parse:forClass:", "assert:equals:", "selector", "visit:", "astPCNodeVisitorForSelector:", "currentNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var ast;
return $core.withContext(function($ctx1) {
var $1,$2;
ast=[$self._parse_forClass_("foo true ifTrue: [ self asString yourself ]. ^ self asBoolean",$globals.Object)
,$ctx1.sendIdx["parse:forClass:"]=1
][0];
$1=[$self._astPCNodeVisitorForSelector_("yourself")
,$ctx1.sendIdx["astPCNodeVisitorForSelector:"]=1
][0];
[$recv($1)._visit_(ast)
,$ctx1.sendIdx["visit:"]=1
][0];
[$self._assert_equals_([$recv([$recv($1)._currentNode()
,$ctx1.sendIdx["currentNode"]=1
][0])._selector()
,$ctx1.sendIdx["selector"]=1
][0],"yourself")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
ast=$self._parse_forClass_("foo true ifTrue: [ self asString yourself ]. ^ self asBoolean",$globals.Object);
$2=$self._astPCNodeVisitorForSelector_("asBoolean");
$recv($2)._visit_(ast);
$self._assert_equals_($recv($recv($2)._currentNode())._selector(),"asBoolean");
return self;
}, function($ctx1) {$ctx1.fill(self,"testMessageSendWithInlining",{ast:ast})});
}; }),
$globals.ASTPCNodeVisitorTest);

$core.addMethod(
$core.method({
selector: "testNoMessageSend",
protocol: "tests",
args: [],
source: "testNoMessageSend\x0a\x09| ast |\x0a\x09\x0a\x09ast := self parse: 'foo ^ self' forClass: Object.\x0a\x09self assert: (self astPCNodeVisitor\x0a\x09\x09visit: ast;\x0a\x09\x09currentNode) isNil",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["parse:forClass:", "assert:", "isNil", "visit:", "astPCNodeVisitor", "currentNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var ast;
return $core.withContext(function($ctx1) {
var $1;
ast=$self._parse_forClass_("foo ^ self",$globals.Object);
$1=$self._astPCNodeVisitor();
$recv($1)._visit_(ast);
$self._assert_($recv($recv($1)._currentNode())._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNoMessageSend",{ast:ast})});
}; }),
$globals.ASTPCNodeVisitorTest);



$core.addClass("ASTPositionTest", $globals.TestCase, "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "testNodeAtPosition",
protocol: "tests",
args: [],
source: "testNodeAtPosition\x0a\x09| node |\x0a\x09\x0a\x09node := self parse: 'yourself\x0a\x09^ self' forClass: Object.\x0a\x09\x0a\x09self assert: (node navigationNodeAt: 2@4 ifAbsent: [ nil ]) source equals: 'self'.\x0a\x09\x0a\x09node := self parse: 'foo\x0a\x09true ifTrue: [ 1 ]' forClass: Object.\x0a\x09\x0a\x09self assert: (node navigationNodeAt: 2@7 ifAbsent: [ nil ]) selector equals: 'ifTrue:'.\x0a\x09\x0a\x09node := self parse: 'foo\x0a\x09self foo; bar; baz' forClass: Object.\x0a\x09\x0a\x09self assert: (node navigationNodeAt: 2@8 ifAbsent: [ nil ]) selector equals: 'foo'",
referencedClasses: ["Object"],
pragmas: [],
messageSends: ["parse:forClass:", "assert:equals:", "source", "navigationNodeAt:ifAbsent:", "@", "selector"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var node;
return $core.withContext(function($ctx1) {
node=[$self._parse_forClass_("yourself\x0a\x09^ self",$globals.Object)
,$ctx1.sendIdx["parse:forClass:"]=1
][0];
[$self._assert_equals_($recv([$recv(node)._navigationNodeAt_ifAbsent_([(2).__at((4))
,$ctx1.sendIdx["@"]=1
][0],(function(){
return nil;

}))
,$ctx1.sendIdx["navigationNodeAt:ifAbsent:"]=1
][0])._source(),"self")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
node=[$self._parse_forClass_("foo\x0a\x09true ifTrue: [ 1 ]",$globals.Object)
,$ctx1.sendIdx["parse:forClass:"]=2
][0];
[$self._assert_equals_([$recv([$recv(node)._navigationNodeAt_ifAbsent_([(2).__at((7))
,$ctx1.sendIdx["@"]=2
][0],(function(){
return nil;

}))
,$ctx1.sendIdx["navigationNodeAt:ifAbsent:"]=2
][0])._selector()
,$ctx1.sendIdx["selector"]=1
][0],"ifTrue:")
,$ctx1.sendIdx["assert:equals:"]=2
][0];
node=$self._parse_forClass_("foo\x0a\x09self foo; bar; baz",$globals.Object);
$self._assert_equals_($recv($recv(node)._navigationNodeAt_ifAbsent_((2).__at((8)),(function(){
return nil;

})))._selector(),"foo");
return self;
}, function($ctx1) {$ctx1.fill(self,"testNodeAtPosition",{node:node})});
}; }),
$globals.ASTPositionTest);



$core.addClass("AbstractCodeGeneratorInstallTest", $globals.TestCase, "Compiler-Tests");
$core.setSlots($globals.AbstractCodeGeneratorInstallTest, ["receiver"]);
$core.addMethod(
$core.method({
selector: "receiver",
protocol: "accessing",
args: [],
source: "receiver\x0a\x09^ receiver",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.receiver;

}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "shouldntInstall:andRaise:",
protocol: "testing",
args: ["aString", "anErrorClass"],
source: "shouldntInstall: aString andRaise: anErrorClass\x0a\x09| method |\x0a\x0a\x09[ self\x0a\x09\x09should: [ method := self install: aString forClass: receiver class ]\x0a\x09\x09raise: anErrorClass ]\x0a\x09ensure: [ method ifNotNil: [ receiver class removeCompiledMethod: method ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ensure:", "should:raise:", "install:forClass:", "class", "ifNotNil:", "removeCompiledMethod:"]
}, function ($methodClass){ return function (aString,anErrorClass){
var self=this,$self=this;
var method;
return $core.withContext(function($ctx1) {
var $1;
$recv((function(){
return $core.withContext(function($ctx2) {
return $self._should_raise_((function(){
return $core.withContext(function($ctx3) {
method=$self._install_forClass_(aString,[$recv($self.receiver)._class()
,$ctx3.sendIdx["class"]=1
][0]);
return method;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),anErrorClass);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
$1=method;
if($1 == null || $1.a$nil){
return $1;
} else {
return $recv($recv($self.receiver)._class())._removeCompiledMethod_(method);
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"shouldntInstall:andRaise:",{aString:aString,anErrorClass:anErrorClass,method:method})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testDyadicJSOverrideArgMismatch",
protocol: "tests",
args: [],
source: "testDyadicJSOverrideArgMismatch\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: aNumber foo: anotherNumber\x0a\x09\x09<jsOverride: #mux args: #(anInteger anotherNumber)>\x0a\x09\x09^ (foo := foo * aNumber + anotherNumber)'\x0a\x09\x09andRaise: CompilerError.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: aNumber foo: anotherNumber\x0a\x09\x09<jsOverride: #mux args: #(aNumber anotherInteger)>\x0a\x09\x09^ (foo := foo * aNumber + anotherNumber)'\x0a\x09\x09andRaise: CompilerError.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: aNumber foo: anotherNumber\x0a\x09\x09<jsOverride: #mux args: #(anotherNumber anInteger)>\x0a\x09\x09^ (foo := foo * aNumber + anotherNumber)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
[$self._shouldntInstall_andRaise_("quux: aNumber foo: anotherNumber\x0a\x09\x09<jsOverride: #mux args: #(anInteger anotherNumber)>\x0a\x09\x09^ (foo := foo * aNumber + anotherNumber)",$globals.CompilerError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=1
][0];
[$self._shouldntInstall_andRaise_("quux: aNumber foo: anotherNumber\x0a\x09\x09<jsOverride: #mux args: #(aNumber anotherInteger)>\x0a\x09\x09^ (foo := foo * aNumber + anotherNumber)",$globals.CompilerError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=2
][0];
$self._shouldntInstall_andRaise_("quux: aNumber foo: anotherNumber\x0a\x09\x09<jsOverride: #mux args: #(anotherNumber anInteger)>\x0a\x09\x09^ (foo := foo * aNumber + anotherNumber)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicJSOverrideArgMismatch",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testDyadicJSOverrideDifferentNames",
protocol: "tests",
args: [],
source: "testDyadicJSOverrideDifferentNames\x0a\x09receiver := ObjectMock new.\x0a\x09receiver foo: 4.\x0a\x09self while: 'quux: anInteger foo: anotherInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anotherInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger)' should: [\x0a\x09\x09self should: [ receiver mux ] raise: MessageNotUnderstood.\x0a\x09\x09self should: [ receiver mux: 2 and: -1 ] raise: MessageNotUnderstood.\x0a\x09\x09self assert: (receiver basicPerform: #mux withArguments: #(2 -2)) equals: 6.\x0a\x09\x09self assert: (receiver quux: 1 foo: 4) equals: 10.\x0a\x09\x09self should: [ receiver basicPerform: #quux ] raise: Error.\x0a\x09\x09self assert: receiver foo equals: 10 ]",
referencedClasses: ["ObjectMock", "MessageNotUnderstood", "Error"],
pragmas: [],
messageSends: ["new", "foo:", "while:should:", "should:raise:", "mux", "mux:and:", "assert:equals:", "basicPerform:withArguments:", "quux:foo:", "basicPerform:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$recv($self.receiver)._foo_((4));
$self._while_should_("quux: anInteger foo: anotherInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anotherInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger)",(function(){
return $core.withContext(function($ctx2) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=1
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux_and_((2),(-1));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=2
][0];
[$self._assert_equals_($recv($self.receiver)._basicPerform_withArguments_("mux",[(2), (-2)]),(6))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.receiver)._quux_foo_((1),(4)),(10))
,$ctx2.sendIdx["assert:equals:"]=2
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._basicPerform_("quux");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}),$globals.Error);
return $self._assert_equals_($recv($self.receiver)._foo(),(10));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicJSOverrideDifferentNames",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testDyadicJSOverrideDifferentNamesPermutated",
protocol: "tests",
args: [],
source: "testDyadicJSOverrideDifferentNamesPermutated\x0a\x09receiver := ObjectMock new.\x0a\x09receiver foo: 4.\x0a\x09self while: 'quux: anInteger foo: anotherInteger\x0a\x09\x09<jsOverride: #mux args: #(anotherInteger anInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger)' should: [\x0a\x09\x09self should: [ receiver mux ] raise: MessageNotUnderstood.\x0a\x09\x09self should: [ receiver mux: 2 and: -1 ] raise: MessageNotUnderstood.\x0a\x09\x09self assert: (receiver basicPerform: #mux withArguments: #(-2 2)) equals: 6.\x0a\x09\x09self assert: (receiver quux: 1 foo: 4) equals: 10.\x0a\x09\x09self should: [ receiver basicPerform: #quux ] raise: Error.\x0a\x09\x09self assert: receiver foo equals: 10 ]",
referencedClasses: ["ObjectMock", "MessageNotUnderstood", "Error"],
pragmas: [],
messageSends: ["new", "foo:", "while:should:", "should:raise:", "mux", "mux:and:", "assert:equals:", "basicPerform:withArguments:", "quux:foo:", "basicPerform:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$recv($self.receiver)._foo_((4));
$self._while_should_("quux: anInteger foo: anotherInteger\x0a\x09\x09<jsOverride: #mux args: #(anotherInteger anInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger)",(function(){
return $core.withContext(function($ctx2) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=1
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux_and_((2),(-1));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=2
][0];
[$self._assert_equals_($recv($self.receiver)._basicPerform_withArguments_("mux",[(-2), (2)]),(6))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.receiver)._quux_foo_((1),(4)),(10))
,$ctx2.sendIdx["assert:equals:"]=2
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._basicPerform_("quux");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}),$globals.Error);
return $self._assert_equals_($recv($self.receiver)._foo(),(10));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicJSOverrideDifferentNamesPermutated",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testDyadicJSOverrideInOneArg",
protocol: "tests",
args: [],
source: "testDyadicJSOverrideInOneArg\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: anInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anotherInteger)>\x0a\x09\x09^ (foo := foo + anInteger)'\x0a\x09\x09andRaise: CompilerError.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: anInteger\x0a\x09\x09<jsOverride: #mux args: #(anotherInteger anInteger)>\x0a\x09\x09^ (foo := foo + anInteger)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
[$self._shouldntInstall_andRaise_("quux: anInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anotherInteger)>\x0a\x09\x09^ (foo := foo + anInteger)",$globals.CompilerError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=1
][0];
$self._shouldntInstall_andRaise_("quux: anInteger\x0a\x09\x09<jsOverride: #mux args: #(anotherInteger anInteger)>\x0a\x09\x09^ (foo := foo + anInteger)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicJSOverrideInOneArg",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testDyadicJSOverrideInUnary",
protocol: "tests",
args: [],
source: "testDyadicJSOverrideInUnary\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux <jsOverride: #mux args: #(anInteger anotherInteger)> ^ (foo := foo + 3)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$self._shouldntInstall_andRaise_("quux <jsOverride: #mux args: #(anInteger anotherInteger)> ^ (foo := foo + 3)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicJSOverrideInUnary",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testDyadicJSOverrideRepeatedArgs",
protocol: "tests",
args: [],
source: "testDyadicJSOverrideRepeatedArgs\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: anInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anInteger)>\x0a\x09\x09^ (foo := foo + anInteger)'\x0a\x09\x09andRaise: CompilerError.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: anInteger foo: anotherInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
[$self._shouldntInstall_andRaise_("quux: anInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anInteger)>\x0a\x09\x09^ (foo := foo + anInteger)",$globals.CompilerError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=1
][0];
$self._shouldntInstall_andRaise_("quux: anInteger foo: anotherInteger\x0a\x09\x09<jsOverride: #mux args: #(anInteger anInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testDyadicJSOverrideRepeatedArgs",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testInvalidAssignment",
protocol: "tests",
args: [],
source: "testInvalidAssignment\x0a\x09self shouldntInstall: 'foo:a a:=1' andRaise: InvalidAssignmentError.\x0a\x09self shouldntInstall: 'foo false:=1' andRaise: InvalidAssignmentError.\x0a\x09self shouldntInstall: 'foo console:=1' andRaise: InvalidAssignmentError.\x0a\x09self shouldntInstall: 'foo Number:=1' andRaise: InvalidAssignmentError",
referencedClasses: ["InvalidAssignmentError"],
pragmas: [],
messageSends: ["shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._shouldntInstall_andRaise_("foo:a a:=1",$globals.InvalidAssignmentError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=1
][0];
[$self._shouldntInstall_andRaise_("foo false:=1",$globals.InvalidAssignmentError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=2
][0];
[$self._shouldntInstall_andRaise_("foo console:=1",$globals.InvalidAssignmentError)
,$ctx1.sendIdx["shouldntInstall:andRaise:"]=3
][0];
$self._shouldntInstall_andRaise_("foo Number:=1",$globals.InvalidAssignmentError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testInvalidAssignment",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testMistypedPragmaJSStatement",
protocol: "tests",
args: [],
source: "testMistypedPragmaJSStatement\x0a\x09self shouldntInstall: 'foo < inlineJS: ''return ''foo'''' >' andRaise: ParseError",
referencedClasses: ["ParseError"],
pragmas: [],
messageSends: ["shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldntInstall_andRaise_("foo < inlineJS: 'return 'foo'' >",$globals.ParseError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMistypedPragmaJSStatement",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testMonadicJSOverrideArgMismatch",
protocol: "tests",
args: [],
source: "testMonadicJSOverrideArgMismatch\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: aNumber <jsOverride: #mux args: #(anInteger)> ^ (foo := foo + aNumber)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$self._shouldntInstall_andRaise_("quux: aNumber <jsOverride: #mux args: #(anInteger)> ^ (foo := foo + aNumber)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMonadicJSOverrideArgMismatch",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testMonadicJSOverrideDifferentNames",
protocol: "tests",
args: [],
source: "testMonadicJSOverrideDifferentNames\x0a\x09receiver := ObjectMock new.\x0a\x09receiver foo: 4.\x0a\x09self while: 'quux: anInteger <jsOverride: #mux args: #(anInteger)> ^ (foo := foo + anInteger)' should: [\x0a\x09\x09self should: [ receiver mux ] raise: MessageNotUnderstood.\x0a\x09\x09self should: [ receiver mux: 2 ] raise: MessageNotUnderstood.\x0a\x09\x09self assert: (receiver basicPerform: #mux withArguments: #(2)) equals: 6.\x0a\x09\x09self assert: (receiver quux: 4) equals: 10.\x0a\x09\x09self should: [ receiver basicPerform: #quux ] raise: Error.\x0a\x09\x09self assert: receiver foo equals: 10 ]",
referencedClasses: ["ObjectMock", "MessageNotUnderstood", "Error"],
pragmas: [],
messageSends: ["new", "foo:", "while:should:", "should:raise:", "mux", "mux:", "assert:equals:", "basicPerform:withArguments:", "quux:", "basicPerform:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$recv($self.receiver)._foo_((4));
$self._while_should_("quux: anInteger <jsOverride: #mux args: #(anInteger)> ^ (foo := foo + anInteger)",(function(){
return $core.withContext(function($ctx2) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=1
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux_((2));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=2
][0];
[$self._assert_equals_($recv($self.receiver)._basicPerform_withArguments_("mux",[(2)]),(6))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.receiver)._quux_((4)),(10))
,$ctx2.sendIdx["assert:equals:"]=2
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._basicPerform_("quux");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}),$globals.Error);
return $self._assert_equals_($recv($self.receiver)._foo(),(10));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testMonadicJSOverrideDifferentNames",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testMonadicJSOverrideInUnary",
protocol: "tests",
args: [],
source: "testMonadicJSOverrideInUnary\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux <jsOverride: #mux args: #(anInteger)> ^ (foo := foo + 3)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$self._shouldntInstall_andRaise_("quux <jsOverride: #mux args: #(anInteger)> ^ (foo := foo + 3)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testMonadicJSOverrideInUnary",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testNiladicJSOverride",
protocol: "tests",
args: [],
source: "testNiladicJSOverride\x0a\x09receiver := ObjectMock new.\x0a\x09receiver foo: 4.\x0a\x09self while: 'baz <jsOverride: #baz> ^ (foo := foo + 3)' should: [\x0a\x09\x09self assert: receiver baz equals: 7.\x0a\x09\x09self assert: (receiver basicPerform: #baz) equals: 10.\x0a\x09\x09self assert: receiver baz equals: 13.\x0a\x09\x09self assert: receiver foo equals: 13 ]",
referencedClasses: ["ObjectMock"],
pragmas: [],
messageSends: ["new", "foo:", "while:should:", "assert:equals:", "baz", "basicPerform:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$recv($self.receiver)._foo_((4));
$self._while_should_("baz <jsOverride: #baz> ^ (foo := foo + 3)",(function(){
return $core.withContext(function($ctx2) {
[$self._assert_equals_([$recv($self.receiver)._baz()
,$ctx2.sendIdx["baz"]=1
][0],(7))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.receiver)._basicPerform_("baz"),(10))
,$ctx2.sendIdx["assert:equals:"]=2
][0];
[$self._assert_equals_($recv($self.receiver)._baz(),(13))
,$ctx2.sendIdx["assert:equals:"]=3
][0];
return $self._assert_equals_($recv($self.receiver)._foo(),(13));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNiladicJSOverride",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testNiladicJSOverrideDifferentNames",
protocol: "tests",
args: [],
source: "testNiladicJSOverrideDifferentNames\x0a\x09receiver := ObjectMock new.\x0a\x09receiver foo: 4.\x0a\x09self while: 'quux <jsOverride: #mux> ^ (foo := foo + 3)' should: [\x0a\x09\x09self should: [ receiver mux ] raise: MessageNotUnderstood.\x0a\x09\x09self assert: (receiver basicPerform: #mux) equals: 7.\x0a\x09\x09self assert: receiver quux equals: 10.\x0a\x09\x09self should: [ receiver basicPerform: #quux ] raise: Error.\x0a\x09\x09self assert: receiver foo equals: 10 ]",
referencedClasses: ["ObjectMock", "MessageNotUnderstood", "Error"],
pragmas: [],
messageSends: ["new", "foo:", "while:should:", "should:raise:", "mux", "assert:equals:", "basicPerform:", "quux", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$recv($self.receiver)._foo_((4));
$self._while_should_("quux <jsOverride: #mux> ^ (foo := foo + 3)",(function(){
return $core.withContext(function($ctx2) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=1
][0];
[$self._assert_equals_([$recv($self.receiver)._basicPerform_("mux")
,$ctx2.sendIdx["basicPerform:"]=1
][0],(7))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.receiver)._quux(),(10))
,$ctx2.sendIdx["assert:equals:"]=2
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._basicPerform_("quux");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}),$globals.Error);
return $self._assert_equals_($recv($self.receiver)._foo(),(10));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testNiladicJSOverrideDifferentNames",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testNiladicJSOverrideInOneArg",
protocol: "tests",
args: [],
source: "testNiladicJSOverrideInOneArg\x0a\x09receiver := ObjectMock new.\x0a\x09self\x0a\x09\x09shouldntInstall: 'quux: anInteger <jsOverride: #mux> ^ (foo := foo + anInteger)'\x0a\x09\x09andRaise: CompilerError",
referencedClasses: ["ObjectMock", "CompilerError"],
pragmas: [],
messageSends: ["new", "shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$self._shouldntInstall_andRaise_("quux: anInteger <jsOverride: #mux> ^ (foo := foo + anInteger)",$globals.CompilerError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testNiladicJSOverrideInOneArg",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testPragmaInBlock",
protocol: "tests",
args: [],
source: "testPragmaInBlock\x0a\x09self shouldntInstall: 'foo ^ [ < fooBar > 4 ] value' andRaise: ParseError",
referencedClasses: ["ParseError"],
pragmas: [],
messageSends: ["shouldntInstall:andRaise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._shouldntInstall_andRaise_("foo ^ [ < fooBar > 4 ] value",$globals.ParseError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testPragmaInBlock",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);

$core.addMethod(
$core.method({
selector: "testTriadicJSOverrideDifferentNamesPermutated",
protocol: "tests",
args: [],
source: "testTriadicJSOverrideDifferentNamesPermutated\x0a\x09receiver := ObjectMock new.\x0a\x09receiver foo: 4.\x0a\x09self while: 'quux: anInteger foo: anotherInteger bar: yaInt\x0a\x09\x09<jsOverride: #mux args: #(yaInt anInteger anotherInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger - yaInt)' should: [\x0a\x09\x09self should: [ receiver mux ] raise: MessageNotUnderstood.\x0a\x09\x09self should: [ receiver mux: 2 and: -1 and: 0 ] raise: MessageNotUnderstood.\x0a\x09\x09self assert: (receiver basicPerform: #mux withArguments: #(5 2 3)) equals: 6.\x0a\x09\x09self assert: (receiver quux: 1 foo: 4 bar: 20) equals: -10.\x0a\x09\x09self should: [ receiver basicPerform: #quux ] raise: Error.\x0a\x09\x09self assert: receiver foo equals: -10 ]",
referencedClasses: ["ObjectMock", "MessageNotUnderstood", "Error"],
pragmas: [],
messageSends: ["new", "foo:", "while:should:", "should:raise:", "mux", "mux:and:and:", "assert:equals:", "basicPerform:withArguments:", "quux:foo:bar:", "basicPerform:", "foo"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.receiver=$recv($globals.ObjectMock)._new();
$recv($self.receiver)._foo_((4));
$self._while_should_("quux: anInteger foo: anotherInteger bar: yaInt\x0a\x09\x09<jsOverride: #mux args: #(yaInt anInteger anotherInteger)>\x0a\x09\x09^ (foo := foo * anInteger + anotherInteger - yaInt)",(function(){
return $core.withContext(function($ctx2) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=1
][0];
[$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._mux_and_and_((2),(-1),(0));
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}),$globals.MessageNotUnderstood)
,$ctx2.sendIdx["should:raise:"]=2
][0];
[$self._assert_equals_($recv($self.receiver)._basicPerform_withArguments_("mux",[(5), (2), (3)]),(6))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_($recv($self.receiver)._quux_foo_bar_((1),(4),(20)),(-10))
,$ctx2.sendIdx["assert:equals:"]=2
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx3) {
return $recv($self.receiver)._basicPerform_("quux");
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,4)});
}),$globals.Error);
return $self._assert_equals_($recv($self.receiver)._foo(),(-10));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTriadicJSOverrideDifferentNamesPermutated",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest);


$core.addMethod(
$core.method({
selector: "isAbstract",
protocol: "testing",
args: [],
source: "isAbstract\x0a\x09^ self name = AbstractCodeGeneratorInstallTest name",
referencedClasses: ["AbstractCodeGeneratorInstallTest"],
pragmas: [],
messageSends: ["=", "name"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$self._name()
,$ctx1.sendIdx["name"]=1
][0]).__eq($recv($globals.AbstractCodeGeneratorInstallTest)._name());
}, function($ctx1) {$ctx1.fill(self,"isAbstract",{})});
}; }),
$globals.AbstractCodeGeneratorInstallTest.a$cls);


$core.addClass("CodeGeneratorInstallTest", $globals.AbstractCodeGeneratorInstallTest, "Compiler-Tests");


$core.addClass("InliningCodeGeneratorInstallTest", $globals.AbstractCodeGeneratorInstallTest, "Compiler-Tests");


$core.addClass("ScopeVarTest", $globals.TestCase, "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "testClassRefVar",
protocol: "tests",
args: [],
source: "testClassRefVar\x0a\x09| node binding |\x0a\x09node := VariableNode new\x0a\x09\x09identifier: 'Object';\x0a\x09\x09yourself.\x0a\x09SemanticAnalyzer new \x0a\x09\x09pushScope: MethodLexicalScope new;\x0a\x09\x09visit: node.\x0a\x09binding := node binding.\x0a\x09self deny: binding isAssignable.\x0a\x09self deny: binding isIdempotent.\x0a\x09self assert: (binding alias includesSubString: 'Object').\x0a\x09self assert: (binding alias ~= 'Object')",
referencedClasses: ["VariableNode", "SemanticAnalyzer", "MethodLexicalScope"],
pragmas: [],
messageSends: ["identifier:", "new", "yourself", "pushScope:", "visit:", "binding", "deny:", "isAssignable", "isIdempotent", "assert:", "includesSubString:", "alias", "~="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var node,binding;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$recv($globals.VariableNode)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._identifier_("Object");
node=$recv($1)._yourself();
$2=[$recv($globals.SemanticAnalyzer)._new()
,$ctx1.sendIdx["new"]=2
][0];
$recv($2)._pushScope_($recv($globals.MethodLexicalScope)._new());
$recv($2)._visit_(node);
binding=$recv(node)._binding();
[$self._deny_($recv(binding)._isAssignable())
,$ctx1.sendIdx["deny:"]=1
][0];
$self._deny_($recv(binding)._isIdempotent());
[$self._assert_($recv([$recv(binding)._alias()
,$ctx1.sendIdx["alias"]=1
][0])._includesSubString_("Object"))
,$ctx1.sendIdx["assert:"]=1
][0];
$self._assert_($recv($recv(binding)._alias()).__tild_eq("Object"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testClassRefVar",{node:node,binding:binding})});
}; }),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testExternallyKnownVar",
protocol: "tests",
args: [],
source: "testExternallyKnownVar\x0a\x09| node binding |\x0a\x09node := VariableNode new\x0a\x09\x09identifier: 'console';\x0a\x09\x09yourself.\x0a\x09SemanticAnalyzer new \x0a\x09\x09pushScope: MethodLexicalScope new;\x0a\x09\x09visit: node.\x0a\x09binding := node binding.\x0a\x09self deny: binding isAssignable.\x0a\x09self deny: binding isIdempotent.\x0a\x09self assert: binding alias equals: 'console'",
referencedClasses: ["VariableNode", "SemanticAnalyzer", "MethodLexicalScope"],
pragmas: [],
messageSends: ["identifier:", "new", "yourself", "pushScope:", "visit:", "binding", "deny:", "isAssignable", "isIdempotent", "assert:equals:", "alias"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var node,binding;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$recv($globals.VariableNode)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._identifier_("console");
node=$recv($1)._yourself();
$2=[$recv($globals.SemanticAnalyzer)._new()
,$ctx1.sendIdx["new"]=2
][0];
$recv($2)._pushScope_($recv($globals.MethodLexicalScope)._new());
$recv($2)._visit_(node);
binding=$recv(node)._binding();
[$self._deny_($recv(binding)._isAssignable())
,$ctx1.sendIdx["deny:"]=1
][0];
$self._deny_($recv(binding)._isIdempotent());
$self._assert_equals_($recv(binding)._alias(),"console");
return self;
}, function($ctx1) {$ctx1.fill(self,"testExternallyKnownVar",{node:node,binding:binding})});
}; }),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testExternallyUnknownVar",
protocol: "tests",
args: [],
source: "testExternallyUnknownVar\x0a\x09| node |\x0a\x09node := VariableNode new\x0a\x09\x09identifier: 'bzzz';\x0a\x09\x09yourself.\x0a\x09self \x0a\x09\x09should: [\x0a\x09\x09\x09SemanticAnalyzer new \x0a\x09\x09\x09pushScope: MethodLexicalScope new;\x0a\x09\x09\x09visit: node ]\x0a\x09\x09raise: UnknownVariableError",
referencedClasses: ["VariableNode", "SemanticAnalyzer", "MethodLexicalScope", "UnknownVariableError"],
pragmas: [],
messageSends: ["identifier:", "new", "yourself", "should:raise:", "pushScope:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var node;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=[$recv($globals.VariableNode)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._identifier_("bzzz");
node=$recv($1)._yourself();
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
$2=[$recv($globals.SemanticAnalyzer)._new()
,$ctx2.sendIdx["new"]=2
][0];
$recv($2)._pushScope_($recv($globals.MethodLexicalScope)._new());
return $recv($2)._visit_(node);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testExternallyUnknownVar",{node:node})});
}; }),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testPseudoVar",
protocol: "tests",
args: [],
source: "testPseudoVar\x0a\x09#('self' 'super' 'true' 'false' 'nil' 'thisContext') do: [ :each |\x0a\x09\x09| binding |\x0a\x09\x09binding := MethodLexicalScope new bindingFor: each.\x0a\x09\x09self deny: binding isAssignable.\x0a\x09\x09self assert: binding isIdempotent ]",
referencedClasses: ["MethodLexicalScope"],
pragmas: [],
messageSends: ["do:", "bindingFor:", "new", "deny:", "isAssignable", "assert:", "isIdempotent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
["self", "super", "true", "false", "nil", "thisContext"]._do_((function(each){
var binding;
return $core.withContext(function($ctx2) {
binding=$recv($recv($globals.MethodLexicalScope)._new())._bindingFor_(each);
$self._deny_($recv(binding)._isAssignable());
return $self._assert_($recv(binding)._isIdempotent());
}, function($ctx2) {$ctx2.fillBlock({each:each,binding:binding},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPseudoVar",{})});
}; }),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testSlotVar",
protocol: "tests",
args: [],
source: "testSlotVar\x0a\x09| binding |\x0a\x09binding := MethodLexicalScope new\x0a\x09\x09addSlotVar: 'bzzz';\x0a\x09\x09bindingFor: 'bzzz'.\x0a\x09self assert: binding isAssignable.\x0a\x09self deny: binding isIdempotent.\x0a\x09self assert: (binding alias includesSubString: 'bzzz').\x0a\x09self assert: (binding alias ~= 'bzzz')",
referencedClasses: ["MethodLexicalScope"],
pragmas: [],
messageSends: ["addSlotVar:", "new", "bindingFor:", "assert:", "isAssignable", "deny:", "isIdempotent", "includesSubString:", "alias", "~="]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var binding;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MethodLexicalScope)._new();
$recv($1)._addSlotVar_("bzzz");
binding=$recv($1)._bindingFor_("bzzz");
[$self._assert_($recv(binding)._isAssignable())
,$ctx1.sendIdx["assert:"]=1
][0];
$self._deny_($recv(binding)._isIdempotent());
[$self._assert_($recv([$recv(binding)._alias()
,$ctx1.sendIdx["alias"]=1
][0])._includesSubString_("bzzz"))
,$ctx1.sendIdx["assert:"]=2
][0];
$self._assert_($recv($recv(binding)._alias()).__tild_eq("bzzz"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testSlotVar",{binding:binding})});
}; }),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testTempVar",
protocol: "tests",
args: [],
source: "testTempVar\x0a\x09| binding |\x0a\x09binding := MethodLexicalScope new\x0a\x09\x09addTemp: 'bzzz';\x0a\x09\x09bindingFor: 'bzzz'.\x0a\x09self assert: binding isAssignable.\x0a\x09self deny: binding isIdempotent.\x0a\x09self assert: binding alias equals: 'bzzz'",
referencedClasses: ["MethodLexicalScope"],
pragmas: [],
messageSends: ["addTemp:", "new", "bindingFor:", "assert:", "isAssignable", "deny:", "isIdempotent", "assert:equals:", "alias"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var binding;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.MethodLexicalScope)._new();
$recv($1)._addTemp_("bzzz");
binding=$recv($1)._bindingFor_("bzzz");
$self._assert_($recv(binding)._isAssignable());
$self._deny_($recv(binding)._isIdempotent());
$self._assert_equals_($recv(binding)._alias(),"bzzz");
return self;
}, function($ctx1) {$ctx1.fill(self,"testTempVar",{binding:binding})});
}; }),
$globals.ScopeVarTest);

$core.addMethod(
$core.method({
selector: "testUnknownVar",
protocol: "tests",
args: [],
source: "testUnknownVar\x0a\x09self assert: (MethodLexicalScope new bindingFor: 'bzzz') isNil",
referencedClasses: ["MethodLexicalScope"],
pragmas: [],
messageSends: ["assert:", "isNil", "bindingFor:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_($recv($recv($recv($globals.MethodLexicalScope)._new())._bindingFor_("bzzz"))._isNil());
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownVar",{})});
}; }),
$globals.ScopeVarTest);



$core.addClass("SemanticAnalyzerTest", $globals.TestCase, "Compiler-Tests");
$core.setSlots($globals.SemanticAnalyzerTest, ["analyzer"]);
$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp\x0a\x09analyzer := SemanticAnalyzer on: Object",
referencedClasses: ["SemanticAnalyzer", "Object"],
pragmas: [],
messageSends: ["on:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.analyzer=$recv($globals.SemanticAnalyzer)._on_($globals.Object);
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testAssignment",
protocol: "tests",
args: [],
source: "testAssignment\x0a\x09| src ast |\x0a\x0a\x09src := 'foo self := 1'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09self should: [analyzer visit: ast] raise: InvalidAssignmentError",
referencedClasses: ["Smalltalk", "InvalidAssignmentError"],
pragmas: [],
messageSends: ["parse:", "should:raise:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo self := 1";
ast=$recv($globals.Smalltalk)._parse_(src);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.analyzer)._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.InvalidAssignmentError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testAssignment",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testNonLocalReturn",
protocol: "tests",
args: [],
source: "testNonLocalReturn\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. ^ a'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self deny: ast scope hasNonLocalReturn",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:", "deny:", "hasNonLocalReturn", "scope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. ^ a";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
$self._deny_($recv($recv(ast)._scope())._hasNonLocalReturn());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonLocalReturn",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testNonLocalReturn2",
protocol: "tests",
args: [],
source: "testNonLocalReturn2\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ [ ^ a] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self assert: ast scope hasNonLocalReturn",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:", "assert:", "hasNonLocalReturn", "scope"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ ^ a] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
$self._assert_($recv($recv(ast)._scope())._hasNonLocalReturn());
return self;
}, function($ctx1) {$ctx1.fill(self,"testNonLocalReturn2",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testScope",
protocol: "tests",
args: [],
source: "testScope\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ | b | b := a ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self deny: ast sequenceNode dagChildren last scope == ast scope.",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:", "deny:", "==", "scope", "last", "dagChildren", "sequenceNode"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ | b | b := a ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
$self._deny_($recv([$recv($recv($recv($recv(ast)._sequenceNode())._dagChildren())._last())._scope()
,$ctx1.sendIdx["scope"]=1
][0]).__eq_eq($recv(ast)._scope()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testScope",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testScope2",
protocol: "tests",
args: [],
source: "testScope2\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ [ | b | b := a ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self deny: ast sequenceNode dagChildren last sequenceNode dagChildren first scope == ast scope.",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:", "deny:", "==", "scope", "first", "dagChildren", "sequenceNode", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ | b | b := a ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
$self._deny_($recv([$recv($recv([$recv([$recv($recv($recv($recv(ast)._sequenceNode())._dagChildren())._last())._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=1
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._first())._scope()
,$ctx1.sendIdx["scope"]=1
][0]).__eq_eq($recv(ast)._scope()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testScope2",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testScopeLevel",
protocol: "tests",
args: [],
source: "testScopeLevel\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ [ | b | b := a ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09self assert: ast scope scopeLevel equals: 1.\x0a\x09self assert: ast sequenceNode dagChildren last sequenceNode dagChildren first scope scopeLevel equals: 3",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:", "assert:equals:", "scopeLevel", "scope", "first", "dagChildren", "sequenceNode", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ | b | b := a ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
[$self._assert_equals_([$recv([$recv(ast)._scope()
,$ctx1.sendIdx["scope"]=1
][0])._scopeLevel()
,$ctx1.sendIdx["scopeLevel"]=1
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($recv($recv($recv([$recv([$recv($recv($recv($recv(ast)._sequenceNode())._dagChildren())._last())._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=1
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._first())._scope())._scopeLevel(),(3));
return self;
}, function($ctx1) {$ctx1.fill(self,"testScopeLevel",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testUnknownVariables",
protocol: "tests",
args: [],
source: "testUnknownVariables\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | b + a'.\x0a\x09ast := Smalltalk parse: src.\x0a\x0a\x09self should: [ analyzer visit: ast ] raise: UnknownVariableError",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
pragmas: [],
messageSends: ["parse:", "should:raise:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | b + a";
ast=$recv($globals.Smalltalk)._parse_(src);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.analyzer)._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownVariables",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testUnknownVariablesWithScope",
protocol: "tests",
args: [],
source: "testUnknownVariablesWithScope\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a b | [ c + 1. [ a + 1. d + 1 ]]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09\x0a\x09self should: [ analyzer visit: ast ] raise: UnknownVariableError",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
pragmas: [],
messageSends: ["parse:", "should:raise:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a b | [ c + 1. [ a + 1. d + 1 ]]";
ast=$recv($globals.Smalltalk)._parse_(src);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.analyzer)._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testUnknownVariablesWithScope",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing",
protocol: "tests",
args: [],
source: "testVariableShadowing\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing2",
protocol: "tests",
args: [],
source: "testVariableShadowing2\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ | a | a := 2 ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09self should: [analyzer visit: ast] raise: ShadowingVariableError",
referencedClasses: ["Smalltalk", "ShadowingVariableError"],
pragmas: [],
messageSends: ["parse:", "should:raise:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ | a | a := 2 ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.analyzer)._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.ShadowingVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing2",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing3",
protocol: "tests",
args: [],
source: "testVariableShadowing3\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ | b | b := 2 ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ | b | b := 2 ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing3",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing4",
protocol: "tests",
args: [],
source: "testVariableShadowing4\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ [ [ | b | b := 2 ] ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ [ | b | b := 2 ] ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing4",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariableShadowing5",
protocol: "tests",
args: [],
source: "testVariableShadowing5\x0a\x09| src ast |\x0a\x09src := 'foo | a | a + 1. [ [ [ | a | a := 2 ] ] ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09self should: [analyzer visit: ast] raise: ShadowingVariableError",
referencedClasses: ["Smalltalk", "ShadowingVariableError"],
pragmas: [],
messageSends: ["parse:", "should:raise:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ [ [ | a | a := 2 ] ] ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.analyzer)._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.ShadowingVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariableShadowing5",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testVariablesLookup",
protocol: "tests",
args: [],
source: "testVariablesLookup\x0a\x09| src ast |\x0a\x0a\x09src := 'foo | a | a + 1. [ | b | b := a ]'.\x0a\x09ast := Smalltalk parse: src.\x0a\x09analyzer visit: ast.\x0a\x0a\x09\x22Binding for `a` in the message send\x22\x0a\x09self assert: ast sequenceNode dagChildren first receiver binding isAssignable.\x0a\x09self assert: ast sequenceNode dagChildren first receiver binding alias equals: 'a'.\x0a\x09self assert: ast sequenceNode dagChildren first receiver binding scope == ast scope.\x0a\x0a\x09\x22Binding for `b`\x22\x0a\x09self assert: ast sequenceNode dagChildren last sequenceNode dagChildren first left binding isAssignable.\x0a\x09self assert: ast sequenceNode dagChildren last sequenceNode dagChildren first left binding alias equals: 'b'.\x0a\x09self assert: ast sequenceNode dagChildren last sequenceNode dagChildren first left binding scope == ast sequenceNode dagChildren last scope.",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["parse:", "visit:", "assert:", "isAssignable", "binding", "receiver", "first", "dagChildren", "sequenceNode", "assert:equals:", "alias", "==", "scope", "left", "last"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | a + 1. [ | b | b := a ]";
ast=$recv($globals.Smalltalk)._parse_(src);
$recv($self.analyzer)._visit_(ast);
[$self._assert_([$recv([$recv([$recv([$recv([$recv([$recv(ast)._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=1
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=1
][0])._first()
,$ctx1.sendIdx["first"]=1
][0])._receiver()
,$ctx1.sendIdx["receiver"]=1
][0])._binding()
,$ctx1.sendIdx["binding"]=1
][0])._isAssignable()
,$ctx1.sendIdx["isAssignable"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
[$self._assert_equals_([$recv([$recv([$recv([$recv([$recv([$recv(ast)._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=2
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=2
][0])._first()
,$ctx1.sendIdx["first"]=2
][0])._receiver()
,$ctx1.sendIdx["receiver"]=2
][0])._binding()
,$ctx1.sendIdx["binding"]=2
][0])._alias()
,$ctx1.sendIdx["alias"]=1
][0],"a")
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_([$recv([$recv([$recv($recv([$recv([$recv([$recv(ast)._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=3
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=3
][0])._first()
,$ctx1.sendIdx["first"]=3
][0])._receiver())._binding()
,$ctx1.sendIdx["binding"]=3
][0])._scope()
,$ctx1.sendIdx["scope"]=1
][0]).__eq_eq([$recv(ast)._scope()
,$ctx1.sendIdx["scope"]=2
][0])
,$ctx1.sendIdx["=="]=1
][0])
,$ctx1.sendIdx["assert:"]=2
][0];
[$self._assert_($recv([$recv([$recv([$recv([$recv([$recv([$recv([$recv([$recv(ast)._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=5
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=5
][0])._last()
,$ctx1.sendIdx["last"]=1
][0])._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=4
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=4
][0])._first()
,$ctx1.sendIdx["first"]=4
][0])._left()
,$ctx1.sendIdx["left"]=1
][0])._binding()
,$ctx1.sendIdx["binding"]=4
][0])._isAssignable())
,$ctx1.sendIdx["assert:"]=3
][0];
$self._assert_equals_($recv([$recv([$recv([$recv([$recv([$recv([$recv([$recv([$recv(ast)._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=7
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=7
][0])._last()
,$ctx1.sendIdx["last"]=2
][0])._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=6
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=6
][0])._first()
,$ctx1.sendIdx["first"]=5
][0])._left()
,$ctx1.sendIdx["left"]=2
][0])._binding()
,$ctx1.sendIdx["binding"]=5
][0])._alias(),"b");
$self._assert_($recv([$recv($recv($recv($recv([$recv([$recv([$recv([$recv([$recv(ast)._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=9
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=9
][0])._last()
,$ctx1.sendIdx["last"]=3
][0])._sequenceNode()
,$ctx1.sendIdx["sequenceNode"]=8
][0])._dagChildren()
,$ctx1.sendIdx["dagChildren"]=8
][0])._first())._left())._binding())._scope()
,$ctx1.sendIdx["scope"]=3
][0]).__eq_eq($recv($recv($recv($recv(ast)._sequenceNode())._dagChildren())._last())._scope()));
return self;
}, function($ctx1) {$ctx1.fill(self,"testVariablesLookup",{src:src,ast:ast})});
}; }),
$globals.SemanticAnalyzerTest);



$core.addClass("AISemanticAnalyzerTest", $globals.SemanticAnalyzerTest, "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp\x0a\x09analyzer := (AISemanticAnalyzer on: Object)\x0a\x09\x09context: (AIContext new\x0a\x09\x09\x09defineLocal: 'local';\x0a\x09\x09\x09localAt: 'local' put: 3;\x0a\x09\x09\x09yourself);\x0a\x09\x09yourself",
referencedClasses: ["AISemanticAnalyzer", "Object", "AIContext"],
pragmas: [],
messageSends: ["context:", "on:", "defineLocal:", "new", "localAt:put:", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$1=$recv($globals.AISemanticAnalyzer)._on_($globals.Object);
$2=$recv($globals.AIContext)._new();
$recv($2)._defineLocal_("local");
$recv($2)._localAt_put_("local",(3));
$recv($1)._context_([$recv($2)._yourself()
,$ctx1.sendIdx["yourself"]=1
][0]);
$self.analyzer=$recv($1)._yourself();
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.AISemanticAnalyzerTest);

$core.addMethod(
$core.method({
selector: "testContextVariables",
protocol: "tests",
args: [],
source: "testContextVariables\x0a\x09| src ast |\x0a\x09\x0a\x09src := 'foo | a | local + a'.\x0a\x09ast := Smalltalk parse: src.\x0a\x0a\x09self shouldnt: [ analyzer visit: ast ] raise: UnknownVariableError",
referencedClasses: ["Smalltalk", "UnknownVariableError"],
pragmas: [],
messageSends: ["parse:", "shouldnt:raise:", "visit:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var src,ast;
return $core.withContext(function($ctx1) {
src="foo | a | local + a";
ast=$recv($globals.Smalltalk)._parse_(src);
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.analyzer)._visit_(ast);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.UnknownVariableError);
return self;
}, function($ctx1) {$ctx1.fill(self,"testContextVariables",{src:src,ast:ast})});
}; }),
$globals.AISemanticAnalyzerTest);



$core.addTrait("TASTCompilingTest", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: "accessing",
args: [],
source: "codeGeneratorClass\x0a\x09self subclassResponsibility",
referencedClasses: [],
pragmas: [],
messageSends: ["subclassResponsibility"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._subclassResponsibility();
return self;
}, function($ctx1) {$ctx1.fill(self,"codeGeneratorClass",{})});
}; }),
$globals.TASTCompilingTest);

$core.addMethod(
$core.method({
selector: "compiler",
protocol: "factory",
args: [],
source: "compiler\x0a\x09^ Compiler new\x0a\x09\x09codeGeneratorClass: self codeGeneratorClass;\x0a\x09\x09yourself",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["codeGeneratorClass:", "new", "codeGeneratorClass", "yourself"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$recv($globals.Compiler)._new();
$recv($1)._codeGeneratorClass_($self._codeGeneratorClass());
return $recv($1)._yourself();
}, function($ctx1) {$ctx1.fill(self,"compiler",{})});
}; }),
$globals.TASTCompilingTest);

$core.addMethod(
$core.method({
selector: "install:forClass:",
protocol: "compiling",
args: ["aString", "aClass"],
source: "install: aString forClass: aClass\x0a\x09^ self compiler\x0a\x09\x09install: aString\x0a\x09\x09forClass: aClass\x0a\x09\x09protocol: 'tests'",
referencedClasses: [],
pragmas: [],
messageSends: ["install:forClass:protocol:", "compiler"]
}, function ($methodClass){ return function (aString,aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._compiler())._install_forClass_protocol_(aString,aClass,"tests");
}, function($ctx1) {$ctx1.fill(self,"install:forClass:",{aString:aString,aClass:aClass})});
}; }),
$globals.TASTCompilingTest);

$core.addMethod(
$core.method({
selector: "while:inClass:should:",
protocol: "testing",
args: ["aString", "aClass", "aBlock"],
source: "while: aString inClass: aClass should: aBlock\x0a\x09| method |\x0a\x0a\x09[\x0a\x09\x09method := self install: aString forClass: aClass.\x0a\x09\x09aBlock value: method ]\x0a\x09ensure: [ method ifNotNil: [ aClass removeCompiledMethod: method ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["ensure:", "install:forClass:", "value:", "ifNotNil:", "removeCompiledMethod:"]
}, function ($methodClass){ return function (aString,aClass,aBlock){
var self=this,$self=this;
var method;
return $core.withContext(function($ctx1) {
var $1;
$recv((function(){
return $core.withContext(function($ctx2) {
method=$self._install_forClass_(aString,aClass);
return $recv(aBlock)._value_(method);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))._ensure_((function(){
return $core.withContext(function($ctx2) {
$1=method;
if($1 == null || $1.a$nil){
return $1;
} else {
return $recv(aClass)._removeCompiledMethod_(method);
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"while:inClass:should:",{aString:aString,aClass:aClass,aBlock:aBlock,method:method})});
}; }),
$globals.TASTCompilingTest);

$core.addMethod(
$core.method({
selector: "while:should:",
protocol: "testing",
args: ["aString", "aBlock"],
source: "while: aString should: aBlock\x0a\x09self while: aString inClass: self receiver class should: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["while:inClass:should:", "class", "receiver"]
}, function ($methodClass){ return function (aString,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._while_inClass_should_(aString,$recv($self._receiver())._class(),aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"while:should:",{aString:aString,aBlock:aBlock})});
}; }),
$globals.TASTCompilingTest);


$core.addTrait("TASTParsingTest", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "parse:forClass:",
protocol: "parsing",
args: ["aString", "aClass"],
source: "parse: aString forClass: aClass\x0a\x09^ Compiler new\x0a\x09\x09ast: aString\x0a\x09\x09forClass: aClass\x0a\x09\x09protocol: 'test'",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["ast:forClass:protocol:", "new"]
}, function ($methodClass){ return function (aString,aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Compiler)._new())._ast_forClass_protocol_(aString,aClass,"test");
}, function($ctx1) {$ctx1.fill(self,"parse:forClass:",{aString:aString,aClass:aClass})});
}; }),
$globals.TASTParsingTest);


$core.addTrait("TCTDebugged", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "interpret:forClass:receiver:withArguments:",
protocol: "private",
args: ["aString", "aClass", "anObject", "aDictionary"],
source: "interpret: aString forClass: aClass receiver: anObject withArguments: aDictionary\x0a\x09\x22The food is a methodNode. Interpret the sequenceNode only\x22\x0a\x09\x0a\x09| ctx |\x0a\x09\x0a\x09ctx := self prepareContextFor: aString class: aClass receiver: anObject withArguments: aDictionary.\x0a\x09\x0a\x09^ (ASTDebugger context: ctx) proceed; result",
referencedClasses: ["ASTDebugger"],
pragmas: [],
messageSends: ["prepareContextFor:class:receiver:withArguments:", "proceed", "context:", "result"]
}, function ($methodClass){ return function (aString,aClass,anObject,aDictionary){
var self=this,$self=this;
var ctx;
return $core.withContext(function($ctx1) {
var $1;
ctx=$self._prepareContextFor_class_receiver_withArguments_(aString,aClass,anObject,aDictionary);
$1=$recv($globals.ASTDebugger)._context_(ctx);
$recv($1)._proceed();
return $recv($1)._result();
}, function($ctx1) {$ctx1.fill(self,"interpret:forClass:receiver:withArguments:",{aString:aString,aClass:aClass,anObject:anObject,aDictionary:aDictionary,ctx:ctx})});
}; }),
$globals.TCTDebugged);


$core.addTrait("TCTExecuted", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "while:inClass:should:",
protocol: "testing",
args: ["aString", "aClass", "aBlock"],
source: "while: aString inClass: aClass should: aBlock\x0a\x09super\x0a\x09\x09while: aString\x0a\x09\x09inClass: aClass\x0a\x09\x09should: [ :method | aBlock value: [\x0a\x09\x09\x09self receiver perform: method selector withArguments: self arguments ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["while:inClass:should:", "value:", "perform:withArguments:", "receiver", "selector", "arguments"]
}, function ($methodClass){ return function (aString,aClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._while_inClass_should_.call($self,aString,aClass,(function(method){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_((function(){
return $core.withContext(function($ctx3) {
return $recv($self._receiver())._perform_withArguments_($recv(method)._selector(),$self._arguments());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({method:method},$ctx1,1)});
})))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"while:inClass:should:",{aString:aString,aClass:aClass,aBlock:aBlock})});
}; }),
$globals.TCTExecuted);


$core.addTrait("TCTInlined", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: "accessing",
args: [],
source: "codeGeneratorClass\x0a\x09^ InliningCodeGenerator",
referencedClasses: ["InliningCodeGenerator"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.InliningCodeGenerator;

}; }),
$globals.TCTInlined);


$core.addTrait("TCTInterpreted", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "interpret:forClass:receiver:withArguments:",
protocol: "private",
args: ["aString", "aClass", "anObject", "aDictionary"],
source: "interpret: aString forClass: aClass receiver: anObject withArguments: aDictionary\x0a\x09\x22The food is a methodNode. Interpret the sequenceNode only\x22\x0a\x09\x0a\x09| ctx |\x0a\x09\x0a\x09ctx := self prepareContextFor: aString class: aClass receiver: anObject withArguments: aDictionary.\x0a\x09\x0a\x09^ ctx interpreter proceed; result",
referencedClasses: [],
pragmas: [],
messageSends: ["prepareContextFor:class:receiver:withArguments:", "proceed", "interpreter", "result"]
}, function ($methodClass){ return function (aString,aClass,anObject,aDictionary){
var self=this,$self=this;
var ctx;
return $core.withContext(function($ctx1) {
var $1;
ctx=$self._prepareContextFor_class_receiver_withArguments_(aString,aClass,anObject,aDictionary);
$1=$recv(ctx)._interpreter();
$recv($1)._proceed();
return $recv($1)._result();
}, function($ctx1) {$ctx1.fill(self,"interpret:forClass:receiver:withArguments:",{aString:aString,aClass:aClass,anObject:anObject,aDictionary:aDictionary,ctx:ctx})});
}; }),
$globals.TCTInterpreted);

$core.addMethod(
$core.method({
selector: "prepareContextFor:class:receiver:withArguments:",
protocol: "private",
args: ["aString", "aClass", "anObject", "anArray"],
source: "prepareContextFor: aString class: aClass receiver: anObject withArguments: anArray\x0a\x09\x22The food is a methodNode. Interpret the sequenceNode only\x22\x0a\x09\x0a\x09| ctx ast |\x0a\x09\x0a\x09ast := self parse: aString forClass: aClass.\x0a\x09\x0a\x09ctx := AIContext new\x0a\x09\x09receiver: anObject;\x0a\x09\x09selector: ast selector;\x0a\x09\x09interpreter: ASTInterpreter new;\x0a\x09\x09yourself.\x0a\x09\x09\x0a\x09\x22Define locals for the context\x22\x0a\x09ast sequenceNode ifNotNil: [ :sequence |\x0a\x09\x09sequence temps do: [ :each |\x0a\x09\x09\x09ctx defineLocal: each ] ].\x0a\x0a\x09ast arguments with: anArray do: [ :key :value |\x0a\x09\x09ctx defineLocal: key; localAt: key put: value ].\x0a\x09\x0a\x09ctx interpreter\x0a\x09\x09context: ctx;\x0a\x09\x09node: ast;\x0a\x09\x09enterNode.\x0a\x09\x0a\x09^ctx",
referencedClasses: ["AIContext", "ASTInterpreter"],
pragmas: [],
messageSends: ["parse:forClass:", "receiver:", "new", "selector:", "selector", "interpreter:", "yourself", "ifNotNil:", "sequenceNode", "do:", "temps", "defineLocal:", "with:do:", "arguments", "localAt:put:", "context:", "interpreter", "node:", "enterNode"]
}, function ($methodClass){ return function (aString,aClass,anObject,anArray){
var self=this,$self=this;
var ctx,ast;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
ast=$self._parse_forClass_(aString,aClass);
$1=[$recv($globals.AIContext)._new()
,$ctx1.sendIdx["new"]=1
][0];
$recv($1)._receiver_(anObject);
$recv($1)._selector_($recv(ast)._selector());
$recv($1)._interpreter_($recv($globals.ASTInterpreter)._new());
ctx=$recv($1)._yourself();
$2=$recv(ast)._sequenceNode();
if($2 == null || $2.a$nil){
$2;
} else {
var sequence;
sequence=$2;
$recv($recv(sequence)._temps())._do_((function(each){
return $core.withContext(function($ctx2) {
return [$recv(ctx)._defineLocal_(each)
,$ctx2.sendIdx["defineLocal:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
}
$recv($recv(ast)._arguments())._with_do_(anArray,(function(key,value){
return $core.withContext(function($ctx2) {
$3=ctx;
$recv($3)._defineLocal_(key);
return $recv($3)._localAt_put_(key,value);
}, function($ctx2) {$ctx2.fillBlock({key:key,value:value},$ctx1,3)});
}));
$4=$recv(ctx)._interpreter();
$recv($4)._context_(ctx);
$recv($4)._node_(ast);
$recv($4)._enterNode();
return ctx;
}, function($ctx1) {$ctx1.fill(self,"prepareContextFor:class:receiver:withArguments:",{aString:aString,aClass:aClass,anObject:anObject,anArray:anArray,ctx:ctx,ast:ast})});
}; }),
$globals.TCTInterpreted);

$core.addMethod(
$core.method({
selector: "while:inClass:should:",
protocol: "testing",
args: ["aString", "aClass", "aBlock"],
source: "while: aString inClass: aClass should: aBlock\x0a\x09super\x0a\x09\x09while: aString\x0a\x09\x09inClass: aClass\x0a\x09\x09should: [ aBlock value: [\x0a\x09\x09\x09self\x0a\x09\x09\x09\x09interpret: aString\x0a\x09\x09\x09\x09forClass: aClass\x0a\x09\x09\x09\x09receiver: self receiver\x0a\x09\x09\x09\x09withArguments: self arguments ] ]",
referencedClasses: [],
pragmas: [],
messageSends: ["while:inClass:should:", "value:", "interpret:forClass:receiver:withArguments:", "receiver", "arguments"]
}, function ($methodClass){ return function (aString,aClass,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._while_inClass_should_.call($self,aString,aClass,(function(){
return $core.withContext(function($ctx2) {
return $recv(aBlock)._value_((function(){
return $core.withContext(function($ctx3) {
return $self._interpret_forClass_receiver_withArguments_(aString,aClass,$self._receiver(),$self._arguments());
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"while:inClass:should:",{aString:aString,aClass:aClass,aBlock:aBlock})});
}; }),
$globals.TCTInterpreted);


$core.addTrait("TCTNonInlined", "Compiler-Tests");
$core.addMethod(
$core.method({
selector: "codeGeneratorClass",
protocol: "accessing",
args: [],
source: "codeGeneratorClass\x0a\x09^ CodeGenerator",
referencedClasses: ["CodeGenerator"],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.CodeGenerator;

}; }),
$globals.TCTNonInlined);

$core.setTraitComposition([{trait: $globals.TASTParsingTest}], $globals.TASTCompilingTest);
$core.setTraitComposition([{trait: $globals.TCTInterpreted}], $globals.TCTDebugged);
$core.setTraitComposition([{trait: $globals.TASTCompilingTest}], $globals.ASTMethodRunningTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}, {trait: $globals.TCTDebugged}], $globals.ASTDebuggerTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}, {trait: $globals.TCTInterpreted}], $globals.ASTInterpreterTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}, {trait: $globals.TCTExecuted}], $globals.CodeGeneratorTest);
$core.setTraitComposition([{trait: $globals.TCTInlined}, {trait: $globals.TCTExecuted}], $globals.InliningCodeGeneratorTest);
$core.setTraitComposition([{trait: $globals.TClassBuildingTest}], $globals.AbstractJavaScriptGatewayTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}, {trait: $globals.TCTDebugged}], $globals.DebuggedJSGTest);
$core.setTraitComposition([{trait: $globals.TCTInlined}, {trait: $globals.TCTExecuted}], $globals.InlinedJSGTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}, {trait: $globals.TCTInterpreted}], $globals.InterpretedJSGTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}, {trait: $globals.TCTExecuted}], $globals.PlainJSGTest);
$core.setTraitComposition([{trait: $globals.TASTParsingTest}], $globals.ASTPCNodeVisitorTest);
$core.setTraitComposition([{trait: $globals.TASTParsingTest}], $globals.ASTPositionTest);
$core.setTraitComposition([{trait: $globals.TASTCompilingTest}], $globals.AbstractCodeGeneratorInstallTest);
$core.setTraitComposition([{trait: $globals.TCTNonInlined}], $globals.CodeGeneratorInstallTest);
$core.setTraitComposition([{trait: $globals.TCTInlined}], $globals.InliningCodeGeneratorInstallTest);

});

define('amber/core/Platform-DOM-Tests',["amber/boot", "require", "amber/core/SUnit"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Platform-DOM-Tests");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("PlatformDomTest", $globals.TestCase, "Platform-DOM-Tests");
$core.setSlots($globals.PlatformDomTest, ["fixtureDiv"]);
$core.addMethod(
$core.method({
selector: "testEntityConversion",
protocol: "testing",
args: [],
source: "testEntityConversion\x0a\x09PlatformDom isFeasible ifTrue: [ self assert: '&copy;' htmlTextContent equals: '' ]",
referencedClasses: ["PlatformDom"],
pragmas: [],
messageSends: ["ifTrue:", "isFeasible", "assert:equals:", "htmlTextContent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($globals.PlatformDom)._isFeasible())){
$self._assert_equals_("&copy;"._htmlTextContent(),"");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"testEntityConversion",{})});
}; }),
$globals.PlatformDomTest);

$core.addMethod(
$core.method({
selector: "testTextContentDoesNotRunScript",
protocol: "testing",
args: [],
source: "testTextContentDoesNotRunScript\x0a\x09PlatformDom isFeasible ifTrue: [\x0a\x09\x09self shouldnt: [ '<script>throw new Error(\x22Intentional\x22)</script>' htmlTextContent ] raise: Error ]",
referencedClasses: ["PlatformDom", "Error"],
pragmas: [],
messageSends: ["ifTrue:", "isFeasible", "shouldnt:raise:", "htmlTextContent"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($recv($globals.PlatformDom)._isFeasible())){
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return "<script>throw new Error(\x22Intentional\x22)</script>"._htmlTextContent();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"testTextContentDoesNotRunScript",{})});
}; }),
$globals.PlatformDomTest);


});

define('amber/core/SUnit-Tests',["amber/boot", "require", "amber/core/SUnit"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("SUnit-Tests");
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("ExampleSetTest", $globals.TestCase, "SUnit-Tests");
$core.setSlots($globals.ExampleSetTest, ["empty", "full"]);
$globals.ExampleSetTest.comment="ExampleSetTest is taken from Pharo 1.4.\x0a\x0aTHe purpose of this class is to demonstrate a simple use case of the test framework.";
$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp\x0a\x09empty := Set new.\x0a\x09full := Set with: 5 with: #abc",
referencedClasses: ["Set"],
pragmas: [],
messageSends: ["new", "with:with:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.empty=$recv($globals.Set)._new();
$self.full=$recv($globals.Set)._with_with_((5),"abc");
return self;
}, function($ctx1) {$ctx1.fill(self,"setUp",{})});
}; }),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testAdd",
protocol: "tests",
args: [],
source: "testAdd\x0a\x09empty add: 5.\x0a\x09self assert: (empty includes: 5)",
referencedClasses: [],
pragmas: [],
messageSends: ["add:", "assert:", "includes:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.empty)._add_((5));
$self._assert_($recv($self.empty)._includes_((5)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testAdd",{})});
}; }),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testGrow",
protocol: "tests",
args: [],
source: "testGrow\x0a\x09empty addAll: (1 to: 100).\x0a\x09self assert: empty size equals: 100",
referencedClasses: [],
pragmas: [],
messageSends: ["addAll:", "to:", "assert:equals:", "size"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.empty)._addAll_((1)._to_((100)));
$self._assert_equals_($recv($self.empty)._size(),(100));
return self;
}, function($ctx1) {$ctx1.fill(self,"testGrow",{})});
}; }),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testIllegal",
protocol: "tests",
args: [],
source: "testIllegal\x0a\x09self\x0a\x09\x09should: [ empty at: 5 ]\x0a\x09\x09raise: Error.\x0a\x09self\x0a\x09\x09should: [ empty at: 5 put: #abc ]\x0a\x09\x09raise: Error",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "at:", "at:put:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.empty)._at_((5));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error)
,$ctx1.sendIdx["should:raise:"]=1
][0];
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return $recv($self.empty)._at_put_((5),"abc");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testIllegal",{})});
}; }),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testIncludes",
protocol: "tests",
args: [],
source: "testIncludes\x0a\x09self assert: (full includes: 5).\x0a\x09self assert: (full includes: #abc)",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:", "includes:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_([$recv($self.full)._includes_((5))
,$ctx1.sendIdx["includes:"]=1
][0])
,$ctx1.sendIdx["assert:"]=1
][0];
$self._assert_($recv($self.full)._includes_("abc"));
return self;
}, function($ctx1) {$ctx1.fill(self,"testIncludes",{})});
}; }),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testOccurrences",
protocol: "tests",
args: [],
source: "testOccurrences\x0a\x09self assert: (empty occurrencesOf: 0) equals: 0.\x0a\x09self assert: (full occurrencesOf: 5) equals: 1.\x0a\x09full add: 5.\x0a\x09self assert: (full occurrencesOf: 5) equals: 1",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:", "occurrencesOf:", "add:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._assert_equals_([$recv($self.empty)._occurrencesOf_((0))
,$ctx1.sendIdx["occurrencesOf:"]=1
][0],(0))
,$ctx1.sendIdx["assert:equals:"]=1
][0];
[$self._assert_equals_([$recv($self.full)._occurrencesOf_((5))
,$ctx1.sendIdx["occurrencesOf:"]=2
][0],(1))
,$ctx1.sendIdx["assert:equals:"]=2
][0];
$recv($self.full)._add_((5));
$self._assert_equals_($recv($self.full)._occurrencesOf_((5)),(1));
return self;
}, function($ctx1) {$ctx1.fill(self,"testOccurrences",{})});
}; }),
$globals.ExampleSetTest);

$core.addMethod(
$core.method({
selector: "testRemove",
protocol: "tests",
args: [],
source: "testRemove\x0a\x09full remove: 5.\x0a\x09self assert: (full includes: #abc).\x0a\x09self deny: (full includes: 5)",
referencedClasses: [],
pragmas: [],
messageSends: ["remove:", "assert:", "includes:", "deny:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.full)._remove_((5));
$self._assert_([$recv($self.full)._includes_("abc")
,$ctx1.sendIdx["includes:"]=1
][0]);
$self._deny_($recv($self.full)._includes_((5)));
return self;
}, function($ctx1) {$ctx1.fill(self,"testRemove",{})});
}; }),
$globals.ExampleSetTest);



$core.addClass("SUnitAsyncTest", $globals.TestCase, "SUnit-Tests");
$core.setSlots($globals.SUnitAsyncTest, ["flag"]);
$core.addMethod(
$core.method({
selector: "fakeError",
protocol: "helpers",
args: [],
source: "fakeError\x0a\x09flag := 'bad'.\x0a\x09self timeout: 30.\x0a\x09flag := (self async: [ flag := 'ok'. self error: 'Intentional' ]) valueWithTimeout: 20",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.flag="bad";
$self._timeout_((30));
$self.flag=$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
$self.flag="ok";
return $self._error_("Intentional");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeError",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeErrorFailingInTearDown",
protocol: "helpers",
args: [],
source: "fakeErrorFailingInTearDown\x0a\x09flag := 'bad'.\x0a\x09self timeout: 30.\x0a\x09flag := (self async: [ self error: 'Intentional' ]) valueWithTimeout: 20",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.flag="bad";
$self._timeout_((30));
$self.flag=$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
return $self._error_("Intentional");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeErrorFailingInTearDown",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeFailure",
protocol: "helpers",
args: [],
source: "fakeFailure\x0a\x09flag := 'bad'.\x0a\x09self timeout: 30.\x0a\x09flag := (self async: [ flag := 'ok'. self assert: false ]) valueWithTimeout: 20",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "assert:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.flag="bad";
$self._timeout_((30));
$self.flag=$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
$self.flag="ok";
return $self._assert_(false);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeFailure",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeMultipleTimeoutFailing",
protocol: "helpers",
args: [],
source: "fakeMultipleTimeoutFailing\x0a\x09self timeout: 100.\x0a\x09(self async: [ \x0a\x09\x09self timeout: 20.\x0a\x09\x09(self async: [ self finished ]) valueWithTimeout: 30\x0a\x09]) valueWithTimeout: 20",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._timeout_((100))
,$ctx1.sendIdx["timeout:"]=1
][0];
[$recv([$self._async_((function(){
return $core.withContext(function($ctx2) {
$self._timeout_((20));
return $recv($self._async_((function(){
return $core.withContext(function($ctx3) {
return $self._finished();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
})))._valueWithTimeout_((30));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["async:"]=1
][0])._valueWithTimeout_((20))
,$ctx1.sendIdx["valueWithTimeout:"]=1
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeMultipleTimeoutFailing",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeMultipleTimeoutPassing",
protocol: "helpers",
args: [],
source: "fakeMultipleTimeoutPassing\x0a\x09self timeout: 20.\x0a\x09(self async: [\x0a\x09\x09self timeout: 40.\x0a\x09\x09(self async: [ self finished ]) valueWithTimeout: 20\x0a\x09]) valueWithTimeout: 10",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._timeout_((20))
,$ctx1.sendIdx["timeout:"]=1
][0];
[$recv([$self._async_((function(){
return $core.withContext(function($ctx2) {
$self._timeout_((40));
return $recv($self._async_((function(){
return $core.withContext(function($ctx3) {
return $self._finished();
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
})))._valueWithTimeout_((20));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["async:"]=1
][0])._valueWithTimeout_((10))
,$ctx1.sendIdx["valueWithTimeout:"]=1
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeMultipleTimeoutPassing",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "fakeTimeout",
protocol: "helpers",
args: [],
source: "fakeTimeout\x0a\x09self timeout: 10.\x0a\x09(self async: [ self finished ]) valueWithTimeout: 20",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._timeout_((10));
$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
return $self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((20));
return self;
}, function($ctx1) {$ctx1.fill(self,"fakeTimeout",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "selectorSetOf:",
protocol: "private",
args: ["aCollection"],
source: "selectorSetOf: aCollection\x0a\x09^ (aCollection collect: [ :each | each selector ]) asSet",
referencedClasses: [],
pragmas: [],
messageSends: ["asSet", "collect:", "selector"]
}, function ($methodClass){ return function (aCollection){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv(aCollection)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._selector();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
})))._asSet();
}, function($ctx1) {$ctx1.fill(self,"selectorSetOf:",{aCollection:aCollection})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "setUp",
protocol: "running",
args: [],
source: "setUp\x0a\x09flag := 'ok'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
$self.flag="ok";
return self;

}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "tearDown",
protocol: "running",
args: [],
source: "tearDown\x0a\x09self assert: 'ok' equals: flag",
referencedClasses: [],
pragmas: [],
messageSends: ["assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._assert_equals_("ok",$self.flag);
return self;
}, function($ctx1) {$ctx1.fill(self,"tearDown",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testAsyncErrorsAndFailures",
protocol: "tests",
args: [],
source: "testAsyncErrorsAndFailures\x0a\x09| suite runner result assertBlock |\x0a\x09suite := #('fakeError' 'fakeErrorFailingInTearDown' 'fakeFailure' 'testPass') collect: [ :each | self class selector: each ].\x0a\x09runner := TestSuiteRunner on: suite.\x0a\x09self timeout: 200.\x0a\x09result := runner result.\x0a\x09assertBlock := self async: [\x0a\x09\x09self assert: (self selectorSetOf: result errors) equals: #('fakeError') asSet.\x0a\x09\x09self assert: (self selectorSetOf: result failures) equals: #('fakeErrorFailingInTearDown' 'fakeFailure') asSet.\x0a\x09\x09self finished\x0a\x09].\x0a\x09runner announcer on: ResultAnnouncement do: [ :ann |\x0a\x09\x09ann result == result ifTrue: [ result runs = result total ifTrue: assertBlock ] ].\x0a\x09runner run",
referencedClasses: ["TestSuiteRunner", "ResultAnnouncement"],
pragmas: [],
messageSends: ["collect:", "selector:", "class", "on:", "timeout:", "result", "async:", "assert:equals:", "selectorSetOf:", "errors", "asSet", "failures", "finished", "on:do:", "announcer", "ifTrue:", "==", "=", "runs", "total", "run"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var suite,runner,result,assertBlock;
return $core.withContext(function($ctx1) {
suite=["fakeError", "fakeErrorFailingInTearDown", "fakeFailure", "testPass"]._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($self._class())._selector_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
runner=$recv($globals.TestSuiteRunner)._on_(suite);
$self._timeout_((200));
result=[$recv(runner)._result()
,$ctx1.sendIdx["result"]=1
][0];
assertBlock=$self._async_((function(){
return $core.withContext(function($ctx2) {
[$self._assert_equals_([$self._selectorSetOf_($recv(result)._errors())
,$ctx2.sendIdx["selectorSetOf:"]=1
][0],[["fakeError"]._asSet()
,$ctx2.sendIdx["asSet"]=1
][0])
,$ctx2.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($self._selectorSetOf_($recv(result)._failures()),["fakeErrorFailingInTearDown", "fakeFailure"]._asSet());
return $self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv($recv(runner)._announcer())._on_do_($globals.ResultAnnouncement,(function(ann){
return $core.withContext(function($ctx2) {
if($core.assert($recv($recv(ann)._result()).__eq_eq(result))){
return $recv($recv($recv(result)._runs()).__eq($recv(result)._total()))._ifTrue_(assertBlock);
}
}, function($ctx2) {$ctx2.fillBlock({ann:ann},$ctx1,3)});
}));
$recv(runner)._run();
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsyncErrorsAndFailures",{suite:suite,runner:runner,result:result,assertBlock:assertBlock})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testAsyncNeedsTimeout",
protocol: "tests",
args: [],
source: "testAsyncNeedsTimeout\x0a\x09self should: [ self async: [ ] ] raise: Error.\x0a\x09self timeout: 0.\x0a\x09self shouldnt: [ self async: [ ] ] raise: Error.\x0a\x09self finished",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "async:", "timeout:", "shouldnt:raise:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$self._async_((function(){

}))
,$ctx2.sendIdx["async:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._timeout_((0));
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $self._async_((function(){

}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}),$globals.Error);
$self._finished();
return self;
}, function($ctx1) {$ctx1.fill(self,"testAsyncNeedsTimeout",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testFinishedNeedsTimeout",
protocol: "tests",
args: [],
source: "testFinishedNeedsTimeout\x0a\x09self should: [ self finished ] raise: Error.\x0a\x09self timeout: 0.\x0a\x09self shouldnt: [ self finished ] raise: Error.",
referencedClasses: ["Error"],
pragmas: [],
messageSends: ["should:raise:", "finished", "timeout:", "shouldnt:raise:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._should_raise_((function(){
return $core.withContext(function($ctx2) {
return [$self._finished()
,$ctx2.sendIdx["finished"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),$globals.Error);
$self._timeout_((0));
$self._shouldnt_raise_((function(){
return $core.withContext(function($ctx2) {
return $self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}),$globals.Error);
return self;
}, function($ctx1) {$ctx1.fill(self,"testFinishedNeedsTimeout",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testIsAsyncReturnsCorrectValues",
protocol: "tests",
args: [],
source: "testIsAsyncReturnsCorrectValues\x0a\x09self deny: self isAsync.\x0a\x09self timeout: 0.\x0a\x09self assert: self isAsync.\x0a\x09self finished.\x0a\x09self deny: self isAsync",
referencedClasses: [],
pragmas: [],
messageSends: ["deny:", "isAsync", "timeout:", "assert:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$self._deny_([$self._isAsync()
,$ctx1.sendIdx["isAsync"]=1
][0])
,$ctx1.sendIdx["deny:"]=1
][0];
$self._timeout_((0));
$self._assert_([$self._isAsync()
,$ctx1.sendIdx["isAsync"]=2
][0]);
$self._finished();
$self._deny_($self._isAsync());
return self;
}, function($ctx1) {$ctx1.fill(self,"testIsAsyncReturnsCorrectValues",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testPass",
protocol: "tests",
args: [],
source: "testPass\x0a\x09flag := 'bad'.\x0a\x09self timeout: 10.\x0a\x09flag := (self async: [ self assert: true. self finished. flag := 'ok' ]) valueWithTimeout: 5",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "assert:", "finished"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.flag="bad";
$self._timeout_((10));
$self.flag=$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
$self._assert_(true);
$self._finished();
$self.flag="ok";
return $self.flag;
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
})))._valueWithTimeout_((5));
return self;
}, function($ctx1) {$ctx1.fill(self,"testPass",{})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testTimeouts",
protocol: "tests",
args: [],
source: "testTimeouts\x0a\x09| suite runner result assertBlock |\x0a\x09suite := #('fakeTimeout' 'fakeMultipleTimeoutFailing' 'fakeMultipleTimeoutPassing' 'testPass') collect: [ :each | self class selector: each ].\x0a\x09runner := TestSuiteRunner on: suite.\x0a\x09self timeout: 200.\x0a\x09result := runner result.\x0a\x09assertBlock := self async: [\x0a\x09\x09self assert: (self selectorSetOf: result errors) equals: Set new.\x0a\x09\x09self assert: (self selectorSetOf: result failures) equals: #('fakeMultipleTimeoutFailing' 'fakeTimeout') asSet.\x0a\x09\x09self finished\x0a\x09].\x0a\x09runner announcer on: ResultAnnouncement do: [ :ann |\x0a\x09\x09ann result == result ifTrue: [ result runs = result total ifTrue: assertBlock ] ].\x0a\x09runner run",
referencedClasses: ["TestSuiteRunner", "Set", "ResultAnnouncement"],
pragmas: [],
messageSends: ["collect:", "selector:", "class", "on:", "timeout:", "result", "async:", "assert:equals:", "selectorSetOf:", "errors", "new", "failures", "asSet", "finished", "on:do:", "announcer", "ifTrue:", "==", "=", "runs", "total", "run"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var suite,runner,result,assertBlock;
return $core.withContext(function($ctx1) {
suite=["fakeTimeout", "fakeMultipleTimeoutFailing", "fakeMultipleTimeoutPassing", "testPass"]._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($self._class())._selector_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
runner=$recv($globals.TestSuiteRunner)._on_(suite);
$self._timeout_((200));
result=[$recv(runner)._result()
,$ctx1.sendIdx["result"]=1
][0];
assertBlock=$self._async_((function(){
return $core.withContext(function($ctx2) {
[$self._assert_equals_([$self._selectorSetOf_($recv(result)._errors())
,$ctx2.sendIdx["selectorSetOf:"]=1
][0],$recv($globals.Set)._new())
,$ctx2.sendIdx["assert:equals:"]=1
][0];
$self._assert_equals_($self._selectorSetOf_($recv(result)._failures()),["fakeMultipleTimeoutFailing", "fakeTimeout"]._asSet());
return $self._finished();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$recv($recv(runner)._announcer())._on_do_($globals.ResultAnnouncement,(function(ann){
return $core.withContext(function($ctx2) {
if($core.assert($recv($recv(ann)._result()).__eq_eq(result))){
return $recv($recv($recv(result)._runs()).__eq($recv(result)._total()))._ifTrue_(assertBlock);
}
}, function($ctx2) {$ctx2.fillBlock({ann:ann},$ctx1,3)});
}));
$recv(runner)._run();
return self;
}, function($ctx1) {$ctx1.fill(self,"testTimeouts",{suite:suite,runner:runner,result:result,assertBlock:assertBlock})});
}; }),
$globals.SUnitAsyncTest);

$core.addMethod(
$core.method({
selector: "testTwoAsyncPassesWithFinishedOnlyOneIsRun",
protocol: "tests",
args: [],
source: "testTwoAsyncPassesWithFinishedOnlyOneIsRun\x0a\x09| x |\x0a\x09flag := 'bad'.\x0a\x09self timeout: 10.\x0a\x09x := 0.\x0a\x09flag := (self async: [ self finished. flag := 'ok'. x := x+1. self assert: x equals: 1 ]) valueWithTimeout: 0.\x0a\x09flag := (self async: [ self finished. flag := 'ok'. x := x+1. self assert: x equals: 1 ]) valueWithTimeout: 0.",
referencedClasses: [],
pragmas: [],
messageSends: ["timeout:", "valueWithTimeout:", "async:", "finished", "+", "assert:equals:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var x;
return $core.withContext(function($ctx1) {
$self.flag="bad";
$self._timeout_((10));
x=(0);
$self.flag=[$recv([$self._async_((function(){
return $core.withContext(function($ctx2) {
[$self._finished()
,$ctx2.sendIdx["finished"]=1
][0];
$self.flag="ok";
x=[$recv(x).__plus((1))
,$ctx2.sendIdx["+"]=1
][0];
return [$self._assert_equals_(x,(1))
,$ctx2.sendIdx["assert:equals:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["async:"]=1
][0])._valueWithTimeout_((0))
,$ctx1.sendIdx["valueWithTimeout:"]=1
][0];
$self.flag=$recv($self._async_((function(){
return $core.withContext(function($ctx2) {
$self._finished();
$self.flag="ok";
x=$recv(x).__plus((1));
return $self._assert_equals_(x,(1));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
})))._valueWithTimeout_((0));
return self;
}, function($ctx1) {$ctx1.fill(self,"testTwoAsyncPassesWithFinishedOnlyOneIsRun",{x:x})});
}; }),
$globals.SUnitAsyncTest);


});

define('amber/devel',[
    './lang',
    './brikz', // pre-fetch, dep of ./boot
    './kernel-checks', // pre-fetch, dep of ./boot
    './kernel-fundamentals', // pre-fetch, dep of ./boot
    './kernel-language', // pre-fetch, dep of ./boot
    './boot', // pre-fetch, class loader
    './deploy', // pre-fetch, dep of ./lang
    // --- packages of the development only Amber begin here ---
    'amber/core/Platform-DOM',
    'amber/core/SUnit',
    'amber/core/Compiler-Tests',
    'amber/core/Kernel-Tests',
    'amber/core/Platform-DOM-Tests',
    'amber/core/SUnit-Tests'
    // --- packages of the development only Amber end here ---
], function (amber) {
    return amber;
});

define('amber/core/Platform-Node',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("Platform-Node");
$pkg.imports = ["amber/core/Platform-Services"];
$pkg.isReady = new Promise(function (resolve, reject) { requirejs(["amber/core/Platform-Services"], function () {resolve();}, reject); });
$pkg.transport = {"type":"amd","amdNamespace":"amber/core"};

$core.addClass("NodePlatform", $globals.Object, "Platform-Node");
$globals.NodePlatform.comment="I am `Platform` service implementation for node-like environment.";
$core.addMethod(
$core.method({
selector: "fetch:",
protocol: "public API",
args: ["aStringOrObject"],
source: "fetch: aStringOrObject\x0a\x09^ self globals at: #fetch\x0a\x09\x09ifPresent: [ :fetch | fetch value: aStringOrObject ]\x0a\x09\x09ifAbsent: [ Promise signal: 'fetch not available.' ]",
referencedClasses: ["Promise"],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:", "globals", "value:", "signal:"]
}, function ($methodClass){ return function (aStringOrObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._globals())._at_ifPresent_ifAbsent_("fetch",(function(fetch){
return $core.withContext(function($ctx2) {
return $recv(fetch)._value_(aStringOrObject);
}, function($ctx2) {$ctx2.fillBlock({fetch:fetch},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Promise)._signal_("fetch not available.");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"fetch:",{aStringOrObject:aStringOrObject})});
}; }),
$globals.NodePlatform);

$core.addMethod(
$core.method({
selector: "fetchUrl:options:",
protocol: "public API",
args: ["aString", "anObject"],
source: "fetchUrl: aString options: anObject\x0a\x09^ self globals at: #fetch\x0a\x09\x09ifPresent: [ :fetch | fetch value: aString value: anObject ]\x0a\x09\x09ifAbsent: [ Promise signal: 'fetch not available.' ]",
referencedClasses: ["Promise"],
pragmas: [],
messageSends: ["at:ifPresent:ifAbsent:", "globals", "value:value:", "signal:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._globals())._at_ifPresent_ifAbsent_("fetch",(function(fetch){
return $core.withContext(function($ctx2) {
return $recv(fetch)._value_value_(aString,anObject);
}, function($ctx2) {$ctx2.fillBlock({fetch:fetch},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
return $recv($globals.Promise)._signal_("fetch not available.");
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
}, function($ctx1) {$ctx1.fill(self,"fetchUrl:options:",{aString:aString,anObject:anObject})});
}; }),
$globals.NodePlatform);

$core.addMethod(
$core.method({
selector: "globals",
protocol: "accessing",
args: [],
source: "globals\x0a\x09^ global",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return global;

}; }),
$globals.NodePlatform);

$core.addMethod(
$core.method({
selector: "newXhr",
protocol: "public API",
args: [],
source: "newXhr\x0a\x09XMLHttpRequest\x0a\x09\x09ifNotNil: [ ^ XMLHttpRequest new ]\x0a\x09\x09ifNil: [ self error: 'XMLHttpRequest not available.' ]",
referencedClasses: ["XMLHttpRequest"],
pragmas: [],
messageSends: ["ifNotNil:ifNil:", "new", "error:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$globals.XMLHttpRequest;
if($1 == null || $1.a$nil){
$self._error_("XMLHttpRequest not available.");
} else {
return $recv($globals.XMLHttpRequest)._new();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"newXhr",{})});
}; }),
$globals.NodePlatform);


$core.addMethod(
$core.method({
selector: "initialize",
protocol: "testing",
args: [],
source: "initialize\x0a\x09self isFeasible ifTrue: [ Platform registerIfNone: self new ]",
referencedClasses: ["Platform"],
pragmas: [],
messageSends: ["ifTrue:", "isFeasible", "registerIfNone:", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert($self._isFeasible())){
$recv($globals.Platform)._registerIfNone_($self._new());
}
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.NodePlatform.a$cls);

$core.addMethod(
$core.method({
selector: "isFeasible",
protocol: "testing",
args: [],
source: "isFeasible\x0a<inlineJS: 'return typeof process !== \x22undefined\x22 && process && process.versions && process.versions.node != null'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return typeof process !== \x22undefined\x22 && process && process.versions && process.versions.node != null"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return typeof process !== "undefined" && process && process.versions && process.versions.node != null;
return self;
}, function($ctx1) {$ctx1.fill(self,"isFeasible",{})});
}; }),
$globals.NodePlatform.a$cls);

});

define('amber_cli/AmberCli',["amber/boot", "require", "amber/core/Kernel-Objects"], function($boot,requirejs){"use strict";
var $core=$boot.api,nil=$boot.nilAsValue,$nil=$boot.nilAsReceiver,$recv=$boot.asReceiver,$globals=$boot.globals;
var $pkg = $core.addPackage("AmberCli");
$pkg.transport = {"type":"amd","amdNamespace":"amber_cli"};

$core.addClass("AmberCli", $globals.Object, "AmberCli");
$globals.AmberCli.comment="I am the Amber CLI (CommandLine Interface) tool which runs on Node.js.\x0a\x0aMy responsibility is to start different Amber programs like the FileServer or the Repl.\x0aWhich program to start is determined by the first commandline parameters passed to the AmberCli executable.\x0aUse `help` to get a list of all available options.\x0aAny further commandline parameters are passed to the specific program.\x0a\x0a## Commands\x0a\x0aNew commands can be added by creating a class side method in the `commands` protocol which takes one parameter.\x0aThis parameter is an array of all commandline options + values passed on to the program.\x0aAny `camelCaseCommand` is transformed into a commandline parameter of the form `camel-case-command` and vice versa.";

$core.addMethod(
$core.method({
selector: "commandLineSwitches",
protocol: "commandline",
args: [],
source: "commandLineSwitches\x0a\x09\x22Collect all methodnames from the 'commands' protocol of the class\x0a\x09 and select the ones with only one parameter.\x0a\x09 Then remove the ':' at the end of the name.\x0a\x09 Additionally all uppercase letters are made lowercase and preceded by a '-'.\x0a\x09 Example: fallbackPage: becomes --fallback-page.\x0a\x09 Return the Array containing the commandline switches.\x22\x0a\x09| switches |\x0a\x09switches := ((self class methodsInProtocol: 'commands') collect: [ :each | each selector]).\x0a\x09switches := switches select: [ :each | each match: '^[^:]*:$'].\x0a\x09switches :=switches collect: [ :each |\x0a\x09\x09(each allButLast replace: '([A-Z])' with: '-$1') asLowercase].\x0a\x09^ switches",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "methodsInProtocol:", "class", "selector", "select:", "match:", "asLowercase", "replace:with:", "allButLast"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var switches;
return $core.withContext(function($ctx1) {
switches=[$recv($recv($self._class())._methodsInProtocol_("commands"))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._selector();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["collect:"]=1
][0];
switches=$recv(switches)._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^[^:]*:$");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
switches=$recv(switches)._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv($recv($recv(each)._allButLast())._replace_with_("([A-Z])","-$1"))._asLowercase();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return switches;
}, function($ctx1) {$ctx1.fill(self,"commandLineSwitches",{switches:switches})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "config:",
protocol: "commands",
args: ["args"],
source: "config: args\x0a\x09Configurator new start",
referencedClasses: ["Configurator"],
pragmas: [],
messageSends: ["start", "new"]
}, function ($methodClass){ return function (args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Configurator)._new())._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"config:",{args:args})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "handleArguments:",
protocol: "commandline",
args: ["args"],
source: "handleArguments: args\x0a\x09| selector |\x0a\x0a\x09selector := self selectorForCommandLineSwitch: (args first).\x0a\x09args remove: args first.\x0a\x09self perform: selector  withArguments: { args }",
referencedClasses: [],
pragmas: [],
messageSends: ["selectorForCommandLineSwitch:", "first", "remove:", "perform:withArguments:"]
}, function ($methodClass){ return function (args){
var self=this,$self=this;
var selector;
return $core.withContext(function($ctx1) {
selector=$self._selectorForCommandLineSwitch_([$recv(args)._first()
,$ctx1.sendIdx["first"]=1
][0]);
$recv(args)._remove_($recv(args)._first());
$self._perform_withArguments_(selector,[args]);
return self;
}, function($ctx1) {$ctx1.fill(self,"handleArguments:",{args:args,selector:selector})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "help:",
protocol: "commands",
args: ["args"],
source: "help: args\x0a\x09Transcript show: 'Available commands'.\x0a\x09self commandLineSwitches do: [ :each | console log: each ]",
referencedClasses: ["Transcript"],
pragmas: [],
messageSends: ["show:", "do:", "commandLineSwitches", "log:"]
}, function ($methodClass){ return function (args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($globals.Transcript)._show_("Available commands");
$recv($self._commandLineSwitches())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(console)._log_(each);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"help:",{args:args})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "init:",
protocol: "commands",
args: ["args"],
source: "init: args\x0a\x09Initer new start",
referencedClasses: ["Initer"],
pragmas: [],
messageSends: ["start", "new"]
}, function ($methodClass){ return function (args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($globals.Initer)._new())._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"init:",{args:args})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "main",
protocol: "startup",
args: [],
source: "main\x0a\x09\x22Main entry point for Amber applications.\x0a\x09Parses commandline arguments and starts the according subprogram.\x22\x0a\x09| args packageJSON |\x0a\x09\x0a\x09packageJSON := require value: '../package.json'.\x0a\x09Transcript show: 'Welcome to Amber CLI version ', packageJSON version, ' (Amber ', Smalltalk version, ', NodeJS ', process versions node, ').'.\x0a\x0a\x09args := process argv.\x0a\x09\x22Remove the first args which contain the path to the node executable and the script file.\x22\x0a\x09args removeFrom: 1 to: 2.\x0a\x09\x0a\x09args\x0a\x09\x09ifEmpty: [self help: nil]\x0a\x09\x09ifNotEmpty: [^self handleArguments: args]",
referencedClasses: ["Transcript", "Smalltalk"],
pragmas: [],
messageSends: ["value:", "show:", ",", "version", "node", "versions", "argv", "removeFrom:to:", "ifEmpty:ifNotEmpty:", "help:", "handleArguments:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var args,packageJSON;
return $core.withContext(function($ctx1) {
var $early={};
try {
packageJSON=$recv(require)._value_("../package.json");
$recv($globals.Transcript)._show_([$recv([$recv([$recv([$recv([$recv("Welcome to Amber CLI version ".__comma([$recv(packageJSON)._version()
,$ctx1.sendIdx["version"]=1
][0])).__comma(" (Amber ")
,$ctx1.sendIdx[","]=5
][0]).__comma($recv($globals.Smalltalk)._version())
,$ctx1.sendIdx[","]=4
][0]).__comma(", NodeJS ")
,$ctx1.sendIdx[","]=3
][0]).__comma($recv($recv(process)._versions())._node())
,$ctx1.sendIdx[","]=2
][0]).__comma(").")
,$ctx1.sendIdx[","]=1
][0]);
args=$recv(process)._argv();
$recv(args)._removeFrom_to_((1),(2));
$recv(args)._ifEmpty_ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $self._help_(nil);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
throw $early=[$self._handleArguments_(args)];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"main",{args:args,packageJSON:packageJSON})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "repl:",
protocol: "commands",
args: ["args"],
source: "repl: args\x0a\x09^ Repl new createInterface",
referencedClasses: ["Repl"],
pragmas: [],
messageSends: ["createInterface", "new"]
}, function ($methodClass){ return function (args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.Repl)._new())._createInterface();
}, function($ctx1) {$ctx1.fill(self,"repl:",{args:args})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "selectorForCommandLineSwitch:",
protocol: "commandline",
args: ["aSwitch"],
source: "selectorForCommandLineSwitch: aSwitch\x0a\x09\x22Add ':' at the end and replace all occurences of a lowercase letter preceded by a '-' with the Uppercase letter.\x0a\x09 Example: fallback-page becomes fallbackPage:.\x0a\x09 If no correct selector is found return 'help:'\x22\x0a\x09 | command selector |\x0a\x0a\x09 (self commandLineSwitches includes: aSwitch)\x0a\x09 ifTrue: [ selector := (aSwitch replace: '-[a-z]' with: [ :each | each second asUppercase ]), ':']\x0a\x09 ifFalse: [ selector := 'help:' ].\x0a\x09^ selector",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "includes:", "commandLineSwitches", ",", "replace:with:", "asUppercase", "second"]
}, function ($methodClass){ return function (aSwitch){
var self=this,$self=this;
var command,selector;
return $core.withContext(function($ctx1) {
if($core.assert($recv($self._commandLineSwitches())._includes_(aSwitch))){
selector=$recv($recv(aSwitch)._replace_with_("-[a-z]",(function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._second())._asUppercase();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}))).__comma(":");
selector;
} else {
selector="help:";
selector;
}
return selector;
}, function($ctx1) {$ctx1.fill(self,"selectorForCommandLineSwitch:",{aSwitch:aSwitch,command:command,selector:selector})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "serve:",
protocol: "commands",
args: ["args"],
source: "serve: args\x0a\x09^ (FileServer createServerWithArguments: args) start",
referencedClasses: ["FileServer"],
pragmas: [],
messageSends: ["start", "createServerWithArguments:"]
}, function ($methodClass){ return function (args){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.FileServer)._createServerWithArguments_(args))._start();
}, function($ctx1) {$ctx1.fill(self,"serve:",{args:args})});
}; }),
$globals.AmberCli.a$cls);

$core.addMethod(
$core.method({
selector: "version:",
protocol: "commands",
args: ["arguments"],
source: "version: arguments",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (arguments_){
var self=this,$self=this;
return self;

}; }),
$globals.AmberCli.a$cls);


$core.addClass("BaseFileManipulator", $globals.Object, "AmberCli");
$core.setSlots($globals.BaseFileManipulator, ["path", "fs"]);
$core.addMethod(
$core.method({
selector: "dirname",
protocol: "private",
args: [],
source: "dirname\x0a\x09<inlineJS: 'return __dirname'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return __dirname"]]],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return __dirname;
return self;
}, function($ctx1) {$ctx1.fill(self,"dirname",{})});
}; }),
$globals.BaseFileManipulator);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09path := require value: 'path'.\x0a\x09fs := require value: 'fs'",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "value:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.path=[$recv(require)._value_("path")
,$ctx1.sendIdx["value:"]=1
][0];
$self.fs=$recv(require)._value_("fs");
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.BaseFileManipulator);

$core.addMethod(
$core.method({
selector: "rootDirname",
protocol: "private",
args: [],
source: "rootDirname\x0a\x09^ path join: self dirname with: '..'",
referencedClasses: [],
pragmas: [],
messageSends: ["join:with:", "dirname"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.path)._join_with_($self._dirname(),"..");
}, function($ctx1) {$ctx1.fill(self,"rootDirname",{})});
}; }),
$globals.BaseFileManipulator);



$core.addClass("Configurator", $globals.BaseFileManipulator, "AmberCli");
$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Configurator);

$core.addMethod(
$core.method({
selector: "start",
protocol: "action",
args: [],
source: "start\x0a\x09self writeConfigThenDo: [ :err | err\x0a\x09\x09ifNotNil: [ process exit: 111 ]\x0a\x09\x09ifNil: [ process exit ]]",
referencedClasses: [],
pragmas: [],
messageSends: ["writeConfigThenDo:", "ifNotNil:ifNil:", "exit:", "exit"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._writeConfigThenDo_((function(err){
return $core.withContext(function($ctx2) {
if(err == null || err.a$nil){
return $recv(process)._exit();
} else {
return $recv(process)._exit_((111));
}
}, function($ctx2) {$ctx2.fillBlock({err:err},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{})});
}; }),
$globals.Configurator);

$core.addMethod(
$core.method({
selector: "writeConfigThenDo:",
protocol: "action",
args: ["aBlock"],
source: "writeConfigThenDo: aBlock\x0a\x09(require value: '@ambers/sdk') configBuilder\x0a\x09\x09writeConfig: process cwd\x0a\x09\x09toFile: 'config.js'\x0a\x09\x09thenDo: aBlock",
referencedClasses: [],
pragmas: [],
messageSends: ["writeConfig:toFile:thenDo:", "configBuilder", "value:", "cwd"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv($recv(require)._value_("@ambers/sdk"))._configBuilder())._writeConfig_toFile_thenDo_($recv(process)._cwd(),"config.js",aBlock);
return self;
}, function($ctx1) {$ctx1.fill(self,"writeConfigThenDo:",{aBlock:aBlock})});
}; }),
$globals.Configurator);



$core.addClass("FileServer", $globals.BaseFileManipulator, "AmberCli");
$core.setSlots($globals.FileServer, ["http", "url", "host", "port", "basePath", "util", "username", "password", "fallbackPage"]);
$globals.FileServer.comment="I am the Amber Smalltalk FileServer.\x0aMy runtime requirement is a functional Node.js executable.\x0a\x0aTo start a FileServer instance on port `4000` use the following code:\x0a\x0a    FileServer new start\x0a\x0aA parameterized instance can be created with the following code:\x0a\x0a    FileServer createServerWithArguments: options\x0a\x0aHere, `options` is an array of commandline style strings each followed by a value e.g. `#('--port', '6000', '--host', '0.0.0.0')`.\x0aA list of all available parameters can be printed to the commandline by passing `--help` as parameter.\x0aSee the `Options` section for further details on how options are mapped to instance methods.\x0a\x0aAfter startup FileServer checks if the directory layout required by Amber is present and logs a warning on absence.\x0a\x0a\x0a## Options\x0a\x0aEach option is of the form `--some-option-string` which is transformed into a selector of the format `someOptionString:`.\x0aThe trailing `--` gets removed, each `-[a-z]` gets transformed into the according uppercase letter, and a `:` is appended to create a selector which takes a single argument.\x0aAfterwards, the selector gets executed on the `FileServer` instance with the value following in the options array as parameter.\x0a\x0a## Adding new commandline parameters\x0a\x0aAdding new commandline parameters to `FileServer` is as easy as adding a new single parameter method to the `accessing` protocol.";
$core.addMethod(
$core.method({
selector: "base64Decode:",
protocol: "private",
args: ["aString"],
source: "base64Decode: aString\x0a\x09<inlineJS: 'return (new Buffer(aString, \x22base64\x22).toString())'>",
referencedClasses: [],
pragmas: [["inlineJS:", ["return (new Buffer(aString, \x22base64\x22).toString())"]]],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return (new Buffer(aString, "base64").toString());
return self;
}, function($ctx1) {$ctx1.fill(self,"base64Decode:",{aString:aString})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "basePath",
protocol: "accessing",
args: [],
source: "basePath\x0a\x09^ basePath ifNil: [self class defaultBasePath]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "defaultBasePath", "class"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.basePath;
if($1 == null || $1.a$nil){
return $recv($self._class())._defaultBasePath();
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"basePath",{})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "basePath:",
protocol: "accessing",
args: ["aString"],
source: "basePath: aString\x0a\x09basePath := aString.\x0a\x09self validateBasePath.",
referencedClasses: [],
pragmas: [],
messageSends: ["validateBasePath"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.basePath=aString;
$self._validateBasePath();
return self;
}, function($ctx1) {$ctx1.fill(self,"basePath:",{aString:aString})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "checkDirectoryLayout",
protocol: "initialization",
args: [],
source: "checkDirectoryLayout\x0a\x09(fs existsSync:\x09(self withBasePath: 'index.html')) ifFalse: [\x0a\x09\x09console warn: 'Warning: project directory does not contain index.html.'.\x0a\x09\x09console warn: '    You can specify the directory containing index.html with --base-path.'.\x0a\x09\x09console warn: '    You can also specify a page to be served by default,'.\x0a\x09\x09console warn: '    for all paths that do not map to a file, with --fallback-page.'].",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "existsSync:", "withBasePath:", "warn:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv($self.fs)._existsSync_($self._withBasePath_("index.html")))){
[$recv(console)._warn_("Warning: project directory does not contain index.html.")
,$ctx1.sendIdx["warn:"]=1
][0];
[$recv(console)._warn_("    You can specify the directory containing index.html with --base-path.")
,$ctx1.sendIdx["warn:"]=2
][0];
[$recv(console)._warn_("    You can also specify a page to be served by default,")
,$ctx1.sendIdx["warn:"]=3
][0];
$recv(console)._warn_("    for all paths that do not map to a file, with --fallback-page.");
}
return self;
}, function($ctx1) {$ctx1.fill(self,"checkDirectoryLayout",{})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "fallbackPage",
protocol: "accessing",
args: [],
source: "fallbackPage\x0a\x09^ fallbackPage",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.fallbackPage;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "fallbackPage:",
protocol: "accessing",
args: ["aString"],
source: "fallbackPage: aString\x0a\x09fallbackPage := aString",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
$self.fallbackPage=aString;
return self;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handleGETRequest:respondTo:",
protocol: "request handling",
args: ["aRequest", "aResponse"],
source: "handleGETRequest: aRequest respondTo: aResponse\x0a\x09| uri filename |\x0a\x09uri := url parse: aRequest url.\x0a\x09filename := path join: self basePath with: uri pathname uriDecoded.\x0a\x09fs exists: filename do: [:aBoolean |\x0a\x09\x09aBoolean\x0a\x09\x09\x09ifFalse: [self respondNotFoundTo: aResponse]\x0a\x09\x09\x09ifTrue: [(fs statSync: filename) isDirectory\x0a\x09\x09\x09\x09ifTrue: [self respondDirectoryNamed: filename from: uri to: aResponse]\x0a\x09\x09\x09\x09ifFalse: [self respondFileNamed: filename to: aResponse]]]",
referencedClasses: [],
pragmas: [],
messageSends: ["parse:", "url", "join:with:", "basePath", "uriDecoded", "pathname", "exists:do:", "ifFalse:ifTrue:", "respondNotFoundTo:", "ifTrue:ifFalse:", "isDirectory", "statSync:", "respondDirectoryNamed:from:to:", "respondFileNamed:to:"]
}, function ($methodClass){ return function (aRequest,aResponse){
var self=this,$self=this;
var uri,filename;
return $core.withContext(function($ctx1) {
uri=$recv($self.url)._parse_($recv(aRequest)._url());
filename=$recv($self.path)._join_with_($self._basePath(),$recv($recv(uri)._pathname())._uriDecoded());
$recv($self.fs)._exists_do_(filename,(function(aBoolean){
return $core.withContext(function($ctx2) {
if($core.assert(aBoolean)){
if($core.assert($recv($recv($self.fs)._statSync_(filename))._isDirectory())){
return $self._respondDirectoryNamed_from_to_(filename,uri,aResponse);
} else {
return $self._respondFileNamed_to_(filename,aResponse);
}
} else {
return $self._respondNotFoundTo_(aResponse);
}
}, function($ctx2) {$ctx2.fillBlock({aBoolean:aBoolean},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"handleGETRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse,uri:uri,filename:filename})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handleOPTIONSRequest:respondTo:",
protocol: "request handling",
args: ["aRequest", "aResponse"],
source: "handleOPTIONSRequest: aRequest respondTo: aResponse\x0a\x09aResponse writeHead: 200 options: #{'Access-Control-Allow-Origin' -> '*'.\x0a\x09\x09\x09\x09\x09'Access-Control-Allow-Methods' -> 'GET, PUT, POST, DELETE, OPTIONS'.\x0a\x09\x09\x09\x09\x09'Access-Control-Allow-Headers' -> 'Content-Type, Accept'.\x0a\x09\x09\x09\x09\x09'Content-Length' -> 0.\x0a\x09\x09\x09\x09\x09'Access-Control-Max-Age' -> 10}.\x0a\x09aResponse end",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "end"]
}, function ($methodClass){ return function (aRequest,aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((200),$globals.HashedCollection._newFromPairs_(["Access-Control-Allow-Origin","*","Access-Control-Allow-Methods","GET, PUT, POST, DELETE, OPTIONS","Access-Control-Allow-Headers","Content-Type, Accept","Content-Length",(0),"Access-Control-Max-Age",(10)]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"handleOPTIONSRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handlePUTRequest:respondTo:",
protocol: "request handling",
args: ["aRequest", "aResponse"],
source: "handlePUTRequest: aRequest respondTo: aResponse\x0a\x09| file stream |\x0a\x09(self isAuthenticated: aRequest)\x0a\x09\x09ifFalse: [self respondAuthenticationRequiredTo: aResponse. ^ nil].\x0a\x0a\x09file := '.', aRequest url uriDecoded.\x0a\x09stream := fs createWriteStream: file.\x0a\x0a\x09stream on: 'error' do: [:error |\x0a\x09\x09console warn: 'Error creating WriteStream for file ', file.\x0a\x09\x09console warn: '    Did you forget to create the necessary directory in your project (often /src)?'.\x0a\x09\x09console warn: '    The exact error is: ', error asString.\x0a\x09\x09self respondNotCreatedTo: aResponse].\x0a\x0a\x09stream on: 'close' do: [\x0a\x09\x09self respondCreatedTo: aResponse].\x0a\x0a\x09aRequest setEncoding: 'utf8'.\x0a\x09aRequest on: 'data' do: [:data |\x0a\x09\x09stream write: data].\x0a\x0a\x09aRequest on: 'end' do: [\x0a\x09\x09stream writable ifTrue: [stream end]]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "isAuthenticated:", "respondAuthenticationRequiredTo:", ",", "uriDecoded", "url", "createWriteStream:", "on:do:", "warn:", "asString", "respondNotCreatedTo:", "respondCreatedTo:", "setEncoding:", "write:", "ifTrue:", "writable", "end"]
}, function ($methodClass){ return function (aRequest,aResponse){
var self=this,$self=this;
var file,stream;
return $core.withContext(function($ctx1) {
if(!$core.assert($self._isAuthenticated_(aRequest))){
$self._respondAuthenticationRequiredTo_(aResponse);
return nil;
}
file=[".".__comma($recv($recv(aRequest)._url())._uriDecoded())
,$ctx1.sendIdx[","]=1
][0];
stream=$recv($self.fs)._createWriteStream_(file);
[$recv(stream)._on_do_("error",(function(error){
return $core.withContext(function($ctx2) {
[$recv(console)._warn_(["Error creating WriteStream for file ".__comma(file)
,$ctx2.sendIdx[","]=2
][0])
,$ctx2.sendIdx["warn:"]=1
][0];
[$recv(console)._warn_("    Did you forget to create the necessary directory in your project (often /src)?")
,$ctx2.sendIdx["warn:"]=2
][0];
$recv(console)._warn_("    The exact error is: ".__comma($recv(error)._asString()));
return $self._respondNotCreatedTo_(aResponse);
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}))
,$ctx1.sendIdx["on:do:"]=1
][0];
[$recv(stream)._on_do_("close",(function(){
return $core.withContext(function($ctx2) {
return $self._respondCreatedTo_(aResponse);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}))
,$ctx1.sendIdx["on:do:"]=2
][0];
$recv(aRequest)._setEncoding_("utf8");
[$recv(aRequest)._on_do_("data",(function(data){
return $core.withContext(function($ctx2) {
return $recv(stream)._write_(data);
}, function($ctx2) {$ctx2.fillBlock({data:data},$ctx1,4)});
}))
,$ctx1.sendIdx["on:do:"]=3
][0];
$recv(aRequest)._on_do_("end",(function(){
return $core.withContext(function($ctx2) {
if($core.assert($recv(stream)._writable())){
return $recv(stream)._end();
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"handlePUTRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse,file:file,stream:stream})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "handleRequest:respondTo:",
protocol: "request handling",
args: ["aRequest", "aResponse"],
source: "handleRequest: aRequest respondTo: aResponse\x0a\x09aRequest method = 'PUT'\x0a\x09\x09ifTrue: [self handlePUTRequest: aRequest respondTo: aResponse].\x0a\x09aRequest method = 'GET'\x0a\x09\x09ifTrue:[self handleGETRequest: aRequest respondTo: aResponse].\x0a\x09aRequest method = 'OPTIONS'\x0a\x09\x09ifTrue:[self handleOPTIONSRequest: aRequest respondTo: aResponse]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "=", "method", "handlePUTRequest:respondTo:", "handleGETRequest:respondTo:", "handleOPTIONSRequest:respondTo:"]
}, function ($methodClass){ return function (aRequest,aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if($core.assert([$recv([$recv(aRequest)._method()
,$ctx1.sendIdx["method"]=1
][0]).__eq("PUT")
,$ctx1.sendIdx["="]=1
][0])){
$self._handlePUTRequest_respondTo_(aRequest,aResponse);
}
if($core.assert([$recv([$recv(aRequest)._method()
,$ctx1.sendIdx["method"]=2
][0]).__eq("GET")
,$ctx1.sendIdx["="]=2
][0])){
$self._handleGETRequest_respondTo_(aRequest,aResponse);
}
if($core.assert($recv($recv(aRequest)._method()).__eq("OPTIONS"))){
$self._handleOPTIONSRequest_respondTo_(aRequest,aResponse);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"handleRequest:respondTo:",{aRequest:aRequest,aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "host",
protocol: "accessing",
args: [],
source: "host\x0a\x09^ host",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.host;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "host:",
protocol: "accessing",
args: ["hostname"],
source: "host: hostname\x0a\x09host := hostname",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (hostname){
var self=this,$self=this;
$self.host=hostname;
return self;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09http := self require: 'http'.\x0a\x09util := self require: 'util'.\x0a\x09url := self require: 'url'.\x0a\x09host := self class defaultHost.\x0a\x09port := self class defaultPort.\x0a\x09username := nil.\x0a\x09password := nil.\x0a\x09fallbackPage := nil.",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "require:", "defaultHost", "class", "defaultPort"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.http=[$self._require_("http")
,$ctx1.sendIdx["require:"]=1
][0];
$self.util=[$self._require_("util")
,$ctx1.sendIdx["require:"]=2
][0];
$self.url=$self._require_("url");
$self.host=$recv([$self._class()
,$ctx1.sendIdx["class"]=1
][0])._defaultHost();
$self.port=$recv($self._class())._defaultPort();
$self.username=nil;
$self.password=nil;
$self.fallbackPage=nil;
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "isAuthenticated:",
protocol: "private",
args: ["aRequest"],
source: "isAuthenticated: aRequest\x0a\x09\x22Basic HTTP Auth: http://stackoverflow.com/a/5957629/293175\x0a\x09 and https://gist.github.com/1686663\x22\x0a\x09| header token auth parts|\x0a\x0a\x09(username isNil and: [password isNil]) ifTrue: [^ true].\x0a\x0a\x09\x22get authentication header\x22\x0a\x09header := (aRequest headers at: 'authorization') ifNil:[''].\x0a\x09header\x0a\x09ifEmpty: [^ false]\x0a\x09ifNotEmpty: [\x0a\x09\x09\x22get authentication token\x22\x0a\x09\x09token := (header tokenize: ' ') ifNil:[''].\x0a\x09\x09\x22convert back from base64\x22\x0a\x09\x09auth := self base64Decode: (token at: 2).\x0a\x09\x09\x22split token at colon\x22\x0a\x09\x09parts := auth tokenize: ':'.\x0a\x0a\x09\x09((username = (parts at: 1)) and: [password = (parts at: 2)])\x0a\x09\x09\x09ifTrue: [^ true]\x0a\x09\x09\x09ifFalse: [^ false]\x0a\x09].",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "and:", "isNil", "ifNil:", "at:", "headers", "ifEmpty:ifNotEmpty:", "tokenize:", "base64Decode:", "ifTrue:ifFalse:", "="]
}, function ($methodClass){ return function (aRequest){
var self=this,$self=this;
var header,token,auth,parts;
return $core.withContext(function($ctx1) {
var $1,$2,$3,$4;
var $early={};
try {
if($core.assert([$recv($self.username)._isNil()
,$ctx1.sendIdx["isNil"]=1
][0])){
$1=$recv($self.password)._isNil();
} else {
$1=false;
}
if($core.assert($1)){
return true;
}
$2=[$recv($recv(aRequest)._headers())._at_("authorization")
,$ctx1.sendIdx["at:"]=1
][0];
if($2 == null || $2.a$nil){
header="";
} else {
header=$2;
}
$recv(header)._ifEmpty_ifNotEmpty_((function(){
throw $early=[false];

}),(function(){
return $core.withContext(function($ctx2) {
$3=[$recv(header)._tokenize_(" ")
,$ctx2.sendIdx["tokenize:"]=1
][0];
if($3 == null || $3.a$nil){
token="";
} else {
token=$3;
}
auth=$self._base64Decode_([$recv(token)._at_((2))
,$ctx2.sendIdx["at:"]=2
][0]);
parts=$recv(auth)._tokenize_(":");
if($core.assert([$recv($self.username).__eq([$recv(parts)._at_((1))
,$ctx2.sendIdx["at:"]=3
][0])
,$ctx2.sendIdx["="]=1
][0])){
$4=$recv($self.password).__eq($recv(parts)._at_((2)));
} else {
$4=false;
}
if($core.assert($4)){
throw $early=[true];
} else {
throw $early=[false];
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"isAuthenticated:",{aRequest:aRequest,header:header,token:token,auth:auth,parts:parts})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "password:",
protocol: "accessing",
args: ["aPassword"],
source: "password: aPassword\x0a\x09password := aPassword.",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aPassword){
var self=this,$self=this;
$self.password=aPassword;
return self;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "port",
protocol: "accessing",
args: [],
source: "port\x0a\x09^ port",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.port;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "port:",
protocol: "accessing",
args: ["aNumber"],
source: "port: aNumber\x0a\x09port := aNumber",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aNumber){
var self=this,$self=this;
$self.port=aNumber;
return self;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "require:",
protocol: "private",
args: ["aModuleString"],
source: "require: aModuleString\x0a\x09\x22call to the require function\x22\x0a\x09^require value: aModuleString",
referencedClasses: [],
pragmas: [],
messageSends: ["value:"]
}, function ($methodClass){ return function (aModuleString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(require)._value_(aModuleString);
}, function($ctx1) {$ctx1.fill(self,"require:",{aModuleString:aModuleString})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondAuthenticationRequiredTo:",
protocol: "request handling",
args: ["aResponse"],
source: "respondAuthenticationRequiredTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 401 options: #{'WWW-Authenticate' -> 'Basic realm=\x22Secured Developer Area\x22'};\x0a\x09\x09write: '<html><body>Authentication needed</body></html>';\x0a\x09\x09end.",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "write:", "end"]
}, function ($methodClass){ return function (aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((401),$globals.HashedCollection._newFromPairs_(["WWW-Authenticate","Basic realm=\x22Secured Developer Area\x22"]));
$recv(aResponse)._write_("<html><body>Authentication needed</body></html>");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondAuthenticationRequiredTo:",{aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondCreatedTo:",
protocol: "request handling",
args: ["aResponse"],
source: "respondCreatedTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 201 options: #{'Content-Type' -> 'text/plain'. 'Access-Control-Allow-Origin' -> '*'};\x0a\x09\x09end.",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "end"]
}, function ($methodClass){ return function (aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((201),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain","Access-Control-Allow-Origin","*"]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondCreatedTo:",{aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondDirectoryNamed:from:to:",
protocol: "request handling",
args: ["aDirname", "aUrl", "aResponse"],
source: "respondDirectoryNamed: aDirname from: aUrl to: aResponse\x0a\x09(aUrl pathname endsWith: '/')\x0a\x09\x09ifTrue: [self respondFileNamed: aDirname, 'index.html' to: aResponse]\x0a\x09\x09ifFalse: [self respondRedirect: aUrl pathname, '/', (aUrl search ifNil: ['']) to: aResponse]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:ifFalse:", "endsWith:", "pathname", "respondFileNamed:to:", ",", "respondRedirect:to:", "ifNil:", "search"]
}, function ($methodClass){ return function (aDirname,aUrl,aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2,$3;
if($core.assert($recv([$recv(aUrl)._pathname()
,$ctx1.sendIdx["pathname"]=1
][0])._endsWith_("/"))){
$self._respondFileNamed_to_([$recv(aDirname).__comma("index.html")
,$ctx1.sendIdx[","]=1
][0],aResponse);
} else {
$1=$recv($recv(aUrl)._pathname()).__comma("/");
$2=$recv(aUrl)._search();
if($2 == null || $2.a$nil){
$3="";
} else {
$3=$2;
}
$self._respondRedirect_to_([$recv($1).__comma($3)
,$ctx1.sendIdx[","]=2
][0],aResponse);
}
return self;
}, function($ctx1) {$ctx1.fill(self,"respondDirectoryNamed:from:to:",{aDirname:aDirname,aUrl:aUrl,aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondFileNamed:to:",
protocol: "request handling",
args: ["aFilename", "aResponse"],
source: "respondFileNamed: aFilename to: aResponse\x0a\x09| type filename |\x0a\x0a\x09filename := aFilename.\x0a\x0a\x09fs readFile: filename do: [:ex :file |\x0a\x09\x09ex notNil \x0a\x09\x09\x09ifTrue: [\x0a\x09\x09\x09\x09console log: filename, ' does not exist'.\x0a\x09\x09\x09\x09self respondNotFoundTo: aResponse]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09type := self class mimeTypeFor: filename.\x0a\x09\x09\x09\x09type = 'application/javascript'\x0a\x09\x09\x09\x09\x09ifTrue: [ type:=type,';charset=utf-8' ].\x0a\x09\x09\x09\x09aResponse \x0a\x09\x09\x09\x09\x09writeHead: 200 options:  #{'Content-Type' -> type};\x0a\x09\x09\x09\x09\x09write: file encoding: 'binary';\x0a\x09\x09\x09\x09\x09end]]",
referencedClasses: [],
pragmas: [],
messageSends: ["readFile:do:", "ifTrue:ifFalse:", "notNil", "log:", ",", "respondNotFoundTo:", "mimeTypeFor:", "class", "ifTrue:", "=", "writeHead:options:", "write:encoding:", "end"]
}, function ($methodClass){ return function (aFilename,aResponse){
var self=this,$self=this;
var type,filename;
return $core.withContext(function($ctx1) {
filename=aFilename;
$recv($self.fs)._readFile_do_(filename,(function(ex,file){
return $core.withContext(function($ctx2) {
if($core.assert($recv(ex)._notNil())){
$recv(console)._log_([$recv(filename).__comma(" does not exist")
,$ctx2.sendIdx[","]=1
][0]);
return $self._respondNotFoundTo_(aResponse);
} else {
type=$recv($self._class())._mimeTypeFor_(filename);
if($core.assert($recv(type).__eq("application/javascript"))){
type=$recv(type).__comma(";charset=utf-8");
type;
}
$recv(aResponse)._writeHead_options_((200),$globals.HashedCollection._newFromPairs_(["Content-Type",type]));
$recv(aResponse)._write_encoding_(file,"binary");
return $recv(aResponse)._end();
}
}, function($ctx2) {$ctx2.fillBlock({ex:ex,file:file},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"respondFileNamed:to:",{aFilename:aFilename,aResponse:aResponse,type:type,filename:filename})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondInternalErrorTo:",
protocol: "request handling",
args: ["aResponse"],
source: "respondInternalErrorTo: aResponse\x0a\x09aResponse \x0a\x09\x09writeHead: 500 options: #{'Content-Type' -> 'text/plain'};\x0a\x09\x09write: '500 Internal server error';\x0a\x09\x09end",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "write:", "end"]
}, function ($methodClass){ return function (aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((500),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain"]));
$recv(aResponse)._write_("500 Internal server error");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondInternalErrorTo:",{aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondNotCreatedTo:",
protocol: "request handling",
args: ["aResponse"],
source: "respondNotCreatedTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 400 options: #{'Content-Type' -> 'text/plain'};\x0a\x09\x09write: 'File could not be created. Did you forget to create the src directory on the server?';\x0a\x09\x09end.",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "write:", "end"]
}, function ($methodClass){ return function (aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((400),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain"]));
$recv(aResponse)._write_("File could not be created. Did you forget to create the src directory on the server?");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondNotCreatedTo:",{aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondNotFoundTo:",
protocol: "request handling",
args: ["aResponse"],
source: "respondNotFoundTo: aResponse\x0a\x09self fallbackPage isNil ifFalse: [^self respondFileNamed: self fallbackPage to: aResponse].\x0a\x09aResponse \x0a\x09\x09writeHead: 404 options: #{'Content-Type' -> 'text/html'};\x0a\x09\x09write: '<html><body><p>404 Not found</p>';\x0a\x09\x09write: '<p>Did you forget to put an index.html file into the directory which is served by \x22bin/amber serve\x22? To solve this you can:<ul>';\x0a\x09\x09write: '<li>create an index.html in the served directory.</li>';\x0a\x09\x09write: '<li>can also specify the location of a page to be served whenever path does not resolve to a file with the \x22--fallback-page\x22 option.</li>';\x0a\x09\x09write: '<li>change the directory to be served with the \x22--base-path\x22 option.</li>';\x0a\x09\x09write: '</ul></p></body></html>';\x0a\x09\x09end",
referencedClasses: [],
pragmas: [],
messageSends: ["ifFalse:", "isNil", "fallbackPage", "respondFileNamed:to:", "writeHead:options:", "write:", "end"]
}, function ($methodClass){ return function (aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
if(!$core.assert($recv([$self._fallbackPage()
,$ctx1.sendIdx["fallbackPage"]=1
][0])._isNil())){
return $self._respondFileNamed_to_($self._fallbackPage(),aResponse);
}
$recv(aResponse)._writeHead_options_((404),$globals.HashedCollection._newFromPairs_(["Content-Type","text/html"]));
[$recv(aResponse)._write_("<html><body><p>404 Not found</p>")
,$ctx1.sendIdx["write:"]=1
][0];
[$recv(aResponse)._write_("<p>Did you forget to put an index.html file into the directory which is served by \x22bin/amber serve\x22? To solve this you can:<ul>")
,$ctx1.sendIdx["write:"]=2
][0];
[$recv(aResponse)._write_("<li>create an index.html in the served directory.</li>")
,$ctx1.sendIdx["write:"]=3
][0];
[$recv(aResponse)._write_("<li>can also specify the location of a page to be served whenever path does not resolve to a file with the \x22--fallback-page\x22 option.</li>")
,$ctx1.sendIdx["write:"]=4
][0];
[$recv(aResponse)._write_("<li>change the directory to be served with the \x22--base-path\x22 option.</li>")
,$ctx1.sendIdx["write:"]=5
][0];
$recv(aResponse)._write_("</ul></p></body></html>");
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondNotFoundTo:",{aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondOKTo:",
protocol: "request handling",
args: ["aResponse"],
source: "respondOKTo: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 200 options: #{'Content-Type' -> 'text/plain'. 'Access-Control-Allow-Origin' -> '*'};\x0a\x09\x09end.",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "end"]
}, function ($methodClass){ return function (aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((200),$globals.HashedCollection._newFromPairs_(["Content-Type","text/plain","Access-Control-Allow-Origin","*"]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondOKTo:",{aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "respondRedirect:to:",
protocol: "request handling",
args: ["aString", "aResponse"],
source: "respondRedirect: aString to: aResponse\x0a\x09aResponse\x0a\x09\x09writeHead: 303 options: #{'Location' -> aString};\x0a\x09\x09end.",
referencedClasses: [],
pragmas: [],
messageSends: ["writeHead:options:", "end"]
}, function ($methodClass){ return function (aString,aResponse){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(aResponse)._writeHead_options_((303),$globals.HashedCollection._newFromPairs_(["Location",aString]));
$recv(aResponse)._end();
return self;
}, function($ctx1) {$ctx1.fill(self,"respondRedirect:to:",{aString:aString,aResponse:aResponse})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "start",
protocol: "starting",
args: [],
source: "start\x0a\x09\x22Checks if required directory layout is present (issue warning if not).\x0a\x09 Afterwards start the server.\x22\x0a\x09self checkDirectoryLayout.\x0a\x09(http createServer: [:request :response |\x0a\x09      self handleRequest: request respondTo: response])\x0a\x09      on: 'error' do: [:error | console log: 'Error starting server: ', error asString];\x0a\x09      on: 'listening' do: [console log: 'Starting file server on http://', self host, ':', self port asString];\x0a\x09      listen: self port host: self host.",
referencedClasses: [],
pragmas: [],
messageSends: ["checkDirectoryLayout", "on:do:", "createServer:", "handleRequest:respondTo:", "log:", ",", "asString", "host", "port", "listen:host:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$self._checkDirectoryLayout();
$1=$recv($self.http)._createServer_((function(request,response){
return $core.withContext(function($ctx2) {
return $self._handleRequest_respondTo_(request,response);
}, function($ctx2) {$ctx2.fillBlock({request:request,response:response},$ctx1,1)});
}));
[$recv($1)._on_do_("error",(function(error){
return $core.withContext(function($ctx2) {
return [$recv(console)._log_(["Error starting server: ".__comma([$recv(error)._asString()
,$ctx2.sendIdx["asString"]=1
][0])
,$ctx2.sendIdx[","]=1
][0])
,$ctx2.sendIdx["log:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,2)});
}))
,$ctx1.sendIdx["on:do:"]=1
][0];
$recv($1)._on_do_("listening",(function(){
return $core.withContext(function($ctx2) {
return $recv(console)._log_([$recv([$recv("Starting file server on http://".__comma([$self._host()
,$ctx2.sendIdx["host"]=1
][0])).__comma(":")
,$ctx2.sendIdx[","]=3
][0]).__comma($recv([$self._port()
,$ctx2.sendIdx["port"]=1
][0])._asString())
,$ctx2.sendIdx[","]=2
][0]);
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
$recv($1)._listen_host_($self._port(),$self._host());
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "startOn:",
protocol: "starting",
args: ["aPort"],
source: "startOn: aPort\x0a\x09self port: aPort.\x0a\x09self start",
referencedClasses: [],
pragmas: [],
messageSends: ["port:", "start"]
}, function ($methodClass){ return function (aPort){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self._port_(aPort);
$self._start();
return self;
}, function($ctx1) {$ctx1.fill(self,"startOn:",{aPort:aPort})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "username:",
protocol: "accessing",
args: ["aUsername"],
source: "username: aUsername\x0a\x09username := aUsername.",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (aUsername){
var self=this,$self=this;
$self.username=aUsername;
return self;

}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "validateBasePath",
protocol: "private",
args: [],
source: "validateBasePath\x0a\x09\x22The basePath must be an existing directory. \x22\x0a\x09fs stat: self basePath then: [ :err :stat | err\x0a\x09\x09ifNil: [ stat isDirectory ifFalse: [ console warn: 'Warning: --base-path parameter ' , self basePath , ' is not a directory.' ]]\x0a\x09\x09ifNotNil: [ console warn: 'Warning: path at --base-path parameter ' , self basePath , ' does not exist.'  ]].",
referencedClasses: [],
pragmas: [],
messageSends: ["stat:then:", "basePath", "ifNil:ifNotNil:", "ifFalse:", "isDirectory", "warn:", ","]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.fs)._stat_then_([$self._basePath()
,$ctx1.sendIdx["basePath"]=1
][0],(function(err,stat){
return $core.withContext(function($ctx2) {
if(err == null || err.a$nil){
if(!$core.assert($recv(stat)._isDirectory())){
return [$recv(console)._warn_([$recv(["Warning: --base-path parameter ".__comma([$self._basePath()
,$ctx2.sendIdx["basePath"]=2
][0])
,$ctx2.sendIdx[","]=2
][0]).__comma(" is not a directory.")
,$ctx2.sendIdx[","]=1
][0])
,$ctx2.sendIdx["warn:"]=1
][0];
}
} else {
return $recv(console)._warn_([$recv("Warning: path at --base-path parameter ".__comma($self._basePath())).__comma(" does not exist.")
,$ctx2.sendIdx[","]=3
][0]);
}
}, function($ctx2) {$ctx2.fillBlock({err:err,stat:stat},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"validateBasePath",{})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "withBasePath:",
protocol: "private",
args: ["aBaseRelativePath"],
source: "withBasePath: aBaseRelativePath\x0a\x09\x22return a file path which is relative to the basePath.\x22\x0a\x09^ path join: self basePath with: aBaseRelativePath",
referencedClasses: [],
pragmas: [],
messageSends: ["join:with:", "basePath"]
}, function ($methodClass){ return function (aBaseRelativePath){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self.path)._join_with_($self._basePath(),aBaseRelativePath);
}, function($ctx1) {$ctx1.fill(self,"withBasePath:",{aBaseRelativePath:aBaseRelativePath})});
}; }),
$globals.FileServer);

$core.addMethod(
$core.method({
selector: "writeData:toFileNamed:",
protocol: "private",
args: ["data", "aFilename"],
source: "writeData: data toFileNamed: aFilename\x0a\x09console log: aFilename",
referencedClasses: [],
pragmas: [],
messageSends: ["log:"]
}, function ($methodClass){ return function (data,aFilename){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_(aFilename);
return self;
}, function($ctx1) {$ctx1.fill(self,"writeData:toFileNamed:",{data:data,aFilename:aFilename})});
}; }),
$globals.FileServer);


$core.setSlots($globals.FileServer.a$cls, ["mimeTypes"]);
$core.addMethod(
$core.method({
selector: "commandLineSwitches",
protocol: "accessing",
args: [],
source: "commandLineSwitches\x0a\x09\x22Collect all methodnames from the 'accessing' protocol\x0a\x09 and select the ones with only one parameter.\x0a\x09 Then remove the ':' at the end of the name\x0a\x09 and add a '--' at the beginning.\x0a\x09 Additionally all uppercase letters are made lowercase and preceded by a '-'.\x0a\x09 Example: fallbackPage: becomes --fallback-page.\x0a\x09 Return the Array containing the commandline switches.\x22\x0a\x09| switches |\x0a\x09switches := ((self methodsInProtocol: 'accessing') collect: [ :each | each selector]).\x0a\x09switches := switches select: [ :each | each match: '^[^:]*:$'].\x0a\x09switches :=switches collect: [ :each |\x0a\x09\x09(each allButLast replace: '([A-Z])' with: '-$1') asLowercase replace: '^([a-z])' with: '--$1' ].\x0a\x09^ switches",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "methodsInProtocol:", "selector", "select:", "match:", "replace:with:", "asLowercase", "allButLast"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var switches;
return $core.withContext(function($ctx1) {
switches=[$recv($self._methodsInProtocol_("accessing"))._collect_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._selector();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["collect:"]=1
][0];
switches=$recv(switches)._select_((function(each){
return $core.withContext(function($ctx2) {
return $recv(each)._match_("^[^:]*:$");
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,2)});
}));
switches=$recv(switches)._collect_((function(each){
return $core.withContext(function($ctx2) {
return [$recv($recv($recv($recv(each)._allButLast())._replace_with_("([A-Z])","-$1"))._asLowercase())._replace_with_("^([a-z])","--$1")
,$ctx2.sendIdx["replace:with:"]=1
][0];
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,3)});
}));
return switches;
}, function($ctx1) {$ctx1.fill(self,"commandLineSwitches",{switches:switches})});
}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "createServerWithArguments:",
protocol: "initialization",
args: ["options"],
source: "createServerWithArguments: options\x0a\x09\x22If options are empty return a default FileServer instance.\x0a\x09 If options are given loop through them and set the passed in values\x0a\x09 on the FileServer instance.\x0a\x09 \x0a\x09 Commanline options map directly to methods in the 'accessing' protocol\x0a\x09 taking one parameter.\x0a\x09 Adding a method to this protocol makes it directly settable through\x0a\x09 command line options.\x0a\x09 \x22\x0a\x09| server popFront front optionName optionValue switches |\x0a\x0a\x09switches := self commandLineSwitches.\x0a\x0a\x09server := self new.\x0a\x0a\x09options ifEmpty: [^server].\x0a\x0a\x09(options size even) ifFalse: [\x0a\x09\x09console log: 'Using default parameters.'.\x0a\x09\x09console log: 'Wrong commandline options or not enough arguments for: ' , (' ' join: options).\x0a\x09\x09console log: 'Use any of the following ones: ', (',' join: switches).\x0a\x09\x09^server].\x0a\x0a\x09popFront := [:args |\x0a\x09\x09front := args first.\x0a\x09\x09args remove: front.\x0a\x09\x09front].\x0a\x0a\x09[options notEmpty] whileTrue: [\x0a\x09\x09optionName  := popFront value: options.\x0a\x09\x09optionValue := popFront value: options.\x0a\x0a\x09\x09(switches includes: optionName) ifTrue: [\x0a\x09\x09\x09optionName := self selectorForCommandLineSwitch: optionName.\x0a\x09\x09\x09server perform: optionName withArguments: { optionValue } ]\x0a\x09\x09\x09ifFalse: [\x0a\x09\x09\x09\x09console log: optionName, ' is not a valid commandline option'.\x0a\x09\x09\x09\x09console log: 'Use any of the following ones: ', (',' join: switches) ]].\x0a\x09^ server.",
referencedClasses: [],
pragmas: [],
messageSends: ["commandLineSwitches", "new", "ifEmpty:", "ifFalse:", "even", "size", "log:", ",", "join:", "first", "remove:", "whileTrue:", "notEmpty", "value:", "ifTrue:ifFalse:", "includes:", "selectorForCommandLineSwitch:", "perform:withArguments:"]
}, function ($methodClass){ return function (options){
var self=this,$self=this;
var server,popFront,front,optionName,optionValue,switches;
return $core.withContext(function($ctx1) {
var $early={};
try {
switches=$self._commandLineSwitches();
server=$self._new();
$recv(options)._ifEmpty_((function(){
throw $early=[server];

}));
if(!$core.assert($recv($recv(options)._size())._even())){
[$recv(console)._log_("Using default parameters.")
,$ctx1.sendIdx["log:"]=1
][0];
[$recv(console)._log_(["Wrong commandline options or not enough arguments for: ".__comma([" "._join_(options)
,$ctx1.sendIdx["join:"]=1
][0])
,$ctx1.sendIdx[","]=1
][0])
,$ctx1.sendIdx["log:"]=2
][0];
[$recv(console)._log_(["Use any of the following ones: ".__comma([","._join_(switches)
,$ctx1.sendIdx["join:"]=2
][0])
,$ctx1.sendIdx[","]=2
][0])
,$ctx1.sendIdx["log:"]=3
][0];
return server;
}
popFront=(function(args){
return $core.withContext(function($ctx2) {
front=$recv(args)._first();
$recv(args)._remove_(front);
return front;
}, function($ctx2) {$ctx2.fillBlock({args:args},$ctx1,3)});
});
$recv((function(){
return $core.withContext(function($ctx2) {
return $recv(options)._notEmpty();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,4)});
}))._whileTrue_((function(){
return $core.withContext(function($ctx2) {
optionName=[$recv(popFront)._value_(options)
,$ctx2.sendIdx["value:"]=1
][0];
optionValue=$recv(popFront)._value_(options);
if($core.assert($recv(switches)._includes_(optionName))){
optionName=$self._selectorForCommandLineSwitch_(optionName);
return $recv(server)._perform_withArguments_(optionName,[optionValue]);
} else {
[$recv(console)._log_([$recv(optionName).__comma(" is not a valid commandline option")
,$ctx2.sendIdx[","]=3
][0])
,$ctx2.sendIdx["log:"]=4
][0];
return $recv(console)._log_("Use any of the following ones: ".__comma(","._join_(switches)));
}
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,5)});
}));
return server;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"createServerWithArguments:",{options:options,server:server,popFront:popFront,front:front,optionName:optionName,optionValue:optionValue,switches:switches})});
}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "defaultBasePath",
protocol: "accessing",
args: [],
source: "defaultBasePath\x0a\x09^ './'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "./";

}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "defaultHost",
protocol: "accessing",
args: [],
source: "defaultHost\x0a\x09^ '127.0.0.1'",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "127.0.0.1";

}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "defaultMimeTypes",
protocol: "accessing",
args: [],
source: "defaultMimeTypes\x0a\x09^ #{\x0a\x09\x09'%' -> 'application/x-trash'.\x0a\x09\x09'323' -> 'text/h323'.\x0a\x09\x09'abw' -> 'application/x-abiword'.\x0a\x09\x09'ai' -> 'application/postscript'.\x0a\x09\x09'aif' -> 'audio/x-aiff'.\x0a\x09\x09'aifc' -> 'audio/x-aiff'.\x0a\x09\x09'aiff' -> 'audio/x-aiff'.\x0a\x09\x09'alc' -> 'chemical/x-alchemy'.\x0a\x09\x09'art' -> 'image/x-jg'.\x0a\x09\x09'asc' -> 'text/plain'.\x0a\x09\x09'asf' -> 'video/x-ms-asf'.\x0a\x09\x09'asn' -> 'chemical/x-ncbi-asn1-spec'.\x0a\x09\x09'aso' -> 'chemical/x-ncbi-asn1-binary'.\x0a\x09\x09'asx' -> 'video/x-ms-asf'.\x0a\x09\x09'au' -> 'audio/basic'.\x0a\x09\x09'avi' -> 'video/x-msvideo'.\x0a\x09\x09'b' -> 'chemical/x-molconn-Z'.\x0a\x09\x09'bak' -> 'application/x-trash'.\x0a\x09\x09'bat' -> 'application/x-msdos-program'.\x0a\x09\x09'bcpio' -> 'application/x-bcpio'.\x0a\x09\x09'bib' -> 'text/x-bibtex'.\x0a\x09\x09'bin' -> 'application/octet-stream'.\x0a\x09\x09'bmp' -> 'image/x-ms-bmp'.\x0a\x09\x09'book' -> 'application/x-maker'.\x0a\x09\x09'bsd' -> 'chemical/x-crossfire'.\x0a\x09\x09'c' -> 'text/x-csrc'.\x0a\x09\x09'c++' -> 'text/x-c++src'.\x0a\x09\x09'c3d' -> 'chemical/x-chem3d'.\x0a\x09\x09'cac' -> 'chemical/x-cache'.\x0a\x09\x09'cache' -> 'chemical/x-cache'.\x0a\x09\x09'cascii' -> 'chemical/x-cactvs-binary'.\x0a\x09\x09'cat' -> 'application/vnd.ms-pki.seccat'.\x0a\x09\x09'cbin' -> 'chemical/x-cactvs-binary'.\x0a\x09\x09'cc' -> 'text/x-c++src'.\x0a\x09\x09'cdf' -> 'application/x-cdf'.\x0a\x09\x09'cdr' -> 'image/x-coreldraw'.\x0a\x09\x09'cdt' -> 'image/x-coreldrawtemplate'.\x0a\x09\x09'cdx' -> 'chemical/x-cdx'.\x0a\x09\x09'cdy' -> 'application/vnd.cinderella'.\x0a\x09\x09'cef' -> 'chemical/x-cxf'.\x0a\x09\x09'cer' -> 'chemical/x-cerius'.\x0a\x09\x09'chm' -> 'chemical/x-chemdraw'.\x0a\x09\x09'chrt' -> 'application/x-kchart'.\x0a\x09\x09'cif' -> 'chemical/x-cif'.\x0a\x09\x09'class' -> 'application/java-vm'.\x0a\x09\x09'cls' -> 'text/x-tex'.\x0a\x09\x09'cmdf' -> 'chemical/x-cmdf'.\x0a\x09\x09'cml' -> 'chemical/x-cml'.\x0a\x09\x09'cod' -> 'application/vnd.rim.cod'.\x0a\x09\x09'com' -> 'application/x-msdos-program'.\x0a\x09\x09'cpa' -> 'chemical/x-compass'.\x0a\x09\x09'cpio' -> 'application/x-cpio'.\x0a\x09\x09'cpp' -> 'text/x-c++src'.\x0a\x09\x09'cpt' -> 'image/x-corelphotopaint'.\x0a\x09\x09'crl' -> 'application/x-pkcs7-crl'.\x0a\x09\x09'crt' -> 'application/x-x509-ca-cert'.\x0a\x09\x09'csf' -> 'chemical/x-cache-csf'.\x0a\x09\x09'csh' -> 'text/x-csh'.\x0a\x09\x09'csm' -> 'chemical/x-csml'.\x0a\x09\x09'csml' -> 'chemical/x-csml'.\x0a\x09\x09'css' -> 'text/css'.\x0a\x09\x09'csv' -> 'text/comma-separated-values'.\x0a\x09\x09'ctab' -> 'chemical/x-cactvs-binary'.\x0a\x09\x09'ctx' -> 'chemical/x-ctx'.\x0a\x09\x09'cu' -> 'application/cu-seeme'.\x0a\x09\x09'cub' -> 'chemical/x-gaussian-cube'.\x0a\x09\x09'cxf' -> 'chemical/x-cxf'.\x0a\x09\x09'cxx' -> 'text/x-c++src'.\x0a\x09\x09'dat' -> 'chemical/x-mopac-input'.\x0a\x09\x09'dcr' -> 'application/x-director'.\x0a\x09\x09'deb' -> 'application/x-debian-package'.\x0a\x09\x09'dif' -> 'video/dv'.\x0a\x09\x09'diff' -> 'text/plain'.\x0a\x09\x09'dir' -> 'application/x-director'.\x0a\x09\x09'djv' -> 'image/vnd.djvu'.\x0a\x09\x09'djvu' -> 'image/vnd.djvu'.\x0a\x09\x09'dl' -> 'video/dl'.\x0a\x09\x09'dll' -> 'application/x-msdos-program'.\x0a\x09\x09'dmg' -> 'application/x-apple-diskimage'.\x0a\x09\x09'dms' -> 'application/x-dms'.\x0a\x09\x09'doc' -> 'application/msword'.\x0a\x09\x09'dot' -> 'application/msword'.\x0a\x09\x09'dv' -> 'video/dv'.\x0a\x09\x09'dvi' -> 'application/x-dvi'.\x0a\x09\x09'dx' -> 'chemical/x-jcamp-dx'.\x0a\x09\x09'dxr' -> 'application/x-director'.\x0a\x09\x09'emb' -> 'chemical/x-embl-dl-nucleotide'.\x0a\x09\x09'embl' -> 'chemical/x-embl-dl-nucleotide'.\x0a\x09\x09'ent' -> 'chemical/x-pdb'.\x0a\x09\x09'eps' -> 'application/postscript'.\x0a\x09\x09'etx' -> 'text/x-setext'.\x0a\x09\x09'exe' -> 'application/x-msdos-program'.\x0a\x09\x09'ez' -> 'application/andrew-inset'.\x0a\x09\x09'fb' -> 'application/x-maker'.\x0a\x09\x09'fbdoc' -> 'application/x-maker'.\x0a\x09\x09'fch' -> 'chemical/x-gaussian-checkpoint'.\x0a\x09\x09'fchk' -> 'chemical/x-gaussian-checkpoint'.\x0a\x09\x09'fig' -> 'application/x-xfig'.\x0a\x09\x09'flac' -> 'application/x-flac'.\x0a\x09\x09'fli' -> 'video/fli'.\x0a\x09\x09'fm' -> 'application/x-maker'.\x0a\x09\x09'frame' -> 'application/x-maker'.\x0a\x09\x09'frm' -> 'application/x-maker'.\x0a\x09\x09'gal' -> 'chemical/x-gaussian-log'.\x0a\x09\x09'gam' -> 'chemical/x-gamess-input'.\x0a\x09\x09'gamin' -> 'chemical/x-gamess-input'.\x0a\x09\x09'gau' -> 'chemical/x-gaussian-input'.\x0a\x09\x09'gcd' -> 'text/x-pcs-gcd'.\x0a\x09\x09'gcf' -> 'application/x-graphing-calculator'.\x0a\x09\x09'gcg' -> 'chemical/x-gcg8-sequence'.\x0a\x09\x09'gen' -> 'chemical/x-genbank'.\x0a\x09\x09'gf' -> 'application/x-tex-gf'.\x0a\x09\x09'gif' -> 'image/gif'.\x0a\x09\x09'gjc' -> 'chemical/x-gaussian-input'.\x0a\x09\x09'gjf' -> 'chemical/x-gaussian-input'.\x0a\x09\x09'gl' -> 'video/gl'.\x0a\x09\x09'gnumeric' -> 'application/x-gnumeric'.\x0a\x09\x09'gpt' -> 'chemical/x-mopac-graph'.\x0a\x09\x09'gsf' -> 'application/x-font'.\x0a\x09\x09'gsm' -> 'audio/x-gsm'.\x0a\x09\x09'gtar' -> 'application/x-gtar'.\x0a\x09\x09'h' -> 'text/x-chdr'.\x0a\x09\x09'h++' -> 'text/x-c++hdr'.\x0a\x09\x09'hdf' -> 'application/x-hdf'.\x0a\x09\x09'hh' -> 'text/x-c++hdr'.\x0a\x09\x09'hin' -> 'chemical/x-hin'.\x0a\x09\x09'hpp' -> 'text/x-c++hdr'.\x0a\x09\x09'hqx' -> 'application/mac-binhex40'.\x0a\x09\x09'hs' -> 'text/x-haskell'.\x0a\x09\x09'hta' -> 'application/hta'.\x0a\x09\x09'htc' -> 'text/x-component'.\x0a\x09\x09'htm' -> 'text/html'.\x0a\x09\x09'html' -> 'text/html'.\x0a\x09\x09'hxx' -> 'text/x-c++hdr'.\x0a\x09\x09'ica' -> 'application/x-ica'.\x0a\x09\x09'ice' -> 'x-conference/x-cooltalk'.\x0a\x09\x09'ico' -> 'image/x-icon'.\x0a\x09\x09'ics' -> 'text/calendar'.\x0a\x09\x09'icz' -> 'text/calendar'.\x0a\x09\x09'ief' -> 'image/ief'.\x0a\x09\x09'iges' -> 'model/iges'.\x0a\x09\x09'igs' -> 'model/iges'.\x0a\x09\x09'iii' -> 'application/x-iphone'.\x0a\x09\x09'inp' -> 'chemical/x-gamess-input'.\x0a\x09\x09'ins' -> 'application/x-internet-signup'.\x0a\x09\x09'iso' -> 'application/x-iso9660-image'.\x0a\x09\x09'isp' -> 'application/x-internet-signup'.\x0a\x09\x09'ist' -> 'chemical/x-isostar'.\x0a\x09\x09'istr' -> 'chemical/x-isostar'.\x0a\x09\x09'jad' -> 'text/vnd.sun.j2me.app-descriptor'.\x0a\x09\x09'jar' -> 'application/java-archive'.\x0a\x09\x09'java' -> 'text/x-java'.\x0a\x09\x09'jdx' -> 'chemical/x-jcamp-dx'.\x0a\x09\x09'jmz' -> 'application/x-jmol'.\x0a\x09\x09'jng' -> 'image/x-jng'.\x0a\x09\x09'jnlp' -> 'application/x-java-jnlp-file'.\x0a\x09\x09'jpe' -> 'image/jpeg'.\x0a\x09\x09'jpeg' -> 'image/jpeg'.\x0a\x09\x09'jpg' -> 'image/jpeg'.\x0a\x09\x09'js' -> 'application/javascript'.\x0a\x09\x09'kar' -> 'audio/midi'.\x0a\x09\x09'key' -> 'application/pgp-keys'.\x0a\x09\x09'kil' -> 'application/x-killustrator'.\x0a\x09\x09'kin' -> 'chemical/x-kinemage'.\x0a\x09\x09'kpr' -> 'application/x-kpresenter'.\x0a\x09\x09'kpt' -> 'application/x-kpresenter'.\x0a\x09\x09'ksp' -> 'application/x-kspread'.\x0a\x09\x09'kwd' -> 'application/x-kword'.\x0a\x09\x09'kwt' -> 'application/x-kword'.\x0a\x09\x09'latex' -> 'application/x-latex'.\x0a\x09\x09'lha' -> 'application/x-lha'.\x0a\x09\x09'lhs' -> 'text/x-literate-haskell'.\x0a\x09\x09'lsf' -> 'video/x-la-asf'.\x0a\x09\x09'lsx' -> 'video/x-la-asf'.\x0a\x09\x09'ltx' -> 'text/x-tex'.\x0a\x09\x09'lzh' -> 'application/x-lzh'.\x0a\x09\x09'lzx' -> 'application/x-lzx'.\x0a\x09\x09'm3u' -> 'audio/x-mpegurl'.\x0a\x09\x09'm4a' -> 'audio/mpeg'.\x0a\x09\x09'maker' -> 'application/x-maker'.\x0a\x09\x09'man' -> 'application/x-troff-man'.\x0a\x09\x09'mcif' -> 'chemical/x-mmcif'.\x0a\x09\x09'mcm' -> 'chemical/x-macmolecule'.\x0a\x09\x09'mdb' -> 'application/msaccess'.\x0a\x09\x09'me' -> 'application/x-troff-me'.\x0a\x09\x09'mesh' -> 'model/mesh'.\x0a\x09\x09'mid' -> 'audio/midi'.\x0a\x09\x09'midi' -> 'audio/midi'.\x0a\x09\x09'mif' -> 'application/x-mif'.\x0a\x09\x09'mm' -> 'application/x-freemind'.\x0a\x09\x09'mmd' -> 'chemical/x-macromodel-input'.\x0a\x09\x09'mmf' -> 'application/vnd.smaf'.\x0a\x09\x09'mml' -> 'text/mathml'.\x0a\x09\x09'mmod' -> 'chemical/x-macromodel-input'.\x0a\x09\x09'mng' -> 'video/x-mng'.\x0a\x09\x09'moc' -> 'text/x-moc'.\x0a\x09\x09'mol' -> 'chemical/x-mdl-molfile'.\x0a\x09\x09'mol2' -> 'chemical/x-mol2'.\x0a\x09\x09'moo' -> 'chemical/x-mopac-out'.\x0a\x09\x09'mop' -> 'chemical/x-mopac-input'.\x0a\x09\x09'mopcrt' -> 'chemical/x-mopac-input'.\x0a\x09\x09'mov' -> 'video/quicktime'.\x0a\x09\x09'movie' -> 'video/x-sgi-movie'.\x0a\x09\x09'mp2' -> 'audio/mpeg'.\x0a\x09\x09'mp3' -> 'audio/mpeg'.\x0a\x09\x09'mp4' -> 'video/mp4'.\x0a\x09\x09'mpc' -> 'chemical/x-mopac-input'.\x0a\x09\x09'mpe' -> 'video/mpeg'.\x0a\x09\x09'mpeg' -> 'video/mpeg'.\x0a\x09\x09'mpega' -> 'audio/mpeg'.\x0a\x09\x09'mpg' -> 'video/mpeg'.\x0a\x09\x09'mpga' -> 'audio/mpeg'.\x0a\x09\x09'ms' -> 'application/x-troff-ms'.\x0a\x09\x09'msh' -> 'model/mesh'.\x0a\x09\x09'msi' -> 'application/x-msi'.\x0a\x09\x09'mvb' -> 'chemical/x-mopac-vib'.\x0a\x09\x09'mxu' -> 'video/vnd.mpegurl'.\x0a\x09\x09'nb' -> 'application/mathematica'.\x0a\x09\x09'nc' -> 'application/x-netcdf'.\x0a\x09\x09'nwc' -> 'application/x-nwc'.\x0a\x09\x09'o' -> 'application/x-object'.\x0a\x09\x09'oda' -> 'application/oda'.\x0a\x09\x09'odb' -> 'application/vnd.oasis.opendocument.database'.\x0a\x09\x09'odc' -> 'application/vnd.oasis.opendocument.chart'.\x0a\x09\x09'odf' -> 'application/vnd.oasis.opendocument.formula'.\x0a\x09\x09'odg' -> 'application/vnd.oasis.opendocument.graphics'.\x0a\x09\x09'odi' -> 'application/vnd.oasis.opendocument.image'.\x0a\x09\x09'odm' -> 'application/vnd.oasis.opendocument.text-master'.\x0a\x09\x09'odp' -> 'application/vnd.oasis.opendocument.presentation'.\x0a\x09\x09'ods' -> 'application/vnd.oasis.opendocument.spreadsheet'.\x0a\x09\x09'odt' -> 'application/vnd.oasis.opendocument.text'.\x0a\x09\x09'ogg' -> 'application/ogg'.\x0a\x09\x09'old' -> 'application/x-trash'.\x0a\x09\x09'oth' -> 'application/vnd.oasis.opendocument.text-web'.\x0a\x09\x09'oza' -> 'application/x-oz-application'.\x0a\x09\x09'p' -> 'text/x-pascal'.\x0a\x09\x09'p7r' -> 'application/x-pkcs7-certreqresp'.\x0a\x09\x09'pac' -> 'application/x-ns-proxy-autoconfig'.\x0a\x09\x09'pas' -> 'text/x-pascal'.\x0a\x09\x09'pat' -> 'image/x-coreldrawpattern'.\x0a\x09\x09'pbm' -> 'image/x-portable-bitmap'.\x0a\x09\x09'pcf' -> 'application/x-font'.\x0a\x09\x09'pcf.Z' -> 'application/x-font'.\x0a\x09\x09'pcx' -> 'image/pcx'.\x0a\x09\x09'pdb' -> 'chemical/x-pdb'.\x0a\x09\x09'pdf' -> 'application/pdf'.\x0a\x09\x09'pfa' -> 'application/x-font'.\x0a\x09\x09'pfb' -> 'application/x-font'.\x0a\x09\x09'pgm' -> 'image/x-portable-graymap'.\x0a\x09\x09'pgn' -> 'application/x-chess-pgn'.\x0a\x09\x09'pgp' -> 'application/pgp-signature'.\x0a\x09\x09'pk' -> 'application/x-tex-pk'.\x0a\x09\x09'pl' -> 'text/x-perl'.\x0a\x09\x09'pls' -> 'audio/x-scpls'.\x0a\x09\x09'pm' -> 'text/x-perl'.\x0a\x09\x09'png' -> 'image/png'.\x0a\x09\x09'pnm' -> 'image/x-portable-anymap'.\x0a\x09\x09'pot' -> 'text/plain'.\x0a\x09\x09'ppm' -> 'image/x-portable-pixmap'.\x0a\x09\x09'pps' -> 'application/vnd.ms-powerpoint'.\x0a\x09\x09'ppt' -> 'application/vnd.ms-powerpoint'.\x0a\x09\x09'prf' -> 'application/pics-rules'.\x0a\x09\x09'prt' -> 'chemical/x-ncbi-asn1-ascii'.\x0a\x09\x09'ps' -> 'application/postscript'.\x0a\x09\x09'psd' -> 'image/x-photoshop'.\x0a\x09\x09'psp' -> 'text/x-psp'.\x0a\x09\x09'py' -> 'text/x-python'.\x0a\x09\x09'pyc' -> 'application/x-python-code'.\x0a\x09\x09'pyo' -> 'application/x-python-code'.\x0a\x09\x09'qt' -> 'video/quicktime'.\x0a\x09\x09'qtl' -> 'application/x-quicktimeplayer'.\x0a\x09\x09'ra' -> 'audio/x-realaudio'.\x0a\x09\x09'ram' -> 'audio/x-pn-realaudio'.\x0a\x09\x09'rar' -> 'application/rar'.\x0a\x09\x09'ras' -> 'image/x-cmu-raster'.\x0a\x09\x09'rd' -> 'chemical/x-mdl-rdfile'.\x0a\x09\x09'rdf' -> 'application/rdf+xml'.\x0a\x09\x09'rgb' -> 'image/x-rgb'.\x0a\x09\x09'rm' -> 'audio/x-pn-realaudio'.\x0a\x09\x09'roff' -> 'application/x-troff'.\x0a\x09\x09'ros' -> 'chemical/x-rosdal'.\x0a\x09\x09'rpm' -> 'application/x-redhat-package-manager'.\x0a\x09\x09'rss' -> 'application/rss+xml'.\x0a\x09\x09'rtf' -> 'text/rtf'.\x0a\x09\x09'rtx' -> 'text/richtext'.\x0a\x09\x09'rxn' -> 'chemical/x-mdl-rxnfile'.\x0a\x09\x09'sct' -> 'text/scriptlet'.\x0a\x09\x09'sd' -> 'chemical/x-mdl-sdfile'.\x0a\x09\x09'sd2' -> 'audio/x-sd2'.\x0a\x09\x09'sda' -> 'application/vnd.stardivision.draw'.\x0a\x09\x09'sdc' -> 'application/vnd.stardivision.calc'.\x0a\x09\x09'sdd' -> 'application/vnd.stardivision.impress'.\x0a\x09\x09'sdf' -> 'chemical/x-mdl-sdfile'.\x0a\x09\x09'sdp' -> 'application/vnd.stardivision.impress'.\x0a\x09\x09'sdw' -> 'application/vnd.stardivision.writer'.\x0a\x09\x09'ser' -> 'application/java-serialized-object'.\x0a\x09\x09'sgf' -> 'application/x-go-sgf'.\x0a\x09\x09'sgl' -> 'application/vnd.stardivision.writer-global'.\x0a\x09\x09'sh' -> 'text/x-sh'.\x0a\x09\x09'shar' -> 'application/x-shar'.\x0a\x09\x09'shtml' -> 'text/html'.\x0a\x09\x09'sid' -> 'audio/prs.sid'.\x0a\x09\x09'sik' -> 'application/x-trash'.\x0a\x09\x09'silo' -> 'model/mesh'.\x0a\x09\x09'sis' -> 'application/vnd.symbian.install'.\x0a\x09\x09'sit' -> 'application/x-stuffit'.\x0a\x09\x09'skd' -> 'application/x-koan'.\x0a\x09\x09'skm' -> 'application/x-koan'.\x0a\x09\x09'skp' -> 'application/x-koan'.\x0a\x09\x09'skt' -> 'application/x-koan'.\x0a\x09\x09'smf' -> 'application/vnd.stardivision.math'.\x0a\x09\x09'smi' -> 'application/smil'.\x0a\x09\x09'smil' -> 'application/smil'.\x0a\x09\x09'snd' -> 'audio/basic'.\x0a\x09\x09'spc' -> 'chemical/x-galactic-spc'.\x0a\x09\x09'spl' -> 'application/x-futuresplash'.\x0a\x09\x09'src' -> 'application/x-wais-source'.\x0a\x09\x09'stc' -> 'application/vnd.sun.xml.calc.template'.\x0a\x09\x09'std' -> 'application/vnd.sun.xml.draw.template'.\x0a\x09\x09'sti' -> 'application/vnd.sun.xml.impress.template'.\x0a\x09\x09'stl' -> 'application/vnd.ms-pki.stl'.\x0a\x09\x09'stw' -> 'application/vnd.sun.xml.writer.template'.\x0a\x09\x09'sty' -> 'text/x-tex'.\x0a\x09\x09'sv4cpio' -> 'application/x-sv4cpio'.\x0a\x09\x09'sv4crc' -> 'application/x-sv4crc'.\x0a\x09\x09'svg' -> 'image/svg+xml'.\x0a\x09\x09'svgz' -> 'image/svg+xml'.\x0a\x09\x09'sw' -> 'chemical/x-swissprot'.\x0a\x09\x09'swf' -> 'application/x-shockwave-flash'.\x0a\x09\x09'swfl' -> 'application/x-shockwave-flash'.\x0a\x09\x09'sxc' -> 'application/vnd.sun.xml.calc'.\x0a\x09\x09'sxd' -> 'application/vnd.sun.xml.draw'.\x0a\x09\x09'sxg' -> 'application/vnd.sun.xml.writer.global'.\x0a\x09\x09'sxi' -> 'application/vnd.sun.xml.impress'.\x0a\x09\x09'sxm' -> 'application/vnd.sun.xml.math'.\x0a\x09\x09'sxw' -> 'application/vnd.sun.xml.writer'.\x0a\x09\x09't' -> 'application/x-troff'.\x0a\x09\x09'tar' -> 'application/x-tar'.\x0a\x09\x09'taz' -> 'application/x-gtar'.\x0a\x09\x09'tcl' -> 'text/x-tcl'.\x0a\x09\x09'tex' -> 'text/x-tex'.\x0a\x09\x09'texi' -> 'application/x-texinfo'.\x0a\x09\x09'texinfo' -> 'application/x-texinfo'.\x0a\x09\x09'text' -> 'text/plain'.\x0a\x09\x09'tgf' -> 'chemical/x-mdl-tgf'.\x0a\x09\x09'tgz' -> 'application/x-gtar'.\x0a\x09\x09'tif' -> 'image/tiff'.\x0a\x09\x09'tiff' -> 'image/tiff'.\x0a\x09\x09'tk' -> 'text/x-tcl'.\x0a\x09\x09'tm' -> 'text/texmacs'.\x0a\x09\x09'torrent' -> 'application/x-bittorrent'.\x0a\x09\x09'tr' -> 'application/x-troff'.\x0a\x09\x09'ts' -> 'text/texmacs'.\x0a\x09\x09'tsp' -> 'application/dsptype'.\x0a\x09\x09'tsv' -> 'text/tab-separated-values'.\x0a\x09\x09'txt' -> 'text/plain'.\x0a\x09\x09'udeb' -> 'application/x-debian-package'.\x0a\x09\x09'uls' -> 'text/iuls'.\x0a\x09\x09'ustar' -> 'application/x-ustar'.\x0a\x09\x09'val' -> 'chemical/x-ncbi-asn1-binary'.\x0a\x09\x09'vcd' -> 'application/x-cdlink'.\x0a\x09\x09'vcf' -> 'text/x-vcard'.\x0a\x09\x09'vcs' -> 'text/x-vcalendar'.\x0a\x09\x09'vmd' -> 'chemical/x-vmd'.\x0a\x09\x09'vms' -> 'chemical/x-vamas-iso14976'.\x0a\x09\x09'vor' -> 'application/vnd.stardivision.writer'.\x0a\x09\x09'vrm' -> 'x-world/x-vrml'.\x0a\x09\x09'vrml' -> 'x-world/x-vrml'.\x0a\x09\x09'vsd' -> 'application/vnd.visio'.\x0a\x09\x09'wad' -> 'application/x-doom'.\x0a\x09\x09'wav' -> 'audio/x-wav'.\x0a\x09\x09'wax' -> 'audio/x-ms-wax'.\x0a\x09\x09'wbmp' -> 'image/vnd.wap.wbmp'.\x0a\x09\x09'wbxml' -> 'application/vnd.wap.wbxml'.\x0a\x09\x09'wk' -> 'application/x-123'.\x0a\x09\x09'wm' -> 'video/x-ms-wm'.\x0a\x09\x09'wma' -> 'audio/x-ms-wma'.\x0a\x09\x09'wmd' -> 'application/x-ms-wmd'.\x0a\x09\x09'wml' -> 'text/vnd.wap.wml'.\x0a\x09\x09'wmlc' -> 'application/vnd.wap.wmlc'.\x0a\x09\x09'wmls' -> 'text/vnd.wap.wmlscript'.\x0a\x09\x09'wmlsc' -> 'application/vnd.wap.wmlscriptc'.\x0a\x09\x09'wmv' -> 'video/x-ms-wmv'.\x0a\x09\x09'wmx' -> 'video/x-ms-wmx'.\x0a\x09\x09'wmz' -> 'application/x-ms-wmz'.\x0a\x09\x09'wp5' -> 'application/wordperfect5.1'.\x0a\x09\x09'wpd' -> 'application/wordperfect'.\x0a\x09\x09'wrl' -> 'x-world/x-vrml'.\x0a\x09\x09'wsc' -> 'text/scriptlet'.\x0a\x09\x09'wvx' -> 'video/x-ms-wvx'.\x0a\x09\x09'wz' -> 'application/x-wingz'.\x0a\x09\x09'xbm' -> 'image/x-xbitmap'.\x0a\x09\x09'xcf' -> 'application/x-xcf'.\x0a\x09\x09'xht' -> 'application/xhtml+xml'.\x0a\x09\x09'xhtml' -> 'application/xhtml+xml'.\x0a\x09\x09'xlb' -> 'application/vnd.ms-excel'.\x0a\x09\x09'xls' -> 'application/vnd.ms-excel'.\x0a\x09\x09'xlt' -> 'application/vnd.ms-excel'.\x0a\x09\x09'xml' -> 'application/xml'.\x0a\x09\x09'xpi' -> 'application/x-xpinstall'.\x0a\x09\x09'xpm' -> 'image/x-xpixmap'.\x0a\x09\x09'xsl' -> 'application/xml'.\x0a\x09\x09'xtel' -> 'chemical/x-xtel'.\x0a\x09\x09'xul' -> 'application/vnd.mozilla.xul+xml'.\x0a\x09\x09'xwd' -> 'image/x-xwindowdump'.\x0a\x09\x09'xyz' -> 'chemical/x-xyz'.\x0a\x09\x09'zip' -> 'application/zip'.\x0a\x09\x09'zmt' -> 'chemical/x-mopac-input'.\x0a\x09\x09'~' -> 'application/x-trash'\x0a\x09}",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $globals.HashedCollection._newFromPairs_(["%","application/x-trash","323","text/h323","abw","application/x-abiword","ai","application/postscript","aif","audio/x-aiff","aifc","audio/x-aiff","aiff","audio/x-aiff","alc","chemical/x-alchemy","art","image/x-jg","asc","text/plain","asf","video/x-ms-asf","asn","chemical/x-ncbi-asn1-spec","aso","chemical/x-ncbi-asn1-binary","asx","video/x-ms-asf","au","audio/basic","avi","video/x-msvideo","b","chemical/x-molconn-Z","bak","application/x-trash","bat","application/x-msdos-program","bcpio","application/x-bcpio","bib","text/x-bibtex","bin","application/octet-stream","bmp","image/x-ms-bmp","book","application/x-maker","bsd","chemical/x-crossfire","c","text/x-csrc","c++","text/x-c++src","c3d","chemical/x-chem3d","cac","chemical/x-cache","cache","chemical/x-cache","cascii","chemical/x-cactvs-binary","cat","application/vnd.ms-pki.seccat","cbin","chemical/x-cactvs-binary","cc","text/x-c++src","cdf","application/x-cdf","cdr","image/x-coreldraw","cdt","image/x-coreldrawtemplate","cdx","chemical/x-cdx","cdy","application/vnd.cinderella","cef","chemical/x-cxf","cer","chemical/x-cerius","chm","chemical/x-chemdraw","chrt","application/x-kchart","cif","chemical/x-cif","class","application/java-vm","cls","text/x-tex","cmdf","chemical/x-cmdf","cml","chemical/x-cml","cod","application/vnd.rim.cod","com","application/x-msdos-program","cpa","chemical/x-compass","cpio","application/x-cpio","cpp","text/x-c++src","cpt","image/x-corelphotopaint","crl","application/x-pkcs7-crl","crt","application/x-x509-ca-cert","csf","chemical/x-cache-csf","csh","text/x-csh","csm","chemical/x-csml","csml","chemical/x-csml","css","text/css","csv","text/comma-separated-values","ctab","chemical/x-cactvs-binary","ctx","chemical/x-ctx","cu","application/cu-seeme","cub","chemical/x-gaussian-cube","cxf","chemical/x-cxf","cxx","text/x-c++src","dat","chemical/x-mopac-input","dcr","application/x-director","deb","application/x-debian-package","dif","video/dv","diff","text/plain","dir","application/x-director","djv","image/vnd.djvu","djvu","image/vnd.djvu","dl","video/dl","dll","application/x-msdos-program","dmg","application/x-apple-diskimage","dms","application/x-dms","doc","application/msword","dot","application/msword","dv","video/dv","dvi","application/x-dvi","dx","chemical/x-jcamp-dx","dxr","application/x-director","emb","chemical/x-embl-dl-nucleotide","embl","chemical/x-embl-dl-nucleotide","ent","chemical/x-pdb","eps","application/postscript","etx","text/x-setext","exe","application/x-msdos-program","ez","application/andrew-inset","fb","application/x-maker","fbdoc","application/x-maker","fch","chemical/x-gaussian-checkpoint","fchk","chemical/x-gaussian-checkpoint","fig","application/x-xfig","flac","application/x-flac","fli","video/fli","fm","application/x-maker","frame","application/x-maker","frm","application/x-maker","gal","chemical/x-gaussian-log","gam","chemical/x-gamess-input","gamin","chemical/x-gamess-input","gau","chemical/x-gaussian-input","gcd","text/x-pcs-gcd","gcf","application/x-graphing-calculator","gcg","chemical/x-gcg8-sequence","gen","chemical/x-genbank","gf","application/x-tex-gf","gif","image/gif","gjc","chemical/x-gaussian-input","gjf","chemical/x-gaussian-input","gl","video/gl","gnumeric","application/x-gnumeric","gpt","chemical/x-mopac-graph","gsf","application/x-font","gsm","audio/x-gsm","gtar","application/x-gtar","h","text/x-chdr","h++","text/x-c++hdr","hdf","application/x-hdf","hh","text/x-c++hdr","hin","chemical/x-hin","hpp","text/x-c++hdr","hqx","application/mac-binhex40","hs","text/x-haskell","hta","application/hta","htc","text/x-component","htm","text/html","html","text/html","hxx","text/x-c++hdr","ica","application/x-ica","ice","x-conference/x-cooltalk","ico","image/x-icon","ics","text/calendar","icz","text/calendar","ief","image/ief","iges","model/iges","igs","model/iges","iii","application/x-iphone","inp","chemical/x-gamess-input","ins","application/x-internet-signup","iso","application/x-iso9660-image","isp","application/x-internet-signup","ist","chemical/x-isostar","istr","chemical/x-isostar","jad","text/vnd.sun.j2me.app-descriptor","jar","application/java-archive","java","text/x-java","jdx","chemical/x-jcamp-dx","jmz","application/x-jmol","jng","image/x-jng","jnlp","application/x-java-jnlp-file","jpe","image/jpeg","jpeg","image/jpeg","jpg","image/jpeg","js","application/javascript","kar","audio/midi","key","application/pgp-keys","kil","application/x-killustrator","kin","chemical/x-kinemage","kpr","application/x-kpresenter","kpt","application/x-kpresenter","ksp","application/x-kspread","kwd","application/x-kword","kwt","application/x-kword","latex","application/x-latex","lha","application/x-lha","lhs","text/x-literate-haskell","lsf","video/x-la-asf","lsx","video/x-la-asf","ltx","text/x-tex","lzh","application/x-lzh","lzx","application/x-lzx","m3u","audio/x-mpegurl","m4a","audio/mpeg","maker","application/x-maker","man","application/x-troff-man","mcif","chemical/x-mmcif","mcm","chemical/x-macmolecule","mdb","application/msaccess","me","application/x-troff-me","mesh","model/mesh","mid","audio/midi","midi","audio/midi","mif","application/x-mif","mm","application/x-freemind","mmd","chemical/x-macromodel-input","mmf","application/vnd.smaf","mml","text/mathml","mmod","chemical/x-macromodel-input","mng","video/x-mng","moc","text/x-moc","mol","chemical/x-mdl-molfile","mol2","chemical/x-mol2","moo","chemical/x-mopac-out","mop","chemical/x-mopac-input","mopcrt","chemical/x-mopac-input","mov","video/quicktime","movie","video/x-sgi-movie","mp2","audio/mpeg","mp3","audio/mpeg","mp4","video/mp4","mpc","chemical/x-mopac-input","mpe","video/mpeg","mpeg","video/mpeg","mpega","audio/mpeg","mpg","video/mpeg","mpga","audio/mpeg","ms","application/x-troff-ms","msh","model/mesh","msi","application/x-msi","mvb","chemical/x-mopac-vib","mxu","video/vnd.mpegurl","nb","application/mathematica","nc","application/x-netcdf","nwc","application/x-nwc","o","application/x-object","oda","application/oda","odb","application/vnd.oasis.opendocument.database","odc","application/vnd.oasis.opendocument.chart","odf","application/vnd.oasis.opendocument.formula","odg","application/vnd.oasis.opendocument.graphics","odi","application/vnd.oasis.opendocument.image","odm","application/vnd.oasis.opendocument.text-master","odp","application/vnd.oasis.opendocument.presentation","ods","application/vnd.oasis.opendocument.spreadsheet","odt","application/vnd.oasis.opendocument.text","ogg","application/ogg","old","application/x-trash","oth","application/vnd.oasis.opendocument.text-web","oza","application/x-oz-application","p","text/x-pascal","p7r","application/x-pkcs7-certreqresp","pac","application/x-ns-proxy-autoconfig","pas","text/x-pascal","pat","image/x-coreldrawpattern","pbm","image/x-portable-bitmap","pcf","application/x-font","pcf.Z","application/x-font","pcx","image/pcx","pdb","chemical/x-pdb","pdf","application/pdf","pfa","application/x-font","pfb","application/x-font","pgm","image/x-portable-graymap","pgn","application/x-chess-pgn","pgp","application/pgp-signature","pk","application/x-tex-pk","pl","text/x-perl","pls","audio/x-scpls","pm","text/x-perl","png","image/png","pnm","image/x-portable-anymap","pot","text/plain","ppm","image/x-portable-pixmap","pps","application/vnd.ms-powerpoint","ppt","application/vnd.ms-powerpoint","prf","application/pics-rules","prt","chemical/x-ncbi-asn1-ascii","ps","application/postscript","psd","image/x-photoshop","psp","text/x-psp","py","text/x-python","pyc","application/x-python-code","pyo","application/x-python-code","qt","video/quicktime","qtl","application/x-quicktimeplayer","ra","audio/x-realaudio","ram","audio/x-pn-realaudio","rar","application/rar","ras","image/x-cmu-raster","rd","chemical/x-mdl-rdfile","rdf","application/rdf+xml","rgb","image/x-rgb","rm","audio/x-pn-realaudio","roff","application/x-troff","ros","chemical/x-rosdal","rpm","application/x-redhat-package-manager","rss","application/rss+xml","rtf","text/rtf","rtx","text/richtext","rxn","chemical/x-mdl-rxnfile","sct","text/scriptlet","sd","chemical/x-mdl-sdfile","sd2","audio/x-sd2","sda","application/vnd.stardivision.draw","sdc","application/vnd.stardivision.calc","sdd","application/vnd.stardivision.impress","sdf","chemical/x-mdl-sdfile","sdp","application/vnd.stardivision.impress","sdw","application/vnd.stardivision.writer","ser","application/java-serialized-object","sgf","application/x-go-sgf","sgl","application/vnd.stardivision.writer-global","sh","text/x-sh","shar","application/x-shar","shtml","text/html","sid","audio/prs.sid","sik","application/x-trash","silo","model/mesh","sis","application/vnd.symbian.install","sit","application/x-stuffit","skd","application/x-koan","skm","application/x-koan","skp","application/x-koan","skt","application/x-koan","smf","application/vnd.stardivision.math","smi","application/smil","smil","application/smil","snd","audio/basic","spc","chemical/x-galactic-spc","spl","application/x-futuresplash","src","application/x-wais-source","stc","application/vnd.sun.xml.calc.template","std","application/vnd.sun.xml.draw.template","sti","application/vnd.sun.xml.impress.template","stl","application/vnd.ms-pki.stl","stw","application/vnd.sun.xml.writer.template","sty","text/x-tex","sv4cpio","application/x-sv4cpio","sv4crc","application/x-sv4crc","svg","image/svg+xml","svgz","image/svg+xml","sw","chemical/x-swissprot","swf","application/x-shockwave-flash","swfl","application/x-shockwave-flash","sxc","application/vnd.sun.xml.calc","sxd","application/vnd.sun.xml.draw","sxg","application/vnd.sun.xml.writer.global","sxi","application/vnd.sun.xml.impress","sxm","application/vnd.sun.xml.math","sxw","application/vnd.sun.xml.writer","t","application/x-troff","tar","application/x-tar","taz","application/x-gtar","tcl","text/x-tcl","tex","text/x-tex","texi","application/x-texinfo","texinfo","application/x-texinfo","text","text/plain","tgf","chemical/x-mdl-tgf","tgz","application/x-gtar","tif","image/tiff","tiff","image/tiff","tk","text/x-tcl","tm","text/texmacs","torrent","application/x-bittorrent","tr","application/x-troff","ts","text/texmacs","tsp","application/dsptype","tsv","text/tab-separated-values","txt","text/plain","udeb","application/x-debian-package","uls","text/iuls","ustar","application/x-ustar","val","chemical/x-ncbi-asn1-binary","vcd","application/x-cdlink","vcf","text/x-vcard","vcs","text/x-vcalendar","vmd","chemical/x-vmd","vms","chemical/x-vamas-iso14976","vor","application/vnd.stardivision.writer","vrm","x-world/x-vrml","vrml","x-world/x-vrml","vsd","application/vnd.visio","wad","application/x-doom","wav","audio/x-wav","wax","audio/x-ms-wax","wbmp","image/vnd.wap.wbmp","wbxml","application/vnd.wap.wbxml","wk","application/x-123","wm","video/x-ms-wm","wma","audio/x-ms-wma","wmd","application/x-ms-wmd","wml","text/vnd.wap.wml","wmlc","application/vnd.wap.wmlc","wmls","text/vnd.wap.wmlscript","wmlsc","application/vnd.wap.wmlscriptc","wmv","video/x-ms-wmv","wmx","video/x-ms-wmx","wmz","application/x-ms-wmz","wp5","application/wordperfect5.1","wpd","application/wordperfect","wrl","x-world/x-vrml","wsc","text/scriptlet","wvx","video/x-ms-wvx","wz","application/x-wingz","xbm","image/x-xbitmap","xcf","application/x-xcf","xht","application/xhtml+xml","xhtml","application/xhtml+xml","xlb","application/vnd.ms-excel","xls","application/vnd.ms-excel","xlt","application/vnd.ms-excel","xml","application/xml","xpi","application/x-xpinstall","xpm","image/x-xpixmap","xsl","application/xml","xtel","chemical/x-xtel","xul","application/vnd.mozilla.xul+xml","xwd","image/x-xwindowdump","xyz","chemical/x-xyz","zip","application/zip","zmt","chemical/x-mopac-input","~","application/x-trash"]);

}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "defaultPort",
protocol: "accessing",
args: [],
source: "defaultPort\x0a\x09^ 4000",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return (4000);

}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "main",
protocol: "initialization",
args: [],
source: "main\x0a\x09\x22Main entry point for Amber applications.\x0a\x09 Creates and starts a FileServer instance.\x22\x0a\x09| fileServer args |\x0a\x09args := process argv.\x0a\x09\x22Remove the first args which contain the path to the node executable and the script file.\x22\x0a\x09args removeFrom: 1 to: 3.\x0a\x0a\x09args detect: [ :each |\x0a\x09\x09(each = '--help') ifTrue: [FileServer printHelp]]\x0a\x09ifNone: [\x0a\x09\x09fileServer := FileServer createServerWithArguments: args.\x0a\x09\x09^ fileServer start]",
referencedClasses: ["FileServer"],
pragmas: [],
messageSends: ["argv", "removeFrom:to:", "detect:ifNone:", "ifTrue:", "=", "printHelp", "createServerWithArguments:", "start"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var fileServer,args;
return $core.withContext(function($ctx1) {
var $early={};
try {
args=$recv(process)._argv();
$recv(args)._removeFrom_to_((1),(3));
$recv(args)._detect_ifNone_((function(each){
return $core.withContext(function($ctx2) {
if($core.assert($recv(each).__eq("--help"))){
return $recv($globals.FileServer)._printHelp();
}
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}),(function(){
return $core.withContext(function($ctx2) {
fileServer=$recv($globals.FileServer)._createServerWithArguments_(args);
throw $early=[$recv(fileServer)._start()];
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,3)});
}));
return self;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"main",{fileServer:fileServer,args:args})});
}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "mimeTypeFor:",
protocol: "accessing",
args: ["aString"],
source: "mimeTypeFor: aString\x0a\x09^ self mimeTypes at: (aString replace: '.*[\x5c.]' with: '') ifAbsent: ['text/plain']",
referencedClasses: [],
pragmas: [],
messageSends: ["at:ifAbsent:", "mimeTypes", "replace:with:"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._mimeTypes())._at_ifAbsent_($recv(aString)._replace_with_(".*[\x5c.]",""),(function(){
return "text/plain";

}));
}, function($ctx1) {$ctx1.fill(self,"mimeTypeFor:",{aString:aString})});
}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "mimeTypes",
protocol: "accessing",
args: [],
source: "mimeTypes\x0a\x09^ mimeTypes ifNil: [mimeTypes := self defaultMimeTypes]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNil:", "defaultMimeTypes"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.mimeTypes;
if($1 == null || $1.a$nil){
$self.mimeTypes=$self._defaultMimeTypes();
return $self.mimeTypes;
} else {
return $1;
}
}, function($ctx1) {$ctx1.fill(self,"mimeTypes",{})});
}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "printHelp",
protocol: "accessing",
args: [],
source: "printHelp\x0a\x09console log: 'Available commandline options are:'.\x0a\x09console log: '--help'.\x0a\x09self commandLineSwitches do: [ :each |\x0a\x09\x09console log: each, ' <parameter>']",
referencedClasses: [],
pragmas: [],
messageSends: ["log:", "do:", "commandLineSwitches", ","]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[$recv(console)._log_("Available commandline options are:")
,$ctx1.sendIdx["log:"]=1
][0];
[$recv(console)._log_("--help")
,$ctx1.sendIdx["log:"]=2
][0];
$recv($self._commandLineSwitches())._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(console)._log_($recv(each).__comma(" <parameter>"));
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"printHelp",{})});
}; }),
$globals.FileServer.a$cls);

$core.addMethod(
$core.method({
selector: "selectorForCommandLineSwitch:",
protocol: "accessing",
args: ["aSwitch"],
source: "selectorForCommandLineSwitch: aSwitch\x0a\x09\x22Remove the trailing '--', add ':' at the end\x0a\x09 and replace all occurences of a lowercase letter preceded by a '-' with\x0a\x09 the Uppercase letter.\x0a\x09 Example: --fallback-page becomes fallbackPage:\x22\x0a\x09^ ((aSwitch replace: '^--' with: '')\x0a\x09\x09replace: '-[a-z]' with: [ :each | each second asUppercase ]), ':'",
referencedClasses: [],
pragmas: [],
messageSends: [",", "replace:with:", "asUppercase", "second"]
}, function ($methodClass){ return function (aSwitch){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv([$recv($recv(aSwitch)._replace_with_("^--",""))._replace_with_("-[a-z]",(function(each){
return $core.withContext(function($ctx2) {
return $recv($recv(each)._second())._asUppercase();
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}))
,$ctx1.sendIdx["replace:with:"]=1
][0]).__comma(":");
}, function($ctx1) {$ctx1.fill(self,"selectorForCommandLineSwitch:",{aSwitch:aSwitch})});
}; }),
$globals.FileServer.a$cls);


$core.addClass("Initer", $globals.BaseFileManipulator, "AmberCli");
$core.setSlots($globals.Initer, ["childProcess", "nmPath"]);
$core.addMethod(
$core.method({
selector: "finishMessage",
protocol: "action",
args: [],
source: "finishMessage\x0a\x09console log: (#(\x0a\x09\x09' '\x0a\x09\x09'The project should now be set up.'\x0a\x09\x09' '\x0a\x09\x09' '\x0a\x09) join: String lf).\x0a\x09[] valueWithTimeout: 600",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["log:", "join:", "lf", "valueWithTimeout:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv(console)._log_([" ", "The project should now be set up.", " ", " "]._join_($recv($globals.String)._lf()));
$recv((function(){

}))._valueWithTimeout_((600));
return self;
}, function($ctx1) {$ctx1.fill(self,"finishMessage",{})});
}; }),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "gruntInitThenDo:",
protocol: "action",
args: ["aBlock"],
source: "gruntInitThenDo: aBlock\x0a\x09| child sanitizedTemplatePath |\x0a\x09sanitizedTemplatePath := ((path join: nmPath with: '@ambers/grunt-init-amber-project')\x0a\x09\x09replace: '\x5c\x5c' with: '\x5c\x5c') replace: ':' with: '\x5c:'.\x0a\x09child := childProcess\x0a\x09\x09fork: (self npmScriptForModule: 'grunt-init' named: 'grunt-init')\x0a\x09\x09args: {sanitizedTemplatePath}.\x0a\x09child\x0a\x09\x09on: 'error' do: aBlock;\x0a\x09\x09on: 'close' do: [ :code |\x0a\x09\x09\x09aBlock value: (code = 0 ifTrue: [ nil ] ifFalse: [ code ]) ]",
referencedClasses: [],
pragmas: [],
messageSends: ["replace:with:", "join:with:", "fork:args:", "npmScriptForModule:named:", "on:do:", "value:", "ifTrue:ifFalse:", "="]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var child,sanitizedTemplatePath;
return $core.withContext(function($ctx1) {
var $1,$2;
sanitizedTemplatePath=[$recv($recv($recv($self.path)._join_with_($self.nmPath,"@ambers/grunt-init-amber-project"))._replace_with_("\x5c\x5c","\x5c\x5c"))._replace_with_(":","\x5c:")
,$ctx1.sendIdx["replace:with:"]=1
][0];
child=$recv($self.childProcess)._fork_args_($self._npmScriptForModule_named_("grunt-init","grunt-init"),[sanitizedTemplatePath]);
$1=child;
[$recv($1)._on_do_("error",aBlock)
,$ctx1.sendIdx["on:do:"]=1
][0];
$recv($1)._on_do_("close",(function(code){
return $core.withContext(function($ctx2) {
if($core.assert($recv(code).__eq((0)))){
$2=nil;
} else {
$2=code;
}
return $recv(aBlock)._value_($2);
}, function($ctx2) {$ctx2.fillBlock({code:code},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"gruntInitThenDo:",{aBlock:aBlock,child:child,sanitizedTemplatePath:sanitizedTemplatePath})});
}; }),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "initProjectThenDo:",
protocol: "action",
args: ["aBlock"],
source: "initProjectThenDo: aBlock\x0a\x09| child |\x0a\x09child := childProcess\x0a\x09\x09exec: 'npm run init'\x0a\x09\x09thenDo: aBlock.\x0a\x09child stdout pipe: process stdout options: #{ 'end' -> false }",
referencedClasses: [],
pragmas: [],
messageSends: ["exec:thenDo:", "pipe:options:", "stdout"]
}, function ($methodClass){ return function (aBlock){
var self=this,$self=this;
var child;
return $core.withContext(function($ctx1) {
child=$recv($self.childProcess)._exec_thenDo_("npm run init",aBlock);
$recv([$recv(child)._stdout()
,$ctx1.sendIdx["stdout"]=1
][0])._pipe_options_($recv(process)._stdout(),$globals.HashedCollection._newFromPairs_(["end",false]));
return self;
}, function($ctx1) {$ctx1.fill(self,"initProjectThenDo:",{aBlock:aBlock,child:child})});
}; }),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09childProcess := require value: 'child_process'.\x0a\x09nmPath := path join: self rootDirname with: 'node_modules'",
referencedClasses: [],
pragmas: [],
messageSends: ["initialize", "value:", "join:with:", "rootDirname"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.childProcess=$recv(require)._value_("child_process");
$self.nmPath=$recv($self.path)._join_with_($self._rootDirname(),"node_modules");
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "npmScriptForModule:named:",
protocol: "npm",
args: ["aString", "anotherString"],
source: "npmScriptForModule: aString named: anotherString\x0a\x09| modulePath packageJson binSection scriptPath |\x0a\x09modulePath := path dirname: (\x0a\x09\x09require provided resolve: aString, '/package.json').\x0a\x09packageJson := Smalltalk readJSObject: (\x0a\x09\x09require value: aString, '/package.json').\x0a\x09binSection := packageJson at: 'bin'.\x0a\x09scriptPath := binSection isString\x0a\x09\x09ifTrue: [ binSection ]\x0a\x09\x09ifFalse: [ binSection at: anotherString ].\x0a\x09^ path join: modulePath with: scriptPath",
referencedClasses: ["Smalltalk"],
pragmas: [],
messageSends: ["dirname:", "resolve:", "provided", ",", "readJSObject:", "value:", "at:", "ifTrue:ifFalse:", "isString", "join:with:"]
}, function ($methodClass){ return function (aString,anotherString){
var self=this,$self=this;
var modulePath,packageJson,binSection,scriptPath;
return $core.withContext(function($ctx1) {
modulePath=$recv($self.path)._dirname_($recv($recv(require)._provided())._resolve_([$recv(aString).__comma("/package.json")
,$ctx1.sendIdx[","]=1
][0]));
packageJson=$recv($globals.Smalltalk)._readJSObject_($recv(require)._value_($recv(aString).__comma("/package.json")));
binSection=[$recv(packageJson)._at_("bin")
,$ctx1.sendIdx["at:"]=1
][0];
if($core.assert($recv(binSection)._isString())){
scriptPath=binSection;
} else {
scriptPath=$recv(binSection)._at_(anotherString);
}
return $recv($self.path)._join_with_(modulePath,scriptPath);
}, function($ctx1) {$ctx1.fill(self,"npmScriptForModule:named:",{aString:aString,anotherString:anotherString,modulePath:modulePath,packageJson:packageJson,binSection:binSection,scriptPath:scriptPath})});
}; }),
$globals.Initer);

$core.addMethod(
$core.method({
selector: "start",
protocol: "action",
args: [],
source: "start\x0a\x09self gruntInitThenDo: [ :error | error\x0a\x09ifNotNil: [\x0a\x09\x09console log: 'grunt-init exec error:'; log: error.\x0a\x09\x09process exit: 101 ]\x0a\x09ifNil: [\x0a\x0a\x09self initProjectThenDo: [ :error2 | error2\x0a\x09ifNotNil: [\x0a\x09\x09console log: 'npm run init exec error:'; log: error2.\x0a\x09\x09process exit: 105 ]\x0a\x09ifNil: [\x0a\x0a\x09self finishMessage.\x0a\x09process exit ]]]]",
referencedClasses: [],
pragmas: [],
messageSends: ["gruntInitThenDo:", "ifNotNil:ifNil:", "log:", "exit:", "initProjectThenDo:", "finishMessage", "exit"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
$self._gruntInitThenDo_((function(error){
return $core.withContext(function($ctx2) {
if(error == null || error.a$nil){
return $self._initProjectThenDo_((function(error2){
return $core.withContext(function($ctx3) {
if(error2 == null || error2.a$nil){
$self._finishMessage();
return $recv(process)._exit();
} else {
$2=console;
[$recv($2)._log_("npm run init exec error:")
,$ctx3.sendIdx["log:"]=3
][0];
$recv($2)._log_(error2);
return $recv(process)._exit_((105));
}
}, function($ctx3) {$ctx3.fillBlock({error2:error2},$ctx2,4)});
}));
} else {
$1=console;
[$recv($1)._log_("grunt-init exec error:")
,$ctx2.sendIdx["log:"]=1
][0];
[$recv($1)._log_(error)
,$ctx2.sendIdx["log:"]=2
][0];
return [$recv(process)._exit_((101))
,$ctx2.sendIdx["exit:"]=1
][0];
}
}, function($ctx2) {$ctx2.fillBlock({error:error},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"start",{})});
}; }),
$globals.Initer);



$core.addClass("Repl", $globals.Object, "AmberCli");
$core.setSlots($globals.Repl, ["readline", "interface", "util", "session", "resultCount", "commands"]);
$globals.Repl.comment="I am a class representing a REPL (Read Evaluate Print Loop) and provide a command line interface to Amber Smalltalk.\x0aOn the prompt you can type Amber statements which will be evaluated after pressing <Enter>.\x0aThe evaluation is comparable with executing a 'DoIt' in a workspace.\x0a\x0aMy runtime requirement is a functional Node.js executable with working Readline support.";
$core.addMethod(
$core.method({
selector: "addVariableNamed:to:",
protocol: "private",
args: ["aString", "anObject"],
source: "addVariableNamed: aString to: anObject\x0a\x09| newClass newObject |\x0a\x09newClass := self subclass: anObject class withVariable: aString.\x0a\x09self encapsulateVariable: aString withValue: anObject in: newClass.\x0a\x09newObject := newClass new.\x0a\x09self setPreviousVariablesFor: newObject from: anObject.\x0a\x09^ newObject",
referencedClasses: [],
pragmas: [],
messageSends: ["subclass:withVariable:", "class", "encapsulateVariable:withValue:in:", "new", "setPreviousVariablesFor:from:"]
}, function ($methodClass){ return function (aString,anObject){
var self=this,$self=this;
var newClass,newObject;
return $core.withContext(function($ctx1) {
newClass=$self._subclass_withVariable_($recv(anObject)._class(),aString);
$self._encapsulateVariable_withValue_in_(aString,anObject,newClass);
newObject=$recv(newClass)._new();
$self._setPreviousVariablesFor_from_(newObject,anObject);
return newObject;
}, function($ctx1) {$ctx1.fill(self,"addVariableNamed:to:",{aString:aString,anObject:anObject,newClass:newClass,newObject:newObject})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "assignNewVariable:do:",
protocol: "private",
args: ["buffer", "aBlock"],
source: "assignNewVariable: buffer do: aBlock\x0a\x09\x22Assigns a new variable and calls the given block with the variable's name and value\x0a\x09 if buffer contains an assignment expression. If it doesn't the block is called with nil for\x0a\x09 both arguments.\x22\x0a\x09^ self parseAssignment: buffer do: [ :name :expr || varName value |\x0a\x09\x09varName := name ifNil: [self nextResultName].\x0a\x09\x09session := self addVariableNamed: varName to: session.\x0a\x09\x09[ value := self eval: varName, ' := ', (expr ifNil: [buffer]) on: session ]\x0a\x09\x09\x09on: Error\x0a\x09\x09\x09do: [ :e | ConsoleErrorHandler new logError: e. value := nil].\x0a\x09\x09aBlock value: varName value: value]",
referencedClasses: ["Error", "ConsoleErrorHandler"],
pragmas: [],
messageSends: ["parseAssignment:do:", "ifNil:", "nextResultName", "addVariableNamed:to:", "on:do:", "eval:on:", ",", "logError:", "new", "value:value:"]
}, function ($methodClass){ return function (buffer,aBlock){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1,$2;
return $self._parseAssignment_do_(buffer,(function(name,expr){
var varName,value;
return $core.withContext(function($ctx2) {
if(name == null || name.a$nil){
varName=$self._nextResultName();
} else {
varName=name;
}
$self.session=$self._addVariableNamed_to_(varName,$self.session);
$recv((function(){
return $core.withContext(function($ctx3) {
$1=$recv(varName).__comma(" := ");
if(expr == null || expr.a$nil){
$2=buffer;
} else {
$2=expr;
}
value=$self._eval_on_([$recv($1).__comma($2)
,$ctx3.sendIdx[","]=1
][0],$self.session);
return value;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,3)});
}))._on_do_($globals.Error,(function(e){
return $core.withContext(function($ctx3) {
$recv($recv($globals.ConsoleErrorHandler)._new())._logError_(e);
value=nil;
return value;
}, function($ctx3) {$ctx3.fillBlock({e:e},$ctx2,5)});
}));
return $recv(aBlock)._value_value_(varName,value);
}, function($ctx2) {$ctx2.fillBlock({name:name,expr:expr,varName:varName,value:value},$ctx1,1)});
}));
}, function($ctx1) {$ctx1.fill(self,"assignNewVariable:do:",{buffer:buffer,aBlock:aBlock})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "clearScreen",
protocol: "actions",
args: [],
source: "clearScreen\x0a\x09| esc cls |\x0a\x09esc := String fromCharCode: 27.\x0a\x09cls := esc, '[2J', esc, '[0;0f'.\x0a\x09process stdout write: cls.\x0a\x09interface prompt",
referencedClasses: ["String"],
pragmas: [],
messageSends: ["fromCharCode:", ",", "write:", "stdout", "prompt"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
var esc,cls;
return $core.withContext(function($ctx1) {
esc=$recv($globals.String)._fromCharCode_((27));
cls=[$recv([$recv($recv(esc).__comma("[2J")).__comma(esc)
,$ctx1.sendIdx[","]=2
][0]).__comma("[0;0f")
,$ctx1.sendIdx[","]=1
][0];
$recv($recv(process)._stdout())._write_(cls);
$recv($self.interface)._prompt();
return self;
}, function($ctx1) {$ctx1.fill(self,"clearScreen",{esc:esc,cls:cls})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "close",
protocol: "actions",
args: [],
source: "close\x0a\x09process stdin destroy",
referencedClasses: [],
pragmas: [],
messageSends: ["destroy", "stdin"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(process)._stdin())._destroy();
return self;
}, function($ctx1) {$ctx1.fill(self,"close",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "commands",
protocol: "accessing",
args: [],
source: "commands\x0a\x09^ commands",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $self.commands;

}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "createInterface",
protocol: "actions",
args: [],
source: "createInterface\x0a\x09interface := readline createInterface: process stdin stdout: process stdout.\x0a\x09interface on: 'line' do: [:buffer | self processLine: buffer].\x0a\x09interface on: 'close' do: [self close].\x0a\x09self printWelcome; setupHotkeys; setPrompt.\x0a\x09interface prompt",
referencedClasses: [],
pragmas: [],
messageSends: ["createInterface:stdout:", "stdin", "stdout", "on:do:", "processLine:", "close", "printWelcome", "setupHotkeys", "setPrompt", "prompt"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.interface=$recv($self.readline)._createInterface_stdout_($recv(process)._stdin(),$recv(process)._stdout());
[$recv($self.interface)._on_do_("line",(function(buffer){
return $core.withContext(function($ctx2) {
return $self._processLine_(buffer);
}, function($ctx2) {$ctx2.fillBlock({buffer:buffer},$ctx1,1)});
}))
,$ctx1.sendIdx["on:do:"]=1
][0];
$recv($self.interface)._on_do_("close",(function(){
return $core.withContext(function($ctx2) {
return $self._close();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}));
$self._printWelcome();
$self._setupHotkeys();
$self._setPrompt();
$recv($self.interface)._prompt();
return self;
}, function($ctx1) {$ctx1.fill(self,"createInterface",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "encapsulateVariable:withValue:in:",
protocol: "private",
args: ["aString", "anObject", "aClass"],
source: "encapsulateVariable: aString withValue: anObject in: aClass\x0a\x09\x22Add getter and setter for given variable to session.\x22\x0a\x09| compiler |\x0a\x09compiler := Compiler new.\x0a\x09compiler install: aString, ': anObject ^ ', aString, ' := anObject' forClass: aClass protocol: 'session'.\x0a\x09compiler install: aString, ' ^ ', aString forClass: aClass protocol: 'session'.",
referencedClasses: ["Compiler"],
pragmas: [],
messageSends: ["new", "install:forClass:protocol:", ","]
}, function ($methodClass){ return function (aString,anObject,aClass){
var self=this,$self=this;
var compiler;
return $core.withContext(function($ctx1) {
compiler=$recv($globals.Compiler)._new();
[$recv(compiler)._install_forClass_protocol_([$recv([$recv([$recv(aString).__comma(": anObject ^ ")
,$ctx1.sendIdx[","]=3
][0]).__comma(aString)
,$ctx1.sendIdx[","]=2
][0]).__comma(" := anObject")
,$ctx1.sendIdx[","]=1
][0],aClass,"session")
,$ctx1.sendIdx["install:forClass:protocol:"]=1
][0];
$recv(compiler)._install_forClass_protocol_([$recv($recv(aString).__comma(" ^ ")).__comma(aString)
,$ctx1.sendIdx[","]=4
][0],aClass,"session");
return self;
}, function($ctx1) {$ctx1.fill(self,"encapsulateVariable:withValue:in:",{aString:aString,anObject:anObject,aClass:aClass,compiler:compiler})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "eval:",
protocol: "actions",
args: ["buffer"],
source: "eval: buffer\x0a\x09^ self eval: buffer on: DoIt new.",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["eval:on:", "new"]
}, function ($methodClass){ return function (buffer){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $self._eval_on_(buffer,$recv($globals.DoIt)._new());
}, function($ctx1) {$ctx1.fill(self,"eval:",{buffer:buffer})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "eval:on:",
protocol: "actions",
args: ["buffer", "anObject"],
source: "eval: buffer on: anObject\x0a\x09| result |\x0a\x09buffer ifNotEmpty: [\x0a\x09\x09[result := Compiler new evaluateExpression: buffer on: anObject]\x0a\x09\x09\x09tryIfTrue: [ :e | (Smalltalk isError: e) not or: [ e context isNil ] ]\x0a\x09\x09\x09catch: [ :e | process stdout write: e jsStack ]].\x0a\x09^ result",
referencedClasses: ["Compiler", "Smalltalk"],
pragmas: [],
messageSends: ["ifNotEmpty:", "tryIfTrue:catch:", "evaluateExpression:on:", "new", "or:", "not", "isError:", "isNil", "context", "write:", "stdout", "jsStack"]
}, function ($methodClass){ return function (buffer,anObject){
var self=this,$self=this;
var result;
return $core.withContext(function($ctx1) {
$recv(buffer)._ifNotEmpty_((function(){
return $core.withContext(function($ctx2) {
return $recv((function(){
return $core.withContext(function($ctx3) {
result=$recv($recv($globals.Compiler)._new())._evaluateExpression_on_(buffer,anObject);
return result;
}, function($ctx3) {$ctx3.fillBlock({},$ctx2,2)});
}))._tryIfTrue_catch_((function(e){
return $core.withContext(function($ctx3) {
if($core.assert($recv($recv($globals.Smalltalk)._isError_(e))._not())){
return true;
} else {
return $recv($recv(e)._context())._isNil();
}
}, function($ctx3) {$ctx3.fillBlock({e:e},$ctx2,3)});
}),(function(e){
return $core.withContext(function($ctx3) {
return $recv($recv(process)._stdout())._write_($recv(e)._jsStack());
}, function($ctx3) {$ctx3.fillBlock({e:e},$ctx2,5)});
}));
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}));
return result;
}, function($ctx1) {$ctx1.fill(self,"eval:on:",{buffer:buffer,anObject:anObject,result:result})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "executeCommand:",
protocol: "private",
args: ["aString"],
source: "executeCommand: aString\x0a\x09\x22Tries to process the given string as a command. Returns true if it was a command, false if not.\x22\x0a\x09self commands keysAndValuesDo: [:names :cmd |\x0a\x09\x09(names includes: aString) ifTrue: [\x0a\x09\x09\x09cmd value.\x0a\x09\x09\x09^ true]].\x0a\x09^ false",
referencedClasses: [],
pragmas: [],
messageSends: ["keysAndValuesDo:", "commands", "ifTrue:", "includes:", "value"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $early={};
try {
$recv($self._commands())._keysAndValuesDo_((function(names,cmd){
return $core.withContext(function($ctx2) {
if($core.assert($recv(names)._includes_(aString))){
$recv(cmd)._value();
throw $early=[true];
}
}, function($ctx2) {$ctx2.fillBlock({names:names,cmd:cmd},$ctx1,1)});
}));
return false;
}
catch(e) {if(e===$early)return e[0]; throw e}
}, function($ctx1) {$ctx1.fill(self,"executeCommand:",{aString:aString})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "initialize",
protocol: "initialization",
args: [],
source: "initialize\x0a\x09super initialize.\x0a\x09session := DoIt new.\x0a\x09readline := require value: 'readline'.\x0a\x09util := require value: 'util'.\x0a\x09self setupCommands",
referencedClasses: ["DoIt"],
pragmas: [],
messageSends: ["initialize", "new", "value:", "setupCommands"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
[(
$ctx1.supercall = true,
($methodClass.superclass||$boot.nilAsClass).fn.prototype._initialize.call($self))
,$ctx1.supercall = false
][0];
$self.session=$recv($globals.DoIt)._new();
$self.readline=[$recv(require)._value_("readline")
,$ctx1.sendIdx["value:"]=1
][0];
$self.util=$recv(require)._value_("util");
$self._setupCommands();
return self;
}, function($ctx1) {$ctx1.fill(self,"initialize",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "instanceVariableNamesFor:",
protocol: "private",
args: ["aClass"],
source: "instanceVariableNamesFor: aClass\x0a\x09\x22Yields all instance variable names for the given class, including inherited ones.\x22\x0a\x09^ aClass superclass\x0a\x09\x09ifNotNil: [\x0a\x09\x09\x09aClass instanceVariableNames copyWithAll: (self instanceVariableNamesFor: aClass superclass)]\x0a\x09\x09ifNil: [\x0a\x09\x09\x09aClass instanceVariableNames]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:ifNil:", "superclass", "copyWithAll:", "instanceVariableNames", "instanceVariableNamesFor:"]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$recv(aClass)._superclass()
,$ctx1.sendIdx["superclass"]=1
][0];
if($1 == null || $1.a$nil){
return $recv(aClass)._instanceVariableNames();
} else {
return $recv([$recv(aClass)._instanceVariableNames()
,$ctx1.sendIdx["instanceVariableNames"]=1
][0])._copyWithAll_($self._instanceVariableNamesFor_($recv(aClass)._superclass()));
}
}, function($ctx1) {$ctx1.fill(self,"instanceVariableNamesFor:",{aClass:aClass})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "isIdentifier:",
protocol: "private",
args: ["aString"],
source: "isIdentifier: aString\x0a\x09^ aString match: '^[a-z_]\x5cw*$' asRegexp",
referencedClasses: [],
pragmas: [],
messageSends: ["match:", "asRegexp"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv(aString)._match_("^[a-z_]\x5cw*$"._asRegexp());
}, function($ctx1) {$ctx1.fill(self,"isIdentifier:",{aString:aString})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "isVariableDefined:",
protocol: "private",
args: ["aString"],
source: "isVariableDefined: aString\x0a\x09^ (self instanceVariableNamesFor: session class) includes: aString",
referencedClasses: [],
pragmas: [],
messageSends: ["includes:", "instanceVariableNamesFor:", "class"]
}, function ($methodClass){ return function (aString){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($self._instanceVariableNamesFor_($recv($self.session)._class()))._includes_(aString);
}, function($ctx1) {$ctx1.fill(self,"isVariableDefined:",{aString:aString})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "nextResultName",
protocol: "private",
args: [],
source: "nextResultName\x0a\x09resultCount := resultCount\x0a    \x09ifNotNil: [resultCount + 1]\x0a    \x09ifNil: [1].\x0a    ^ 'res', resultCount asString",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:ifNil:", "+", ",", "asString"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$self.resultCount;
if($1 == null || $1.a$nil){
$self.resultCount=(1);
} else {
$self.resultCount=$recv($self.resultCount).__plus((1));
}
return "res".__comma($recv($self.resultCount)._asString());
}, function($ctx1) {$ctx1.fill(self,"nextResultName",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "onKeyPress:",
protocol: "private",
args: ["key"],
source: "onKeyPress: key\x0a\x09(key ctrl and: [key name = 'l'])\x0a\x09\x09ifTrue: [self clearScreen]",
referencedClasses: [],
pragmas: [],
messageSends: ["ifTrue:", "and:", "ctrl", "=", "name", "clearScreen"]
}, function ($methodClass){ return function (key){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
if($core.assert($recv(key)._ctrl())){
$1=$recv($recv(key)._name()).__eq("l");
} else {
$1=false;
}
if($core.assert($1)){
$self._clearScreen();
}
return self;
}, function($ctx1) {$ctx1.fill(self,"onKeyPress:",{key:key})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "parseAssignment:do:",
protocol: "private",
args: ["aString", "aBlock"],
source: "parseAssignment: aString do: aBlock\x0a\x09\x22Assigns a new variable if the given string is an assignment expression. Calls the given block with name and value.\x0a\x09 If the string is not one no variable will be assigned and the block will be called with nil for both arguments.\x22\x0a\x09| assignment |\x0a\x09assignment := (aString tokenize: ':=') collect: [:s | s trimBoth].\x0a\x09^ (assignment size = 2 and: [self isIdentifier: assignment first])\x0a\x09\x09ifTrue: [ aBlock value: assignment first value: assignment last ]\x0a\x09\x09ifFalse: [ aBlock value: nil value: nil ]",
referencedClasses: [],
pragmas: [],
messageSends: ["collect:", "tokenize:", "trimBoth", "ifTrue:ifFalse:", "and:", "=", "size", "isIdentifier:", "first", "value:value:", "last"]
}, function ($methodClass){ return function (aString,aBlock){
var self=this,$self=this;
var assignment;
return $core.withContext(function($ctx1) {
var $1;
assignment=$recv($recv(aString)._tokenize_(":="))._collect_((function(s){
return $core.withContext(function($ctx2) {
return $recv(s)._trimBoth();
}, function($ctx2) {$ctx2.fillBlock({s:s},$ctx1,1)});
}));
if($core.assert($recv($recv(assignment)._size()).__eq((2)))){
$1=$self._isIdentifier_([$recv(assignment)._first()
,$ctx1.sendIdx["first"]=1
][0]);
} else {
$1=false;
}
if($core.assert($1)){
return [$recv(aBlock)._value_value_($recv(assignment)._first(),$recv(assignment)._last())
,$ctx1.sendIdx["value:value:"]=1
][0];
} else {
return $recv(aBlock)._value_value_(nil,nil);
}
}, function($ctx1) {$ctx1.fill(self,"parseAssignment:do:",{aString:aString,aBlock:aBlock,assignment:assignment})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "presentResultNamed:withValue:",
protocol: "private",
args: ["varName", "value"],
source: "presentResultNamed: varName withValue: value\x0a\x09Transcript show: varName, ': ', value class name, ' = ', value asString; cr.\x0a\x09interface prompt",
referencedClasses: ["Transcript"],
pragmas: [],
messageSends: ["show:", ",", "name", "class", "asString", "cr", "prompt"]
}, function ($methodClass){ return function (varName,value){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$globals.Transcript;
$recv($1)._show_([$recv([$recv([$recv($recv(varName).__comma(": ")).__comma($recv($recv(value)._class())._name())
,$ctx1.sendIdx[","]=3
][0]).__comma(" = ")
,$ctx1.sendIdx[","]=2
][0]).__comma($recv(value)._asString())
,$ctx1.sendIdx[","]=1
][0]);
$recv($1)._cr();
$recv($self.interface)._prompt();
return self;
}, function($ctx1) {$ctx1.fill(self,"presentResultNamed:withValue:",{varName:varName,value:value})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "printWelcome",
protocol: "actions",
args: [],
source: "printWelcome\x0a\x09Transcript show: 'Type :q to exit.'; cr.",
referencedClasses: ["Transcript"],
pragmas: [],
messageSends: ["show:", "cr"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=$globals.Transcript;
$recv($1)._show_("Type :q to exit.");
$recv($1)._cr();
return self;
}, function($ctx1) {$ctx1.fill(self,"printWelcome",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "processLine:",
protocol: "private",
args: ["buffer"],
source: "processLine: buffer\x0a\x09\x22Processes lines entered through the readline interface.\x22\x0a\x09| show |\x0a\x09show := [:varName :value | self presentResultNamed: varName withValue: value].\x0a\x09(self executeCommand: buffer) ifFalse: [\x0a\x09\x09(self isVariableDefined: buffer)\x0a\x09\x09\x09ifTrue: [show value: buffer value: (session perform: buffer)]\x0a\x09\x09\x09ifFalse: [self assignNewVariable: buffer do: show]]",
referencedClasses: [],
pragmas: [],
messageSends: ["presentResultNamed:withValue:", "ifFalse:", "executeCommand:", "ifTrue:ifFalse:", "isVariableDefined:", "value:value:", "perform:", "assignNewVariable:do:"]
}, function ($methodClass){ return function (buffer){
var self=this,$self=this;
var show;
return $core.withContext(function($ctx1) {
show=(function(varName,value){
return $core.withContext(function($ctx2) {
return $self._presentResultNamed_withValue_(varName,value);
}, function($ctx2) {$ctx2.fillBlock({varName:varName,value:value},$ctx1,1)});
});
if(!$core.assert($self._executeCommand_(buffer))){
if($core.assert($self._isVariableDefined_(buffer))){
$recv(show)._value_value_(buffer,$recv($self.session)._perform_(buffer));
} else {
$self._assignNewVariable_do_(buffer,show);
}
}
return self;
}, function($ctx1) {$ctx1.fill(self,"processLine:",{buffer:buffer,show:show})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "prompt",
protocol: "accessing",
args: [],
source: "prompt\x0a\x09^ 'amber >> '",
referencedClasses: [],
pragmas: [],
messageSends: []
}, function ($methodClass){ return function (){
var self=this,$self=this;
return "amber >> ";

}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setPreviousVariablesFor:from:",
protocol: "private",
args: ["newObject", "oldObject"],
source: "setPreviousVariablesFor: newObject from: oldObject\x0a\x09(self instanceVariableNamesFor: oldObject class) do: [:each |\x0a\x09\x09newObject perform: each, ':' withArguments: {oldObject perform: each}].",
referencedClasses: [],
pragmas: [],
messageSends: ["do:", "instanceVariableNamesFor:", "class", "perform:withArguments:", ",", "perform:"]
}, function ($methodClass){ return function (newObject,oldObject){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._instanceVariableNamesFor_($recv(oldObject)._class()))._do_((function(each){
return $core.withContext(function($ctx2) {
return $recv(newObject)._perform_withArguments_($recv(each).__comma(":"),[$recv(oldObject)._perform_(each)]);
}, function($ctx2) {$ctx2.fillBlock({each:each},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"setPreviousVariablesFor:from:",{newObject:newObject,oldObject:oldObject})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setPrompt",
protocol: "actions",
args: [],
source: "setPrompt\x0a\x09interface setPrompt: self prompt",
referencedClasses: [],
pragmas: [],
messageSends: ["setPrompt:", "prompt"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self.interface)._setPrompt_($self._prompt());
return self;
}, function($ctx1) {$ctx1.fill(self,"setPrompt",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setupCommands",
protocol: "initialization",
args: [],
source: "setupCommands\x0a\x09commands := Dictionary from: {\x0a\x09\x09{':q'} -> [process exit].\x0a\x09\x09{''} -> [interface prompt]}",
referencedClasses: ["Dictionary"],
pragmas: [],
messageSends: ["from:", "->", "exit", "prompt"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$self.commands=$recv($globals.Dictionary)._from_([[$recv([":q"]).__minus_gt((function(){
return $core.withContext(function($ctx2) {
return $recv(process)._exit();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,1)});
}))
,$ctx1.sendIdx["->"]=1
][0],$recv([""]).__minus_gt((function(){
return $core.withContext(function($ctx2) {
return $recv($self.interface)._prompt();
}, function($ctx2) {$ctx2.fillBlock({},$ctx1,2)});
}))]);
return self;
}, function($ctx1) {$ctx1.fill(self,"setupCommands",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "setupHotkeys",
protocol: "initialization",
args: [],
source: "setupHotkeys\x0a\x09process stdin on: 'keypress' do: [:s :key | key ifNotNil: [self onKeyPress: key]].",
referencedClasses: [],
pragmas: [],
messageSends: ["on:do:", "stdin", "ifNotNil:", "onKeyPress:"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($recv(process)._stdin())._on_do_("keypress",(function(s,key){
return $core.withContext(function($ctx2) {
if(key == null || key.a$nil){
return key;
} else {
return $self._onKeyPress_(key);
}
}, function($ctx2) {$ctx2.fillBlock({s:s,key:key},$ctx1,1)});
}));
return self;
}, function($ctx1) {$ctx1.fill(self,"setupHotkeys",{})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "subclass:withVariable:",
protocol: "private",
args: ["aClass", "varName"],
source: "subclass: aClass withVariable: varName\x0a\x09\x22Create subclass with new variable.\x22\x0a\x09^ ClassBuilder new\x0a\x09\x09addSubclassOf: aClass\x0a\x09\x09named: (self subclassNameFor: aClass) asSymbol\x0a\x09\x09slots: {varName}\x0a\x09\x09package: 'Compiler-Core'",
referencedClasses: ["ClassBuilder"],
pragmas: [],
messageSends: ["addSubclassOf:named:slots:package:", "new", "asSymbol", "subclassNameFor:"]
}, function ($methodClass){ return function (aClass,varName){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
return $recv($recv($globals.ClassBuilder)._new())._addSubclassOf_named_slots_package_(aClass,$recv($self._subclassNameFor_(aClass))._asSymbol(),[varName],"Compiler-Core");
}, function($ctx1) {$ctx1.fill(self,"subclass:withVariable:",{aClass:aClass,varName:varName})});
}; }),
$globals.Repl);

$core.addMethod(
$core.method({
selector: "subclassNameFor:",
protocol: "private",
args: ["aClass"],
source: "subclassNameFor: aClass\x0a\x09^ (aClass name matchesOf: '\x5cd+$')\x0a\x09\x09ifNotNil: [ | counter |\x0a\x09\x09\x09counter := (aClass name matchesOf: '\x5cd+$') first asNumber + 1.\x0a\x09\x09\x09aClass name replaceRegexp: '\x5cd+$' asRegexp with: counter asString]\x0a\x09\x09ifNil: [\x0a\x09\x09\x09aClass name, '2'].",
referencedClasses: [],
pragmas: [],
messageSends: ["ifNotNil:ifNil:", "matchesOf:", "name", "+", "asNumber", "first", "replaceRegexp:with:", "asRegexp", "asString", ","]
}, function ($methodClass){ return function (aClass){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
var $1;
$1=[$recv([$recv(aClass)._name()
,$ctx1.sendIdx["name"]=1
][0])._matchesOf_("\x5cd+$")
,$ctx1.sendIdx["matchesOf:"]=1
][0];
if($1 == null || $1.a$nil){
return $recv($recv(aClass)._name()).__comma("2");
} else {
var counter;
counter=$recv($recv($recv($recv([$recv(aClass)._name()
,$ctx1.sendIdx["name"]=2
][0])._matchesOf_("\x5cd+$"))._first())._asNumber()).__plus((1));
return $recv([$recv(aClass)._name()
,$ctx1.sendIdx["name"]=3
][0])._replaceRegexp_with_("\x5cd+$"._asRegexp(),$recv(counter)._asString());
}
}, function($ctx1) {$ctx1.fill(self,"subclassNameFor:",{aClass:aClass})});
}; }),
$globals.Repl);


$core.addMethod(
$core.method({
selector: "main",
protocol: "initialization",
args: [],
source: "main\x0a\x09self new createInterface",
referencedClasses: [],
pragmas: [],
messageSends: ["createInterface", "new"]
}, function ($methodClass){ return function (){
var self=this,$self=this;
return $core.withContext(function($ctx1) {
$recv($self._new())._createInterface();
return self;
}, function($ctx1) {$ctx1.fill(self,"main",{})});
}; }),
$globals.Repl.a$cls);

});

(function () {
                            define('__app__',["amber/devel", "amber/core/Platform-Node", "amber_cli/AmberCli"], function (amber) {
                                amber.initialize().then(function () {
                                    amber.globals.AmberCli._main();
                                });
                            });
                        }());
(function () {
        define('app',["require", "amber/es6-promise"], function (require, promiseLib) {
            promiseLib.polyfill();
            return new Promise(function (resolve, reject) {
                require(["__app__"], resolve, reject);
            });
        });
    }());

require(["app"]);
});
}((function amdefine(module, requireFn) {
    'use strict';
    var defineCache = {},
        loaderCache = {},
        alreadyCalled = false,
        path = require('path'),
        makeRequire, stringRequire;

    /**
     * Trims the . and .. from an array of path segments.
     * It will keep a leading path segment if a .. will become
     * the first path segment, to help with module name lookups,
     * which act like paths, but can be remapped. But the end result,
     * all paths that use this function should look normalized.
     * NOTE: this method MODIFIES the input array.
     * @param {Array} ary the array of path segments.
     */
    function trimDots(ary) {
        var i, part;
        for (i = 0; ary[i]; i+= 1) {
            part = ary[i];
            if (part === '.') {
                ary.splice(i, 1);
                i -= 1;
            } else if (part === '..') {
                if (i === 1 && (ary[2] === '..' || ary[0] === '..')) {
                    //End of the line. Keep at least one non-dot
                    //path segment at the front so it can be mapped
                    //correctly to disk. Otherwise, there is likely
                    //no path mapping for a path starting with '..'.
                    //This can still fail, but catches the most reasonable
                    //uses of ..
                    break;
                } else if (i > 0) {
                    ary.splice(i - 1, 2);
                    i -= 2;
                }
            }
        }
    }

    function normalize(name, baseName) {
        var baseParts;

        //Adjust any relative paths.
        if (name && name.charAt(0) === '.') {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                baseParts = baseName.split('/');
                baseParts = baseParts.slice(0, baseParts.length - 1);
                baseParts = baseParts.concat(name.split('/'));
                trimDots(baseParts);
                name = baseParts.join('/');
            }
        }

        return name;
    }

    /**
     * Create the normalize() function passed to a loader plugin's
     * normalize method.
     */
    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(id) {
        function load(value) {
            loaderCache[id] = value;
        }

        load.fromText = function (id, text) {
            //This one is difficult because the text can/probably uses
            //define, and any relative paths and requires should be relative
            //to that id was it would be found on disk. But this would require
            //bootstrapping a module/require fairly deeply from node core.
            //Not sure how best to go about that yet.
            throw new Error('amdefine does not implement load.fromText');
        };

        return load;
    }

    makeRequire = function (systemRequire, exports, module, relId) {
        function requireInContext(depName) {
            return stringRequire(systemRequire, exports, module, depName, relId);
        }

        function amdRequire(deps, callback) {
            if (typeof deps === 'string') {
                //Synchronous, single module require('')
                return requireInContext(deps);
            } else {
                //Array of dependencies with a callback.

                if (callback) {
                    //Wait for next tick to call back the require call.
                    process.nextTick(function () {
                        //Convert the dependencies to modules.
                        callback.apply(null, deps.map(requireInContext));
                    });
                } else {
                    //Require the dependencies' moduies.
                    deps.forEach(requireInContext);
                }
            }
        }

        amdRequire.toUrl = function (filePath) {
            if (filePath.indexOf('.') === 0) {
                return normalize(filePath, path.dirname(module.filename));
            } else {
                return filePath;
            }
        };

        return amdRequire;
    };

    //Favor explicit value, passed in if the module wants to support Node 0.4.
    requireFn = requireFn || function req() {
        return module.require.apply(module, arguments);
    };

    function runFactory(id, deps, factory) {
        var r, e, m, result;

        if (id) {
            e = loaderCache[id] = {};
            m = {
                id: id,
                uri: __filename,
                exports: e
            };
            r = makeRequire(requireFn, e, m, id);
        } else {
            //Only support one define call per file
            if (alreadyCalled) {
                throw new Error('amdefine with no module ID cannot be called more than once per file.');
            }
            alreadyCalled = true;

            //Use the real variables from node
            //Use module.exports for exports, since
            //the exports in here is amdefine exports.
            e = module.exports;
            m = module;
            r = makeRequire(requireFn, e, m, module.id);
        }

        //If there are dependencies, they are strings, so need
        //to convert them to dependency values.
        if (deps) {
            deps = deps.map(function (depName) {
                return r(depName);
            });
        }

        //Call the factory with the right dependencies.
        if (typeof factory === 'function') {
            result = factory.apply(m.exports, deps);
        } else {
            result = factory;
        }

        if (result !== undefined) {
            m.exports = result;
            if (id) {
                loaderCache[id] = m.exports;
            }
        }
    }

    stringRequire = function (systemRequire, exports, module, id, relId) {
        //Split the ID by a ! so that
        var index = id.indexOf('!'),
            originalId = id,
            prefix, plugin;

        if (index === -1) {
            id = normalize(id, relId);

            //Straight module lookup. If it is one of the special dependencies,
            //deal with it, otherwise, delegate to node.
            if (id === 'require') {
                return makeRequire(systemRequire, exports, module, relId);
            } else if (id === 'exports') {
                return exports;
            } else if (id === 'module') {
                return module;
            } else if (loaderCache.hasOwnProperty(id)) {
                return loaderCache[id];
            } else if (defineCache[id]) {
                runFactory.apply(null, defineCache[id]);
                return loaderCache[id];
            } else {
                if(systemRequire) {
                    return systemRequire(originalId);
                } else {
                    throw new Error('No module with ID: ' + id);
                }
            }
        } else {
            //There is a plugin in play.
            prefix = id.substring(0, index);
            id = id.substring(index + 1, id.length);

            plugin = stringRequire(systemRequire, exports, module, prefix, relId);

            if (plugin.normalize) {
                id = plugin.normalize(id, makeNormalize(relId));
            } else {
                //Normalize the ID normally.
                id = normalize(id, relId);
            }

            if (loaderCache[id]) {
                return loaderCache[id];
            } else {
                plugin.load(id, makeRequire(systemRequire, exports, module, relId), makeLoad(id), {});

                return loaderCache[id];
            }
        }
    };

    //Create a define function specific to the module asking for amdefine.
    function define(id, deps, factory) {
        if (Array.isArray(id)) {
            factory = deps;
            deps = id;
            id = undefined;
        } else if (typeof id !== 'string') {
            factory = id;
            id = deps = undefined;
        }

        if (deps && !Array.isArray(deps)) {
            factory = deps;
            deps = undefined;
        }

        if (!deps) {
            deps = ['require', 'exports', 'module'];
        }

        //Set up properties for this module. If an ID, then use
        //internal cache. If no ID, then use the external variables
        //for this node module.
        if (id) {
            //Put the module in deep freeze until there is a
            //require call for it.
            defineCache[id] = [id, deps, factory];
        } else {
            runFactory(id, deps, factory);
        }
    }

    //define.require, which has access to all the values in the
    //cache. Useful for AMD modules that all have IDs in the file,
    //but need to finally export a value to node based on one of those
    //IDs.
    define.require = function (id) {
        if (loaderCache[id]) {
            return loaderCache[id];
        }

        if (defineCache[id]) {
            runFactory.apply(null, defineCache[id]);
            return loaderCache[id];
        }
    };

    define.amd = {};

    return define;
}(module)), require));
